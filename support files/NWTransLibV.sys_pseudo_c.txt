/*
Type: PE
Platform: windows-kernel-x86_64
Architecture: x86_64

Libraries: 
  ntoskrnl.exe
  HAL.dll

Compiler(s) Used: 
  Imported Functions (46 objects)
  VS2008 v9.0 SP1 build 30729 (86 objects)
  Windows Server 2003 SP1 DDK (for AMD64) (9 objects)

Segments:
r--  0x00010000-0x00010400 
r-x  0x00011000-0x00039cc8  {Code}
r--  0x0003a000-0x0003eab4  {Data}
rw-  0x0003f000-0x00040200  {Data}
rw-  0x00040200-0x00040388  {Data}
r--  0x00041000-0x00041e88  {Data}
r--  0x00042000-0x0004229f  {Data}
rwx  0x00043000-0x0004361a  {Code}
r--  0x00044000-0x000442d0  {Data}
r--  0x00045000-0x00045460  {Data}
---  0x00045460-0x000455d0 
---  0x000455d0-0x00045600 

Sections:
0x00011000-0x00039cc8  .text  {Code}
0x0003a000-0x0003eab4  .rdata  {Read-only data}
0x0003f000-0x00040388  .data  {Writable data}
0x00041000-0x00041e88  .pdata  {Read-only data}
0x00042000-0x0004229f  .edata  {Read-only data}
0x00043000-0x0004361a  INIT
0x00044000-0x000442d0  .rsrc  {Read-only data}
0x00045000-0x00045460  .reloc  {Read-only data}
0x00045460-0x000455d0  .extern  {External}
0x000455d0-0x00045600  .synthetic_builtins  {External}
*/
00010000  struct DOS_Header _iob = 
00010000  {
00010000      char e_magic[0x2] = "MZ"
00010002      uint16_t e_cblp = 0x90
00010004      uint16_t e_cp = 0x3
00010006      uint16_t e_crlc = 0x0
00010008      uint16_t e_cparhdr = 0x4
0001000a      uint16_t e_minalloc = 0x0
0001000c      uint16_t e_maxalloc = 0xffff
0001000e      uint16_t e_ss = 0x0
00010010      uint16_t e_sp = 0xb8
00010012      uint16_t e_csum = 0x0
00010014      uint16_t e_ip = 0x0
00010016      uint16_t e_cs = 0x0
00010018      uint16_t e_lfarlc = 0x40
0001001a      uint16_t e_ovno = 0x0
0001001c      char e_res1[0x8] = "\x00\x00\x00\x00\x00\x00\x00", 0
00010024      uint16_t e_oemid = 0x0
00010026      uint16_t e_oeminfo = 0x0
00010028      char e_res2[0x14] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
0001003c      uint32_t e_lfanew = 0xf8
00010040  }

00010040  __dos_stub:
00010040  0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  ........!..L.!This program canno
00010060  74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  t be run in DOS mode....$.......

00010080  struct Rich_Header __rich_header = 
00010080  {
00010080      uint32_t e_magic__DanS = 0xe289cf7e
00010084      uint32_t e_align[0x3] = 
00010084      {
00010084          [0x0] =  0xb1e7ae3a
00010088          [0x1] =  0xb1e7ae3a
0001008c          [0x2] =  0xb1e7ae3a
00010090      }
00010090      uint32_t e_entry_id0__00010000 = 0xb1e6ae3a
00010094      uint32_t e_entry_count0__46 = 0xb1e7ae14
00010098      uint32_t e_entry_id1__007b9d76 = 0xb19c334c
0001009c      uint32_t e_entry_count1__5 = 0xb1e7ae3f
000100a0      uint32_t e_entry_id2__007d9d76 = 0xb19a334c
000100a4      uint32_t e_entry_count2__3 = 0xb1e7ae39
000100a8      uint32_t e_entry_id3__00837809 = 0xb164d633
000100ac      uint32_t e_entry_count3__20 = 0xb1e7ae2e
000100b0      uint32_t e_entry_id4__00957809 = 0xb172d633
000100b4      uint32_t e_entry_count4__4 = 0xb1e7ae3e
000100b8      uint32_t e_entry_id5__006d9d76 = 0xb18a334c
000100bc      uint32_t e_entry_count5__1 = 0xb1e7ae3b
000100c0      uint32_t e_entry_id6__00927809 = 0xb175d633
000100c4      uint32_t e_entry_count6__1 = 0xb1e7ae3b
000100c8      uint32_t e_entry_id7__00897809 = 0xb16ed633
000100cc      uint32_t e_entry_count7__59 = 0xb1e7ae01
000100d0      uint32_t e_entry_id8__00947809 = 0xb173d633
000100d4      uint32_t e_entry_count8__1 = 0xb1e7ae3b
000100d8      uint32_t e_entry_id9__00917809 = 0xb176d633
000100dc      uint32_t e_entry_count9__1 = 0xb1e7ae3b
000100e0      char e_magic[0x4] = "Rich"
000100e4      uint32_t e_checksum = 0xb1e7ae3a
000100e8  }

000100e8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

000100f8  struct COFF_Header __coff_header = 
000100f8  {
000100f8      char magic[0x4] = "PE\x00", 0
000100fc      enum coff_machine machine = IMAGE_FILE_MACHINE_AMD64
000100fe      uint16_t numberOfSections = 0x8
00010100      uint32_t timeDateStamp = 0x510f14d3
00010104      uint32_t pointerToSymbolTable = 0x0
00010108      uint32_t numberOfSymbols = 0x0
0001010c      uint16_t sizeOfOptionalHeader = 0xf0
0001010e      enum coff_characteristics characteristics = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LARGE_ADDRESS_AWARE
00010110  }
00010110  struct PE64_Optional_Header __pe64_optional_header = 
00010110  {
00010110      enum pe_magic magic = PE_64BIT
00010112      uint8_t majorLinkerVersion = 0x9
00010113      uint8_t minorLinkerVersion = 0x0
00010114      uint32_t sizeOfCode = 0x29600
00010118      uint32_t sizeOfInitializedData = 0x7e00
0001011c      uint32_t sizeOfUninitializedData = 0x0
00010120      uint32_t addressOfEntryPoint = 0x33064
00010124      uint32_t baseOfCode = 0x1000
00010128      uint64_t imageBase = 0x10000
00010130      uint32_t sectionAlignment = 0x1000
00010134      uint32_t fileAlignment = 0x200
00010138      uint16_t majorOperatingSystemVersion = 0x6
0001013a      uint16_t minorOperatingSystemVersion = 0x1
0001013c      uint16_t majorImageVersion = 0x6
0001013e      uint16_t minorImageVersion = 0x1
00010140      uint16_t majorSubsystemVersion = 0x5
00010142      uint16_t minorSubsystemVersion = 0x2
00010144      uint32_t win32VersionValue = 0x0
00010148      uint32_t sizeOfImage = 0x36000
0001014c      uint32_t sizeOfHeaders = 0x400
00010150      uint32_t checkSum = 0x3816e
00010154      enum pe_subsystem subsystem = IMAGE_SUBSYSTEM_NATIVE
00010156      enum pe_dll_characteristics dllCharacteristics = 0
00010158      uint64_t sizeOfStackReserve = 0x40000
00010160      uint64_t sizeOfStackCommit = 0x1000
00010168      uint64_t sizeOfHeapReserve = 0x100000
00010170      uint64_t sizeOfHeapCommit = 0x1000
00010178      uint32_t loaderFlags = 0x0
0001017c      uint32_t numberOfRvaAndSizes = 0x10
00010180      struct PE_Data_Directory_Entry exportTableEntry = 
00010180      {
00010180          uint32_t virtualAddress = 0x32000
00010184          uint32_t size = 0x29f
00010188      }
00010188      struct PE_Data_Directory_Entry importTableEntry = 
00010188      {
00010188          uint32_t virtualAddress = 0x33084
0001018c          uint32_t size = 0x3c
00010190      }
00010190      struct PE_Data_Directory_Entry resourceTableEntry = 
00010190      {
00010190          uint32_t virtualAddress = 0x34000
00010194          uint32_t size = 0x2d0
00010198      }
00010198      struct PE_Data_Directory_Entry exceptionTableEntry = 
00010198      {
00010198          uint32_t virtualAddress = 0x31000
0001019c          uint32_t size = 0xe88
000101a0      }
000101a0      struct PE_Data_Directory_Entry certificateTableEntry = 
000101a0      {
000101a0          uint32_t virtualAddress = 0x31600
000101a4          uint32_t size = 0x22f8
000101a8      }
000101a8      struct PE_Data_Directory_Entry baseRelocationTableEntry = 
000101a8      {
000101a8          uint32_t virtualAddress = 0x35000
000101ac          uint32_t size = 0x264
000101b0      }
000101b0      struct PE_Data_Directory_Entry debugEntry = 
000101b0      {
000101b0          uint32_t virtualAddress = 0x2a180
000101b4          uint32_t size = 0x1c
000101b8      }
000101b8      struct PE_Data_Directory_Entry architectureEntry = 
000101b8      {
000101b8          uint32_t virtualAddress = 0x0
000101bc          uint32_t size = 0x0
000101c0      }
000101c0      struct PE_Data_Directory_Entry globalPtrEntry = 
000101c0      {
000101c0          uint32_t virtualAddress = 0x0
000101c4          uint32_t size = 0x0
000101c8      }
000101c8      struct PE_Data_Directory_Entry tlsTableEntry = 
000101c8      {
000101c8          uint32_t virtualAddress = 0x0
000101cc          uint32_t size = 0x0
000101d0      }
000101d0      struct PE_Data_Directory_Entry loadConfigTableEntry = 
000101d0      {
000101d0          uint32_t virtualAddress = 0x0
000101d4          uint32_t size = 0x0
000101d8      }
000101d8      struct PE_Data_Directory_Entry boundImportEntry = 
000101d8      {
000101d8          uint32_t virtualAddress = 0x0
000101dc          uint32_t size = 0x0
000101e0      }
000101e0      struct PE_Data_Directory_Entry iatEntry = 
000101e0      {
000101e0          uint32_t virtualAddress = 0x2a000
000101e4          uint32_t size = 0x180
000101e8      }
000101e8      struct PE_Data_Directory_Entry delayImportDescriptorEntry = 
000101e8      {
000101e8          uint32_t virtualAddress = 0x0
000101ec          uint32_t size = 0x0
000101f0      }
000101f0      struct PE_Data_Directory_Entry clrRuntimeHeaderEntry = 
000101f0      {
000101f0          uint32_t virtualAddress = 0x0
000101f4          uint32_t size = 0x0
000101f8      }
000101f8      struct PE_Data_Directory_Entry reservedEntry = 
000101f8      {
000101f8          uint32_t virtualAddress = 0x0
000101fc          uint32_t size = 0x0
00010200      }
00010200  }
00010200  struct Section_Header __section_headers[0x8] = 
00010200  {
00010200      [0x0] = 
00010200      {
00010200          char name[0x8] = ".text\x00\x00", 0
00010208          uint32_t virtualSize = 0x28cc8
0001020c          uint32_t virtualAddress = 0x1000
00010210          uint32_t sizeOfRawData = 0x28e00
00010214          uint32_t pointerToRawData = 0x400
00010218          uint32_t pointerToRelocations = 0x0
0001021c          uint32_t pointerToLineNumbers = 0x0
00010220          uint16_t numberOfRelocations = 0x0
00010222          uint16_t numberOfLineNumbers = 0x0
00010224          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
00010228      }
00010228      [0x1] = 
00010228      {
00010228          char name[0x8] = ".rdata\x00", 0
00010230          uint32_t virtualSize = 0x4ab4
00010234          uint32_t virtualAddress = 0x2a000
00010238          uint32_t sizeOfRawData = 0x4c00
0001023c          uint32_t pointerToRawData = 0x29200
00010240          uint32_t pointerToRelocations = 0x0
00010244          uint32_t pointerToLineNumbers = 0x0
00010248          uint16_t numberOfRelocations = 0x0
0001024a          uint16_t numberOfLineNumbers = 0x0
0001024c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_READ
00010250      }
00010250      [0x2] = 
00010250      {
00010250          char name[0x8] = ".data\x00\x00", 0
00010258          uint32_t virtualSize = 0x1388
0001025c          uint32_t virtualAddress = 0x2f000
00010260          uint32_t sizeOfRawData = 0x1200
00010264          uint32_t pointerToRawData = 0x2de00
00010268          uint32_t pointerToRelocations = 0x0
0001026c          uint32_t pointerToLineNumbers = 0x0
00010270          uint16_t numberOfRelocations = 0x0
00010272          uint16_t numberOfLineNumbers = 0x0
00010274          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
00010278      }
00010278      [0x3] = 
00010278      {
00010278          char name[0x8] = ".pdata\x00", 0
00010280          uint32_t virtualSize = 0xe88
00010284          uint32_t virtualAddress = 0x31000
00010288          uint32_t sizeOfRawData = 0x1000
0001028c          uint32_t pointerToRawData = 0x2f000
00010290          uint32_t pointerToRelocations = 0x0
00010294          uint32_t pointerToLineNumbers = 0x0
00010298          uint16_t numberOfRelocations = 0x0
0001029a          uint16_t numberOfLineNumbers = 0x0
0001029c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_READ
000102a0      }
000102a0      [0x4] = 
000102a0      {
000102a0          char name[0x8] = ".edata\x00", 0
000102a8          uint32_t virtualSize = 0x29f
000102ac          uint32_t virtualAddress = 0x32000
000102b0          uint32_t sizeOfRawData = 0x400
000102b4          uint32_t pointerToRawData = 0x30000
000102b8          uint32_t pointerToRelocations = 0x0
000102bc          uint32_t pointerToLineNumbers = 0x0
000102c0          uint16_t numberOfRelocations = 0x0
000102c2          uint16_t numberOfLineNumbers = 0x0
000102c4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
000102c8      }
000102c8      [0x5] = 
000102c8      {
000102c8          char name[0x8] = "INIT\x00\x00\x00", 0
000102d0          uint32_t virtualSize = 0x61a
000102d4          uint32_t virtualAddress = 0x33000
000102d8          uint32_t sizeOfRawData = 0x800
000102dc          uint32_t pointerToRawData = 0x30400
000102e0          uint32_t pointerToRelocations = 0x0
000102e4          uint32_t pointerToLineNumbers = 0x0
000102e8          uint16_t numberOfRelocations = 0x0
000102ea          uint16_t numberOfLineNumbers = 0x0
000102ec          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
000102f0      }
000102f0      [0x6] = 
000102f0      {
000102f0          char name[0x8] = ".rsrc\x00\x00", 0
000102f8          uint32_t virtualSize = 0x2d0
000102fc          uint32_t virtualAddress = 0x34000
00010300          uint32_t sizeOfRawData = 0x400
00010304          uint32_t pointerToRawData = 0x30c00
00010308          uint32_t pointerToRelocations = 0x0
0001030c          uint32_t pointerToLineNumbers = 0x0
00010310          uint16_t numberOfRelocations = 0x0
00010312          uint16_t numberOfLineNumbers = 0x0
00010314          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
00010318      }
00010318      [0x7] = 
00010318      {
00010318          char name[0x8] = ".reloc\x00", 0
00010320          uint32_t virtualSize = 0x460
00010324          uint32_t virtualAddress = 0x35000
00010328          uint32_t sizeOfRawData = 0x600
0001032c          uint32_t pointerToRawData = 0x31000
00010330          uint32_t pointerToRelocations = 0x0
00010334          uint32_t pointerToLineNumbers = 0x0
00010338          uint16_t numberOfRelocations = 0x0
0001033a          uint16_t numberOfLineNumbers = 0x0
0001033c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
00010340      }
00010340  }

00010340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00010360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00010380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000103a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000103c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000103e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

.text section started  {0x11000-0x39cc8}
00011000  00 00 00 00 00 00 00 00                                                                          ........

00011008    int32_t TransLibInitialize(struct _DRIVER_OBJECT* DriverObject, struct _UNICODE_STRING* RegistryPath, void* PDeviceContext, struct _NW_TRANSLIB_DEVICE_CONTEXT** PTransLibContext, uint16_t VendorId, uint16_t ProductId, uint8_t InputMode, int32_t (* CallBackFnc)(void*, uint32_t, void*, uint32_t))

00011008  {
00011041      uint32_t cSFEnabled[0x4];
00011041      cSFEnabled[0] = 1;
00011045      struct _NW_TRANSLIB_DEVICE_CONTEXT** PTransLibContext_1 = PTransLibContext;
00011048      struct _NW_TRANSLIB_DEVICE_CONTEXT* rax =
00011048          ExAllocatePoolWithTag(NonPagedPool, 0x9300, 0x44504c54);
00011056      uint8_t rax_3;
00011056      
00011056      if (rax)
00011056      {
00011075          rax->DeviceContext = PDeviceContext;
00011087          rax->VendorId = VendorId;
00011099          rax->ProductId = ProductId;
000110a0          rax->TLDeviceState = 0;
000110a3          rax_3 = TransLibUserModeContextInit(&rax->UserModeContext);
00011056      }
00011056      
000110aa      int32_t result;
000110aa      struct _TL_WORKER_QUEUE_HDR* r13;
000110aa      void* r14;
000110aa      struct _TL_WORKER_QUEUE_HDR* r15;
000110aa      
000110aa      if (!rax || !rax_3)
000110aa      {
00011058          *(uint64_t*)PTransLibContext_1 = nullptr;
0001105b          result = -0x3fffff66;
00011061      label_11061:
00011061          r13 = *(uint64_t*)&cSFEnabled[0];
00011066          r15 = *(uint64_t*)&cSFEnabled[0];
0001106b          r14 = *(uint64_t*)&cSFEnabled[0];
000110aa      }
000110aa      else
000110aa      {
000110b4          rax->UserModeContext.DrvSettingsContext.InputMode = (uint32_t)InputMode;
000110ba          *(uint64_t*)PTransLibContext_1 = rax;
000110ba          
000110c3          if (!nDeviceInstances)
000110c3          {
000110c8              int32_t result_1 = TransLibInitRegistry(RegistryPath);
000110cf              result = result_1;
000110cf              
000110d2              if (result_1 < 0)
000110d2                  goto label_11061;
000110d2              
000110db              if (!TLSettingsFolder.Length)
000110db              {
000110e4                  TLReadSettingsFolder(&TLRegistryPath);
000110e4                  
000110f0                  if (!TLSettingsFolder.Length)
000110fe                      TLDbgLogMsg(0, 1, 
000110fe                          "TLInitialize Failed to locate settings folder in regsitry\n");
000110db              }
000110c3          }
000110c3          
00011103          nDeviceInstances += 1;
0001110a          r13 = &rax->TLReaderWorkerCB;
0001111c          r15 = &rax->USBReaderWorkerCB;
00011123          r14 = &rax->TimerWorkerCB;
0001112a          memset(r13, 0, 0x80);
0001113a          r13->pTransLibContext = rax;
0001113e          memset(r15, 0, 0x80);
0001114f          r15->pTransLibContext = rax;
00011153          memset(&rax->TLConsumerQueueWorkerCB, 0, 0x80);
00011163          rax->TLConsumerQueueWorkerCB.pTransLibContext = rax;
0001116a          memset(r14, 0, 0x80);
00011176          *(uint64_t*)((char*)r14 + 0x78) = rax;
0001117a          rax->UserModeContext.pTransLibResetUSB = ResetUSB;
00011186          rax->UserModeContext.pTransLibContext = rax;
00011186          
0001118c          if (CallBackFnc)
0001118c          {
000111b9              TLCallbackFnc = CallBackFnc;
000111c0              int32_t result_2 = TLInitQueueWorker(r13, TLReaderWorker, r13);
000111c7              result = result_2;
000111c7              
000111ca              if (result_2 >= 0)
000111ca              {
000111f4                  result_2 = TLInitQueueWorker(r15, TLReaderWorker, r15);
000111fb                  result = result_2;
000111fb                  
000111fe                  if (result_2 >= 0)
000111fe                  {
00011216                      result_2 = TLInitQueueWorker(r14, TLTimerWorker, r14);
0001121d                      result = result_2;
0001121d                      
00011220                      if (result_2 >= 0)
00011220                      {
00011237                          TLReadCSFEnabled(&TLRegistryPath, &cSFEnabled);
0001123c                          uint8_t r11_1 = cSFEnabled[0];
0001125c                          r13->ReaderCallbackFnc = TLIO_ReceiveTLReport;
0001126e                          QueueConnectedCallback = TLIO_TransLibBulkConnect;
0001127c                          gCSFEnabled = r11_1;
00011283                          QueueDisconnectedCallback = TLIO_TransLibBulkDisconnect;
00011291                          rax->UserModeContext.TLIOContext.SendHWReportCallback =
00011291                              HWWriteReport;
0001129b                          rax->UserModeContext.TLIOContext.ReceiveHWReportCallback =
0001129b                              DSI_InputReport;
000112a6                          rax->UserModeContext.TLIOContext.SendTLReportCallback =
000112a6                              TLWriteReport;
000112b1                          rax->UserModeContext.TLIOContext.ReceiveTLReportCallback =
000112b1                              SI_Input_Report;
000112bc                          rax->UserModeContext.TLIOContext.UpdateCamerasCallback =
000112bc                              UpdateCameras;
000112c0                          struct _NW_CSF_CONTEXT* pCSFContext =
000112c0                              rax->UserModeContext.pCSFContext;
000112c4                          pCSFContext->ctlContext.edgesCallback = SI_SendEdges;
000112cb                          pCSFContext->ctlContext.edgesParam = &rax->UserModeContext;
000112d2                          struct _NW_CSF_CONTEXT* pCSFContext_1 =
000112d2                              rax->UserModeContext.pCSFContext;
000112d6                          pCSFContext_1->PTContext.TouchPointCBParam =
000112d6                              &rax->UserModeContext.DrvSettingsContext.ReportMode;
000112e2                          pCSFContext_1->PTContext.TouchPointCallback = drv_CSFTouchPoint;
000112e7                          struct _NW_CSF_CONTEXT* pCSFContext_2 =
000112e7                              rax->UserModeContext.pCSFContext;
000112f2                          pCSFContext_2->PTContext.VendorTouchPointCallback =
000112f2                              TLIO_CSFTouchPointVendor;
000112f7                          pCSFContext_2->PTContext.VendorTouchPointCBParam =
000112f7                              &rax->UserModeContext.TLIOContext.SendHWReportCallback;
000112fc                          struct _NW_CSF_CONTEXT* pCSFContext_3 =
000112fc                              rax->UserModeContext.pCSFContext;
00011300                          pCSFContext_3->PTContext.OffscreenTouchPointCBParam =
00011300                              &rax->UserModeContext.TLIOContext.SendHWReportCallback;
0001130c                          pCSFContext_3->PTContext.OffscreenTouchPointCallback =
0001130c                              TLIO_CSFTouchPointOffscreen;
00011311                          struct _NW_CSF_CONTEXT* pCSFContext_4 =
00011311                              rax->UserModeContext.pCSFContext;
0001131c                          pCSFContext_4->CalibContext.CalibFinishedCB =
0001131c                              SI_CalibrationFinished;
00011323                          pCSFContext_4->CalibContext.CalibFinishedParam =
00011323                              &rax->UserModeContext;
0001132a                          struct _NW_CSF_CONTEXT* pCSFContext_6 =
0001132a                              rax->UserModeContext.pCSFContext;
00011335                          pCSFContext_6->ctlContext.penshutter_callback =
00011335                              fw_UpdatePenShutter;
00011343                          pCSFContext_6->ctlContext.shutterParam =
00011343                              &rax->UserModeContext.FwSettingsContext;
0001134a                          struct _NW_CSF_CONTEXT* pCSFContext_5 =
0001134a                              rax->UserModeContext.pCSFContext;
00011355                          pCSFContext_5->KickMongrelFirmware_tmr.f =
00011355                              KickFirmwareOutOfLowSpeedMode;
0001135c                          pCSFContext_5->KickMongrelFirmware_tmr.param =
0001135c                              &rax->UserModeContext.TLIOContext.SendHWReportCallback;
00011363                          pCSFContext_5->KickMongrelFirmware_tmr.elapsedTime = 0;
00011369                          pCSFContext_5->KickMongrelFirmware_tmr.expiredTime = 0x493e0;
00011373                          pCSFContext_5->KickMongrelFirmware_tmr.enabled = 1;
0001137a                          pCSFContext_5->KickMongrelFirmware_tmr.periodic = 1;
0001138c                          SendInputReportCallback = SendInputLoopback;
0001139d                          rax->UserModeContext.DrvSettingsContext.GetSettingsDataCallback =
0001139d                              GetTransLibSettingsData;
000113ab                          rax->UserModeContext.DrvSettingsContext.
000113ab                              GetDefaultSettingsDataCallback = GetDefaultTransLibSettingsData;
000113b9                          rax->UserModeContext.DrvSettingsContext.
000113b9                              FreeSettingsDataCallback = FreeTransLibSettingsData;
000113c7                          rax->UserModeContext.DrvSettingsContext.SetSettingsDataCallback =
000113c7                              SetTransLibSettingsData;
000113ce                          rax->UserModeContext.DrvSettingsContext.TouchPointCBParam =
000113ce                              &rax->UserModeContext;
000113dc                          rax->UserModeContext.DrvSettingsContext.TouchPointCallback =
000113dc                              TLInputDistProcessTouch;
000113f1                          rax->UserModeContext.FwSettingsContext.FWVersionCallback =
000113f1                              TLWriteFirmwareVersionToReg;
000113ff                          rax->UserModeContext.ParserContext.rawWaveformsCBParam = rax;
00011406                          rax->UserModeContext.ParserContext.rawWaveformsCB =
00011406                              TransLibRawWaveformsCallback;
0001140d                          rax->ParsedTransfer = 0;
00011413                          result_2 = TLInitQueueWorker(&rax->TLConsumerQueueWorkerCB, 
00011413                              TLConsumerQueueWorker, 
00011413                              &rax->TLConsumerQueueWorkerCB.WorkerThreadReady.Header...
00011413                                  Lock);
00011418                          result = result_2;
00011418                          
0001141d                          if (result_2 >= 0)
0001141d                          {
00011432                              KeInitializeTimer(&rax->Timer);
00011449                              KeInitializeDpc(&rax->TimerDpc, TransLibTimer, rax);
00011466                              KeSetTimerEx(&rax->Timer, 0, 0xa, &rax->TimerDpc);
0001146c                              rax->TLDeviceState |= 5;
00011470                              PTransLibContext_1 = PTransLibContext;
0001141d                          }
0001141d                          else
000111dd                              TLDbgLogMsg(0, 1, 
000111dd                                  "TLInitialize Failed to initialize consumer queue worker "
000111dd                              "thread Status %08lX\n", 
000111dd                                  (uint64_t)result_2);
00011220                      }
00011220                      else
000111dd                          TLDbgLogMsg(0, 1, 
000111dd                              "TLInitialize Failed to initialize timer thread Status %08lX\n", 
000111dd                              (uint64_t)result_2);
000111fe                  }
000111fe                  else
000111dd                      TLDbgLogMsg(0, 1, 
000111dd                          "TLInitialize Failed to initialize USB Reader thread Status %08lX\n", 
000111dd                          (uint64_t)result_2);
000111ca              }
000111ca              else
000111dd                  TLDbgLogMsg(0, 1, 
000111dd                      "TLInitialize Failed to initialize TL Reader thread Status %08lX\n", 
000111dd                      (uint64_t)result_2);
0001118c          }
0001118c          else
0001118c          {
0001119c              TLDbgLogMsg(0, 1, "TLInitialize No callback function passed to library\n");
000111a1              result = -0x3ffffff3;
0001118c          }
000110aa      }
000110aa      
00011487      TLDbgLogMsg(4, 3, 
00011487          "TLInitialize Initialization of NW Trans Library Exit Status %08lX\n", 
00011487          (uint64_t)result);
00011487      
0001148f      if (result < 0)
0001148f      {
00011496          TLShutdownQueueWorker(r13, 1);
000114a0          TLShutdownQueueWorker(r15, 1);
000114aa          TLShutdownQueueWorker(r14, 1);
000114aa          
000114b2          if (rax)
000114b2          {
000114b4              struct _NW_CSF_CONTEXT* pCSFContext_7 = rax->UserModeContext.pCSFContext;
000114b4              
000114be              if (!pCSFContext_7)
000114e5                  onBug__("TransLibUserModeContextCleanup: pCSFContext already NULL", 
000114e5                      "c:\development_work\csf_release_hp\driver\translib\translibio.c", 
000114e5                      0x3f);
000114be              else
000114be              {
000114c2                  ExFreePoolWithTag(pCSFContext_7, 0);
000114c8                  rax->UserModeContext.pCSFContext = nullptr;
000114be              }
000114be              
000114ef              ExFreePoolWithTag(rax, 0);
000114f5              *(uint64_t*)PTransLibContext_1 = nullptr;
000114b2          }
0001148f      }
0001148f      
00011517      return result;
00011008  }

00011518                                                                          cc cc cc cc cc cc cc cc                          ........

00011520    int32_t __convention("sysv") TransLibShutdown(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext @ rcx)

00011520  {
0001152f      int32_t result = 0;
0001152f      
00011544      if (PTransLibContext && PTransLibContext->TLDeviceState & 1)
00011544      {
00011557          TLDbgLogMsg(4, 3, "TLShutdown: Shutdown of NW Trans Library\n");
00011563          KeCancelTimer(&PTransLibContext->Timer);
00011569          PTransLibContext->TLDeviceState &= 0xfffffffa;
00011574          int32_t rax_1 =
00011574              TLShutdownQueueWorker(&PTransLibContext->TLConsumerQueueWorkerCB, 1);
0001157b          int64_t entry_rdi;
0001157b          
0001157b          if (rax_1 < 0)
0001158b              TLDbgLogMsg(0, 1, 
0001158b                  "TLShutdown Failed to shutdown consumer queue worker Status %08lX\n", 
0001158b                  (uint64_t)rax_1, entry_rdi);
0001158b          
0001159a          int32_t rax_2 = TLShutdownQueueWorker(&PTransLibContext->TLReaderWorkerCB, 1);
0001159a          
000115a1          if (rax_2 < 0)
000115b1              TLDbgLogMsg(0, 1, "TLShutdown Failed to shutdown TL Reader Status %08lX\n", 
000115b1                  (uint64_t)rax_2, entry_rdi);
000115b1          
000115c0          int32_t rax_3 = TLShutdownQueueWorker(&PTransLibContext->USBReaderWorkerCB, 1);
000115c0          
000115c7          if (rax_3 < 0)
000115d7              TLDbgLogMsg(0, 1, "TLShutdown Failed to shutdown USB Reader Status %08lX\n", 
000115d7                  (uint64_t)rax_3, entry_rdi);
000115d7          
000115e6          int32_t result_1 = TLShutdownQueueWorker(&PTransLibContext->TimerWorkerCB, 1);
000115eb          result = result_1;
000115eb          
000115ef          if (result_1 < 0)
000115ff              TLDbgLogMsg(0, 1, "TLShutdown Failed to shutdown timer Status %08lX\n", 
000115ff                  (uint64_t)result_1, entry_rdi);
000115ff          
00011604          int32_t nDeviceInstances_1 = nDeviceInstances;
00011604          nDeviceInstances -= 1;
00011604          
0001160a          if (nDeviceInstances_1 == 1)
0001160a          {
0001160c              TransLibCleanupRegistry();
00011611              result = 0;
0001160a          }
0001160a          
0001162a          struct _NW_CSF_CONTEXT* pCSFContext =
0001162a              PTransLibContext->UserModeContext.pCSFContext;
0001162a          
00011634          if (!pCSFContext)
0001165c              onBug__("TransLibUserModeContextCleanup: pCSFContext already NULL", 
0001165c                  "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0x3f);
00011634          else
00011634          {
00011638              ExFreePoolWithTag(pCSFContext, 0);
0001163e              PTransLibContext->UserModeContext.pCSFContext = nullptr;
00011634          }
00011634          
00011666          ExFreePoolWithTag(PTransLibContext, 0);
00011544      }
00011544      
0001167d      return result;
00011520  }

0001167e                                                                                            cc cc                                ..
00011680  cc cc cc cc                                                                                      ....

00011684    uint8_t HWWriteReport(struct _TLIO_CONTEXT* pContext, uint8_t* pHIDReport, int32_t size)

00011684  {
000116a5      int32_t rax_1;
000116a5      (uint8_t)rax_1 = TLCallbackFnc(
000116a5          *(uint64_t*)pContext->pUserModeContext->pTransLibContext, 0x15, pHIDReport, size)
000116a5          >= 0;
000116ac      return (uint8_t)rax_1;
00011684  }

000116ad                                         cc cc cc cc cc cc cc                                                   .......

000116b4    uint8_t TLWriteReport(struct _TLIO_CONTEXT* pContext, uint8_t* pHIDReport, int32_t size)

000116b4  {
000116c4      void var_88;
000116c4      int64_t rax_1 = __security_cookie ^ &var_88;
000116d5      void* pTransLibContext = pContext->pUserModeContext->pTransLibContext;
000116d8      int32_t size_1 = 0x40;
000116dd      char var_68 = 6;
000116dd      
000116e5      if (size < 0x40)
000116e5          size_1 = size;
000116e5      
000116ec      char var_67[0x4f];
000116ec      memmove(&var_67, pHIDReport, (int64_t)size_1);
0001170b      int32_t rax_3;
0001170b      (uint8_t)rax_3 = TLCallbackFnc(*(uint64_t*)pTransLibContext, 4, &var_68, 0x41) >= 0;
00011716      __security_check_cookie(rax_1 ^ &var_88);
00011723      return (uint8_t)rax_3;
000116b4  }

00011724              cc cc cc cc cc cc cc cc                                                                  ........

0001172c    int32_t TransLibProcessUserReport(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext, void* ReportBuffer, uint32_t Length)

0001172c  {
0001174c      NTSTATUS result = STATUS_SUCCESS;
0001174e      uint64_t Length_1 = (uint64_t)Length;
0001174e      
0001175c      if (!((char)(PTransLibContext->TLDeviceState >> 2) & 1))
0001175e          return STATUS_DEVICE_NOT_READY;
0001175e      
00011774      struct _TL_WORK_ITEM* rax_2 =
00011774          ExAllocatePoolWithTag(NonPagedPool, Length_1 + 0x38, 0x52554c54);
00011774      
00011780      if (rax_2)
00011780      {
0001179c          uint32_t rax_4 = (*(uint224_t*)TLMemoryUsage.AllocationTable)[3];
000117a2          TLMemoryUsage.TotalNonPagedPool =
000117a2              TLMemoryUsage.TotalNonPagedPool + (uint32_t)Length_1 + 0x38;
000117ac          (*(uint224_t*)TLMemoryUsage.AllocationTable)[3] =
000117ac              rax_4 + (uint32_t)Length_1 + 0x38;
000117b5          memset(rax_2, 0, Length_1 + 0x38);
000117c4          rax_2->Size = (uint32_t)Length_1;
000117c7          memmove(&rax_2[1], ReportBuffer, Length_1);
000117d0          struct _TL_WORKER_QUEUE_HDR* WorkerContext;
000117d0          
000117d0          if (*(uint8_t*)ReportBuffer == 6)
000117d0          {
000117d2              WorkerContext = &PTransLibContext->TLReaderWorkerCB;
000117ea          label_117ea:
000117ea              int64_t rbx;
000117ea              (uint8_t)rbx = rax_2->RequestFlags;
000117f0              TLInsertWorkItem(WorkerContext, rax_2);
000117f5              (uint8_t)rbx &= 1;
000117f8              result = STATUS_SUCCESS;
000117f8              
000117fa              if ((uint8_t)rbx)
00011814                  result = KeWaitForSingleObject(&rax_2->Event, Executive, 0, 0, nullptr);
00011814              
00011818              if (result < STATUS_SUCCESS)
00011818                  goto label_1181a;
000117d0          }
000117d0          else if (*(uint8_t*)ReportBuffer == 7)
000117e0          {
000117e2              WorkerContext = &PTransLibContext->USBReaderWorkerCB;
000117e2              goto label_117ea;
000117e0          }
00011780      }
00011780      else
00011780      {
00011782          result = STATUS_INSUFFICIENT_RESOURCES;
0001181a      label_1181a:
0001181a          
0001181d          if (rax_2)
0001181d          {
00011824              ExFreePoolWithTag(rax_2, 0);
00011838              TLMemoryUsage.TotalNonPagedPool += 0xffffffc8 - (uint32_t)Length_1;
0001183e              (*(uint224_t*)TLMemoryUsage.AllocationTable)[3] +=
0001183e                  0xffffffc8 - (uint32_t)Length_1;
0001181d          }
00011780      }
00011780      
00011865      return result;
0001172c  }

00011866                    cc cc cc cc cc cc                                                                    ......

0001186c    void TLSetTranslationMode(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext, uint32_t TranslationMode)

0001186c  {
0001186f      if (TranslationMode == 1)
0001186f      {
00011876          PTransLibContext->TLDeviceState |= 2;
0001187a          return;
0001186f      }
0001186f      
00011871      PTransLibContext->TLDeviceState &= 0xfffffffd;
0001186c  }

0001187b                                                                                   cc cc cc cc cc                             .....
00011880  cc cc cc cc                                                                                      ....

00011884    int32_t TLGetTranslationMode(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext, uint32_t* TranslationMode)

00011884  {
00011891      *(uint32_t*)TranslationMode =
00011891          (uint32_t)(uint8_t)(PTransLibContext->TLDeviceState >> 1) & 1;
00011893      return 0;
00011884  }

00011894                                                              cc cc cc cc cc cc cc cc                                  ........

0001189c    int32_t TransLibGetThreadTimes(struct _NW_KERNEL_THREAD_TIMES* ThreadTimes)

0001189c  {
000118ab      ThreadTimes->TimeIncrement = KeQueryTimeIncrement();
000118b3      ThreadTimes->TLDeviceAccessThreadTime = TLDeviceAccessThreadTime;
000118bc      ThreadTimes->TLConsumerWorkerThreadTime = TLConsumerWorkerThreadTime;
000118c5      ThreadTimes->TLReaderWorkerThreadTime = TLReaderWorkerThreadTime;
000118ce      ThreadTimes->TLTimerWorkerThreadTime = TLTimerWorkerThreadTime;
000118db      *(uint64_t*)((char*)ThreadTimes->TotalSystemCount + 0) =
000118db          *(uint64_t*)-0xfffff78000000320;
000118e6      return 0;
0001189c  }

000118e7                       cc cc cc cc cc cc cc cc cc                                                         .........

000118f0    int32_t TransLibEnterWorkingState(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext)

000118f0  {
00011900      j_DbgPrint("gProcessTouchStatus = FALSE\n");
00011905      struct _NW_CSF_CONTEXT* pCSFContext = PTransLibContext->UserModeContext.pCSFContext;
00011913      *(uint64_t*)((char*)pCSFContext->PTContext.ProcessTouchStatusTime + 0) = 0;
00011926      pCSFContext->PTContext.ProcessTouchStatus = 0;
0001192e      uint8_t hIDReport = 0x43;
00011933      char arg_9 = 2;
00011938      char arg_a = 0xf0;
0001193d      char arg_b = 1;
00011942      HWWriteReport(&PTransLibContext->UserModeContext.TLIOContext, &hIDReport, 4);
0001194e      return 0;
000118f0  }

0001194f                                               cc cc cc cc cc cc cc cc cc                                         .........

00011958    int32_t TransLibLeaveWorkingState(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext)

00011958  {
00011964      if ((char)(PTransLibContext->TLDeviceState >> 2) & 1)
00011964      {
00011978          uint8_t hIDReport = 0x43;
0001197d          char arg_9 = 2;
00011982          char arg_a = 0xf0;
00011987          char arg_b = 0;
0001198c          HWWriteReport(&PTransLibContext->UserModeContext.TLIOContext, &hIDReport, 4);
00011964      }
00011964      
00011997      return 0;
00011958  }

00011998                                                                          cc cc cc cc cc cc cc cc                          ........

000119a0    void TransLibTimer(struct _KDPC* Dpc, void* DeferredContext, void* SystemArgument1, void* SystemArgument2)

000119a0  {
000119ac      /* tailcall */
000119ac      return KeSetEvent((char*)DeferredContext + 0x1f8, 0, 0);
000119a0  }

000119b3                                                           cc cc cc cc cc cc cc cc cc                                 .........

000119bc    int32_t TransLibProcessStreamSync(struct _NW_TRANSLIB_DEVICE_CONTEXT* pTransLibContext, void* DataBuffer, uint32_t DataBufferLength)

000119bc  {
000119d0      int32_t rbx = (int32_t)*(uint64_t*)-0xfffff78000000320;
000119d3      uint32_t TLDeviceState = pTransLibContext->TLDeviceState;
000119d3      
000119df      if (!((char)(TLDeviceState >> 2) & 1))
000119e1          return -0x3fffff5d;
000119e1      
000119fe      uint32_t RequestType = 2;
000119fe      
00011a03      if (!((char)(TLDeviceState >> 1) & 1))
00011a05          RequestType = 1;
00011a05      
00011a0a      TLQueueConsumerQueueWorkerRequest(&pTransLibContext->TLConsumerQueueWorkerCB, 
00011a0a          RequestType, DataBuffer, DataBufferLength, 0);
00011a14      TLDeviceAccessThreadTime += (int32_t)*(uint64_t*)-0xfffff78000000320 - rbx;
00011a1a      return 0;
000119bc  }

00011a27                       cc cc cc cc cc cc cc cc cc                                                         .........

00011a30    int32_t TransLibHardwareReadSync(struct _NW_TRANSLIB_DEVICE_CONTEXT* pTransLibContext, void* DataBuffer, uint32_t DataBufferLength)

00011a30  {
00011a44      int32_t rbx = (int32_t)*(uint64_t*)-0xfffff78000000320;
00011a47      uint32_t TLDeviceState = pTransLibContext->TLDeviceState;
00011a47      
00011a53      if (!((char)(TLDeviceState >> 2) & 1))
00011a55          return -0x3fffff5d;
00011a55      
00011a63      if ((char)(TLDeviceState >> 1) & 1)
00011a65          return -0x3ffffff0;
00011a65      
00011a80      TLQueueConsumerQueueWorkerRequest(&pTransLibContext->TLConsumerQueueWorkerCB, 3, 
00011a80          DataBuffer, DataBufferLength, 0);
00011a8a      TLDeviceAccessThreadTime += (int32_t)*(uint64_t*)-0xfffff78000000320 - rbx;
00011a90      return 0;
00011a30  }

00011a9d                                                                                         cc cc cc                               ...
00011aa0  cc cc cc cc                                                                                      ....

00011aa4    uint8_t TransLibGetParsedTransfer(struct _NW_TRANSLIB_DEVICE_CONTEXT* pTransLibContext)

00011aa4  {
00011aaa      return pTransLibContext->ParsedTransfer;
00011aa4  }

00011aab                                   cc cc cc cc cc cc cc cc cc                                                 .........

00011ab4    void TransLibSetParsedTransfer(struct _NW_TRANSLIB_DEVICE_CONTEXT* pTransLibContext, uint8_t value)

00011ab4  {
00011ab4      pTransLibContext->ParsedTransfer = value;
00011ab4  }

00011abb                                                                                   cc cc cc cc cc                             .....
00011ac0  cc cc cc cc                                                                                      ....

00011ac4    int32_t __convention("sysv") RtlStringCchPrintfA(char* pszDest @ rcx, uint64_t cchDest @ rdx, char const* pszFormat @ r8, ...)

00011ac4  {
00011ac4      char const* pszFormat_1 = pszFormat;
00011ac9      int64_t entry_r9;
00011ac9      int64_t arg_20 = entry_r9;
00011ad5      int32_t result = 0;
00011ad5      
00011ae6      if (!cchDest || cchDest > 0x7fffffff)
00011ae8          result = -0x3ffffff3;
00011ae8      
00011aef      if (result >= 0)
00011aef      {
00011afa          result = 0;
00011aff          int64_t entry_rsi;
00011aff          int64_t entry_rdi;
00011aff          int32_t rax_1 =
00011aff              _vsnprintf(pszDest, cchDest - 1, pszFormat, &arg_20, entry_rdi, entry_rsi);
00011b07          int64_t rax_2;
00011b07          
00011b07          if (rax_1 >= 0)
00011b09              rax_2 = (int64_t)rax_1;
00011b09          
00011b0e          if (rax_1 < 0 || rax_2 > cchDest - 1)
00011b0e          {
00011b17              *(uint8_t*)(cchDest - 1 + pszDest) = 0;
00011b1a              return -0x7ffffffb;
00011b0e          }
00011b0e          
00011b10          if (rax_2 == cchDest - 1)
00011b12              *(uint8_t*)(cchDest - 1 + pszDest) = 0;
00011aef      }
00011aef      
00011b28      return result;
00011ac4  }

00011b29                             cc cc cc cc cc cc cc                                                           .......

00011b30    int32_t TLDbgLogMsg(uint32_t Subsystem, uint32_t Level, char const* Format, ...)

00011b30  {
00011b35      int64_t entry_r9;
00011b35      int64_t arg_20 = entry_r9;
00011b46      int32_t rbx = 0;
00011b48      int32_t result = 0;
00011b48      
00011b51      if (!TLDbgBuffer)
00011b53          return -0x3fffff5d;
00011b53      
00011b77      if ((Subsystem <= 0 || TLDebugSubsystem & Subsystem)
00011b77          && (Level <= 0 || Level <= TLDebugLevel))
00011b77      {
00011b84          (uint8_t)Level = 1;
00011b86          TLAcquireExcl(&TLDbgLogLock, (uint8_t)Level);
00011b8b          char* pszDest = TLDbgBuffer;
00011b8b          
00011b95          if (pszDest)
00011b95          {
00011bab              if (TLDbgLogRemainingLength >= 0xff)
00011bc9                  pszDest = TLDbgCurrentBuffer;
00011bab              else
00011bab              {
00011bad                  uint32_t TLDbgBufferLength_1 = TLDbgBufferLength;
00011bb3                  TLDbgLogFlags |= 1;
00011bba                  TLDbgCurrentBuffer = pszDest;
00011bc1                  TLDbgLogRemainingLength = TLDbgBufferLength_1;
00011bab              }
00011bab              
00011bd0              uint32_t TLDbgLogCounter_1 = TLDbgLogCounter;
00011be7              TLDbgLogCounter = TLDbgLogCounter_1 + 1;
00011bed              RtlStringCchPrintfA(pszDest, 0xa, "%08lX:", (uint64_t)TLDbgLogCounter_1);
00011bff              uint32_t TLDbgLogRemainingLength_1 = TLDbgLogRemainingLength - 9;
00011c07              void* TLDbgCurrentBuffer_1 = &TLDbgCurrentBuffer[9];
00011c0b              uint64_t TLDbgLogRemainingLength_2 = (uint64_t)TLDbgLogRemainingLength_1;
00011c0d              TLDbgLogRemainingLength = TLDbgLogRemainingLength_1;
00011c13              TLDbgCurrentBuffer = TLDbgCurrentBuffer_1;
00011c13              
00011c28              if (!TLDbgLogRemainingLength_2 || TLDbgLogRemainingLength_2 > 0x7fffffff)
00011c2a                  result = -0x3ffffff3;
00011c2a              
00011c31              if (result >= 0)
00011c31              {
00011c44                  result = 0;
00011c46                  int32_t rax_3 = _vsnprintf(TLDbgCurrentBuffer_1, 
00011c46                      TLDbgLogRemainingLength_2 - 1, Format, &arg_20);
00011c4e                  int64_t rax_4;
00011c4e                  
00011c4e                  if (rax_3 >= 0)
00011c50                      rax_4 = (int64_t)rax_3;
00011c50                  
00011c55                  if (rax_3 < 0 || rax_4 > TLDbgLogRemainingLength_2 - 1)
00011c55                  {
00011c5b                      result = -0x7ffffffb;
00011c60                      *(uint8_t*)((char*)TLDbgCurrentBuffer_1 + TLDbgLogRemainingLength_2
00011c60                          - 1) = 0;
00011c55                  }
00011c55                  else if (rax_4 == TLDbgLogRemainingLength_2 - 1)
00011c60                      *(uint8_t*)((char*)TLDbgCurrentBuffer_1 + TLDbgLogRemainingLength_2
00011c60                          - 1) = 0;
00011c60                  
00011c63                  TLDbgLogRemainingLength_1 = TLDbgLogRemainingLength;
00011c69                  TLDbgCurrentBuffer_1 = TLDbgCurrentBuffer;
00011c31              }
00011c31              
00011c76              if (result != 0x80000005)
00011c76              {
00011d47              label_11d47:
00011d47                  
00011d49                  if (result >= 0)
00011d49                  {
00011d4b                      uint64_t TLDbgLogRemainingLength_3 =
00011d4b                          (uint64_t)TLDbgLogRemainingLength_1;
00011d4e                      int32_t rcx_3 = 0;
00011d59                      int32_t r9_4;
00011d59                      
00011d59                      if (!TLDbgCurrentBuffer_1 || TLDbgLogRemainingLength_3 > 0x7fffffff)
00011d86                          r9_4 = -0x3ffffff3;
00011d59                      else
00011d59                      {
00011d5b                          uint64_t TLDbgLogRemainingLength_4 = TLDbgLogRemainingLength_3;
00011d5e                          void* TLDbgCurrentBuffer_2 = TLDbgCurrentBuffer_1;
00011d61                          r9_4 = 0;
00011d61                          
00011d67                          if (TLDbgLogRemainingLength_3)
00011d67                          {
00011d6b                              while (*(uint8_t*)TLDbgCurrentBuffer_2)
00011d6b                              {
00011d6d                                  TLDbgCurrentBuffer_2 += 1;
00011d70                                  uint64_t TLDbgLogRemainingLength_5 =
00011d70                                      TLDbgLogRemainingLength_4;
00011d70                                  TLDbgLogRemainingLength_4 -= 1;
00011d70                                  
00011d74                                  if (TLDbgLogRemainingLength_5 == 1)
00011d74                                      break;
00011d6b                              }
00011d67                          }
00011d67                          
00011d79                          if (!TLDbgLogRemainingLength_3 || !TLDbgLogRemainingLength_4)
00011d79                          {
00011d83                              rcx_3 = 0;
00011d86                              r9_4 = -0x3ffffff3;
00011d79                          }
00011d79                          else
00011d7e                              rcx_3 = (uint32_t)TLDbgLogRemainingLength_3
00011d7e                                  - (uint32_t)TLDbgLogRemainingLength_4;
00011d59                      }
00011d59                      
00011d8f                      if (r9_4 >= 0)
00011d8f                          rbx = rcx_3;
00011d8f                      
00011d9a                      TLDbgLogRemainingLength = TLDbgLogRemainingLength_1 - rbx;
00011da0                      TLDbgCurrentBuffer = (char*)TLDbgCurrentBuffer_1 + (uint64_t)rbx;
00011d49                  }
00011c76              }
00011c76              else
00011c76              {
00011c84                  memset(TLDbgCurrentBuffer_1, 0, (uint64_t)TLDbgLogRemainingLength_1);
00011c89                  uint32_t TLDbgLogCounter_2 = TLDbgLogCounter;
00011c8f                  uint32_t TLDbgBufferLength_2 = TLDbgBufferLength;
00011c96                  char* TLDbgBuffer_1 = TLDbgBuffer;
00011c9d                  TLDbgLogFlags |= 1;
00011cb5                  TLDbgLogRemainingLength = TLDbgBufferLength_2;
00011cbc                  TLDbgCurrentBuffer = TLDbgBuffer_1;
00011cc3                  TLDbgLogCounter = TLDbgLogCounter_2 + 1;
00011cc9                  RtlStringCchPrintfA(TLDbgBuffer_1, 0xa, "%08lX:", 
00011cc9                      (uint64_t)TLDbgLogCounter_2);
00011cdb                  uint32_t rax_7 = TLDbgLogRemainingLength - 9;
00011cde                  void* rsi_3 = &TLDbgCurrentBuffer[9];
00011ce2                  result = 0;
00011ce4                  uint64_t rbp_2 = (uint64_t)rax_7;
00011ce6                  TLDbgCurrentBuffer = rsi_3;
00011ced                  TLDbgLogRemainingLength = rax_7;
00011ced                  
00011cfb                  if (!rbp_2 || rbp_2 > 0x7fffffff)
00011cfd                      result = -0x3ffffff3;
00011cfd                  
00011d04                  if (result >= 0)
00011d04                  {
00011d1b                      result = 0;
00011d1d                      int32_t rax_8 = _vsnprintf(rsi_3, rbp_2 - 1, Format, &arg_20);
00011d25                      int64_t rax_9;
00011d25                      
00011d25                      if (rax_8 >= 0)
00011d27                          rax_9 = (int64_t)rax_8;
00011d27                      
00011d2c                      if (rax_8 < 0 || rax_9 > rbp_2 - 1)
00011d2c                      {
00011d32                          result = -0x7ffffffb;
00011d37                          *(uint8_t*)((char*)rsi_3 + rbp_2 - 1) = 0;
00011d2c                      }
00011d2c                      else if (rax_9 == rbp_2 - 1)
00011d37                          *(uint8_t*)((char*)rsi_3 + rbp_2 - 1) = 0;
00011d37                      
00011d3a                      TLDbgLogRemainingLength_1 = TLDbgLogRemainingLength;
00011d40                      TLDbgCurrentBuffer_1 = TLDbgCurrentBuffer;
00011d40                      goto label_11d47;
00011d04                  }
00011c76              }
00011b95          }
00011b95          else
00011b97              result = -0x3fffff5d;
00011b97          
00011dae          ExReleaseResourceLite(&TLDbgLogLock);
00011db4          KeLeaveCriticalRegion();
00011b77      }
00011b77      
00011dc8      return result;
00011b30  }

00011dc9                             cc cc cc cc cc cc cc                                                           .......

00011dd0    int32_t TLDbgLogRawData(uint32_t Subsystem, uint32_t Level, char* Header, void* Buffer, uint32_t BufferLength)

00011dd0  {
00011deb      void* Buffer_1 = Buffer;
00011df1      int32_t result = 0;
00011df1      
00011dff      if (!TLDbgBuffer)
00011e01          return -0x3fffff5d;
00011e01      
00011e27      if ((Subsystem <= 0 || TLDebugSubsystem & Subsystem)
00011e27          && (Level <= 0 || Level <= TLDebugLevel))
00011e27      {
00011e34          (uint8_t)Level = 1;
00011e36          TLAcquireExcl(&TLDbgLogLock, (uint8_t)Level);
00011e36          
00011e42          if (TLDbgBuffer)
00011e42          {
00011e4e              uint32_t TLDbgLogCounter_1 = TLDbgLogCounter;
00011e54              uint64_t TLDbgLogRemainingLength_1 = (uint64_t)TLDbgLogRemainingLength;
00011e5a              char* TLDbgCurrentBuffer_1 = TLDbgCurrentBuffer;
00011e6d              TLDbgLogCounter = TLDbgLogCounter_1 + 1;
00011e73              char* Header_1 = Header;
00011e78              int32_t result_1 = RtlStringCchPrintfA(TLDbgCurrentBuffer_1, 
00011e78                  TLDbgLogRemainingLength_1, "%08lX: %s ", (uint64_t)TLDbgLogCounter_1);
00011e7d              result = result_1;
00011e7d              
00011e84              if (result_1 == 0x80000005)
00011e84              {
00011e96                  memset(TLDbgCurrentBuffer, 0, (uint64_t)TLDbgLogRemainingLength);
00011e9b                  uint32_t TLDbgLogCounter_2 = TLDbgLogCounter;
00011ea1                  uint64_t TLDbgBufferLength_2 = (uint64_t)TLDbgBufferLength;
00011ea8                  char* TLDbgBuffer_1 = TLDbgBuffer;
00011eaf                  TLDbgLogFlags |= 1;
00011ec2                  TLDbgLogRemainingLength = (uint32_t)TLDbgBufferLength_2;
00011ec9                  TLDbgLogCounter = TLDbgLogCounter_2 + 1;
00011ed2                  TLDbgCurrentBuffer = TLDbgBuffer_1;
00011ed9                  char* Header_2 = Header;
00011ede                  RtlStringCchPrintfA(TLDbgBuffer_1, TLDbgBufferLength_2, "%08lX: %s ", 
00011ede                      (uint64_t)TLDbgLogCounter_2);
00011e84              }
00011e84              
00011ee3              void* TLDbgCurrentBuffer_2 = TLDbgCurrentBuffer;
00011eea              uint64_t TLDbgLogRemainingLength_2 = (uint64_t)TLDbgLogRemainingLength;
00011efe              uint64_t rax_3;
00011efe              int32_t rcx_1;
00011efe              
00011efe              if (!TLDbgCurrentBuffer_2 || TLDbgLogRemainingLength_2 > 0x7fffffff)
00011efe              {
00011f2b                  rax_3 = 0;
00011f30                  rcx_1 = -0x3ffffff3;
00011efe              }
00011efe              else
00011efe              {
00011f00                  uint64_t TLDbgLogRemainingLength_3 = TLDbgLogRemainingLength_2;
00011f03                  void* TLDbgCurrentBuffer_3 = TLDbgCurrentBuffer_2;
00011f06                  rcx_1 = 0;
00011f06                  
00011f0c                  if (TLDbgLogRemainingLength_2)
00011f0c                  {
00011f11                      while (*(uint8_t*)TLDbgCurrentBuffer_3)
00011f11                      {
00011f13                          TLDbgCurrentBuffer_3 += 1;
00011f16                          uint64_t TLDbgLogRemainingLength_4 = TLDbgLogRemainingLength_3;
00011f16                          TLDbgLogRemainingLength_3 -= 1;
00011f16                          
00011f1a                          if (TLDbgLogRemainingLength_4 == 1)
00011f1a                              break;
00011f11                      }
00011f0c                  }
00011f0c                  
00011f1f                  if (!TLDbgLogRemainingLength_2 || !TLDbgLogRemainingLength_3)
00011f1f                  {
00011f26                      rax_3 = 0;
00011f30                      rcx_1 = -0x3ffffff3;
00011f1f                  }
00011f1f                  else
00011f21                      rax_3 = TLDbgLogRemainingLength_2 - TLDbgLogRemainingLength_3;
00011efe              }
00011efe              
00011f38              if (rcx_1 < 0)
00011f38                  rax_3 = 0;
00011f38              
00011f3c              uint32_t BufferLength_1 = BufferLength;
00011f44              int32_t var_28;
00011f44              var_28 = rax_3;
00011f49              uint32_t TLDbgBufferLength_1 = (uint32_t)TLDbgLogRemainingLength_2;
00011f4f              char* TLDbgBuffer_2 = (char*)TLDbgCurrentBuffer_2 + (uint64_t)(uint32_t)rax_3;
00011f4f              
00011f55              if (TLDbgBufferLength_1 < BufferLength_1)
00011f55              {
00011f60                  uint64_t TLDbgBufferLength_3 = (uint64_t)TLDbgBufferLength_1;
00011f62                  memmove(TLDbgBuffer_2, Buffer_1, (uint64_t)TLDbgBufferLength_1);
00011f67                  TLDbgBuffer_2 = TLDbgBuffer;
00011f6e                  BufferLength_1 -= TLDbgBufferLength_1;
00011f71                  TLDbgBufferLength_1 = TLDbgBufferLength;
00011f77                  Buffer_1 += TLDbgBufferLength_3;
00011f7a                  TLDbgLogFlags |= 1;
00011f55              }
00011f55              
00011f8d              memmove(TLDbgBuffer_2, Buffer_1, (uint64_t)BufferLength_1);
00011f98              TLDbgCurrentBuffer = &TLDbgBuffer_2[(uint64_t)BufferLength_1];
00011f9f              TLDbgLogRemainingLength = TLDbgBufferLength_1 - BufferLength_1;
00011e42          }
00011e42          else
00011e44              result = -0x3fffff5d;
00011e44          
00011fac          ExReleaseResourceLite(&TLDbgLogLock);
00011fb2          KeLeaveCriticalRegion();
00011e27      }
00011e27      
00011fd2      return result;
00011dd0  }

00011fd3                                                           cc cc cc cc cc cc cc cc cc                                 .........

00011fdc    int32_t TLConfigureTrace(struct _TL_DEBUG_TRACE_CONFIG_CB* TraceInfo)

00011fdc  {
00012001      int32_t result = 0;
00012003      TLAcquireExcl(&TLDbgLogLock, 1);
00012008      uint32_t TraceLevel = TraceInfo->TraceLevel;
0001200b      uint32_t TLDebugLevel_1 = TLDebugLevel;
00012011      uint32_t TLDebugSubsystem_1 = TLDebugSubsystem;
00012011      
0001202a      if (TraceLevel != TLDebugLevel_1 || TraceInfo->TraceBufferLength != TLDbgBufferLength
0001202a          || TraceInfo->Subsystem != TLDebugSubsystem_1)
0001202a      {
00012042          void var_18;
00012042          
00012042          if (TraceLevel != 0xffffffff && TraceLevel != TLDebugLevel_1)
00012042          {
00012050              TLDebugLevel = TraceLevel;
00012057              RtlInitUnicodeString(&var_18, u"DebugLevel");
0001206b              int32_t result_1 = TLUpdateRegistryParameter(&var_18, 4, TraceInfo, 4);
00012070              TLDebugSubsystem_1 = TLDebugSubsystem;
00012076              result = result_1;
00012042          }
00012042          
00012078          uint32_t Subsystem = TraceInfo->Subsystem;
00012078          
00012082          if (Subsystem != 0xffffffff && Subsystem != TLDebugSubsystem_1)
00012082          {
00012090              TLDebugSubsystem = Subsystem;
00012096              RtlInitUnicodeString(&var_18, u"TraceSubsystem");
000120b0              result = TLUpdateRegistryParameter(&var_18, 4, &TraceInfo->Subsystem, 4);
00012082          }
00012082          
000120b2          uint32_t DebugFlags = TraceInfo->DebugFlags;
000120b2          
000120c0          if (DebugFlags != 0xffffffff && DebugFlags != TLDebugFlags)
000120c0          {
000120ce              TLDebugFlags = DebugFlags;
000120d4              RtlInitUnicodeString(&var_18, u"DebugFlags");
000120ee              result = TLUpdateRegistryParameter(&var_18, 4, &TraceInfo->DebugFlags, 4);
000120c0          }
000120c0          
000120f0          uint32_t TraceBufferLength = TraceInfo->TraceBufferLength;
000120f0          
00012102          if (TraceBufferLength != 0xffffffff && TraceBufferLength != TLDbgBufferLength)
00012102          {
00012114              RtlInitUnicodeString(&var_18, u"TraceBufferSize");
00012129              int32_t result_2 =
00012129                  TLUpdateRegistryParameter(&var_18, 4, &TraceInfo->TraceBufferLength, 4);
0001212e              char* TLDbgBuffer_1 = TLDbgBuffer;
00012135              TLDbgLogFlags &= 0xfffffffe;
0001213c              result = result_2;
00012141              uint32_t TLDbgBufferLength_1 = TraceInfo->TraceBufferLength << 0xa;
00012144              TLDbgBufferLength = TLDbgBufferLength_1;
00012144              
0001214d              if (TLDbgBuffer_1)
0001214d              {
00012151                  ExFreePoolWithTag(TLDbgBuffer_1, 0);
00012157                  TLDbgBufferLength_1 = TLDbgBufferLength;
0001215d                  TLDbgBuffer = nullptr;
00012165                  TLMemoryUsage.TotalNonPagedPool -= TLDbgBufferLength_1;
0001216b                  TLMemoryUsage.AllocationTable[0] -= TLDbgBufferLength_1;
00012171                  TLDbgCurrentBuffer = nullptr;
00012179                  TLDbgLogRemainingLength = 0;
0001214d              }
0001214d              
00012182              if (TLDbgBufferLength_1)
00012182              {
0001218e                  char* rax_5 = ExAllocatePoolWithTag(NonPagedPool, 
0001218e                      (uint64_t)TLDbgBufferLength_1, 0x41474c54);
00012197                  TLDbgBuffer = rax_5;
00012197                  
000121a1                  if (rax_5)
000121a1                  {
000121b0                      uint32_t TLDbgBufferLength_2 = TLDbgBufferLength;
000121b6                      TLDbgCurrentBuffer = rax_5;
000121bd                      TLMemoryUsage.TotalNonPagedPool += TLDbgBufferLength_2;
000121c3                      TLMemoryUsage.AllocationTable[0] += TLDbgBufferLength_2;
000121c9                      TLDbgLogRemainingLength = TLDbgBufferLength_2;
000121cf                      TLTagInitialLogEntry();
000121a1                  }
000121a1                  else
000121a1                  {
000121a3                      TLDbgBufferLength &= (uint32_t)rax_5;
000121a9                      result = -0x3fffff66;
000121a1                  }
00012182              }
00012102          }
0001202a      }
0001202a      
000121db      ExReleaseResourceLite(&TLDbgLogLock);
000121e1      KeLeaveCriticalRegion();
00012203      return result;
00011fdc  }

00012204              cc cc cc cc cc cc cc cc                                                                  ........

0001220c    int32_t TLGetTraceBuffer(uint32_t TraceBufferLength, void* TraceBuffer, uint64_t* CopiedLength)

0001220c  {
00012228      void* TraceBuffer_1 = TraceBuffer;
0001222d      int32_t result = 0;
0001222f      KeEnterCriticalRegion();
0001222f      
00012247      if (!ExAcquireResourceSharedLite(&TLDbgLogLock, 1))
00012249          KeLeaveCriticalRegion();
00012249      
0001224f      uint32_t TLDbgBufferLength_1 = TLDbgBufferLength;
0001224f      
00012257      if (TraceBufferLength >= TLDbgBufferLength_1)
00012257      {
00012260          bool cond:0_1 = !((*(uint8_t*)TLDbgLogFlags) & 1);
00012267          *(uint64_t*)CopiedLength = 0;
00012267          
0001226b          if (!cond:0_1)
0001226b          {
0001226d              uint64_t TLDbgLogRemainingLength_1 = (uint64_t)TLDbgLogRemainingLength;
00012280              memmove(TraceBuffer_1, TLDbgCurrentBuffer, TLDbgLogRemainingLength_1);
00012285              *(uint8_t*)TraceBuffer_1 = 0x30;
0001228a              TraceBuffer_1 += TLDbgLogRemainingLength_1;
0001228d              *(uint64_t*)CopiedLength = TLDbgLogRemainingLength_1;
0001226b          }
0001226b          
00012291          uint32_t rdi = TLDbgBufferLength_1 - TLDbgLogRemainingLength;
00012291          
00012297          if (TLDbgBufferLength_1 != TLDbgLogRemainingLength)
00012297          {
000122a8              memmove(TraceBuffer_1, TLDbgBuffer, (uint64_t)rdi);
000122ad              *(uint64_t*)CopiedLength += (uint64_t)rdi;
00012297          }
00012257      }
00012257      else
00012259          result = -0x3ffffff3;
00012259      
000122b8      ExReleaseResourceLite(&TLDbgLogLock);
000122be      KeLeaveCriticalRegion();
000122e0      return result;
0001220c  }

000122e1     cc cc cc cc cc cc cc                                                                           .......

000122e8    void TLTagInitialLogEntry(...)

000122e8  {
00012303      int64_t SystemTime = *(uint64_t*)-0xfffff78000000014;
00012308      void arg_10;
00012308      ExSystemTimeToLocalTime(&SystemTime, &arg_10);
00012318      TIME_FIELDS TimeFields;
00012318      RtlTimeToTimeFields(&arg_10, &TimeFields);
0001236b      TLDbgLogMsg(0, 0, "TL Log Initialized %d-%d-%d %d:%d Level %d Subsystems %08lX\n", 
0001236b          (uint64_t)(int32_t)TimeFields.Month, (int32_t)TimeFields.Day, 
0001236b          (int32_t)TimeFields.Year, (int32_t)TimeFields.Hour, (int32_t)TimeFields.Minute, 
0001236b          TLDebugLevel, TLDebugSubsystem);
000122e8  }

00012375                                                                 cc cc cc cc cc cc cc                                   .......

0001237c    int32_t TLInitQueueWorker(struct _TL_WORKER_QUEUE_HDR* WorkerContext, void (* StartRoutine)(void*), void* Context)

0001237c  {
0001238b      HANDLE arg_8 = nullptr;
0001239f      KeInitializeEvent(WorkerContext, NotificationEvent, 0);
000123ae      KeInitializeEvent(&WorkerContext->WorkerThreadShutdown, NotificationEvent, 0);
000123bd      KeInitializeEvent(&WorkerContext->WorkerQueueHasItems, NotificationEvent, 0);
000123c3      WorkerContext->QueueLock = 0;
000123e5      WorkerContext->State = 1;
000123ec      NTSTATUS result_1 =
000123ec          PsCreateSystemThread(&arg_8, 0, nullptr, nullptr, nullptr, StartRoutine, Context);
000123f2      NTSTATUS result = result_1;
000123f2      
000123f6      if (result_1 >= STATUS_SUCCESS)
000123f6      {
00012417          ObReferenceObjectByHandle(arg_8, 0xc0000000, nullptr, 0, 
00012417              &WorkerContext->WorkerThreadObject, nullptr);
00012439          result = KeWaitForSingleObject(WorkerContext, Executive, 0, 0, nullptr);
0001243b          ZwClose(arg_8);
000123f6      }
000123f6      
00012452      return result;
0001237c  }

00012453                                                           cc cc cc cc cc cc cc cc cc                                 .........

0001245c    int32_t TLShutdownQueueWorker(struct _TL_WORKER_QUEUE_HDR* WorkerContext, uint8_t WaitFlag)

0001245c  {
00012466      NTSTATUS result = STATUS_SUCCESS;
00012466      
0001246f      if (WorkerContext->WorkerThreadObject)
0001246f      {
00012471          uint32_t State = WorkerContext->State;
00012471          
0001247a          if ((char)(State >> 1) & 1)
0001247a          {
00012484              WorkerContext->State = State & 0xfffffffc;
0001248b              KeSetEvent(&WorkerContext->WorkerThreadShutdown, 0, 0);
0001247a          }
0001247a          
000124ac          result = KeWaitForSingleObject(WorkerContext->WorkerThreadObject, Executive, 0, 
000124ac              0, nullptr);
000124ae          ObfDereferenceObject(WorkerContext->WorkerThreadObject);
000124b4          WorkerContext->WorkerThreadObject = nullptr;
0001246f      }
0001246f      
000124c5      return result;
0001245c  }

000124c6                    cc cc cc cc cc cc                                                                    ......

000124cc    void TLConsumerQueueWorker(void* Context)

000124cc  {
000124de      uint32_t UserTime = 0;
000124e3      int64_t* r12 = *(uint64_t*)((char*)Context + 0x78);
000124eb      void* Object = (char*)Context + 0x18;
000124fb      void* var_30 = (char*)Context + 0x58;
000124ff      KeSetEvent(Context, 0, 0);
00012505      *(uint32_t*)((char*)Context + 0x38) |= 2;
00012511      QueueConnectedCallback(&r12[0x11d7]);
0001267f      void* gsbase;
0001267f      
0001267f      while (*(uint8_t*)((char*)Context + 0x38) & 1)
0001267f      {
0001255a          TLConsumerWorkerThreadTime =
0001255a              KeQueryRuntimeThread(*(uint64_t*)((char*)gsbase + 0x188), &UserTime);
00012565          NTSTATUS rax_3 = KeWaitForMultipleObjects(2, &Object, WaitAny, Executive, 0, 0, 
00012565              nullptr, nullptr);
00012565          
0001256d          if (!rax_3)
0001256d              break;
0001256d          
00012576          if (rax_3 != 0x1)
00012576          {
0001265b              if (rax_3 != STATUS_USER_APC)
0001265b                  break;
0001265b              
00012669              int64_t Interval = -0x2710;
00012675              KeDelayExecutionThread(0, 0, &Interval);
00012576          }
00012576          else
00012576          {
0001257f              struct _TL_WORK_ITEM* P_2 = TLRemoveWorkItem(Context);
00012584              struct _TL_WORK_ITEM* P_1 = P_2;
00012584              
0001258a              if (P_2)
0001258a              {
00012590                  uint32_t RequestType = P_2->RequestType;
00012590                  
00012596                  if (RequestType == 1)
00012627                      Parser_ProcessStream(&r12[0x56], &P_1[1], P_1->Size);
00012596                  else if (RequestType == 2)
0001259b                  {
000125e6                      uint32_t Size = P_1->Size;
000125e6                      
000125fb                      if (TLCallbackFnc(*(uint64_t*)r12, 8, P_1, 0) >= 0)
000125fb                      {
00012602                          TLMemoryUsage.TotalNonPagedPool += 0xffffffc8 - Size;
0001260d                          (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] +=
0001260d                              0xffffffc8 - Size;
00012613                          P_1 = nullptr;
000125fb                      }
0001259b                  }
0001259b                  else if (RequestType == 3)
000125a0                  {
000125a6                      int64_t rax_6 = r12[0x11d8];
000125a6                      
000125b1                      if (!rax_6)
000125db                          onBug__("TransLibIO.c: ReceiveHWReportCallback not assigned", 
000125db                              "c:\development_work\csf_release_hp\driver\translib\translibio.c", 
000125db                              0x81);
000125b1                      else
000125c3                          rax_6(&r12[0x11d7], &P_1[1], (uint64_t)P_1->Size);
000125a0                  }
000125a0                  
0001262f                  if (P_1)
0001262f                  {
0001263c                      TLMemoryUsage.TotalNonPagedPool += 0xffffffc8 - P_1->Size;
00012648                      (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] +=
00012648                          0xffffffc8 - P_1->Size;
0001264e                      ExFreePoolWithTag(P_1, 0);
0001262f                  }
0001258a              }
00012576          }
0001267f      }
0001267f      
0001268d      QueueDisconnectedCallback(&r12[0x11d7]);
0001268d      
000126bb      while (true)
000126bb      {
000126bb          struct _TL_WORK_ITEM* P = TLRemoveWorkItem(Context);
000126bb          
000126c3          if (!P)
000126c3              break;
000126c3          
0001269d          TLMemoryUsage.TotalNonPagedPool += 0xffffffc8 - P->Size;
000126a9          (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] += 0xffffffc8 - P->Size;
000126b2          ExFreePoolWithTag(P, 0);
000126bb      }
000126bb      
000126de      TLConsumerWorkerThreadTime =
000126de          KeQueryRuntimeThread(*(uint64_t*)((char*)gsbase + 0x188), &UserTime);
000126e4      PsTerminateSystemThread(STATUS_SUCCESS);
000124cc  }

000126fe                                                                                            cc cc                                ..
00012700  cc cc cc cc                                                                                      ....

00012704    void TLReaderWorker(void* Context)

00012704  {
00012714      uint32_t UserTime = 0;
00012719      int64_t rsi = *(uint64_t*)((char*)Context + 0x78);
00012721      void* Object = (char*)Context + 0x18;
00012731      void* var_10 = (char*)Context + 0x58;
00012735      KeSetEvent(Context, 0, 0);
0001273b      *(uint32_t*)((char*)Context + 0x38) |= 2;
0001282a      void* gsbase;
0001282a      
0001282a      while (*(uint8_t*)((char*)Context + 0x38) & 1)
0001282a      {
00012779          TLReaderWorkerThreadTime =
00012779              KeQueryRuntimeThread(*(uint64_t*)((char*)gsbase + 0x188), &UserTime);
00012784          NTSTATUS rax_3 = KeWaitForMultipleObjects(2, &Object, WaitAny, Executive, 0, 0, 
00012784              nullptr, nullptr);
00012784          
0001278c          if (!rax_3)
0001278c              break;
0001278c          
00012795          if (rax_3 != 0x1)
00012795          {
0001280c              if (rax_3 != STATUS_USER_APC)
0001280c                  break;
0001280c              
00012817              int64_t Interval = -0x2710;
00012820              KeDelayExecutionThread(0, 0, &Interval);
00012795          }
00012795          else
00012795          {
0001279a              struct _TL_WORK_ITEM* P = TLRemoveWorkItem(Context);
0001279a              
000127a5              if (P)
000127a5              {
000127a7                  int64_t rax_4 = *(uint64_t*)((char*)Context + 0x70);
000127a7                  
000127ae                  if (rax_4)
000127ae                  {
000127b0                      uint32_t Size = P->Size;
000127b0                      
000127b7                      if (Size)
000127c7                          rax_4(rsi + 0x8eb8, (char*)P + 0x39, (uint64_t)(Size - 1));
000127ae                  }
000127ae                  
000127cf                  if (!(P->RequestFlags & 1))
000127cf                  {
000127eb                      TLMemoryUsage.TotalNonPagedPool += 0xffffffc8 - P->Size;
000127f9                      (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] +=
000127f9                          0xffffffc8 - P->Size;
000127ff                      ExFreePoolWithTag(P, 0);
000127cf                  }
000127cf                  else
000127d8                      KeSetEvent(&P->Event, 0, 0);
000127a5              }
00012795          }
0001282a      }
0001282a      
00012874      while (true)
00012874      {
00012874          struct _TL_WORK_ITEM* P_1 = TLRemoveWorkItem(Context);
00012874          
0001287f          if (!P_1)
0001287f              break;
0001287f          
00012839          if (!(P_1->RequestFlags & 1))
00012839          {
00012856              TLMemoryUsage.TotalNonPagedPool += 0xffffffc8 - P_1->Size;
00012865              (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] += 0xffffffc8 - P_1->Size;
0001286b              ExFreePoolWithTag(P_1, 0);
00012839          }
00012839          else
00012842              KeSetEvent(&P_1->Event, 0, 0);
00012874      }
00012874      
00012897      TLReaderWorkerThreadTime =
00012897          KeQueryRuntimeThread(*(uint64_t*)((char*)gsbase + 0x188), &UserTime);
0001289d      PsTerminateSystemThread(STATUS_SUCCESS);
00012704  }

000128b3                                                           cc cc cc cc cc cc cc cc cc                                 .........

000128bc    void TLTimerWorker(void* Context)

000128bc  {
000128cf      uint32_t UserTime = 0;
000128d4      void* rbp = *(uint64_t*)((char*)Context + 0x78);
000128e5      void* var_20 = (char*)Context + 0x18;
000128ec      void* Object = (char*)Context + 0x58;
000128f0      KeSetEvent(Context, 0, 0);
000128f6      *(uint32_t*)((char*)Context + 0x38) |= 2;
000128fe      void* gsbase;
000128fe      
000128fe      while (*(uint8_t*)((char*)Context + 0x38) & 1)
000128fe      {
0001293f          TLTimerWorkerThreadTime =
0001293f              KeQueryRuntimeThread(*(uint64_t*)((char*)gsbase + 0x188), &UserTime);
0001294a          NTSTATUS rax_2 = KeWaitForMultipleObjects(2, &Object, WaitAny, Executive, 0, 0, 
0001294a              nullptr, nullptr);
0001294a          
00012953          if (rax_2 == 0x1)
00012953              break;
00012953          
00012957          if (!rax_2)
00012957          {
0001296a              if ((char)(*(uint32_t*)((char*)rbp + 0x18) >> 2) & 1 && gCSFEnabled)
0001296a              {
0001296c                  void* rbx_1 = *(uint64_t*)((char*)rbp + 0x2c0);
0001297d                  ST_TickSoftTimer((char*)rbx_1 + 0x8b20, 0xa);
0001298c                  ST_TickSoftTimer((char*)rbx_1 + 0x8b40, 0xa);
0001299b                  ST_TickSoftTimer((char*)rbx_1 + 0x8dd0, 0xa);
000129aa                  ST_TickSoftTimer((char*)rbx_1 + 0x8db0, 0xa);
000129b9                  ST_TickSoftTimer((char*)rbx_1 + 0x8f08, 0xa);
0001296a              }
0001296a              
000129c1              KeResetEvent((char*)Context + 0x58);
00012957          }
000128fe      }
000128fe      
000129e7      TLTimerWorkerThreadTime =
000129e7          KeQueryRuntimeThread(*(uint64_t*)((char*)gsbase + 0x188), &UserTime);
000129ed      PsTerminateSystemThread(STATUS_SUCCESS);
000128bc  }

00012a08                          cc cc cc cc cc cc cc cc                                                          ........

00012a10    int32_t TLInsertWorkItem(struct _TL_WORKER_QUEUE_HDR* WorkerContext, struct _TL_WORK_ITEM* WorkItem)

00012a10  {
00012a2e      char rax = KeAcquireSpinLockRaiseToDpc(&WorkerContext->QueueLock);
00012a34      struct _TL_WORK_ITEM* QueueTail = WorkerContext->QueueTail;
00012a38      int64_t rbp;
00012a38      (uint8_t)rbp = rax;
00012a38      
00012a3e      if (!QueueTail)
00012a45          WorkerContext->QueueHead = WorkItem;
00012a3e      else
00012a3e      {
00012a40          QueueTail->next = (uint32_t)WorkItem;
00012a40          *(uint32_t*)((char*)QueueTail->next)[4] = *(uint32_t*)((char*)WorkItem)[4];
00012a3e      }
00012a3e      
00012a49      WorkItem->next = 0;
00012a56      WorkerContext->QueueTail = WorkItem;
00012a5a      KeSetEvent(&WorkerContext->WorkerQueueHasItems, 0, 0);
00012a64      uint64_t NewIrql;
00012a64      (uint8_t)NewIrql = (uint8_t)rbp;
00012a67      KeReleaseSpinLock(&WorkerContext->QueueLock, NewIrql);
00012a83      return 0;
00012a10  }

00012a84              cc cc cc cc cc cc cc cc                                                                  ........

00012a8c    struct _TL_WORK_ITEM* TLRemoveWorkItem(struct _TL_WORKER_QUEUE_HDR* WorkerContext)

00012a8c  {
00012aa7      struct _TL_WORK_ITEM* result = nullptr;
00012aa9      char rax;
00012aa9      uint64_t NewIrql;
00012aa9      rax = KeAcquireSpinLockRaiseToDpc(&WorkerContext->QueueLock);
00012aaf      int64_t rbp;
00012aaf      (uint8_t)rbp = rax;
00012ab2      struct _TL_WORK_ITEM* QueueHead = WorkerContext->QueueHead;
00012ab2      
00012ab9      if (!QueueHead)
00012ad2          KeResetEvent(&WorkerContext->WorkerQueueHasItems);
00012ab9      else
00012ab9      {
00012abb          result = QueueHead;
00012abe          struct _TL_WORK_ITEM* next = QueueHead->next;
00012ac1          WorkerContext->QueueHead = next;
00012ac1          
00012ac8          if (!next)
00012ac8          {
00012aca              WorkerContext->QueueTail &= next;
00012ad2              KeResetEvent(&WorkerContext->WorkerQueueHasItems);
00012ac8          }
00012ab9      }
00012ab9      
00012adc      (uint8_t)NewIrql = (uint8_t)rbp;
00012adf      KeReleaseSpinLock(&WorkerContext->QueueLock, NewIrql);
00012afc      return result;
00012a8c  }

00012afd                                                                                         cc cc cc                               ...
00012b00  cc cc cc cc                                                                                      ....

00012b04    int32_t TLQueueConsumerQueueWorkerRequest(struct _TL_WORKER_QUEUE_HDR* pWorkerContext, uint32_t RequestType, uint8_t* DataBuffer, uint32_t DataBufferLength, int32_t Command)

00012b04  {
00012b20      uint64_t DataBufferLength_1 = (uint64_t)DataBufferLength;
00012b20      
00012b38      if (!((char)(pWorkerContext->pTransLibContext->TLDeviceState >> 2) & 1))
00012b3a          return -0x3fffff5d;
00012b3a      
00012b50      struct _TL_WORK_ITEM* rax_1 =
00012b50          ExAllocatePoolWithTag(NonPagedPool, DataBufferLength_1 + 0x38, 0x52484c54);
00012b50      
00012b5c      if (!rax_1)
00012b5c      {
00012bc9          if (rax_1)
00012bc9          {
00012bd0              ExFreePoolWithTag(rax_1, 0);
00012bdd              uint32_t rax_4 = (*(uint224_t*)TLMemoryUsage.AllocationTable)[2];
00012be8              TLMemoryUsage.TotalNonPagedPool =
00012be8                  TLMemoryUsage.TotalNonPagedPool + (uint32_t)DataBufferLength_1 + 0x38;
00012bf2              (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] =
00012bf2                  rax_4 + (uint32_t)DataBufferLength_1 + 0x38;
00012bc9          }
00012bc9          
00012c12          return -0x3fffff66;
00012b5c      }
00012b5c      
00012b71      uint32_t rax_3 = (*(uint224_t*)TLMemoryUsage.AllocationTable)[2];
00012b7b      TLMemoryUsage.TotalNonPagedPool =
00012b7b          TLMemoryUsage.TotalNonPagedPool + (uint32_t)DataBufferLength_1 + 0x38;
00012b85      (*(uint224_t*)TLMemoryUsage.AllocationTable)[2] =
00012b85          rax_3 + (uint32_t)DataBufferLength_1 + 0x38;
00012b8e      memset(rax_1, 0, 0x38);
00012b93      rax_1->Command = 0;
00012ba1      rax_1->Size = (uint32_t)DataBufferLength_1;
00012ba4      rax_1->RequestType = RequestType;
00012ba8      memmove(&rax_1[1], DataBuffer, DataBufferLength_1);
00012bad      QueueCount += 1;
00012bbb      TLInsertWorkItem(pWorkerContext, rax_1);
00012bc0      return 0;
00012b04  }

00012c13                                                           cc cc cc cc cc cc cc cc cc                                 .........

00012c1c    int32_t TransLibInitRegistry(struct _UNICODE_STRING* RegistryPath)

00012c1c  {
00012c2e      uint16_t rdx = RegistryPath->Length + 2;
00012c38      TLRegistryPath.MaximumLength = rdx;
00012c48      TLRegistryPath.Length = RegistryPath->Length;
00012c4f      WCHAR* rax_1 = ExAllocatePoolWithTag(PagedPool, (uint64_t)rdx, 0x41474c54);
00012c55      TLRegistryPath.Buffer = rax_1;
00012c55      
00012c5f      if (!rax_1)
00012c61          return -0x3fffff66;
00012c61      
00012c78      memset(rax_1, 0, (uint64_t)TLRegistryPath.MaximumLength);
00012c8c      memmove(TLRegistryPath.Buffer, RegistryPath->Buffer, (uint64_t)RegistryPath->Length);
00012c9e      memset(&TLMemoryUsage, 0, 0x24);
00012caa      TLReadRegistry(&TLRegistryPath);
00012cb6      int32_t rdi_1 = -0x3fffff66;
00012cbb      ExInitializeResourceLite(&TLDbgLogLock);
00012cca      TLAcquireExcl(&TLDbgLogLock, 1);
00012ccf      uint64_t TLDbgBufferLength_2 = (uint64_t)TLDbgBufferLength;
00012ccf      
00012cd9      if ((uint32_t)TLDbgBufferLength_2 > 0)
00012cd9      {
00012ce6          char* rax_2 =
00012ce6              ExAllocatePoolWithTag(NonPagedPool, TLDbgBufferLength_2, 0x41474c54);
00012cef          TLDbgBuffer = rax_2;
00012cef          
00012cf9          if (rax_2)
00012cf9          {
00012cfb              uint32_t TLDbgBufferLength_1 = TLDbgBufferLength;
00012d01              TLDbgCurrentBuffer = rax_2;
00012d08              rdi_1 = 0;
00012d0a              TLMemoryUsage.TotalNonPagedPool += TLDbgBufferLength_1;
00012d10              TLMemoryUsage.AllocationTable[0] += TLDbgBufferLength_1;
00012d16              TLDbgLogRemainingLength = TLDbgBufferLength_1;
00012cf9          }
00012cd9      }
00012cd9      
00012d23      ExReleaseResourceLite(&TLDbgLogLock);
00012d29      KeLeaveCriticalRegion();
00012d29      
00012d31      if (rdi_1 >= 0)
00012d33          TLTagInitialLogEntry();
00012d33      
00012d47      TLDbgLogMsg(4, 3, "NWTransLib DllInitialize Initialization of NW Trans Library\n");
00012d53      TLReadSettingsFolder(&TLRegistryPath);
00012d53      
00012d5f      if (!TLSettingsFolder.Length)
00012d6f          TLDbgLogMsg(0, 1, 
00012d6f              "NWTransLib DllInitialize Failed to locate settings folder in regsitry\n");
00012d6f      
00012d80      return 0;
00012c1c  }

00012d81     cc cc cc cc cc cc cc                                                                           .......

00012d88    int32_t TransLibCleanupRegistry()

00012d88  {
00012d8c      WCHAR* Buffer = TLRegistryPath.Buffer;
00012d8c      
00012d96      if (Buffer)
00012d96      {
00012d9a          ExFreePoolWithTag(Buffer, 0);
00012da0          TLRegistryPath.Buffer = nullptr;
00012d96      }
00012d96      
00012da8      WCHAR* Buffer_1 = TLSettingsFolder.Buffer;
00012da8      
00012db2      if (Buffer_1)
00012db2      {
00012db6          ExFreePoolWithTag(Buffer_1, 0);
00012dbc          TLSettingsFolder.Buffer = nullptr;
00012db2      }
00012db2      
00012dcd      TLAcquireExcl(&TLDbgLogLock, 1);
00012dd2      char* TLDbgBuffer_1 = TLDbgBuffer;
00012dd2      
00012ddc      if (TLDbgBuffer_1)
00012ddc      {
00012de0          ExFreePoolWithTag(TLDbgBuffer_1, 0);
00012de6          uint32_t TLDbgBufferLength_1 = TLDbgBufferLength;
00012ded          TLMemoryUsage.TotalNonPagedPool -= TLDbgBufferLength_1;
00012df4          TLMemoryUsage.AllocationTable[0] -= TLDbgBufferLength_1;
00012ddc      }
00012ddc      
00012dfb      TLDbgBuffer = nullptr;
00012e03      TLDbgCurrentBuffer = nullptr;
00012e0b      TLDbgLogRemainingLength = 0;
00012e19      ExReleaseResourceLite(&TLDbgLogLock);
00012e1f      KeLeaveCriticalRegion();
00012e2c      ExDeleteResourceLite(&TLDbgLogLock);
00012e38      return 0;
00012d88  }

00012e39                                                                             cc cc cc cc cc cc cc                           .......

00012e40    int32_t TLReadSettingsFolder(struct _UNICODE_STRING* RegistryPath)

00012e40  {
00012e5a      void var_d8;
00012e5a      int64_t rax_1 = __security_cookie ^ &var_d8;
00012e73      int64_t var_28;
00012e73      __builtin_memcpy(&var_28, "\\Parameters", 0x18);
00012ea1      char* rax_3 = ExAllocatePoolWithTag(PagedPool, 
00012ea1          (uint64_t)(RegistryPath->Length + 0x18), 0x41474c54);
00012eb9      UNICODE_STRING DestinationString;
00012eb9      RtlInitUnicodeString(&DestinationString, u"NO NAME");
00012ebf      int32_t result = 0;
00012ebf      
00012ec4      if (!rax_3)
00012f95          result = -0x3fffff66;
00012ec4      else
00012ec4      {
00012ed5          memmove(rax_3, RegistryPath->Buffer, (uint64_t)RegistryPath->Length);
00012ee9          uint64_t r11_2 = (uint64_t)RegistryPath->Length >> 1;
00012ef0          *(uint64_t*)(rax_3 + (r11_2 << 1)) = var_28;
00012efa          int64_t var_20;
00012efa          *(uint64_t*)(rax_3 + (r11_2 << 1) + 8) = var_20;
00012f08          int64_t var_18;
00012f08          *(uint64_t*)(rax_3 + (r11_2 << 1) + 0x10) = var_18;
00012f0d          RTL_QUERY_REGISTRY_TABLE QueryTable;
00012f0d          memset(&QueryTable, 0, 0x70);
00012f19          QueryTable.Name = u"SettingsFolder";
00012f35          QueryTable.EntryContext = &TLSettingsFolder;
00012f3a          TLSettingsFolder.Length = 0;
00012f41          TLSettingsFolder.MaximumLength = 0;
00012f48          TLSettingsFolder.Buffer = nullptr;
00012f4f          QueryTable.Flags = 0x20;
00012f57          QueryTable.DefaultType = 0;
00012f5b          QueryTable.DefaultData = 0;
00012f60          QueryTable.DefaultLength = 0;
00012f60          
00012f71          if (RtlQueryRegistryValues(0x80000000, rax_3, &QueryTable, nullptr, 0)
00012f71              < STATUS_SUCCESS)
00012f71          {
00012f73              TLSettingsFolder.Length = 0;
00012f7a              TLSettingsFolder.MaximumLength = 0;
00012f81              TLSettingsFolder.Buffer = nullptr;
00012f71          }
00012f71          
00012f8d          ExFreePoolWithTag(rax_3, 0);
00012ec4      }
00012ec4      
00012fa7      __security_check_cookie(rax_1 ^ &var_d8);
00012fc0      return result;
00012e40  }

00012fc1     cc cc cc cc cc cc cc                                                                           .......

00012fc8    int32_t TLReadCSFEnabled(struct _UNICODE_STRING* RegistryPath, uint32_t* pCSFEnabled)

00012fc8  {
00012fe2      void var_d8;
00012fe2      int64_t rax_1 = __security_cookie ^ &var_d8;
00012ffb      int64_t var_28;
00012ffb      __builtin_memcpy(&var_28, "\\Parameters", 0x18);
00013015      int32_t result = 0;
0001302c      int32_t var_a4 = 1;
00013030      uint32_t var_a8 = 0;
00013037      uint16_t rax_2;
00013037      char* rax_3 = ExAllocatePoolWithTag(PagedPool, (uint64_t)rax_2, 0x41474c54);
00013037      
00013043      if (!rax_3)
00013101          result = -0x3fffff66;
00013043      else
00013043      {
0001305b          memmove(rax_3, TLRegistryPath.Buffer, (uint64_t)TLRegistryPath.Length);
00013073          uint64_t r11_2 = (uint64_t)TLRegistryPath.Length >> 1;
0001307a          *(uint64_t*)(rax_3 + (r11_2 << 1)) = var_28;
00013084          int64_t var_20;
00013084          *(uint64_t*)(rax_3 + (r11_2 << 1) + 8) = var_20;
00013092          int64_t var_18;
00013092          *(uint64_t*)(rax_3 + (r11_2 << 1) + 0x10) = var_18;
00013097          RTL_QUERY_REGISTRY_TABLE QueryTable;
00013097          memset(&QueryTable, 0, 0x70);
000130a6          QueryTable.DefaultType = 4;
000130aa          QueryTable.DefaultLength = 4;
000130ae          QueryTable.Name = u"CSFEnabled";
000130bd          QueryTable.EntryContext = &var_a8;
000130d2          QueryTable.Flags = 0x20;
000130da          QueryTable.DefaultData = &var_a4;
000130da          
000130ec          if (RtlQueryRegistryValues(0x80000000, rax_3, &QueryTable, nullptr, 0)
000130ec                  >= STATUS_SUCCESS)
000130f2              *(uint32_t*)pCSFEnabled = var_a8;
000130f2          
000130f9          ExFreePoolWithTag(rax_3, 0);
00013043      }
00013043      
00013113      __security_check_cookie(rax_1 ^ &var_d8);
0001312c      return result;
00012fc8  }

0001312d                                         cc cc cc cc cc cc cc                                                   .......

00013134    int32_t TLReadRegistry(struct _UNICODE_STRING* RegistryPath)

00013134  {
00013152      void var_e8;
00013152      int64_t rax_1 = __security_cookie ^ &var_e8;
0001316b      int64_t var_28;
0001316b      __builtin_memcpy(&var_28, "\\Parameters", 0x18);
00013175      int32_t result = 0;
00013192      uint16_t rax_2 = RegistryPath->Length + 0x18;
00013196      int32_t var_b4 = 0;
0001319a      uint32_t var_b8 = 0;
000131a1      char* rax_3 = ExAllocatePoolWithTag(PagedPool, (uint64_t)rax_2, 0x41474c54);
000131b9      UNICODE_STRING DestinationString;
000131b9      RtlInitUnicodeString(&DestinationString, u"NO NAME");
000131b9      
000131c2      if (!rax_3)
000133d5          result = -0x3fffff66;
000131c2      else
000131c2      {
000131d3          memmove(rax_3, RegistryPath->Buffer, (uint64_t)RegistryPath->Length);
000131e7          uint64_t r11_2 = (uint64_t)RegistryPath->Length >> 1;
000131ed          *(uint64_t*)(rax_3 + (r11_2 << 1)) = var_28;
000131f8          int64_t var_20;
000131f8          *(uint64_t*)(rax_3 + (r11_2 << 1) + 8) = var_20;
00013208          int64_t var_18;
00013208          *(uint64_t*)(rax_3 + (r11_2 << 1) + 0x10) = var_18;
0001320d          RTL_QUERY_REGISTRY_TABLE QueryTable;
0001320d          memset(&QueryTable, 0, 0x70);
0001321c          QueryTable.Name = u"DebugFlags";
0001322b          QueryTable.EntryContext = &var_b8;
00013240          var_b8 = 0;
00013244          QueryTable.DefaultData = &var_b4;
00013249          QueryTable.Flags = 0x20;
00013251          QueryTable.DefaultType = 4;
00013255          QueryTable.DefaultLength = 4;
0001325e          NTSTATUS rax_7 =
0001325e              RtlQueryRegistryValues(0x80000000, rax_3, &QueryTable, nullptr, 0);
00013264          uint32_t TLDebugFlags_1 = TLDebugFlags;
00013264          
0001326f          if (rax_7 >= STATUS_SUCCESS)
0001326f              TLDebugFlags_1 = var_b8;
0001326f          
00013276          TLDebugFlags = TLDebugFlags_1;
00013281          memset(&QueryTable, 0, 0x70);
00013292          QueryTable.Name = u"TraceSubsystem";
0001329f          QueryTable.EntryContext = &var_b8;
000132b1          var_b8 = 0;
000132b5          QueryTable.Flags = 0x20;
000132bd          QueryTable.DefaultData = &var_b4;
000132c2          QueryTable.DefaultType = 4;
000132c6          QueryTable.DefaultLength = 4;
000132cf          NTSTATUS rax_8 =
000132cf              RtlQueryRegistryValues(0x80000000, rax_3, &QueryTable, nullptr, 0);
000132d5          uint32_t TLDebugSubsystem_1 = TLDebugSubsystem;
000132d5          
000132e0          if (rax_8 >= STATUS_SUCCESS)
000132e0              TLDebugSubsystem_1 = var_b8;
000132e0          
000132e7          TLDebugSubsystem = TLDebugSubsystem_1;
000132f2          memset(&QueryTable, 0, 0x70);
000132fe          var_b8 = 0;
00013302          QueryTable.Name = u"TraceBufferSize";
0001330c          QueryTable.Flags = 0x20;
00013314          QueryTable.EntryContext = &var_b8;
0001331e          QueryTable.DefaultType = 4;
00013322          QueryTable.DefaultLength = 4;
0001332e          QueryTable.DefaultData = &var_b4;
00013340          NTSTATUS rax_9 =
00013340              RtlQueryRegistryValues(0x80000000, rax_3, &QueryTable, nullptr, 0);
00013348          uint32_t rax_10;
00013348          
00013348          if (rax_9 >= STATUS_SUCCESS)
0001334a              rax_10 = var_b8;
0001334a          
00013350          if (rax_9 < STATUS_SUCCESS || rax_10 <= 0)
0001335f              rax_10 = 0;
00013350          else if (rax_10 > 0x2710)
0001335b              rax_10 = 0x2710;
0001335b          
0001336e          TLDbgBufferLength = rax_10 << 0xa;
00013374          memset(&QueryTable, 0, 0x70);
00013385          QueryTable.Name = u"DebugLevel";
00013392          QueryTable.EntryContext = &var_b8;
000133a4          var_b8 = 0;
000133a8          QueryTable.Flags = 0x20;
000133b0          QueryTable.DefaultData = &var_b4;
000133b5          QueryTable.DefaultType = 4;
000133b9          QueryTable.DefaultLength = 4;
000133c2          RtlQueryRegistryValues(0x80000000, rax_3, &QueryTable, nullptr, 0);
000133cd          ExFreePoolWithTag(rax_3, 0);
000131c2      }
000131c2      
000133e7      __security_check_cookie(rax_1 ^ &var_e8);
00013404      return result;
00013134  }

00013405                 cc cc cc cc cc cc cc                                                                   .......

0001340c    int32_t TLUpdateRegistryParameter(struct _UNICODE_STRING* ValueName, uint32_t ValueType, void* ValueData, uint32_t ValueDataLength)

0001340c  {
0001341f      HANDLE var_68 = nullptr;
00013435      UNICODE_STRING DestinationString;
00013435      RtlInitUnicodeString(&DestinationString, u"\Parameters");
00013448      uint16_t r11 = TLRegistryPath.Length + DestinationString.Length;
00013458      uint16_t var_5e = r11;
0001345e      char* P = ExAllocatePoolWithTag(PagedPool, (uint64_t)r11, 0x41474c54);
0001345e      
0001346c      if (!P)
0001346e          return STATUS_INSUFFICIENT_RESOURCES;
0001346e      
0001348a      memmove(P, TLRegistryPath.Buffer, (uint64_t)TLRegistryPath.Length);
0001348f      uint64_t Length_1 = (uint64_t)TLRegistryPath.Length;
0001349c      uint64_t Length = (uint64_t)DestinationString.Length;
000134a2      WCHAR* Buffer = DestinationString.Buffer;
000134ad      int16_t var_60 = (uint16_t)Length_1;
000134b7      memmove(&P[Length_1 >> 1 << 1], Buffer, Length);
000134c2      OBJECT_ATTRIBUTES ObjectAttributes;
000134c2      ObjectAttributes.RootDirectory = 0;
000134c8      var_60 += DestinationString.Length;
000134ce      ObjectAttributes.SecurityDescriptor = 0;
000134d4      ObjectAttributes.SecurityQualityOfService = 0;
000134f1      ObjectAttributes.Length = 0x30;
000134f9      ObjectAttributes.Attributes = 0x240;
00013501      ObjectAttributes.ObjectName = &var_60;
00013506      NTSTATUS result_1 = ZwOpenKey(&var_68, 0xf003f, &ObjectAttributes);
0001350c      NTSTATUS result = result_1;
0001350c      
00013510      if (result_1 >= STATUS_SUCCESS)
00013510      {
00013538          result = ZwSetValueKey(var_68, ValueName, 0, 4, ValueData, 4);
0001353a          ZwClose(var_68);
00013510      }
00013510      
00013548      if (P)
0001354c          ExFreePoolWithTag(P, 0);
0001354c      
00013568      return result;
0001340c  }

00013569                             cc cc cc cc cc cc cc                                                           .......

00013570    void UpdateCameras(struct _TLIO_CONTEXT* pContext)

00013570  {
00013581      uint8_t hIDReport = 0x54;
00013585      char arg_11 = 1;
00013589      char arg_12 = 0x75;
0001358d      HWWriteReport(pContext, &hIDReport, 3);
00013570  }

00013597                                                                       cc cc cc cc cc cc cc cc cc                         .........

000135a0    void KickFirmwareOutOfLowSpeedMode(void* param)

000135a0  {
000135a4      void* rax = *(uint64_t*)((char*)param + 0x28);
000135a4      
000135b8      if (*(uint8_t*)((char*)rax + 0x50d) != 5 || *(uint8_t*)((char*)rax + 0x50c) >= 0x9c)
000135b8          return;
000135b8      
000135c5      uint8_t hIDReport = 0x43;
000135ca      char arg_9 = 2;
000135cf      char arg_a = 0xf3;
000135d4      char arg_b = 0;
000135d9      HWWriteReport(param, &hIDReport, 4);
000135a0  }

000135e3           cc cc cc cc cc cc cc cc cc                                                                 .........

000135ec    uint8_t SendInputLoopback(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t* buf, int32_t size)

000135ec  {
00013609      int32_t rax;
00013609      (uint8_t)rax = TLCallbackFnc(*(uint64_t*)PTransLibUserModeContext->pTransLibContext, 
00013609          4, buf, (uint64_t)size) >= 0;
00013610      return (uint8_t)rax;
000135ec  }

00013611                                                     cc cc cc cc cc cc cc                                           .......

00013618    uint8_t ResetUSB(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext)

00013618  {
00013634      int32_t rax;
00013634      (uint8_t)rax =
00013634          TLCallbackFnc(*(uint64_t*)PTransLibUserModeContext->pTransLibContext, 0x14, 0, 0)
00013634          >= 0;
0001363b      return (uint8_t)rax;
00013618  }

0001363c                                                                                      cc cc cc cc                              ....
00013640  cc cc cc cc                                                                                      ....

00013644    void TLWriteFirmwareVersionToReg(uint16_t Version)

00013644  {
00013657      uint32_t ValueData = (uint32_t)Version;
0001365b      void var_18;
0001365b      RtlInitUnicodeString(&var_18, u"FirmwareVersion");
00013673      TLUpdateRegistryParameter(&var_18, 4, &ValueData, 4);
00013644  }

0001367d                                                                                         cc cc cc                               ...
00013680  cc cc cc cc                                                                                      ....

00013684    uint8_t TLAcquireExcl(struct _ERESOURCE* Resource, uint8_t wait)

00013684  {
0001368a      KeEnterCriticalRegion();
00013699      BOOLEAN rax = ExAcquireResourceExclusiveLite(&TLDbgLogLock, 1);
0001369f      int64_t rbx;
0001369f      (uint8_t)rbx = rax;
0001369f      
000136a3      if (!rax)
000136a5          KeLeaveCriticalRegion();
000136a5      
000136b2      return (uint8_t)rbx;
00013684  }

000136b3                                                           cc cc cc cc cc cc cc cc cc                                 .........

000136bc    int32_t TransLibGetMemoryUsage(struct _NW_TRANSLIB_DEVICE_CONTEXT* pTransLibContext, struct _NW_MEMORY_USAGE_STATS_CB* MemoryUsageCB)

000136bc  {
000136d0      MemoryUsageCB->TotalNonPagedPool += TLMemoryUsage.TotalNonPagedPool;
000136d8      MemoryUsageCB->TotalPagedPool += TLMemoryUsage.TotalPagedPool;
000136e1      MemoryUsageCB->TransLibNonPagedPoolTotal = TLMemoryUsage.TotalNonPagedPool;
000136ea      MemoryUsageCB->TransLibPagedPoolTotal = TLMemoryUsage.TotalPagedPool;
000136f4      memmove(&MemoryUsageCB->TransLibAllocationTable, &TLMemoryUsage.AllocationTable, 
000136f4          0x1c);
000136ff      return 0;
000136bc  }

00013700  cc cc cc cc cc cc cc cc                                                                          ........

00013708    int32_t TransLibUpdateInputMode(struct _NW_TRANSLIB_DEVICE_CONTEXT* PTransLibContext, uint8_t InputMode)

00013708  {
0001370b      PTransLibContext->UserModeContext.DrvSettingsContext.InputMode = (uint32_t)InputMode;
00013713      return 0;
00013708  }

00013714                                                              cc cc cc cc cc cc cc cc                                  ........

0001371c    void TransLibRawWaveformsCallback(void* param, uint8_t cam, uint8_t backlit, uint16_t* pix, uint32_t pixCount)

0001371c  {
0001371c      *(uint8_t*)((char*)param + 0x2a8) = 1;
0001371c  }

00013724              cc cc cc cc cc cc cc cc                                                                  ........

0001372c    int32_t RtlStringCbPrintfW(uint16_t* pszDest, uint64_t cbDest, wchar16 const* pszFormat, ...)

0001372c  {
0001372c      wchar16 const* pszFormat_1 = pszFormat;
00013731      int64_t entry__ArgList;
00013731      int64_t _ArgList = entry__ArgList;
0001373e      uint64_t rdx = cbDest >> 1;
00013749      int32_t result = 0;
00013749      
00013754      if (!rdx || rdx > 0x7fffffff)
00013756          result = -0x3ffffff3;
00013756      
0001375d      if (result >= 0)
0001375d      {
00013768          result = 0;
0001376d          int32_t rax_1 = _vsnwprintf(pszDest, rdx - 1, pszFormat, &_ArgList);
00013775          int64_t rax_2;
00013775          
00013775          if (rax_1 >= 0)
00013777              rax_2 = (int64_t)rax_1;
00013777          
0001377c          if (rax_1 < 0 || rax_2 > rdx - 1)
0001377c          {
00013782              result = -0x7ffffffb;
00013787              pszDest[rdx - 1] = 0;
0001377c          }
0001377c          else if (rax_2 == rdx - 1)
00013787              pszDest[rdx - 1] = 0;
0001375d      }
0001375d      
00013795      return result;
0001372c  }

00013796                                                                    cc cc cc cc cc cc                                    ......

0001379c    int32_t TLGetSettingsInRegistry(uint32_t ModelNumber, uint32_t SerialNumber, int32_t Tree, void** SettingsData, int32_t* SettingsDataLength)

0001379c  {
000137db      int16_t var_68 = 0;
000137e0      int16_t var_66 = 0;
000137e5      int64_t var_60 = 0;
000137e9      UNICODE_STRING ValueName;
000137e9      ValueName.Length = 0;
000137ee      ValueName.MaximumLength = 0;
000137f3      ValueName.Buffer = 0;
000137f7      HANDLE KeyHandle_1 = nullptr;
000137fb      int64_t rbp = 0;
000137fe      uint32_t Length = 0;
00013801      int32_t Length_1 = 0;
00013806      uint16_t* pszDest = ExAllocatePoolWithTag(PagedPool, 0x1000, 0x41474c54);
0001380c      uint16_t* P = pszDest;
00013817      NTSTATUS result;
00013817      WCHAR* Buffer_3;
00013817      
00013817      if (pszDest)
00013817      {
00013823          TLMemoryUsage.TotalPagedPool += 0x1000;
00013829          TLMemoryUsage.AllocationTable[0] += 0x1000;
00013834          memset(P, 0, 0x1000);
00013839          WCHAR* Buffer_2 = TLRegistryPath.Buffer;
00013845          var_66 = 0x1000;
0001384a          var_68 = 0;
00013856          uint32_t ModelNumber_1;
00013856          
00013856          if (ModelNumber != 0xffffffff)
00013856          {
0001386d              ModelNumber_1 = ModelNumber;
00013871              RtlStringCbPrintfW(pszDest, 0x1000, %s\Parameters\Settings\%d", Buffer_2, 
00013871                  ModelNumber_1);
00013856          }
00013856          else
0001385f              RtlStringCbPrintfW(pszDest, 0x1000, u"%s\Parameters\Settings", Buffer_2);
0001385f          
0001387b          uint16_t* pszDest_1 = pszDest;
00013880          uint64_t rcx_1 = 0;
00013883          uint64_t rax_1 = (uint64_t)var_66 >> 1;
00013891          int32_t r9;
00013891          
00013891          if (!pszDest_1 || rax_1 > 0x7fffffff)
000138c5              r9 = -0x3ffffff3;
00013891          else
00013891          {
00013893              uint64_t r8 = rax_1;
00013896              r9 = 0;
00013896              
000138a1              if (!rax_1)
000138c5                  r9 = -0x3ffffff3;
000138a1              else
000138a1              {
000138a7                  while (*(uint16_t*)pszDest_1)
000138a7                  {
000138a9                      pszDest_1 = &pszDest_1[1];
000138ad                      uint64_t temp0_1 = r8;
000138ad                      r8 -= 1;
000138ad                      
000138b1                      if (temp0_1 == 1)
000138b1                          break;
000138a7                  }
000138a7                  
000138b6                  if (!r8)
000138c5                      r9 = -0x3ffffff3;
000138b6                  else
000138bb                      rcx_1 = rax_1 - r8;
000138a1              }
00013891          }
00013891          
000138cb          uint64_t var_88;
000138cb          
000138cb          var_88 = r9 < 0 ? 0 : rcx_1 * 2;
000138cb          
000138f2          var_68 = (uint16_t)var_88;
000138f7          WCHAR* Buffer_4 = ExAllocatePoolWithTag(PagedPool, 0x1000, 0x41474c54);
000138fd          Buffer_3 = Buffer_4;
00013900          ValueName.Buffer = Buffer_4;
00013900          
00013908          if (Buffer_4)
00013908          {
00013923              TLMemoryUsage.TotalPagedPool += 0x1000;
00013929              TLMemoryUsage.AllocationTable[0] += 0x1000;
00013932              memset(Buffer_3, 0, 0x1000);
00013937              uint16_t* Buffer = ValueName.Buffer;
00013941              ValueName.MaximumLength = 0x1000;
00013949              ValueName.Length = 0;
00013949              
00013952              if (!Tree)
00013952              {
0001396e                  if (ModelNumber != 0xffffffff)
00013988                      RtlStringCbPrintfW(Buffer, 0x1000, %dData", (uint64_t)SerialNumber, 
00013988                          ModelNumber_1);
0001396e                  else
00013977                      RtlStringCbPrintfW(Buffer, 0x1000, u"DefaultData");
00013952              }
00013952              else if (ModelNumber != 0xffffffff)
00013988                  RtlStringCbPrintfW(Buffer, 0x1000, %dTree", (uint64_t)SerialNumber, 
00013988                      ModelNumber_1);
00013957              else
00013977                  RtlStringCbPrintfW(Buffer, 0x1000, u"DefaultTree");
00013977              
00013992              WCHAR* Buffer_1 = ValueName.Buffer;
00013997              uint64_t rcx_4 = 0;
0001399a              uint64_t rax_5 = (uint64_t)ValueName.MaximumLength >> 1;
000139a8              int32_t r9_2;
000139a8              
000139a8              if (!Buffer_1 || rax_5 > 0x7fffffff)
000139d2                  r9_2 = -0x3ffffff3;
000139a8              else
000139a8              {
000139aa                  uint64_t rdx = rax_5;
000139ad                  r9_2 = 0;
000139ad                  
000139b3                  if (!rax_5)
000139d2                      r9_2 = -0x3ffffff3;
000139b3                  else
000139b3                  {
000139b9                      while (*(uint16_t*)Buffer_1)
000139b9                      {
000139bb                          Buffer_1 = &Buffer_1[1];
000139bf                          uint64_t temp1_1 = rdx;
000139bf                          rdx -= 1;
000139bf                          
000139c3                          if (temp1_1 == 1)
000139c3                              break;
000139b9                      }
000139b9                      
000139c8                      if (!rdx)
000139d2                          r9_2 = -0x3ffffff3;
000139c8                      else
000139cd                          rcx_4 = rax_5 - rdx;
000139b3                  }
000139a8              }
000139a8              
000139d8              var_88 = r9_2 < 0 ? 0 : rcx_4 * 2;
000139d8              
000139f9              ValueName.Length = (uint16_t)var_88;
00013a08              OBJECT_ATTRIBUTES ObjectAttributes;
00013a08              ObjectAttributes.Length = 0x30;
00013a10              ObjectAttributes.RootDirectory = 0;
00013a15              ObjectAttributes.Attributes = 0x240;
00013a1d              ObjectAttributes.ObjectName = &var_68;
00013a22              ObjectAttributes.SecurityDescriptor = 0;
00013a2a              ObjectAttributes.SecurityQualityOfService = 0;
00013a32              NTSTATUS result_1 = ZwOpenKey(&KeyHandle_1, 0xf003f, &ObjectAttributes);
00013a3b              result = result_1;
00013a3b              
00013a3d              if (result_1 >= STATUS_SUCCESS)
00013a3d              {
00013a63                  NTSTATUS result_2 = ZwQueryValueKey(KeyHandle_1, &ValueName, 
00013a63                      KeyValuePartialInformation, nullptr, 0, 
00013a63                      &*(uint64_t*)((char*)var_88)[4]);
00013a6c                  result = result_2;
00013a6c                  
00013a6e                  if (result_2 >= STATUS_SUCCESS)
00013a6e                  {
00013b39                      result = STATUS_NO_DATA_DETECTED;
00013b3e                  label_13b3e:
00013b3e                      
00013b41                      if (rbp)
00013b41                      {
00013b43                          TLMemoryUsage.TotalPagedPool -= Length;
00013b49                          TLMemoryUsage.AllocationTable[0] -= Length;
00013b54                          ExFreePoolWithTag(rbp, 0);
00013b41                      }
00013a6e                  }
00013a6e                  else if (result_2 == STATUS_BUFFER_OVERFLOW
00013a6e                      || result_2 == STATUS_BUFFER_TOO_SMALL)
00013a80                  {
00013a8a                      int32_t* SettingsDataLength_1 = SettingsDataLength;
00013aa3                      Length = Length_1;
00013aa6                      *(uint32_t*)SettingsDataLength_1 = Length_1 - 0xc;
00013aaa                      int64_t rax_10 =
00013aaa                          ExAllocatePoolWithTag(PagedPool, (uint64_t)Length, 0x41474c54);
00013ab0                      rbp = rax_10;
00013ab0                      
00013ab6                      if (rax_10)
00013ab6                      {
00013abf                          HANDLE KeyHandle = KeyHandle_1;
00013ac4                          TLMemoryUsage.TotalPagedPool += Length;
00013aca                          TLMemoryUsage.AllocationTable[0] += Length;
00013af7                          result = ZwQueryValueKey(KeyHandle, &ValueName, 
00013af7                              KeyValuePartialInformation, rbp, Length, 
00013af7                              &*(uint64_t*)((char*)var_88)[4]);
00013af9                          ZwClose(KeyHandle_1);
00013af9                          
00013b02                          if (result >= STATUS_SUCCESS)
00013b02                          {
00013b19                              *(uint64_t*)SettingsData = ExAllocatePoolWithTag(PagedPool, 
00013b19                                  (int64_t)*(uint32_t*)SettingsDataLength_1, 0x41474c54);
00013b1e                              TLMemoryUsage.TotalPagedPool +=
00013b1e                                  *(uint32_t*)SettingsDataLength_1;
00013b26                              TLMemoryUsage.AllocationTable[0] +=
00013b26                                  *(uint32_t*)SettingsDataLength_1;
00013b32                              memmove(*(uint64_t*)SettingsData, rbp + 0xc, 
00013b32                                  (int64_t)*(uint32_t*)SettingsDataLength_1);
00013b02                          }
00013ab6                      }
00013ab6                      else
00013ab8                          result = STATUS_INSUFFICIENT_RESOURCES;
00013ab8                      
00013ab6                      goto label_13b3e;
00013a80                  }
00013a3d              }
00013a3d              
00013b5a              P = pszDest;
00013b5f              Buffer_3 = ValueName.Buffer;
00013908          }
00013908          else
00013908          {
0001390a              P = pszDest;
0001390f              result = STATUS_INSUFFICIENT_RESOURCES;
00013908          }
00013817      }
00013817      else
00013817      {
00013819          result = STATUS_INSUFFICIENT_RESOURCES;
00013b5f          Buffer_3 = ValueName.Buffer;
00013817      }
00013817      
00013b67      if (Buffer_3)
00013b67      {
00013b69          uint32_t MaximumLength = (uint32_t)ValueName.MaximumLength;
00013b73          TLMemoryUsage.TotalPagedPool -= MaximumLength;
00013b79          TLMemoryUsage.AllocationTable[0] -= MaximumLength;
00013b7f          ExFreePoolWithTag(Buffer_3, 0);
00013b85          P = pszDest;
00013b67      }
00013b67      
00013b8d      if (P)
00013b8d      {
00013b8f          uint32_t rax_15 = (uint32_t)var_66;
00013b96          TLMemoryUsage.TotalPagedPool -= rax_15;
00013b9c          TLMemoryUsage.AllocationTable[0] -= rax_15;
00013ba2          ExFreePoolWithTag(P, 0);
00013b8d      }
00013b8d      
00013bca      return result;
0001379c  }

00013bcb                                   cc cc cc cc cc cc cc cc cc                                                 .........

00013bd4    int32_t TLUpdateSettingsInRegistry(uint32_t ModelNumber, uint32_t SerialNumber, int32_t Tree, void* SettingsData, int32_t SettingsDataLength)

00013bd4  {
00013c14      int16_t var_68 = 0;
00013c19      int16_t var_66 = 0;
00013c1e      int64_t var_60 = 0;
00013c22      UNICODE_STRING ValueName;
00013c22      ValueName.Length = 0;
00013c27      ValueName.MaximumLength = 0;
00013c2c      ValueName.Buffer = 0;
00013c30      HANDLE var_70 = nullptr;
00013c34      uint16_t* pszDest = ExAllocatePoolWithTag(PagedPool, 0x1000, 0x41474c54);
00013c3a      void* P = pszDest;
00013c45      NTSTATUS result;
00013c45      WCHAR* Buffer_2;
00013c45      
00013c45      if (pszDest)
00013c45      {
00013c51          TLMemoryUsage.TotalPagedPool += 0x1000;
00013c58          TLMemoryUsage.AllocationTable[0] += 0x1000;
00013c64          memset(P, 0, 0x1000);
00013c69          WCHAR* Buffer_1 = TLRegistryPath.Buffer;
00013c7f          var_66 = 0x1000;
00013c85          var_68 = 0;
00013c8b          RtlStringCbPrintfW(pszDest, 0x1000, u"%s\Parameters\Settings", Buffer_1);
00013c96          uint16_t* pszDest_1 = pszDest;
00013c9b          uint64_t r11_2 = (uint64_t)var_66 >> 1;
00013c9e          int16_t rax = 0;
00013cad          int32_t rdx;
00013cad          
00013cad          if (!pszDest_1 || r11_2 > 0x7fffffff)
00013cd7              rdx = -0x3ffffff3;
00013cad          else
00013cad          {
00013caf              uint64_t rcx_1 = r11_2;
00013cb2              rdx = 0;
00013cb2              
00013cb8              if (!r11_2)
00013cd7                  rdx = -0x3ffffff3;
00013cb8              else
00013cb8              {
00013cbe                  while (*(uint16_t*)pszDest_1)
00013cbe                  {
00013cc0                      pszDest_1 = &pszDest_1[1];
00013cc4                      uint64_t temp0_1 = rcx_1;
00013cc4                      rcx_1 -= 1;
00013cc4                      
00013cc8                      if (temp0_1 == 1)
00013cc8                          break;
00013cbe                  }
00013cbe                  
00013ccd                  if (!rcx_1)
00013cd7                      rdx = -0x3ffffff3;
00013ccd                  else
00013cd2                      rax = (uint16_t)r11_2 - (uint16_t)rcx_1;
00013cb8              }
00013cad          }
00013cad          
00013cdf          int16_t var_78_1;
00013cdf          
00013cdf          var_78_1 = rdx < 0 ? 0 : rax * 2;
00013cdf          
00013cff          var_68 = var_78_1;
00013d1b          OBJECT_ATTRIBUTES ObjectAttributes;
00013d1b          ObjectAttributes.ObjectName = &var_68;
00013d23          ObjectAttributes.Length = 0x30;
00013d2b          ObjectAttributes.RootDirectory = 0;
00013d30          ObjectAttributes.Attributes = 0x240;
00013d3b          ObjectAttributes.SecurityDescriptor = 0;
00013d43          ObjectAttributes.SecurityQualityOfService = 0;
00013d4b          int64_t var_98_1 = 0;
00013d50          NTSTATUS result_1 =
00013d50              ZwCreateKey(&var_70, 0xf003f, &ObjectAttributes, 0, nullptr, 0, nullptr);
00013d59          result = result_1;
00013d59          
00013d5b          if (result_1 < STATUS_SUCCESS)
00013d5b          {
00013f65              P = pszDest;
00013f6a              Buffer_2 = ValueName.Buffer;
00013d5b          }
00013d5b          else
00013d5b          {
00013d75              (uint32_t)var_98_1 = ModelNumber;
00013d79              RtlStringCbPrintfW(pszDest, (uint64_t)var_66, u"%s\%d", pszDest, 0);
00013d84              uint16_t* pszDest_2 = pszDest;
00013d89              uint64_t r11_4 = (uint64_t)var_66 >> 1;
00013d8c              int16_t rax_4 = 0;
00013d9b              int32_t rdx_2;
00013d9b              
00013d9b              if (!pszDest_2 || r11_4 > 0x7fffffff)
00013dc5                  rdx_2 = -0x3ffffff3;
00013d9b              else
00013d9b              {
00013d9d                  uint64_t rcx_4 = r11_4;
00013da0                  rdx_2 = 0;
00013da0                  
00013da6                  if (!r11_4)
00013dc5                      rdx_2 = -0x3ffffff3;
00013da6                  else
00013da6                  {
00013dac                      while (*(uint16_t*)pszDest_2)
00013dac                      {
00013dae                          pszDest_2 = &pszDest_2[1];
00013db2                          uint64_t temp1_1 = rcx_4;
00013db2                          rcx_4 -= 1;
00013db2                          
00013db6                          if (temp1_1 == 1)
00013db6                              break;
00013dac                      }
00013dac                      
00013dbb                      if (!rcx_4)
00013dc5                          rdx_2 = -0x3ffffff3;
00013dbb                      else
00013dc0                          rax_4 = (uint16_t)r11_4 - (uint16_t)rcx_4;
00013da6                  }
00013d9b              }
00013d9b              
00013dcd              int16_t var_78_2;
00013dcd              
00013dcd              var_78_2 = rdx_2 < 0 ? 0 : rax_4 * 2;
00013dcd              
00013df1              var_68 = var_78_2;
00013df6              WCHAR* Buffer_3 = ExAllocatePoolWithTag(PagedPool, 0x1000, 0x41474c54);
00013dfc              Buffer_2 = Buffer_3;
00013dff              ValueName.Buffer = Buffer_3;
00013dff              
00013e07              if (Buffer_3)
00013e07              {
00013e18                  TLMemoryUsage.TotalPagedPool += 0x1000;
00013e1f                  TLMemoryUsage.AllocationTable[0] += 0x1000;
00013e2e                  memset(Buffer_3, 0, 0x1000);
00013e38                  ValueName.MaximumLength = 0x1000;
00013e3e                  ValueName.Length = 0;
00013e4a                  wchar16* pszFormat = u"%dTree";
00013e4a                  
00013e54                  if (!Tree)
00013e56                      pszFormat = u"%dData";
00013e56                  
00013e5d                  RtlStringCbPrintfW(ValueName.Buffer, 0x1000, pszFormat, 
00013e5d                      (uint64_t)SerialNumber);
00013e67                  WCHAR* Buffer = ValueName.Buffer;
00013e6c                  uint64_t rcx_8 = (uint64_t)ValueName.MaximumLength >> 1;
00013e6f                  int16_t rax_8 = 0;
00013e7e                  int32_t r9_2;
00013e7e                  
00013e7e                  if (!Buffer || rcx_8 > 0x7fffffff)
00013ea8                      r9_2 = -0x3ffffff3;
00013e7e                  else
00013e7e                  {
00013e80                      uint64_t rdx_3 = rcx_8;
00013e83                      r9_2 = 0;
00013e83                      
00013e89                      if (!rcx_8)
00013ea8                          r9_2 = -0x3ffffff3;
00013e89                      else
00013e89                      {
00013e8f                          while (*(uint16_t*)Buffer)
00013e8f                          {
00013e91                              Buffer = &Buffer[1];
00013e95                              uint64_t temp2_1 = rdx_3;
00013e95                              rdx_3 -= 1;
00013e95                              
00013e99                              if (temp2_1 == 1)
00013e99                                  break;
00013e8f                          }
00013e8f                          
00013e9e                          if (!rdx_3)
00013ea8                              r9_2 = -0x3ffffff3;
00013e9e                          else
00013ea3                              rax_8 = (uint16_t)rcx_8 - (uint16_t)rdx_3;
00013e89                      }
00013e7e                  }
00013e7e                  
00013eb1                  int16_t var_78_3;
00013eb1                  
00013eb1                  var_78_3 = r9_2 < 0 ? 0 : rax_8 * 2;
00013eb1                  
00013ed1                  ValueName.Length = var_78_3;
00013eed                  ObjectAttributes.ObjectName = &var_68;
00013ef5                  ObjectAttributes.Length = 0x30;
00013efd                  ObjectAttributes.RootDirectory = 0;
00013f02                  ObjectAttributes.Attributes = 0x240;
00013f0d                  ObjectAttributes.SecurityDescriptor = 0;
00013f15                  ObjectAttributes.SecurityQualityOfService = 0;
00013f22                  NTSTATUS result_2 = ZwCreateKey(&var_70, 0xf003f, &ObjectAttributes, 0, 
00013f22                      nullptr, 0, nullptr);
00013f2b                  result = result_2;
00013f2b                  
00013f2d                  if (result_2 >= STATUS_SUCCESS)
00013f2d                  {
00013f5d                      result = ZwSetValueKey(var_70, &ValueName, 0, 3, SettingsData, 
00013f5d                          SettingsDataLength);
00013f5f                      ZwClose(var_70);
00013f2d                  }
00013f2d                  
00013f65                  P = pszDest;
00013f6a                  Buffer_2 = ValueName.Buffer;
00013e07              }
00013e07              else
00013e07              {
00013e09                  P = pszDest;
00013e0e                  result = STATUS_INSUFFICIENT_RESOURCES;
00013e07              }
00013d5b          }
00013c45      }
00013c45      else
00013c45      {
00013c47          result = STATUS_INSUFFICIENT_RESOURCES;
00013f6a          Buffer_2 = ValueName.Buffer;
00013c45      }
00013c45      
00013f72      if (Buffer_2)
00013f72      {
00013f74          uint32_t MaximumLength = (uint32_t)ValueName.MaximumLength;
00013f7e          TLMemoryUsage.TotalPagedPool -= MaximumLength;
00013f84          TLMemoryUsage.AllocationTable[0] -= MaximumLength;
00013f8a          ExFreePoolWithTag(Buffer_2, 0);
00013f90          P = pszDest;
00013f72      }
00013f72      
00013f98      if (P)
00013f98      {
00013f9a          uint32_t rax_14 = (uint32_t)var_66;
00013fa1          TLMemoryUsage.TotalPagedPool -= rax_14;
00013fa7          TLMemoryUsage.AllocationTable[0] -= rax_14;
00013fad          ExFreePoolWithTag(P, 0);
00013f98      }
00013f98      
00013fd6      return result;
00013bd4  }

00013fd7                                                                       cc cc cc cc cc cc cc cc cc                         .........

00013fe0    uint8_t GetTransLibSettingsData(uint32_t modelNum, uint32_t serialNum, struct tv_item_t** tree, int32_t* treeSize, uint8_t** data, int32_t* dataSize)

00013fe0  {
00014012      int32_t rax;
00014012      
00014012      if (TLGetSettingsInRegistry(modelNum, serialNum, 1, tree, treeSize) >= 0)
00014012      {
00014035          if (TLGetSettingsInRegistry(modelNum, serialNum, 0, data, dataSize) >= 0)
00014054              (uint8_t)rax = 1;
00014035          else
00014035          {
0001403b              TLMemoryUsage.TotalPagedPool -= *(uint32_t*)treeSize;
00014043              TLMemoryUsage.AllocationTable[0] -= *(uint32_t*)treeSize;
0001404c              ExFreePoolWithTag(*(uint64_t*)tree, 0);
00014014              (uint8_t)rax = 0;
00014035          }
00014012      }
00014012      else
00014014          (uint8_t)rax = 0;
00014014      
0001406a      return (uint8_t)rax;
00013fe0  }

0001406b                                   cc cc cc cc cc cc cc cc cc                                                 .........

00014074    uint8_t GetDefaultTransLibSettingsData(struct tv_item_t** tree, int32_t* treeSize, uint8_t** data, int32_t* dataSize)

00014074  {
000140ab      int32_t rax;
000140ab      
000140ab      if (TLGetSettingsInRegistry(0xffffffff, 0, 1, tree, treeSize) >= 0)
000140ab      {
000140c8          if (TLGetSettingsInRegistry(0xffffffff, 0, 0, data, dataSize) >= 0)
000140e7              (uint8_t)rax = 1;
000140c8          else
000140c8          {
000140ce              TLMemoryUsage.TotalPagedPool -= *(uint32_t*)treeSize;
000140d6              TLMemoryUsage.AllocationTable[0] -= *(uint32_t*)treeSize;
000140df              ExFreePoolWithTag(*(uint64_t*)tree, 0);
000140ad              (uint8_t)rax = 0;
000140c8          }
000140ab      }
000140ab      else
000140ad          (uint8_t)rax = 0;
000140ad      
000140fd      return (uint8_t)rax;
00014074  }

000140fe                                                                                            cc cc                                ..
00014100  cc cc cc cc                                                                                      ....

00014104    void FreeTransLibSettingsData(struct tv_item_t* tree, int32_t treeSize, uint8_t* data, int32_t dataSize)

00014104  {
0001410e      TLMemoryUsage.TotalPagedPool -= treeSize;
00014114      TLMemoryUsage.AllocationTable[0] -= treeSize;
00014122      ExFreePoolWithTag(tree, 0);
00014128      TLMemoryUsage.TotalPagedPool -= dataSize;
0001412e      TLMemoryUsage.AllocationTable[0] -= dataSize;
00014143      /* tailcall */
00014143      return ExFreePoolWithTag(data, 0);
00014104  }

0001414a                                cc cc cc cc cc cc                                                            ......

00014150    void SetTransLibSettingsData(uint32_t modelNum, uint32_t serialNum, struct tv_item_t* tree, int32_t treeSize, uint8_t* data, int32_t dataSize)

00014150  {
0001416c      TLUpdateSettingsInRegistry(modelNum, serialNum, 1, tree, treeSize);
00014187      TLUpdateSettingsInRegistry(modelNum, serialNum, 0, data, dataSize);
00014150  }

00014197                                                                       cc cc cc cc cc cc cc cc cc                         .........

000141a0    void CSF_Init(struct _NW_CSF_CONTEXT* pContext)

000141a0  {
000141bf      memset(pContext, 0, 0x8f28);
000141c6      pContext->ctlContext.publicContextSize = 0x56c8;
000141d3      int64_t i_3 = 4;
000141d6      __builtin_memset(&pContext->ctlContext.triangulatedTouchesCallback, 0, 0x20);
000141dd      pContext->ctlContext.settings.triggers.thresholdFloor = 0xa;
000141f2      uint8_t* rax = &pContext->ctlContext.waveforms[0].trigInit;
00014200      pContext->ctlContext.settings.AmbientSubON = 1;
00014207      int64_t i_2 = 4;
00014221      int64_t i;
00014221      
00014221      do
00014221      {
0001420a          *((char*)ADJ(rax) + 0xc4a) = 1;
0001420d          rax = &rax[0xc4a];
00014213          i = i_2;
00014213          i_2 -= 1;
00014217          pContext->ctlContext.settings.triggers.trigPercentage = 75f;
00014221      } while (i != 1);
00014223      uint16_t (* rbx)[0x20c] = &pContext->ctlContext.waveforms[0].ambient;
00014248      int64_t i_1;
00014248      
00014248      do
00014248      {
00014238          memset(rbx, 0xffff, 0x418);
0001423d          rbx = &(*(uint4096_t*)rbx)[0x625];
00014244          i_1 = i_3;
00014244          i_3 -= 1;
00014248      } while (i_1 != 1);
0001424d      InitSubmodules(pContext);
00014252      pContext->meContext.meRB.samples = 0;
00014258      pContext->meContext.currentState = ME_IDLE_STATE;
0001425e      pContext->meContext.lastSignal = ME_ENTRY;
00014264      pContext->meContext.DoubleClick_tmr.expiredTime = 0;
0001426a      pContext->meContext.DoubleClick_tmr.elapsedTime = 0;
00014270      pContext->meContext.DoubleClick_tmr.enabled = 0;
00014277      pContext->meContext.DoubleClick_tmr.f = nullptr;
0001427e      pContext->meContext.RightClick_tmr.expiredTime = 0;
00014284      pContext->meContext.RightClick_tmr.elapsedTime = 0;
0001428a      pContext->meContext.RightClick_tmr.enabled = 0;
00014291      pContext->meContext.RightClick_tmr.f = nullptr;
00014298      pContext->meContext.MouseEngine_lock.initialised = 0;
000142ad      pContext->meContext.meRB.tail = &pContext->meContext.meRB.buf[2];
000142b4      pContext->meContext.meRB.head = &pContext->meContext.meRB.buf[2];
000142bb      pContext->CalibContext.CalibrateMode = 0;
000142c1      pContext->CalibContext.calState = CSM_MOVE_CURSOR;
000142c7      pContext->CalibContext.ignoredSamples = 0;
000142ce      pContext->CalibContext.sampleNum = 0;
000142d5      pContext->CalibContext.calibrationTime = 0;
000142db      pContext->CalibContext.cursorMoveTime = 0;
000142e1      pContext->CalibContext.CalibrationTimeout_tmr.enabled = 0;
000142e8      pContext->CalibContext.CalibrationMove_tmr.elapsedTime = 0;
000142ee      pContext->CalibContext.Calibration_lock.initialised = 0;
000142f5      pContext->CalibContext.CalibFinishedCB = nullptr;
000142fc      pContext->CalibContext.CalibFinishedParam = nullptr;
00014308      pContext->PTContext.MouseMode = 0;
0001430b      pContext->PTContext.Border.left = 0x190;
0001430f      pContext->PTContext.Border.top = 0x190;
00014313      pContext->PTContext.Border.right = 0x190;
00014317      pContext->PTContext.Border.bottom = 0x190;
0001431d      pContext->PTContext.RawMouse = 0;
00014321      pContext->PTContext.NoCalibration = 0;
0001432f      pContext->PTContext.OutOfBorderTouchIds = 0;
00014333      memset(&pContext->PTContext.OutOfBorderTouchPos, 0, (uint64_t)(uint32_t)(i_3 + 0x10));
0001433d      pContext->PTContext.OffscreenMode = 1;
00014343      pContext->PTContext.OffscreenBlockedIds = 0;
00014347      __builtin_memset(&pContext->PTContext.TouchPointCallback, 0, 0x30);
0001435f      pContext->PTContext.ProcessTouchStatus = 0;
00014363      pContext->PTContext.ProcessTouchStatusTime..LowPart = 0;
00014367      pContext->PTContext.pCSFContext = pContext;
0001436b      pContext->KickMongrelFirmware_tmr.enabled = 0;
00014377      pContext->ctlContext.triangulatedTouchesParam = &pContext->PTContext.MouseMode;
00014385      pContext->ctlContext.triangulatedTouchesCallback = PT_ProcessFourEyesTouches;
0001438c      pContext->meContext.OutputParam = &pContext->PTContext.MouseMode;
0001439a      pContext->meContext.OutputCB = PT_SendMouse;
000143a1      pContext->CalibContext.CalibOutputParam = &pContext->PTContext.MouseMode;
000143ad      pContext->CalibContext.CalibOutputCB = PT_SendMouse;
000141a0  }

000143ba                                                                                cc cc cc cc cc cc                            ......

000143c0    uint8_t CSF_CopyWaveform(struct _NW_CSF_CONTEXT* pContext, int32_t sensor, uint8_t ambient, uint8_t lit, uint8_t trigger, uint16_t* destBuffer, int32_t bufferLength)

000143c0  {
000143d8      int64_t sensor_1 = (int64_t)sensor;
000143db      int64_t i = 0;
000143dd      int64_t r12;
000143dd      (uint8_t)r12 = lit;
000143e0      int64_t r13;
000143e0      (uint8_t)r13 = ambient;
000143e9      uint8_t rax;
000143e9      
000143e9      if ((uint32_t)sensor_1 <= 3)
000143fb          rax = ST_AcquireLock(&pContext->ctlContext.waveformLock, 0x3e8);
000143fb      
00014402      int64_t rsi;
00014402      
00014402      if ((uint32_t)sensor_1 > 3 || !rax)
0001449c          (uint8_t)rsi = 0;
00014402      else
00014402      {
00014408          rsi = 1;
00014408          
00014413          if ((uint8_t)r13 || (uint8_t)r12)
00014413          {
00014447              char* destBuffer_1 = destBuffer;
00014464              memmove(destBuffer_1, &pContext->ctlContext.waveforms[sensor_1].ambient, 
00014464                  0x418);
00014464              
0001446c              if ((uint8_t)r12)
0001446c              {
0001446e                  void* rcx_3 = &pContext->ctlContext.waveforms[sensor_1];
0001446e                  
00014489                  do
00014489                  {
00014473                      int16_t rax_3 = *(uint16_t*)rcx_3;
00014476                      rcx_3 += 2;
0001447a                      *(uint16_t*)(destBuffer_1 + (i << 1)) += rax_3;
0001447f                      i += 1;
00014489                  } while (i < 0x20c);
0001446c              }
00014413          }
00014413          else
00014413          {
0001442a              void* rdx = &pContext->ctlContext.waveforms[sensor_1].trigger;
0001442a              
00014436              if (!trigger)
00014438                  rdx = &pContext->ctlContext.waveforms[sensor_1];
00014438              
0001443d              memmove(destBuffer, rdx, 0x418);
00014413          }
00014413          
00014494          KeReleaseMutex(&pContext->ctlContext.waveformLock.mutex, 0);
00014402      }
00014402      
000144ba      return (uint8_t)rsi;
000143c0  }

000144bb                                                                                   cc cc cc cc cc                             .....
000144c0  cc cc cc cc                                                                                      ....

000144c4    void CSF_InitTransform(struct _NW_CSF_CONTEXT* pContext, struct fpoint_t* Pts, struct fpoint_t* FPts, uint8_t CamOrientation, uint8_t NumCalPoints)

000144c4  {
000144eb      int64_t rsi;
000144eb      (uint8_t)rsi = CamOrientation;
000144ee      memmove(&pContext->CalibContext.Pts, Pts, 0x20);
00014503      memmove(&pContext->CalibContext.FPts, FPts, 0x20);
0001450c      pContext->CalibContext.CamOrientation = (uint8_t)rsi;
0001452b      pContext->CalibContext.NumCalPoints = NumCalPoints;
00014549      float zmm3 =
00014549          (pContext->CalibContext.Pts[2].x + pContext->CalibContext.Pts[1].x) * 0.5f;
0001454d      float zmm4 =
0001454d          (pContext->CalibContext.Pts[3].y + pContext->CalibContext.Pts[2].y) * 0.5f;
00014561      pContext->CalibContext.calibScreenData.Xright = zmm3;
00014569      float zmm2 =
00014569          (pContext->CalibContext.Pts[3].x + pContext->CalibContext.Pts[0].x) * 0.5f;
00014575      zmm3 = zmm3 - zmm2;
00014579      pContext->CalibContext.calibScreenData.Ybottom = zmm4;
00014581      float zmm0 =
00014581          (pContext->CalibContext.Pts[1].y + pContext->CalibContext.Pts[0].y) * 0.5f;
00014585      zmm4 = zmm4 - zmm0;
00014589      pContext->CalibContext.calibScreenData.Ytop = zmm0;
00014594      zmm3 - 0f;
00014597      pContext->CalibContext.calibScreenData.Xleft = zmm2;
0001459f      pContext->CalibContext.calibScreenData.Xwidth = zmm3;
000145a7      pContext->CalibContext.calibScreenData.YHeight = zmm4;
000145a7      
000145b1      if (!FCMP_UO(zmm3, 0f) && !(zmm3 != 0f))
000145b1      {
000145b3          zmm4 - 0f;
000145b3          
000145b8          if (!FCMP_UO(zmm4, 0f) && !(zmm4 != 0f))
000145b8          {
000145ba              pContext->CalibContext.calibScreenData.Xwidth = 0x467ffc00;
000145c4              pContext->CalibContext.calibScreenData.YHeight = 8191f;
000145b8          }
000145b1      }
000145b1      
000145de      pContext->CalibContext.CalibrateMode = 0;
000145f3      pContext->CalibContext.calibScreenData.MoveWeightX =
000145f3          pContext->CalibContext.calibScreenData.Xwidth * 2f;
00014607      pContext->CalibContext.calibScreenData.MoveWeightY =
00014607          pContext->CalibContext.calibScreenData.YHeight * 2f;
000144c4  }

0001461a                                                                                cc cc cc cc cc cc                            ......

00014620    void CSF_StartCalibration(struct _NW_CSF_CONTEXT* pContext)

00014620  {
00014636      ST_AcquireLock(&pContext->CalibContext.Calibration_lock, 0);
0001463b      pContext->CalibContext.CalibrateMode = 1;
00014644      pContext->CalibContext.calibrationTime = 0;
0001464b      pContext->CalibContext.cursorMoveTime = 0;
00014652      pContext->CalibContext.calState = CSM_MOVE_CURSOR;
00014661      pContext->CalibContext.cX = 0x3fff;
00014665      pContext->CalibContext.cY = 0x3fff;
00014672      pContext->CalibContext.currentTarget.X =
00014672          (int16_t)(int64_t)(long double)pContext->CalibContext.FPts[0].x;
0001467f      pContext->CalibContext.currentTarget.Y =
0001467f          (int16_t)(int64_t)(long double)pContext->CalibContext.FPts[0].y;
00014683      pContext->CalibContext.CalibrationTimeout_tmr.expiredTime = 0xa;
00014689      pContext->CalibContext.CalibrationTimeout_tmr.elapsedTime = 0;
00014690      pContext->CalibContext.CalibrationTimeout_tmr.enabled = 1;
00014697      pContext->CalibContext.CalibrationTimeout_tmr.periodic = 1;
0001469e      pContext->CalibContext.CalibrationTimeout_tmr.param = &pContext->CalibContext;
000146ac      pContext->CalibContext.CalibrationTimeout_tmr.f = Calib_TimeoutTimer;
000146b3      pContext->CalibContext.CalibrationMove_tmr.expiredTime = 0xa;
000146c7      pContext->CalibContext.CalibrationMove_tmr.elapsedTime = 0;
000146ce      pContext->CalibContext.CalibrationMove_tmr.enabled = 1;
000146d5      pContext->CalibContext.CalibrationMove_tmr.f = Calib_MoveTimer;
000146dc      pContext->CalibContext.CalibrationMove_tmr.periodic = 1;
000146e3      pContext->CalibContext.CalibrationMove_tmr.param = &pContext->CalibContext;
000146ef      /* tailcall */
000146ef      return KeReleaseMutex(&pContext->CalibContext.Calibration_lock.mutex, 0);
00014620  }

000146f6                                                                    cc cc cc cc cc cc                                    ......

000146fc    void PT_ProcessFourEyesTouches(void* pContext, struct touches_t* pTouches)

000146fc  {
00014710      uint128_t zmm1;
00014710      (uint32_t)zmm1 = pTouches->touches[0].height;
00014710      *(uint32_t*)((char*)zmm1)[4] = pTouches->touches[0].height;
00014710      *(uint32_t*)((char*)zmm1)[8] = pTouches->touches[0].height;
00014710      *(uint32_t*)((char*)zmm1)[0xc] = pTouches->touches[0].height;
00014715      uint8_t touchCount = pTouches->touchCount;
00014719      struct csf_touch_report_t touchReport;
00014719      touchReport.touchCount = touchCount;
0001471d      int128_t zmm6;
0001471d      int128_t var_18 = zmm6;
00014721      int128_t zmm7;
00014721      int128_t var_28 = zmm7;
00014728      int32_t state = 0;
0001472e      touchReport.touch[0].width = pTouches->touches[0].width;
00014739      touchReport.touch[0].height = (uint32_t)zmm1;
0001473f      touchReport.touch[0].touchState = pTouches->touches[0].touchState;
00014743      int64_t rax_1;
00014743      (uint32_t)rax_1 = pTouches->touches[0].position.x;
00014743      *(uint32_t*)((char*)rax_1)[4] = pTouches->touches[0].position.y;
0001474a      (uint32_t)zmm1 = pTouches->touches[1].height;
0001474a      *(uint8_t*)((char*)zmm1)[4] = pTouches->touchCount;
0001474a      *(uint16_t*)((char*)zmm1)[6] = pTouches->id.id;
0001474a      *(uint16_t*)((char*)zmm1)[8] = pTouches->id.deltaTimeStamp;
0001474f      touchReport.touch[1].width = pTouches->touches[1].width;
00014755      touchReport.touch[1].height = (uint32_t)zmm1;
0001475b      touchReport.touch[0].pt.x = (uint32_t)rax_1;
0001475b      touchReport.touch[0].pt.y = *(uint32_t*)((char*)rax_1)[4];
00014763      touchReport.touch[0].id = 0;
00014768      touchReport.touch[1].touchState = pTouches->touches[1].touchState;
0001476c      int64_t rax_3;
0001476c      (uint32_t)rax_3 = pTouches->touches[1].position.x;
0001476c      *(uint32_t*)((char*)rax_3)[4] = pTouches->touches[1].position.y;
00014770      void* rdx = *(uint64_t*)((char*)pContext + 0x58);
00014774      touchReport.touch[1].pt.x = (uint32_t)rax_3;
00014774      touchReport.touch[1].pt.y = *(uint32_t*)((char*)rax_3)[4];
00014779      touchReport.touch[1].id = 1;
0001477e      int64_t rbx;
0001477e      (uint8_t)rbx = *(uint8_t*)((char*)rdx + 0x53c9);
00014784      var_64;
00014784      void* rcx = &*(uint0_t*)((char*)var_64)[4];
00014789      int64_t i_4 = 2;
0001489c      int64_t i;
0001489c      
0001489c      do
0001489c      {
0001478c          float a = *(uint32_t*)((char*)rcx - 4);
00014794          float a_1;
00014794          uint128_t zmm1_3;
00014794          
00014794          if ((uint8_t)rbx != 2)
00014794          {
0001483a              *(uint32_t*)((char*)rcx - 4) =
0001483a                  _divide(a, _mm_cvtepi32_ps((uint128_t)*(uint16_t*)((char*)rdx + 0x5504)));
00014856              *(uint32_t*)rcx = _divide(*(uint32_t*)rcx, 
00014856                  _mm_cvtepi32_ps((uint128_t)*(uint16_t*)((char*)rdx + 0x5506)));
00014872              *(uint32_t*)((char*)rcx + 4) = _divide(*(uint32_t*)((char*)rcx + 4), 
00014872                  _mm_cvtepi32_ps((uint128_t)*(uint16_t*)((char*)rdx + 0x5504)));
0001487e              a_1 = *(uint32_t*)((char*)rcx + 8);
00014887              zmm1_3 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)((char*)rdx + 0x5506));
00014794          }
00014794          else
00014794          {
0001479a              float zmm2 = *(uint32_t*)((char*)rdx + 0x54f4);
000147aa              (uint32_t)zmm1 = (*(uint32_t*)((char*)rdx + 0x54fc)) - zmm2;
000147b7              *(uint32_t*)((char*)rcx - 4) = _divide(a - zmm2, (uint32_t)zmm1);
000147dd              *(uint32_t*)rcx = _divide(
000147dd                  *(uint32_t*)rcx - *(uint32_t*)((char*)rdx + 0x54f8), 
000147dd                  *(uint32_t*)((char*)rdx + 0x54fc) - *(uint32_t*)((char*)rdx + 0x54f4));
000147e1              float zmm4 = *(uint32_t*)((char*)rdx + 0x54f4);
00014803              *(uint32_t*)((char*)rcx + 4) = _divide(*(uint32_t*)((char*)rcx + 4) - zmm4, 
00014803                  *(uint32_t*)((char*)rdx + 0x54fc) - zmm4);
00014815              (uint32_t)zmm1_3 =
00014815                  (*(uint32_t*)((char*)rdx + 0x54fc)) - *(uint32_t*)((char*)rdx + 0x54f4);
0001481d              a_1 = *(uint32_t*)((char*)rcx + 8) - *(uint32_t*)((char*)rdx + 0x54f8);
00014794          }
00014794          
0001488f          rcx += 0x18;
00014893          i = i_4;
00014893          i_4 -= 1;
00014897          *(uint32_t*)((char*)rcx - 0x10) = _divide(a_1, (uint32_t)zmm1_3);
0001489c      } while (i != 1);
0001489c      
000148a5      if (touchCount <= 0)
000148a5          return;
000148a5      
000148b5      if (!*(uint32_t*)((char*)rdx + 0x8bc0))
000148b5      {
0001490d          int64_t i_3;
0001490d          
0001490d          if (*(uint8_t*)((char*)pContext + 2))
0001490d          {
000149d3              void* rax_11 = &*(uint0_t*)((char*)var_64)[4];
000149fa              int64_t i_1;
000149fa              
000149fa              do
000149fa              {
000149e5                  (uint32_t)zmm1 = (*(uint32_t*)rax_11) * 32767f;
000149e9                  *(uint32_t*)((char*)rax_11 - 4) =
000149e9                      *(uint32_t*)((char*)rax_11 - 4) * 32767f;
000149ee                  *(uint32_t*)rax_11 = (uint32_t)zmm1;
000149f2                  rax_11 += 0x18;
000149f6                  i_1 = i_3;
000149f6                  i_3 -= 1;
000149fa              } while (i_1 != 1);
0001490d          }
0001490d          else
0001490d          {
00014913              zmm6 = {0};
00014916              zmm7 = 0x3f800000;
0001491e              var_5c;
0001491e              void* r9_1 = &var_5c;
000149c3              int64_t i_2;
000149c3              
000149c3              do
000149c3              {
00014923                  float x_1 = (uint32_t)zmm6;
00014935                  struct fpoint_t returnStruct;
00014935                  returnStruct.x = x_1;
00014935                  returnStruct.y = x_1;
00014940                  float x = (uint32_t)zmm7;
00014952                  struct fpoint_t rax_8 =
00014952                      Calib_CalibrateCoords((char*)rdx + 0x8bc0, returnStruct);
00014957                  struct fpoint_t returnStruct_1;
00014957                  returnStruct_1.x = x;
00014957                  returnStruct_1.y = x;
0001495f                  x_1 = rax_8.x;
00014967                  struct fpoint_t rax_9 =
00014967                      Calib_CalibrateCoords((char*)rdx + 0x8bc0, returnStruct_1);
0001496c                  x = rax_9.x;
0001499d                  *(uint32_t*)r9_1 = (rax_9.y - rax_8.y) * *(uint32_t*)r9_1;
000149a8                  *(uint32_t*)((char*)r9_1 + 4) =
000149a8                      ((uint32_t)zmm7 - (uint32_t)zmm6) * *(uint32_t*)((char*)r9_1 + 4);
000149ae                  struct fpoint_t returnStruct_2;
000149ae                  returnStruct_2.x = *(uint32_t*)((char*)r9_1 - 8);
000149ae                  returnStruct_2.y = *(uint32_t*)((char*)r9_1 - 4);
000149b2                  struct fpoint_t rax_10;
000149b2                  rax_10 = Calib_CalibrateCoords((char*)rdx + 0x8bc0, returnStruct_2);
000149b7                  r9_1 += 0x18;
000149bb                  i_2 = i_3;
000149bb                  i_3 -= 1;
000149bf                  *(uint32_t*)((char*)r9_1 - 0x20) = rax_10.x;
000149bf                  *(uint32_t*)((char*)r9_1 - 0x1c) = rax_10.y;
000149c3              } while (i_2 != 1);
0001490d          }
00014a04          PT_ProcessTouch(pContext, &touchReport);
000148b5      }
000148b5      else
000148b5      {
000148b7          enum touch_state_t touchState = touchReport.touch[0].touchState;
000148b7          
000148be          if (touchState)
000148be          {
000148c3              if (touchState == TS_TOUCH_DOWN)
000148e7                  state = 1;
000148c3              else if (touchState == 2)
000148e2                  state = 2;
000148c8              else if (touchState == 3)
000148da                  state = 3;
000148cd              else if (touchState == 5)
000148d4                  state = (int32_t)(i_4 + 5);
000148be          }
000148be          
000148f4          struct fpoint_t pt;
000148f4          pt.x = touchReport.touch[0].pt.x;
000148f4          pt.y = touchReport.touch[0].pt.y;
000148ff          Calib_CalibrationHandler((char*)rdx + 0x8bc0, state, pt, 
000148ff              *(uint32_t*)((char*)rdx + 0x32ec));
000148b5      }
000146fc  }

00014a24              cc cc cc cc cc cc cc cc                                                                  ........

00014a2c    uint8_t IsPointInBorder(struct PTContext_t* pContext, struct fpoint_t* pt)

00014a2c  {
00014a31      pt->x
00014a31      float zmm1 = pt->x;
00014a35      char r9 = 1;
00014a35      
00014a4e      if (zmm1 < _mm_cvtepi32_ps((uint128_t)(1 - (uint32_t)pContext->Border.left)))
00014a97          r9 = 0;
00014a4e      else if (_mm_cvtepi32_ps((uint128_t)((uint32_t)pContext->Border.right + 0x7fff))
00014a4e              < zmm1)
00014a97          r9 = 0;
00014a67      else
00014a67      {
00014a6d          zmm1 = pt->y;
00014a6d          
00014a81          if (zmm1 < _mm_cvtepi32_ps((uint128_t)(1 - (uint32_t)pContext->Border.top)))
00014a97              r9 = 0;
00014a81          else if (!(
00014a81                  _mm_cvtepi32_ps((uint128_t)((uint32_t)pContext->Border.bottom + 0x7fff))
00014a81                  >= zmm1))
00014a97              r9 = 0;
00014a67      }
00014a67      
00014a9a      uint32_t rax;
00014a9a      (uint8_t)rax = r9;
00014a9d      return (uint8_t)rax;
00014a2c  }

00014a9e                                                                                            cc cc                                ..
00014aa0  cc cc cc cc                                                                                      ....

00014aa4    void MovePointInScreen(struct fpoint_t* pt)

00014aa4  {
00014ab4      if (!(1f <= pt->x))
00014ab6          pt->x = 0x3f800000;
00014ab6      
00014ab8      pt->x
00014ab8      
00014acc      if (!(pt->x <= 32767f))
00014ace          pt->x = 0x46fffe00;
00014ace      
00014ad4      if (!(1f <= pt->y))
00014ad6          pt->y = 1f;
00014ad6      
00014ae1      if (!(pt->y <= 32767f))
00014ae3          pt->y = 32767f;
00014aa4  }

00014ae7                       cc cc cc cc cc cc cc cc cc                                                         .........

00014af0    uint8_t InterpolatePointToBorder(struct fpoint_t const* outPoint, struct fpoint_t const* inPoint, struct PTContext_t* pContext, struct fpoint_t* result)

00014af0  {
00014afb      outPoint->x
00014afb      float zmm4 = outPoint->x;
00014b1e      uint128_t zmm2 = (uint128_t)((uint32_t)pContext->Border.right + 0x7fff);
00014b22      uint32_t top = (uint32_t)pContext->Border.top;
00014b27      uint128_t zmm3 = _mm_cvtepi32_ps((uint128_t)(1 - (uint32_t)pContext->Border.left));
00014b32      int32_t rax_4 = (uint32_t)pContext->Border.bottom + 0x7fff;
00014b39      zmm2 = _mm_cvtepi32_ps(zmm2);
00014b43      uint128_t zmm0 = _mm_cvtepi32_ps((uint128_t)(1 - top));
00014b46      uint128_t zmm1 = _mm_cvtepi32_ps((uint128_t)rax_4);
00014b49      struct fpoint_t p4;
00014b49      struct fpoint_t p3;
00014b49      
00014b49      if (!((uint32_t)zmm3 <= zmm4))
00014b49      {
00014b4b          p4.x = (uint32_t)zmm3;
00014b51          p3.y = (uint32_t)zmm0;
00014ba7      label_14ba7:
00014ba7          p3.x = (uint32_t)zmm3;
00014bad          p4.y = (uint32_t)zmm1;
00014bc8          rax_4 = SFP_IntersectSegments(inPoint, outPoint, &p3, &p4, result);
00014b49      }
00014b49      else if (zmm4 <= (uint32_t)zmm2)
00014b5c      {
00014b72          zmm4 = outPoint->y;
00014b72          
00014b7a          if ((uint32_t)zmm0 <= zmm4)
00014b7a          {
00014b99              if (!(zmm4 <= (uint32_t)zmm1))
00014b99              {
00014b9b                  p4.x = (uint32_t)zmm2;
00014ba1                  p3.y = (uint32_t)zmm1;
00014ba1                  goto label_14ba7;
00014b99              }
00014b99              
00014bcf              (uint8_t)rax_4 = 0;
00014b7a          }
00014b7a          else
00014b7a          {
00014b7c              p3.x = (uint32_t)zmm3;
00014b82              p4.x = (uint32_t)zmm2;
00014b88              p4.y = (uint32_t)zmm0;
00014b8e              p3.y = (uint32_t)zmm0;
00014bc8              rax_4 = SFP_IntersectSegments(inPoint, outPoint, &p3, &p4, result);
00014b7a          }
00014b5c      }
00014b5c      else
00014b5c      {
00014b5e          p4.x = (uint32_t)zmm2;
00014b64          p3.x = (uint32_t)zmm2;
00014b6a          p3.y = (uint32_t)zmm0;
00014bad          p4.y = (uint32_t)zmm1;
00014bc8          rax_4 = SFP_IntersectSegments(inPoint, outPoint, &p3, &p4, result);
00014b5c      }
00014bd6      return (uint8_t)rax_4;
00014af0  }

00014bd7                                                                       cc cc cc cc cc cc cc cc cc                         .........

00014be0    void PT_ProcessTouch(struct PTContext_t* pContext, struct csf_touch_report_t* touchReport)

00014be0  {
00014bfd      int128_t zmm6;
00014bfd      int128_t var_38 = zmm6;
00014bfd      
00014c11      if (!pContext->ProcessTouchStatus)
00014c11      {
00014c1a          j_DbgPrint("pContext->ProcessTouchStatus = TRUE\n");
00014c1f          pContext->ProcessTouchStatus = 1;
00014c11      }
00014c11      
00014c3b      *(uint64_t*)((char*)pContext->ProcessTouchStatusTime + 0) =
00014c3b          *(uint64_t*)-0xfffff78000000014;
00014c3f      char var_70[0x30];
00014c3f      memmove(&var_70, touchReport, 0x34);
00014c44      int32_t i = 0;
00014c4c      char var_40;
00014c4c      
00014c4c      if (var_40 > 0)
00014c4c      {
00014c4e          char (* r11_1)[0x30] = &var_70;
00014c4e          
00014ca1          do
00014ca1          {
00014c5c              if (pContext->OffscreenMode == 1 && *(uint32_t*)r11_1)
00014c5c              {
00014c5e                  int32_t temp1_1 = *(uint32_t*)r11_1;
00014c5e                  
00014c61                  if (temp1_1 == 1)
00014c61                  {
00014c7c                  label_14c7c:
00014c7c                      
00014c84                      if (IsPointInBorder(pContext, &(*(uint384_t*)r11_1)[4]))
00014c84                      {
00014c86                          uint64_t rax_2 = (uint64_t)(*(uint384_t*)r11_1)[0x14];
00014c8b                          *(uint32_t*)r11_1 = 0;
00014c8e                          pContext->OffscreenBlockedIds[rax_2] = 1;
00014c84                      }
00014c61                  }
00014c61                  else if (temp1_1 > 1)
00014c63                  {
00014c69                      if (*(uint32_t*)r11_1 <= 3)
00014c69                      {
00014d84                          uint64_t rax_10 = (uint64_t)(*(uint384_t*)r11_1)[0x14];
00014d84                          
00014d8e                          if (pContext->OffscreenBlockedIds[rax_10])
00014d8e                          {
00014d98                              if (*(uint32_t*)r11_1 == 3)
00014d9a                                  pContext->OffscreenBlockedIds[rax_10] = 0;
00014d9a                              
00014d9f                              *(uint32_t*)r11_1 = 0;
00014d8e                          }
00014c69                      }
00014c69                      else if (*(uint32_t*)r11_1 <= 5)
00014c73                          goto label_14c7c;
00014c63                  }
00014c5c              }
00014c5c              
00014c98              i += 1;
00014c9b              r11_1 = &(*(uint384_t*)r11_1)[0x18];
00014ca1          } while (i < (uint32_t)var_40);
00014c4c      }
00014c4c      
00014ca3      void (* OffscreenTouchPointCallback)(void*, uint8_t, struct csf_touch_report_t*) =
00014ca3          pContext->OffscreenTouchPointCallback;
00014ca3      
00014caa      if (OffscreenTouchPointCallback)
00014cb7          OffscreenTouchPointCallback(pContext->OffscreenTouchPointCBParam, 0, &var_70);
00014cb7      
00014cb9      int64_t rbp;
00014cb9      (uint8_t)rbp = touchReport->touchCount;
00014cbd      char temp0 = (uint8_t)rbp;
00014cbd      (uint8_t)rbp -= 1;
00014cbd      
00014cc0      if (temp0 - 1 >= 0)
00014cc0      {
00014cc6          zmm6 = {0};
00014cd1          struct fpoint_t* rbx = &touchReport->touch[(int64_t)(uint8_t)rbp].pt;
00014cd1          
00014e2d          do
00014e2d          {
00014cda              if (*(int64_t*)((char*)rbx + -4))
00014cda              {
00014ce0                  int32_t temp2_1 = *(int64_t*)((char*)rbx + -4);
00014ce0                  
00014ce4                  if (temp2_1 == 1)
00014ce4                  {
00014d06                  label_14d06:
00014d06                      
00014d0e                      if (IsPointInBorder(pContext, rbx))
00014e1e                          MovePointInScreen(rbx);
00014d0e                      else
00014d0e                      {
00014d18                          pContext->OutOfBorderTouchIds[(uint64_t)*((char*)rbx + 0x10)] = 1;
00014d21                          int64_t rax_7;
00014d21                          (uint32_t)rax_7 = rbx->x;
00014d21                          *(uint32_t*)((char*)rax_7)[4] = rbx->y;
00014d24                          pContext->OutOfBorderTouchPos[(uint64_t)*((char*)rbx + 0x10)].x =
00014d24                              rax_7;
00014d38                      label_14d38:
00014d38                          *(int64_t*)((char*)rbx + -4) = 0;
00014d3c                          char var_88[0x18];
00014d3c                          memmove(&var_88, (char*)rbx - 4, 0x18);
00014d5c                          memmove((char*)rbx - 4, 
00014d5c                              &touchReport->touch[(uint64_t)touchReport->touchCount]
00014d5c                                  - 0x18, 
00014d5c                              0x18);
00014d77                          memmove(
00014d77                              &touchReport->touch[(uint64_t)touchReport->touchCount]
00014d77                                  - 0x18, 
00014d77                              &var_88, 0x18);
00014d7c                          touchReport->touchCount -= 1;
00014d0e                      }
00014ce4                  }
00014ce4                  else if (temp2_1 > 1)
00014ce6                  {
00014cf0                      if (*(int64_t*)((char*)rbx + -4) <= 3)
00014cf0                      {
00014da7                          uint64_t r11_4 = (uint64_t)*((char*)rbx + 0x10);
00014da7                          
00014db1                          if (!pContext->OutOfBorderTouchIds[r11_4])
00014e1e                              MovePointInScreen(rbx);
00014db1                          else
00014db1                          {
00014db7                              if (*(int64_t*)((char*)rbx + -4) == 3)
00014db7                              {
00014db9                                  pContext->OutOfBorderTouchIds[r11_4] = 0;
00014dbe                                  goto label_14d38;
00014db7                              }
00014db7                              
00014dd1                              if (!IsPointInBorder(pContext, rbx))
00014dd1                              {
00014e7a                                  int64_t rax_15;
00014e7a                                  (uint32_t)rax_15 = rbx->x;
00014e7a                                  *(uint32_t*)((char*)rax_15)[4] = rbx->y;
00014e7d                                  pContext->OutOfBorderTouchPos[r11_4].x = rax_15;
00014e82                                  goto label_14d38;
00014dd1                              }
00014dd1                              
00014dd9                              *(int64_t*)((char*)rbx + -4) = 1;
00014ddd                              pContext->OutOfBorderTouchIds[r11_4] = 0;
00014de2                              struct fpoint_t result;
00014de2                              result.y = 0;
00014df5                              result.x = (uint32_t)zmm6;
00014e06                              uint8_t rax_13;
00014e06                              rax_13 = InterpolatePointToBorder(
00014e06                                  &pContext->OutOfBorderTouchPos[(uint64_t)
00014e06                                      *((char*)rbx + 0x10)], 
00014e06                                  rbx, pContext, &result);
00014e06                              
00014e0e                              if (rax_13)
00014e0e                              {
00014e10                                  struct fpoint_t rax_14;
00014e10                                  rax_14.x = result.x;
00014e10                                  rax_14.y = result.y;
00014e18                                  rbx->x = rax_14.x;
00014e18                                  rbx->y = rax_14.y;
00014e0e                              }
00014e0e                              
00014e1e                              MovePointInScreen(rbx);
00014db1                          }
00014cf0                      }
00014cf0                      else if (*(int64_t*)((char*)rbx + -4) <= 5)
00014cfa                          goto label_14d06;
00014ce6                  }
00014cda              }
00014cda              
00014e23              (uint8_t)rbp -= 1;
00014e26              rbx -= 0x18;
00014e2d          } while ((uint8_t)rbp >= 0);
00014cc0      }
00014cc0      
00014e40      struct _NW_CSF_CONTEXT* pCSFContext;
00014e40      
00014e40      if (!pContext->RawMouse && pContext->MouseMode)
00014e46          pCSFContext = pContext->pCSFContext;
00014e46      
00014e51      if (pContext->RawMouse || !pContext->MouseMode
00014e51          || !pCSFContext->meContext.Settings.Enabled)
00014e51      {
00014ee5          void (* TouchPointCallback)(void*, uint8_t, struct csf_touch_report_t*) =
00014ee5              pContext->TouchPointCallback;
00014ee5          
00014eec          if (TouchPointCallback)
00014ef7              TouchPointCallback(pContext->TouchPointCBParam, 0, touchReport);
00014e51      }
00014e51      else
00014e51      {
00014e57          enum touch_state_t touchState = touchReport->touch[0].touchState;
00014e59          int32_t rdx_8 = 0;
00014e59          
00014e5f          if (touchState)
00014e5f          {
00014e64              if (touchState == TS_TOUCH_DOWN)
00014e95                  rdx_8 = 1;
00014e64              else if (touchState == 2)
00014e8e                  rdx_8 = 2;
00014e69              else if (touchState == 3)
00014e87                  rdx_8 = 3;
00014e6e              else if (touchState == 5)
00014e75                  rdx_8 = touchState;
00014e5f          }
00014e5f          
00014e98          float x = touchReport->touch[0].pt.x;
00014e9d          float y = touchReport->touch[0].pt.y;
00014ea2          int32_t param = rdx_8;
00014eaf          float x_1 = x;
00014eb5          float y_1 = y;
00014ebb          ST_AcquireLock(&pCSFContext->meContext.MouseEngine_lock, 0);
00014ecf          _me_SignalInternal(&pCSFContext->meContext, ME_TOUCH_SIG, &param);
00014edd          KeReleaseMutex(&pCSFContext->meContext.MouseEngine_lock.mutex, 0);
00014e51      }
00014e51      
00014ef9      void (* VendorTouchPointCallback)(void*, uint8_t, struct csf_touch_report_t*) =
00014ef9          pContext->VendorTouchPointCallback;
00014ef9      
00014f00      if (VendorTouchPointCallback)
00014f0b          VendorTouchPointCallback(pContext->VendorTouchPointCBParam, 0, touchReport);
00014be0  }

00014f2e                                            cc cc cc cc cc cc                                                    ......

00014f34    void PT_SendMouse(void* param, struct mouseReport_t* mouseReport)

00014f34  {
00014f38      enum MOUSE_INPUT_STATE state = mouseReport->state;
00014f3b      int64_t rax;
00014f3b      (uint32_t)rax = mouseReport->pt.x;
00014f3b      *(uint32_t*)((char*)rax)[4] = mouseReport->pt.y;
00014f3f      char var_34 = 0;
00014f47      int64_t var_44 = rax;
00014f51      bool var_18 = state;
00014f59      int32_t var_48;
00014f59      
00014f59      switch (state)
00014f59      {
00014f56          case MOUSE_NONE:
00014f56          {
00014fa2              var_48 = 0;
00014f56              break;
00014f56          }
00014f5b          case MOUSE_DOWN:
00014f5b          {
00014f9c              var_48 = 1;
00014f5b              break;
00014f5b          }
00014f60          case MOUSE_MOVE:
00014f60          {
00014f92              var_48 = 2;
00014f60              break;
00014f60          }
00014f65          case MOUSE_UP:
00014f65          {
00014f88              var_48 = 3;
00014f65              break;
00014f65          }
00014f6a          case MOUSE_RIGHTDOWN:
00014f6a          {
00014f7e              var_48 = 4;
00014f6a              break;
00014f6a          }
00014f6f          case MOUSE_HOVER:
00014f6f          {
00014f74              var_48 = 5;
00014f6f              break;
00014f6f          }
00014f59      }
00014f59      
00014fa7      int64_t rax_1 = *(uint64_t*)((char*)param + 0x28);
00014fa7      
00014fae      if (rax_1)
00014fb9          rax_1(*(uint64_t*)((char*)param + 0x30), 1, &var_48);
00014f34  }

00014fc0  cc cc cc cc cc cc cc cc                                                                          ........

00014fc8    struct fpoint_t Calib_CalibrateCoords(struct CalibContext_t* pContext, struct fpoint_t returnStruct)

00014fc8  {
00014fcb      int64_t result;
00014fcb      (uint32_t)result = returnStruct.x;
00014fcb      *(uint32_t*)((char*)result)[4] = returnStruct.y;
00014fd6      float zmm0[0x4] = 0x46fffe00;
00014fde      double zmm1[0x2] = {0};
00014fee      float zmm9[0x4];
00014fee      float var_48[0x4] = zmm9;
00014ff3      int128_t zmm8;
00014ff3      (uint32_t)zmm8 = pContext->Pts[0].x;
00014ff3      *(uint32_t*)((char*)zmm8)[4] = pContext->Pts[0].x;
00014ff3      *(uint32_t*)((char*)zmm8)[8] = pContext->Pts[0].x;
00014ff3      *(uint32_t*)((char*)zmm8)[0xc] = pContext->Pts[0].x;
00014ffc      float zmm6[0x4] = (uint32_t)result;
00015001      float zmm7[0x4] = *(uint32_t*)((char*)result)[4];
00015006      float zmm10[0x4];
00015006      float var_58[0x4] = zmm10;
0001500b      float zmm12[0x4];
0001500b      float var_68[0x4] = zmm12;
00015010      float zmm13[0x4];
00015010      float var_78[0x4] = zmm13;
00015015      zmm6[0] = zmm6[0] * 32767f;
00015019      zmm7[0] = zmm7[0] * 32767f;
0001501d      (uint32_t)zmm8 - 0f;
00015021      float zmm14[0x4];
00015021      float var_88[0x4] = zmm14;
00015027      double zmm15[0x2];
00015027      double var_98[0x2] = zmm15;
00015027      
0001502e      if (!FCMP_UO((uint32_t)zmm8, 0f) && !((uint32_t)zmm8 != 0f))
0001502e      {
00015030          zmm0[0] = pContext->FPts[0].x;
00015030          zmm0[1] = pContext->FPts[0].x;
00015030          zmm0[2] = pContext->FPts[0].x;
00015030          zmm0[3] = pContext->FPts[0].x;
00015038          zmm0[0] - 0f;
0001502e      }
0001502e      
0001503d      if (FCMP_UO((uint32_t)zmm8, 0f) || (uint32_t)zmm8 != 0f || FCMP_UO(zmm0[0], 0f)
0001503d          || zmm0[0] != 0f)
0001503d      {
00015050          if (pContext->CamOrientation)
00015050          {
00015052              zmm0 = zmm6;
00015055              zmm6 = zmm7;
00015058              zmm7 = zmm0;
00015050          }
00015050          
0001505b          zmm0[0] = pContext->calibScreenData.Xwidth;
0001505b          zmm0[1] = pContext->calibScreenData.Xwidth;
0001505b          zmm0[2] = pContext->calibScreenData.Xwidth;
0001505b          zmm0[3] = pContext->calibScreenData.Xwidth;
00015060          zmm0[0] - 0f;
00015065          float zmm4;
00015065          
00015065          if (FCMP_UO(zmm0[0], 0f) || zmm0[0] != 0f)
00015081              zmm4 = (zmm6[0] - pContext->calibScreenData.Xleft) / zmm0[0];
00015065          else
0001506f              zmm4 = (zmm6[0] - pContext->calibScreenData.Xleft) / 24000f;
0001506f          
00015085          zmm0[0] = pContext->calibScreenData.YHeight;
00015085          zmm0[1] = pContext->calibScreenData.YHeight;
00015085          zmm0[2] = pContext->calibScreenData.YHeight;
00015085          zmm0[3] = pContext->calibScreenData.YHeight;
0001508a          zmm0[0] - 0f;
0001508f          float zmm5;
0001508f          
0001508f          if (FCMP_UO(zmm0[0], 0f) || zmm0[0] != 0f)
000150ab              zmm5 = (zmm7[0] - pContext->calibScreenData.Ytop) / zmm0[0];
0001508f          else
00015099              zmm5 = (zmm7[0] - pContext->calibScreenData.Ytop) / 14000f;
00015099          
000150af          zmm13[0] = pContext->Pts[1].y;
000150af          zmm13[1] = pContext->Pts[1].y;
000150af          zmm13[2] = pContext->Pts[1].y;
000150af          zmm13[3] = pContext->Pts[1].y;
000150b8          zmm12[0] = pContext->Pts[1].x;
000150b8          zmm12[1] = pContext->Pts[1].x;
000150c1          zmm14[0] = pContext->Pts[2].x;
000150c1          zmm14[1] = pContext->Pts[2].x;
000150ca          char rax_1 = 1;
000150cc          zmm15[0] = pContext->Pts[2].y;
000150cc          *(uint32_t*)((char*)zmm15[0])[4] = pContext->Pts[2].y;
000150cc          zmm15[1] = pContext->Pts[2].y;
000150cc          *(uint32_t*)((char*)zmm15[1])[4] = pContext->Pts[2].y;
000150d5          zmm4 = zmm4 + 0f;
000150d9          zmm5 = zmm5 + 0f;
000150dd          zmm1[0] = pContext->Pts[0].y;
000150dd          *(uint32_t*)((char*)zmm1[0])[4] = pContext->Pts[0].y;
000150dd          zmm1[1] = pContext->Pts[0].y;
000150dd          *(uint32_t*)((char*)zmm1[1])[4] = pContext->Pts[0].y;
000150e5          zmm12[0] = zmm12[0] - (uint32_t)zmm8;
000150ea          zmm13[0] = zmm13[0] - zmm1[0];
000150f3          zmm12[0] = zmm12[0] * zmm4;
000150f7          zmm12[0] = zmm12[0] + (uint32_t)zmm8;
00015100          zmm13[0] = zmm13[0] * zmm4;
00015104          zmm13[0] = zmm13[0] + zmm1[0];
00015108          zmm1[0] = pContext->Pts[3].x;
00015108          *(uint32_t*)((char*)zmm1[0])[4] = pContext->Pts[3].x;
00015110          zmm14[0] = zmm14[0] - zmm1[0];
00015119          zmm14[0] = zmm14[0] * zmm4;
0001511d          zmm14[0] = zmm14[0] + zmm1[0];
00015121          zmm14[0] = zmm14[0] - zmm12[0];
00015125          zmm14[0] = zmm14[0] * zmm5;
00015129          zmm14[0] = zmm14[0] + zmm12[0];
0001512d          zmm12[0] = pContext->Pts[3].y;
0001512d          zmm12[1] = pContext->Pts[3].y;
0001512d          zmm12[2] = pContext->Pts[3].y;
0001512d          zmm12[3] = pContext->Pts[3].y;
00015135          zmm15[0] = zmm15[0] - zmm12[0];
0001513a          zmm1 = zmm15;
0001513e          zmm1[0] = zmm1[0] * zmm4;
00015142          zmm1[0] = zmm1[0] + zmm12[0];
00015149          zmm1[0] = zmm1[0] - zmm13[0];
0001514d          zmm1[0] = zmm1[0] * zmm5;
00015151          zmm1[0] = zmm1[0] + zmm13[0];
00015158          zmm7[0] = zmm7[0] - zmm1[0];
0001515c          zmm6[0] = zmm6[0] - zmm14[0];
00015160          zmm10 = zmm7;
00015167          zmm9 = zmm6;
0001516b          zmm0 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0])[0]);
0001516e          float zmm2[0x4] = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
00015179          zmm1[0] = (float)__andpd_xmmxuq_memxuq(zmm0, __mask@@AbsDouble@)[0];
00015180          zmm0 =
00015180              __andpd_xmmxuq_memxuq(_mm_cvtps_pd(*(uint64_t*)&zmm2[0]), __mask@@AbsDouble@);
00015188          zmm0[0] = (float)*(uint64_t*)&zmm0[0];
0001518c          zmm1[0] = zmm1[0] + zmm0[0];
00015198          bool cond:5_1 = 5f <= zmm1[0];
00015198          
00015252          while (true)
00015252          {
00015252              zmm10[0] = zmm10[0] / pContext->calibScreenData.MoveWeightY;
00015258              zmm9[0] = zmm9[0] / pContext->calibScreenData.MoveWeightX;
00015258              
0001525e              if (!cond:5_1)
0001525e                  break;
0001525e              
000151a2              if (rax_1 > 0x1e)
000151a2                  break;
000151a2              
000151a8              zmm4 = zmm4 + zmm9[0];
000151ad              zmm5 = zmm5 + zmm10[0];
000151be              zmm2 = zmm14;
000151c2              rax_1 += 1;
000151c4              zmm13[0] = zmm13[0] * zmm4;
000151c8              zmm13[0] = zmm13[0] + pContext->Pts[0].y;
000151d0              zmm12[0] = zmm12[0] * zmm4;
000151d4              zmm15[0] = zmm15[0] * zmm4;
000151d8              zmm15[0] = zmm15[0] + pContext->Pts[3].y;
000151e0              zmm12[0] = zmm12[0] + (uint32_t)zmm8;
000151e5              zmm2[0] = zmm2[0] * zmm4;
000151e9              zmm2[0] = zmm2[0] + pContext->Pts[3].x;
000151f1              zmm15[0] = zmm15[0] - zmm13[0];
000151f5              zmm15[0] = zmm15[0] * zmm5;
000151f9              zmm2[0] = zmm2[0] - zmm12[0];
000151fd              zmm15[0] = zmm15[0] + zmm13[0];
00015204              zmm2[0] = zmm2[0] * zmm5;
00015208              zmm2[0] = zmm2[0] + zmm12[0];
0001520f              zmm7[0] = zmm7[0] - zmm15[0];
00015213              zmm6[0] = zmm6[0] - zmm2[0];
00015217              zmm10 = zmm7;
0001521e              zmm9 = zmm6;
00015222              zmm0 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0])[0]);
00015228              double temp0_10[0x2] =
00015228                  _mm_cvtps_pd(_mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0])[0]);
0001522b              zmm0 = __andpd_xmmxuq_memxuq(zmm0, __mask@@AbsDouble@);
00015233              zmm1 = __andpd_xmmxuq_memxuq(temp0_10, __mask@@AbsDouble@);
0001523b              zmm2[0] = (float)*(uint64_t*)&zmm0[0];
0001523f              zmm0[0] = (float)zmm1[0];
00015243              zmm2[0] = zmm2[0] + zmm0[0];
0001524f              cond:5_1 = 5f <= zmm2[0];
00015252          }
00015252          
00015264          zmm0[0] = pContext->FPts[0].x;
00015264          zmm0[1] = pContext->FPts[0].x;
00015264          zmm0[2] = pContext->FPts[0].x;
00015264          zmm0[3] = pContext->FPts[0].x;
0001526c          zmm2[0] = pContext->FPts[2].y;
0001526c          zmm2[1] = pContext->FPts[2].y;
0001526c          zmm2[2] = pContext->FPts[2].y;
0001526c          zmm2[3] = pContext->CamOrientation;
0001526c          *(uint8_t*)((char*)zmm2[3])[1] = pContext->NumCalPoints;
0001526c          *(uint16_t*)((char*)zmm2[3])[2] = *(int64_t*)((char*)pContext + 0x2b2);
00015274          zmm1[0] = pContext->FPts[1].x;
00015274          *(uint32_t*)((char*)zmm1[0])[4] = pContext->FPts[1].x;
0001527c          zmm2[0] = zmm2[0] - pContext->FPts[1].y;
00015284          zmm1[0] = zmm1[0] - zmm0[0];
00015288          zmm1[0] = zmm1[0] * zmm4;
0001528c          zmm2[0] = zmm2[0] * zmm5;
00015290          zmm1[0] = zmm1[0] + zmm0[0];
00015294          zmm2[0] = zmm2[0] + pContext->FPts[0].y;
0001529c          *(uint32_t*)((char*)result)[4] = zmm2[0];
0001503d      }
0001503d      else
0001503f          *(uint32_t*)((char*)result)[4] = 0;
0001503f      
000152bd      (uint32_t)result = zmm1[0];
000152ef      return result;
00014fc8  }

000152f0                                                  cc cc cc cc cc cc cc cc                                          ........

000152f8    void Calib_CancelCalibration(struct CalibContext_t* pContext)

000152f8  {
0001530a      ST_AcquireLock(&pContext->Calibration_lock, 0);
0001531b      j_strrchr("c:\development_work\csf_release_hp\driver\csf\calibrator.c", 0x5c);
00015334      Error_Count.cnt_infos += 1;
00015355      void (* CalibFinishedCB)(void*, uint8_t, uint8_t, struct fpoint_t*) =
00015355          pContext->CalibFinishedCB;
0001535c      pContext->CalibrateMode = 0;
0001535c      
00015362      if (CalibFinishedCB)
00015373          CalibFinishedCB(pContext->CalibFinishedParam, 0, 0, 0);
00015373      
00015375      pContext->CalibrationTimeout_tmr.f = nullptr;
0001537d      pContext->CalibrationTimeout_tmr.param = nullptr;
00015385      pContext->CalibrationTimeout_tmr.enabled = 0;
0001538c      pContext->CalibrationMove_tmr.f = nullptr;
00015394      pContext->CalibrationMove_tmr.param = nullptr;
000153a5      pContext->CalibrationMove_tmr.enabled = 0;
000153b1      /* tailcall */
000153b1      return KeReleaseMutex(&pContext->Calibration_lock.mutex, 0);
000152f8  }

000153b8                                                                          cc cc cc cc cc cc cc cc                          ........

000153c0    uint8_t SetCalCursor(struct CalibContext_t* pContext)

000153c0  {
000153cc      uint32_t CalibrateMode = pContext->CalibrateMode;
000153d2      int64_t rbx;
000153d2      (uint8_t)rbx = 0;
000153d4      uint64_t rdx = (uint64_t)(CalibrateMode - 1);
000153de      int32_t rax_1 = (uint32_t)rdx;
000153e0      float zmm3 = (float)(uint64_t)pContext->cursorMoveTime / 333f;
000153e8      int64_t entry_r9;
000153e8      uint128_t entry_zmm2;
000153e8      uint128_t zmm0;
000153e8      uint128_t zmm1;
000153e8      bool cond:1_1;
000153e8      
000153e8      if (CalibrateMode == 1)
000153e8      {
0001556b          (uint32_t)zmm0 = pContext->FPts[0].x;
0001556b          *(uint32_t*)((char*)zmm0)[4] = pContext->FPts[0].x;
0001556b          *(uint32_t*)((char*)zmm0)[8] = pContext->FPts[0].x;
0001556b          *(uint32_t*)((char*)zmm0)[0xc] = pContext->FPts[0].x;
00015573          entry_r9 = 0x3fff;
00015579          (uint32_t)zmm0 = (uint32_t)zmm0 - 16383f;
0001557d          (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
00015581          int16_t rax_16 = (int16_t)(int64_t)(uint32_t)zmm0;
00015586          (uint32_t)zmm0 = pContext->FPts[0].y;
00015586          *(uint32_t*)((char*)zmm0)[4] = pContext->FPts[0].y;
00015586          *(uint32_t*)((char*)zmm0)[8] = pContext->FPts[0].y;
00015586          *(uint32_t*)((char*)zmm0)[0xc] = pContext->FPts[0].y;
0001558f          (uint32_t)zmm0 = (uint32_t)zmm0 - 16383f;
00015597          uint32_t rcx_2 = (uint32_t)(rax_16 + 0x3fff);
0001559a          pContext->cX = (uint16_t)rcx_2;
000155a3          (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
000155ac          zmm1 = _mm_cvtepi32_ps((uint128_t)rcx_2);
000155b3          pContext->cY = (int16_t)(int64_t)(uint32_t)zmm0 + 0x3fff;
000155b8          (uint32_t)zmm0 = pContext->FPts[0].x;
000155b8          *(uint32_t*)((char*)zmm0)[4] = pContext->FPts[0].x;
000155b8          *(uint32_t*)((char*)zmm0)[8] = pContext->FPts[0].x;
000155b8          *(uint32_t*)((char*)zmm0)[0xc] = pContext->FPts[0].x;
000155c1          cond:1_1 = (uint32_t)zmm0 < (uint32_t)zmm1;
000155c4      label_155c4:
000155c4          
000155c4          if (!cond:1_1)
000155c4          {
000155d0              (uint8_t)rbx = 1;
000155d2              pContext->cX = (int16_t)(int64_t)(long double)pContext->FPts[rdx].x;
000155e1              pContext->cY = (int16_t)(int64_t)(long double)pContext->FPts[rdx].y;
000155c4          }
000153e8      }
000153e8      else
000153e8      {
000153f1          uint32_t rax_12;
000153f1          
000153f1          if (rax_1 == 1)
000153f1          {
000154f7              (uint32_t)zmm1 = pContext->FPts[0].x;
000154f7              *(uint32_t*)((char*)zmm1)[4] = pContext->FPts[0].x;
000154f7              *(uint32_t*)((char*)zmm1)[8] = pContext->FPts[0].x;
000154f7              *(uint32_t*)((char*)zmm1)[0xc] = pContext->FPts[0].x;
000154ff              (uint32_t)entry_zmm2 = pContext->FPts[1].x;
000154ff              *(uint32_t*)((char*)entry_zmm2)[4] = pContext->FPts[1].x;
0001550a              (uint32_t)zmm0 = (uint32_t)entry_zmm2 - (uint32_t)zmm1;
0001550e              (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
0001551d              (uint32_t)zmm0 =
0001551d                  _mm_cvtepi32_ps((uint128_t)(int32_t)(uint32_t)zmm0) + (uint32_t)zmm1;
00015521              (uint32_t)zmm1 = pContext->FPts[0].y;
00015521              *(uint32_t*)((char*)zmm1)[4] = pContext->FPts[0].y;
00015521              *(uint32_t*)((char*)zmm1)[8] = pContext->FPts[0].y;
00015521              *(uint32_t*)((char*)zmm1)[0xc] = pContext->FPts[0].y;
0001552a              int16_t rcx_1 = (int16_t)(int64_t)(uint32_t)zmm0;
0001552f              (uint32_t)zmm0 = pContext->FPts[1].y;
0001552f              *(uint32_t*)((char*)zmm0)[4] = pContext->FPts[1].y;
0001552f              *(uint32_t*)((char*)zmm0)[8] = pContext->FPts[1].y;
0001552f              *(uint32_t*)((char*)zmm0)[0xc] = pContext->FPts[1].y;
00015538              (uint32_t)zmm0 = (uint32_t)zmm0 - (uint32_t)zmm1;
0001553c              pContext->cX = rcx_1;
00015541              (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
00015550              (uint32_t)zmm0 =
00015550                  _mm_cvtepi32_ps((uint128_t)(int32_t)(uint32_t)zmm0) + (uint32_t)zmm1;
00015559              pContext->cY = (int16_t)(int64_t)(uint32_t)zmm0;
0001555e              rax_12 = (uint32_t)rcx_1;
000154ef          label_154ef:
000154ef              cond:1_1 = _mm_cvtepi32_ps((uint128_t)rax_12) < (uint32_t)entry_zmm2;
000154f2              goto label_155c4;
000153f1          }
000153f1          
000153fa          if (rax_1 == 2)
000153fa          {
00015482              (uint32_t)zmm1 = pContext->FPts[1].x;
00015482              *(uint32_t*)((char*)zmm1)[4] = pContext->FPts[1].x;
0001548a              (uint32_t)zmm0 = pContext->FPts[2].x;
0001548a              *(uint32_t*)((char*)zmm0)[4] = pContext->FPts[2].x;
00015492              (uint32_t)entry_zmm2 = pContext->FPts[2].y;
00015492              *(uint32_t*)((char*)entry_zmm2)[4] = pContext->FPts[2].y;
00015492              *(uint32_t*)((char*)entry_zmm2)[8] = pContext->FPts[2].y;
00015492              *(uint8_t*)((char*)entry_zmm2)[0xc] = pContext->CamOrientation;
00015492              *(uint8_t*)((char*)entry_zmm2)[0xd] = pContext->NumCalPoints;
0001549a              (uint32_t)zmm0 = (uint32_t)zmm0 - (uint32_t)zmm1;
0001549e              (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
000154ad              (uint32_t)zmm0 =
000154ad                  _mm_cvtepi32_ps((uint128_t)(int32_t)(uint32_t)zmm0) + (uint32_t)zmm1;
000154b1              (uint32_t)zmm1 = pContext->FPts[1].y;
000154b1              *(uint32_t*)((char*)zmm1)[4] = pContext->FPts[1].y;
000154b1              *(uint32_t*)((char*)zmm1)[8] = pContext->FPts[1].y;
000154b1              *(uint32_t*)((char*)zmm1)[0xc] = pContext->FPts[1].y;
000154b9              int16_t rax_9 = (int16_t)(int64_t)(uint32_t)zmm0;
000154c1              (uint32_t)zmm0 = (uint32_t)entry_zmm2 - (uint32_t)zmm1;
000154c5              pContext->cX = rax_9;
000154c9              (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
000154d8              (uint32_t)zmm0 =
000154d8                  _mm_cvtepi32_ps((uint128_t)(int32_t)(uint32_t)zmm0) + (uint32_t)zmm1;
000154dc              int16_t rax_11 = (int16_t)(int64_t)(uint32_t)zmm0;
000154e1              pContext->cY = rax_11;
000154e5              rax_12 = (uint32_t)rax_11;
000154e5              goto label_154ef;
000153fa          }
000153fa          
00015403          if (rax_1 == 3)
00015403          {
00015409              (uint32_t)zmm1 = pContext->FPts[2].x;
00015409              *(uint32_t*)((char*)zmm1)[4] = pContext->FPts[2].x;
00015411              (uint32_t)entry_zmm2 = pContext->FPts[3].x;
00015411              *(uint32_t*)((char*)entry_zmm2)[4] = pContext->FPts[3].x;
0001541c              (uint32_t)zmm0 = (uint32_t)entry_zmm2 - (uint32_t)zmm1;
00015420              (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
0001542f              (uint32_t)zmm0 =
0001542f                  _mm_cvtepi32_ps((uint128_t)(int32_t)(uint32_t)zmm0) + (uint32_t)zmm1;
00015433              (uint32_t)zmm1 = pContext->FPts[2].y;
00015433              *(uint32_t*)((char*)zmm1)[4] = pContext->FPts[2].y;
00015433              *(uint32_t*)((char*)zmm1)[8] = pContext->FPts[2].y;
00015433              *(uint8_t*)((char*)zmm1)[0xc] = pContext->CamOrientation;
00015433              *(uint8_t*)((char*)zmm1)[0xd] = pContext->NumCalPoints;
0001543c              uint16_t rcx = (int16_t)(int64_t)(uint32_t)zmm0;
00015441              (uint32_t)zmm0 = pContext->FPts[3].y;
00015441              *(uint8_t*)((char*)zmm0)[4] = pContext->CamOrientation;
00015441              *(uint8_t*)((char*)zmm0)[5] = pContext->NumCalPoints;
00015441              *(uint32_t*)((char*)zmm0)[0xc] = pContext->FPts[3].y;
0001544a              (uint32_t)zmm0 = (uint32_t)zmm0 - (uint32_t)zmm1;
0001544e              pContext->cX = rcx;
00015453              (uint32_t)zmm0 = (uint32_t)zmm0 * zmm3;
00015462              (uint32_t)zmm0 =
00015462                  _mm_cvtepi32_ps((uint128_t)(int32_t)(uint32_t)zmm0) + (uint32_t)zmm1;
0001546b              pContext->cY = (int16_t)(int64_t)(uint32_t)zmm0;
0001547a              cond:1_1 = (uint32_t)entry_zmm2 < _mm_cvtepi32_ps((uint128_t)rcx);
0001547d              goto label_155c4;
00015403          }
000153e8      }
000155e6      uint32_t cX = (uint32_t)pContext->cX;
000155eb      uint32_t cY = (uint32_t)pContext->cY;
000155f0      int32_t var_18 = 5;
000155fc      void (* CalibOutputCB)(void*, struct mouseReport_t*) = pContext->CalibOutputCB;
0001560d      int32_t var_14 = _mm_cvtepi32_ps((uint128_t)cX);
00015613      int32_t var_10 = _mm_cvtepi32_ps((uint128_t)cY);
00015613      
0001561c      if (CalibOutputCB)
0001562a          CalibOutputCB(pContext->CalibOutputParam, &var_18, entry_zmm2, entry_r9);
0001562a      
0001562c      (uint8_t)CalibOutputCB = (uint8_t)rbx;
00015633      return (uint8_t)CalibOutputCB;
000153c0  }

00015634                                                              cc cc cc cc cc cc cc cc                                  ........

0001563c    void __convention("sysv") Calib_CalibrationHandler(struct CalibContext_t* pContext @ rcx, enum MOUSE_INPUT_STATE state @ rdx, struct fpoint_t pt @ r8, uint32_t timestamp @ r9)

0001563c  {
00015646      int64_t arg_18;
00015646      (uint32_t)arg_18 = pt.x;
00015646      *(uint32_t*)((char*)arg_18)[4] = pt.y;
00015664      char i_2 = 4;
00015669      ST_AcquireLock(&pContext->Calibration_lock, 0);
00015674      bool r8;
00015674      
00015674      if (!timestamp)
00015694          r8 = false;
00015674      else
00015674      {
00015683          r8 = timestamp - pContext->lastTimestamp > 0x1f40;
00015683          
0001568a          if (r8)
0001568c              pContext->lastTimestamp = timestamp;
00015674      }
00015674      
00015697      enum cal_state_t calState = pContext->calState;
00015697      
0001569d      if (!calState)
0001569d      {
00015b04          if (SetCalCursor(pContext))
00015b0b              pContext->calState = CSM_WAIT_TOUCHDOWN;
0001569d      }
0001569d      else if (calState == CSM_WAIT_TOUCHDOWN)
000156aa      {
00015ae6          if (state == MOUSE_DOWN)
00015ae6          {
00015ae8              pContext->ignoredSamples = 0;
00015af0              pContext->calState = CSM_IGNORE;
00015ae6          }
000156aa      }
000156aa      else
000156aa      {
000156b2          int32_t var_28;
000156b2          uint64_t y[0x2];
000156b2          float entry_zmm3;
000156b2          
000156b2          if (calState == 2)
000156b2          {
00015a96              if (state != MOUSE_MOVE)
00015a96              {
00015acf                  pContext->ignoredSamples = 0;
00015ad7                  pContext->calState = CSM_MOVE_CURSOR;
00015adb                  pContext->cursorMoveTime = 0;
00015a96              }
00015a96              else
00015a96              {
00015a98                  pContext->calibrationTime = 0;
00015a98                  
00015aa2                  if (r8)
00015aa4                      pContext->ignoredSamples += 1;
00015aa4                  
00015ab9                  if (pContext->ignoredSamples < 0x32)
00015ab9                      goto label_15a3e;
00015ab9                  
00015abb                  pContext->ignoredSamples = 0;
00015ac3                  pContext->calState = CSM_COLLECT_SAMPLES;
00015a34              label_15a34:
00015a34                  pContext->sampleNum = 0;
00015a3e              label_15a3e:
00015a3e                  uint64_t rax_22 = (uint64_t)(pContext->CalibrateMode - 1);
00015a49                  float var_24_2 = pContext->FPts[rax_22].x[0];
00015a4f                  y = pContext->FPts[rax_22].y;
00015a58                  void (* CalibOutputCB_1)(void*, struct mouseReport_t*) =
00015a58                      pContext->CalibOutputCB;
00015a5f                  var_28 = 5;
00015a67                  int32_t var_20_2 = y[0];
00015a67                  
00015a70                  if (CalibOutputCB_1)
00015a82                      CalibOutputCB_1(pContext->CalibOutputParam, &var_28, 0x32, 
00015a82                          entry_zmm3);
00015a96              }
000156b2          }
000156b2          else
000156b2          {
000156ba              float zmm0[0x4];
000156ba              float y_1[0x4];
000156ba              uint128_t zmm4_1;
000156ba              float zmm5_1;
000156ba              
000156ba              if (calState == 3)
000156ba              {
0001593c                  if (state == MOUSE_MOVE)
0001593c                  {
00015942                      pContext->calibrationTime = 0;
00015942                      
0001594c                      if (r8)
0001594c                      {
0001595a                          zmm0 = (uint32_t)arg_18;
00015960                          y = *(uint32_t*)((char*)arg_18)[4];
00015966                          uint64_t sampleNum = (uint64_t)pContext->sampleNum;
0001596d                          zmm0[0] = zmm0[0] * 32767f;
00015971                          y[0] = y[0] * 32767f;
00015975                          zmm4_1 = 0x7f61b1e6;
0001597d                          entry_zmm3 = -3.00000001e+38f;
00015985                          (uint32_t)arg_18 = zmm0[0];
0001598b                          zmm5_1 = 3.00000001e+38f;
0001598e                          y_1 = 0xff61b1e6;
00015991                          *(uint32_t*)((char*)arg_18)[4] = y[0];
0001599c                          pContext->calSamples[sampleNum].x = arg_18;
000159a1                          pContext->sampleNum += 1;
000159af                          uint16_t rax_18 = pContext->sampleNum - 1;
000159b2                          void* rcx_11 = &pContext->calSamples;
000159b2                          
000159b9                          if (rax_18 >= 4)
000159b9                          {
000159bb                              uint32_t rax_19 = (uint32_t)rax_18;
000159bb                              
000159c0                              if (rax_19 - 4 >= 0)
000159c0                              {
000159c2                                  uint64_t r8_2 = (uint64_t)(rax_19 - 3);
000159f6                                  int64_t i;
000159f6                                  
000159f6                                  do
000159f6                                  {
000159c6                                      zmm0[0] = *(uint32_t*)rcx_11;
000159c6                                      zmm0[1] = *(uint16_t*)((char*)rcx_11 + 4);
000159c6                                      *(uint16_t*)((char*)zmm0[1])[2] =
000159c6                                          *(uint16_t*)((char*)rcx_11 + 6);
000159c6                                      zmm0[2] = *(uint16_t*)((char*)rcx_11 + 8);
000159c6                                      *(uint16_t*)((char*)zmm0[2])[2] =
000159c6                                          *(uint16_t*)((char*)rcx_11 + 0xa);
000159c6                                      zmm0[3] = *(uint32_t*)rcx_11;
000159c6                                      
000159cd                                      if (!((uint32_t)zmm4_1 <= zmm0[0]))
000159cf                                          zmm4_1 = zmm0;
000159cf                                      
000159d2                                      y[0] = *(uint16_t*)((char*)rcx_11 + 4);
000159d2                                      *(uint16_t*)((char*)y[0])[2] =
000159d2                                          *(uint16_t*)((char*)rcx_11 + 6);
000159d2                                      
000159da                                      if (!(zmm5_1 <= y[0]))
000159dc                                          zmm5_1 = y[0];
000159dc                                      
000159e2                                      if (!(zmm0[0] <= entry_zmm3))
000159e4                                          entry_zmm3 = zmm0[0];
000159e4                                      
000159ea                                      if (!(y[0] <= y_1[0]))
000159ec                                          y_1 = y;
000159ec                                      
000159ef                                      rcx_11 += 8;
000159f3                                      (uint32_t)i = (uint32_t)r8_2;
000159f3                                      *(uint32_t*)((char*)i)[4] =
000159f3                                          *(uint32_t*)((char*)r8_2)[4];
000159f3                                      r8_2 -= 1;
000159f6                                  } while (i != 1);
000159c0                              }
000159c0                              
00015a00                              entry_zmm3 = entry_zmm3 - (uint32_t)zmm4_1;
00015a00                              
00015a07                              if (!(entry_zmm3 > 70f))
00015a09                                  y_1[0] = y_1[0] - zmm5_1;
00015a09                              
00015a10                              if (entry_zmm3 > 70f || !(y_1[0] <= 70f))
00015a10                              {
00015a12                                  pContext->sampleNum = 0;
00015a1a                                  pContext->calState = CSM_IGNORE;
00015a10                              }
000159b9                          }
0001594c                      }
0001594c                      
00015a2f                      if (pContext->sampleNum < 0x32)
00015a2f                          goto label_15a3e;
00015a2f                      
00015a31                      pContext->calState = CSM_STORE;
00015a31                      goto label_15a34;
0001593c                  }
0001593c                  
00015a89                  pContext->sampleNum = 0;
00015ad7                  pContext->calState = CSM_MOVE_CURSOR;
00015adb                  pContext->cursorMoveTime = 0;
000156ba              }
000156ba              else if (calState == 4)
000156c2              {
00015830                  uint32_t CalibrateMode = pContext->CalibrateMode;
00015832                  pContext->calibrationTime = 0;
00015839                  float* r9_1 = &pContext->calSamples[0].y;
0001583f                  int64_t r8_1;
0001583f                  (uint32_t)r8_1 = 0x32;
0001583f                  *(uint32_t*)((char*)r8_1)[4] = 0;
00015845                  pContext->calPts[(uint64_t)(CalibrateMode - 1)].x = 0;
00015851                  pContext->calPts[(uint64_t)(pContext->CalibrateMode - 1)].y = 0;
00015897                  int64_t i_1;
00015897                  
00015897                  do
00015897                  {
00015859                      uint32_t CalibrateMode_1 = pContext->CalibrateMode;
0001585b                      zmm0[0] = ADJ(r9_1)->calSamples[0].x;
0001585b                      zmm0[1] = ADJ(r9_1)->calSamples[0].x;
0001585b                      zmm0[2] = ADJ(r9_1)->calSamples[0].x;
0001585b                      zmm0[3] = ADJ(r9_1)->calSamples[0].x;
00015861                      uint64_t rax_6 = (uint64_t)(CalibrateMode_1 - 1);
00015863                      zmm0[0] = zmm0[0] + pContext->calPts[rax_6].x;
0001586c                      pContext->calPts[rax_6].x = zmm0[0];
00015877                      uint64_t rax_8 = (uint64_t)(pContext->CalibrateMode - 1);
00015879                      zmm0 = pContext->calPts[rax_8].y;
00015882                      zmm0[0] = zmm0[0] + ADJ(r9_1)->calSamples[0].y;
00015887                      r9_1 = &r9_1[2];
0001588b                      (uint32_t)i_1 = (uint32_t)r8_1;
0001588b                      *(uint32_t*)((char*)i_1)[4] = *(uint32_t*)((char*)r8_1)[4];
0001588b                      r8_1 -= 1;
0001588e                      pContext->calPts[rax_8].y = zmm0[0];
00015897                  } while (i_1 != 1);
000158a3                  uint64_t rax_10 = (uint64_t)(pContext->CalibrateMode - 1);
000158a5                  zmm0 = pContext->calPts[rax_10].x;
000158ae                  zmm0[0] = zmm0[0] / 50f;
000158b2                  pContext->calPts[rax_10].x = zmm0[0];
000158bd                  uint64_t rax_12 = (uint64_t)(pContext->CalibrateMode - 1);
000158bf                  zmm0 = pContext->calPts[rax_12].y;
000158c8                  zmm0[0] = zmm0[0] / 50f;
000158cc                  pContext->calPts[rax_12].y = zmm0[0];
000158d5                  pContext->CalibrateMode += 1;
000158d7                  bool cond:1_1 = pContext->NumCalPoints != 2;
000158de                  uint32_t CalibrateMode_2 = pContext->CalibrateMode;
000158e0                  pContext->sampleNum = 0;
000158e0                  
000158e8                  if (!cond:1_1)
000158ec                      pContext->CalibrateMode = CalibrateMode_2 + 1;
000158ec                  
000158ee                  uint32_t CalibrateMode_3 = pContext->CalibrateMode;
000158ee                  
000158f2                  if (CalibrateMode_3 <= 4)
000158f2                  {
00015900                      pContext->calState = CSM_MOVE_CURSOR;
00015904                      pContext->cursorMoveTime = 0;
00015904                      
0001590e                      if (CalibrateMode_3 > 0)
0001590e                      {
00015914                          uint64_t rax_14 = (uint64_t)(CalibrateMode_3 - 1);
00015922                          pContext->currentTarget.X =
00015922                              (int16_t)(int64_t)(long double)pContext->FPts[rax_14].x;
00015930                          pContext->currentTarget.Y = (int16_t)(int64_t)(long double)
00015930                              pContext->FPts[(uint64_t)(uint32_t)rax_14].y;
0001590e                      }
000158f2                  }
000158f2                  else
000158f4                      pContext->calState = CSM_FINISH;
000156c2              }
000156c2              else if (calState == 5)
000156ca              {
0001570c                  zmm0[0] = pContext->calPts[2].y;
0001570c                  zmm0[1] = pContext->calPts[2].y;
0001570c                  zmm0[2] = pContext->calPts[2].y;
0001570c                  zmm0[3] = pContext->ignoredSamples;
0001570c                  *(uint16_t*)((char*)zmm0[3])[2] = pContext->sampleNum;
00015714                  y_1[0] = pContext->calPts[2].x;
00015714                  y_1[1] = pContext->calPts[2].x;
00015714                  y_1[2] = pContext->calPts[2].x;
00015714                  y_1[3] = pContext->calPts[2].x;
0001571c                  uint32_t* rcx_7 = &pContext->calibrationTime;
00015723                  zmm0[0] = zmm0[0] - pContext->calPts[3].y;
0001572b                  y_1[0] = y_1[0] - pContext->calPts[3].x;
00015733                  ADJ(rcx_7)->calibrationTime = 0;
00015736                  zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
00015739                  y_1 = _mm_unpacklo_ps(y_1, *(uint64_t*)&y_1[0]);
0001573c                  zmm4_1 = 0x7fffffffffffffff;
00015744                  y = _mm_cvtps_pd(*(uint64_t*)&zmm0[0]);
00015747                  zmm0[0] = pContext->calPts[0].y;
00015747                  zmm0[1] = pContext->calPts[0].y;
00015747                  zmm0[2] = pContext->calPts[0].y;
00015747                  zmm0[3] = pContext->calPts[0].y;
0001574f                  y = _mm_and_pd(y, zmm4_1);
00015753                  zmm0[0] = zmm0[0] - pContext->calPts[1].y;
0001575b                  zmm5_1 = (float)y[0];
0001575f                  zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
00015765                  y = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm0[0]), zmm4_1);
00015769                  zmm0[0] = (float)y[0];
0001576d                  y[0] = pContext->calPts[0].x;
0001576d                  *(uint32_t*)((char*)y[0])[4] = pContext->calPts[0].x;
0001576d                  y[1] = pContext->calPts[0].x;
0001576d                  *(uint32_t*)((char*)y[1])[4] = pContext->calPts[0].x;
00015775                  y[0] = y[0] - pContext->calPts[1].x;
0001577d                  zmm5_1 = zmm5_1 + zmm0[0];
00015784                  zmm0 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&y_1[0]), zmm4_1);
00015788                  y = _mm_unpacklo_ps(y, y[0]);
0001578b                  entry_zmm3 = (float)*(uint64_t*)&zmm0[0];
00015792                  zmm0 = _mm_and_pd(_mm_cvtps_pd(y[0]), zmm4_1);
00015796                  zmm0[0] = (float)*(uint64_t*)&zmm0[0];
00015796                  
000157a1                  if (zmm5_1 <= entry_zmm3 + zmm0[0])
000157ab                      pContext->CamOrientation = 0;
000157a1                  else
000157a3                      pContext->CamOrientation = 1;
000157a3                  
000157b9                  if (pContext->CamOrientation)
000157b9                  {
000157d3                      do
000157d3                      {
000157bb                          zmm0[0] = ADJ(rcx_7)->calPts[3].x;
000157bb                          zmm0[1] = ADJ(rcx_7)->calPts[3].x;
000157bb                          zmm0[2] = ADJ(rcx_7)->ignoredSamples;
000157bb                          *(uint16_t*)((char*)zmm0[2])[2] = ADJ(rcx_7)->sampleNum;
000157bb                          zmm0[3] = ADJ(rcx_7)->calPts[3].x;
000157c0                          rcx_7 -= 8;
000157c4                          i_2 -= 1;
000157c7                          uint32_t calibrationTime = ADJ(rcx_7)->calibrationTime;
000157c9                          ADJ(rcx_7)->calibrationTime = zmm0[0];
000157cd                          ADJ(rcx_7)->ignoredSamples = (uint16_t)calibrationTime;
000157cd                          ADJ(rcx_7)->sampleNum = *(uint16_t*)((char*)calibrationTime)[2];
000157d3                      } while (i_2);
000157b9                  }
000157b9                  
000157e9                  memmove(&pContext->Pts, &pContext->calPts, 0x20);
000157ee                  void (* CalibOutputCB)(void*, struct mouseReport_t*) =
000157ee                      pContext->CalibOutputCB;
000157f5                  var_28 = 5;
00015805                  int32_t var_24_1 = 0x467ffc00;
0001580b                  int32_t var_20_1 = 0x467ffc00;
0001580b                  
00015814                  if (CalibOutputCB)
00015822                      CalibOutputCB(pContext->CalibOutputParam, &var_28);
00015822                  
00015824                  pContext->calState = CSM_EXIT;
000156ca              }
000156ca              else if (calState == 6 && state != MOUSE_MOVE)
000156d7              {
000156dd                  void (* CalibFinishedCB)(void*, uint8_t, uint8_t, struct fpoint_t*) =
000156dd                      pContext->CalibFinishedCB;
000156e4                  pContext->CalibrateMode = 0;
000156e4                  
000156ea                  if (CalibFinishedCB)
00015705                      CalibFinishedCB(pContext->CalibFinishedParam, 1, 
00015705                          pContext->CamOrientation, &pContext->Pts);
000156d7              }
000156b2          }
000156aa      }
000156aa      
00015b17      KeReleaseMutex(&pContext->Calibration_lock.mutex, 0);
0001563c  }

00015b30                                                  cc cc cc cc cc cc cc cc                                          ........

00015b38    void Calib_TimeoutTimer(void* param)

00015b38  {
00015b3f      if (!*(uint32_t*)param)
00015b3f          return;
00015b3f      
00015b47      *(uint32_t*)((char*)param + 0x1e4) += *(uint32_t*)((char*)param + 0x1f4);
00015b47      
00015b57      if (*(uint32_t*)((char*)param + 0x1e4) >= 0x4e20)
00015b59          Calib_CancelCalibration(param);
00015b38  }

00015b63           cc cc cc cc cc cc cc cc cc                                                                 .........

00015b6c    void Calib_MoveTimer(void* param)

00015b6c  {
00015b79      if (!*(uint32_t*)param || *(uint32_t*)((char*)param + 0xc))
00015b79          return;
00015b79      
00015b87      *(uint32_t*)((char*)param + 0x1e8) += *(uint32_t*)((char*)param + 0x214);
00015b8d      int32_t arg_8 = 0;
00015b93      int32_t arg_c = 0;
00015b99      struct fpoint_t pt;
00015b99      pt.x = arg_8;
00015b99      pt.y = arg_8;
00015ba0      Calib_CalibrationHandler(param, MOUSE_NONE, pt, 0);
00015b6c  }

00015baa                                cc cc cc cc cc cc                                                            ......

00015bb0    void _me_RightClickTimerExpire(void* param)

00015bb0  {
00015bc2      ST_AcquireLock((char*)param + 0xe80, 0);
00015bd1      _me_SignalInternal(param, ME_RIGHT_CLICK_TMR_SIG, nullptr);
00015be4      /* tailcall */
00015be4      return KeReleaseMutex((char*)param + 0xe88, 0);
00015bb0  }

00015beb                                   cc cc cc cc cc cc cc cc cc                                                 .........

00015bf4    void _me_DoubleClickTimerExpire(void* param)

00015bf4  {
00015c06      ST_AcquireLock((char*)param + 0xe80, 0);
00015c15      _me_SignalInternal(param, ME_DOUBLE_CLICK_TMR_SIG, nullptr);
00015c28      /* tailcall */
00015c28      return KeReleaseMutex((char*)param + 0xe88, 0);
00015bf4  }

00015c2f                                               cc cc cc cc cc cc cc cc cc                                         .........

00015c38    void _me_PushBuffer(struct meRB_t* pmeRB, struct mouseReport_t* in)

00015c38  {
00015c4f      if (pmeRB->samples >= 0x12c)
00015c4f      {
00015c65          onWarning__("Mouse Engine Buffer Overrun", 
00015c65              "c:\development_work\csf_release_hp\driver\csf\mouseengine.c", 0x109);
00015c6a          struct mouseReport_t* tail = pmeRB->tail;
00015c78          struct mouseReport_t* rax_2 = &pmeRB->buf;
00015c78          
00015c7c          if (tail != &pmeRB->buf[0x12b])
00015c7e              rax_2 = &tail[1];
00015c7e          
00015c82          pmeRB->samples -= 1;
00015c85          pmeRB->tail = rax_2;
00015c4f      }
00015c4f      
00015c8b      enum MOUSE_INPUT_STATE* head = pmeRB->head;
00015c8e      *(uint32_t*)head = in->state;
00015c93      head[1] = in->pt.x;
00015c99      head[2] = in->pt.y;
00015c9c      struct mouseReport_t* head_1 = pmeRB->head;
00015c9f      pmeRB->samples += 1;
00015cac      struct mouseReport_t (* rax_7)[0x12c] = &pmeRB->buf;
00015cac      
00015cb0      if (head_1 != &pmeRB->buf[0x12b])
00015cb2          rax_7 = &head_1[1];
00015cb2      
00015cb6      pmeRB->head = rax_7;
00015c38  }

00015cc4              cc cc cc cc cc cc cc cc                                                                  ........

00015ccc    void _me_PlayBuffer(struct meContext_t* pContext)

00015ccc  {
00015cde      while (true)
00015cde      {
00015cde          int32_t samples = pContext->meRB.samples;
00015ce1          struct mouseReport_t* tail = pContext->meRB.tail;
00015ce1          
00015ce7          if (samples)
00015ce7          {
00015cf3              struct mouseReport_t* rax_2 = &pContext->meRB.buf;
00015cf3              
00015cf7              if (tail != &pContext->meRB.buf[0x12b])
00015cf9                  rax_2 = &tail[1];
00015cf9              
00015cfd              pContext->meRB.tail = rax_2;
00015d04              pContext->meRB.samples = samples - 1;
00015ce7          }
00015ce7          
00015d0a          if (!samples || !tail)
00015d53              return;
00015d53          
00015d11          int64_t PerformanceFrequency;
00015d11          int64_t rax_4 = KeQueryPerformanceCounter(&PerformanceFrequency);
00015d28          int64_t rax_5;
00015d28          
00015d28          do
00015d1f              rax_5 = KeQueryPerformanceCounter(&PerformanceFrequency);
00015d28           while (rax_5 == rax_4);
00015d2a          void (* OutputCB)(void*, struct mouseReport_t*) = pContext->OutputCB;
00015d2a          
00015d34          if (OutputCB)
00015d40              OutputCB(pContext->OutputParam, tail);
00015cde      }
00015ccc  }

00015d54                                                              cc cc cc cc cc cc cc cc                                  ........

00015d5c    void _me_Transition(struct meContext_t* pContext, enum MOUSE_ENGINE_STATES newState, void* param)

00015d5c  {
00015d78      _me_SignalInternal(pContext, ME_EXIT, param);
00015d85      pContext->currentState = newState;
00015d9a      /* tailcall */
00015d9a      return _me_SignalInternal(pContext, ME_ENTRY, param);
00015d5c  }

00015d9f                                                                                               cc                                 .
00015da0  cc cc cc cc cc cc cc cc                                                                          ........

00015da8    void _me_SignalInternal(struct meContext_t* pContext, enum MOUSE_ENGINE_SIGNALS meSignal, void* param)

00015da8  {
00015db2      enum MOUSE_ENGINE_STATES currentState = pContext->currentState;
00015dbf      pContext->lastSignal = meSignal;
00015dbf      
00015dc8      if (!currentState)
00015dc8      {
00015e1c          if (meSignal == ME_TOUCH_SIG && param)
00015e1c          {
00015e21              if (*(uint32_t*)param != meSignal)
00015e21              {
00015e2a                  void (* OutputCB)(void*, struct mouseReport_t*) = pContext->OutputCB;
00015e2a                  
00015e34                  if (OutputCB)
00015e40                      OutputCB(pContext->OutputParam, param);
00015e21              }
00015e21              else
00015e23                  _me_Transition(pContext, meSignal, param);
00015e1c          }
00015dc8      }
00015dc8      else if (currentState == ME_TOUCH_STATE)
00015e0d          _me_Touch(pContext, meSignal, param);
00015dce      else if (currentState == 2)
00015e06          _me_Release(pContext, meSignal, param);
00015dd4      else if (currentState == 3)
00015dff          _me_RightClick(pContext, meSignal, param);
00015dda      else
00015dda      {
00015df0          onError__("ARRRRG WE ARE IN LIMBO!", 
00015df0              "c:\development_work\csf_release_hp\driver\csf\mouseengine.c", 0x1eb);
00015e23          _me_Transition(pContext, ME_ENTRY, param);
00015dda      }
00015da8  }

00015e4d                                         cc cc cc cc cc cc cc                                                   .......

00015e54    void _me_Touch(struct meContext_t* pContext, enum MOUSE_ENGINE_SIGNALS meSignal, void* param)

00015e54  {
00015e6b      if (!meSignal)
00015e6b      {
00015fd1          uint32_t DragThreshold_1 = (uint32_t)pContext->Settings.DragThreshold;
00015fda          void (* OutputCB_2)(void*, struct mouseReport_t*);
00015fda          struct mouseReport_t* rdx_7;
00015fda          
00015fda          if (!DragThreshold_1)
00015fda          {
00016088              _me_PlayBuffer(pContext);
0001608d              void (* OutputCB_3)(void*, struct mouseReport_t*) = pContext->OutputCB;
00016094              pContext->initTouchDown.state = 1;
00016094              
000160a1              if (OutputCB_3)
000160b1                  OutputCB_3(pContext->OutputParam, &pContext->initTouchDown);
000160b1              
000160b3              OutputCB_2 = pContext->OutputCB;
000160ba              pContext->initTouchDown.state = 3;
000160ba              
000160c7              if (!OutputCB_2)
000160e1                  _me_Transition(pContext, ME_IDLE_STATE, param);
000160c7              else
000160c7              {
000160c9                  rdx_7 = &pContext->initTouchDown;
000160d7              label_160d7:
000160d7                  OutputCB_2(pContext->OutputParam, rdx_7);
000160e1                  _me_Transition(pContext, ME_IDLE_STATE, param);
000160c7              }
00015fda          }
00015fda          else if (DragThreshold_1 == 1)
00015fe3          {
00016065              _me_PlayBuffer(pContext);
0001606a              OutputCB_2 = pContext->OutputCB;
00016071              rdx_7 = &pContext->initTouchDown;
00016078              rdx_7->state = 1;
00016078              
00016081              if (OutputCB_2)
00016081                  goto label_160d7;
00016081              
000160e1              _me_Transition(pContext, ME_IDLE_STATE, param);
00015fe3          }
00015fe3          else
00015fe3          {
00015feb              pContext->RightClick_tmr.elapsedTime = 0;
00015ff2              pContext->RightClick_tmr.enabled = 1;
00015ff9              pContext->RightClick_tmr.expiredTime = pContext->Settings.RightClickDelay;
00016006              pContext->RightClick_tmr.periodic = 0;
0001600d              pContext->RightClick_tmr.param = pContext;
00016014              pContext->RightClick_tmr.f = _me_RightClickTimerExpire;
00016014              
0001601e              if (param)
0001601e              {
0001602e                  pContext->initTouchDown.state = *(uint32_t*)param;
00016034                  pContext->initTouchDown.pt.x = *(uint32_t*)((char*)param + 4);
0001603b                  pContext->initTouchDown.pt.y = *(uint32_t*)((char*)param + 8);
0001603e                  void (* OutputCB_1)(void*, struct mouseReport_t*) = pContext->OutputCB;
00016045                  pContext->initTouchDown.state = 5;
00016045                  
0001604e                  if (OutputCB_1)
0001605b                      OutputCB_1(pContext->OutputParam);
0001601e              }
00015fe3          }
00015e6b      }
00015e6b      else if (meSignal == ME_TOUCH_SIG)
00015e74      {
00015ebc          if (param)
00015ebc          {
00015ec2              int32_t rcx = *(uint32_t*)param;
00015ec2              
00015ec8              if (rcx == 1)
000160e1                  _me_Transition(pContext, ME_TOUCH_STATE, param);
00015ec8              else if (rcx == 2)
00015ed1              {
00015ef6                  uint128_t zmm2 = 0x7fffffffffffffff;
00015f03                  int32_t var_28_1 = *(uint32_t*)param;
00015f0c                  int32_t rax_5 = *(uint32_t*)((char*)param + 8);
00015f1e                  float zmm0[0x4] = *(uint32_t*)((char*)param + 4);
00015f24                  enum MOUSE_INPUT_STATE state = pContext->initTouchDown.state;
00015f2f                  float y = pContext->initTouchDown.pt.y;
00015f38                  uint16_t DragThreshold = pContext->Settings.DragThreshold;
00015f3f                  zmm0[0] = zmm0[0] - pContext->initTouchDown.pt.x;
00015f4f                  int16_t rax_8 = (int16_t)(int64_t)_mm_and_pd(
00015f4f                      _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]), zmm2)[0];
00015f57                  int16_t rax_9;
00015f57                  
00015f57                  if (rax_8 <= DragThreshold)
00015f57                  {
00015f59                      zmm0 = rax_5;
00015f5f                      zmm0[0] = zmm0[0] - y;
00015f6f                      rax_9 = (int16_t)(int64_t)_mm_and_pd(
00015f6f                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]), 
00015f6f                          zmm2)[0];
00015f57                  }
00015f57                  
00015f77                  if (rax_8 > DragThreshold || rax_9 > DragThreshold)
00015f77                  {
00015f8f                      _me_PushBuffer(pContext, param);
00015f94                      void (* OutputCB)(void*, struct mouseReport_t*) = pContext->OutputCB;
00015f9b                      pContext->initTouchDown.state = 1;
00015f9b                      
00015fa8                      if (OutputCB)
00015fb8                          OutputCB(pContext->OutputParam, &pContext->initTouchDown);
00015fb8                      
00015fbd                      _me_PlayBuffer(pContext);
000160e1                      _me_Transition(pContext, ME_IDLE_STATE, param);
00015f77                  }
00015f77                  else
00015f7f                      _me_PushBuffer(pContext, param);
00015ed1              }
00015ed1              else if (rcx == 3)
00015ed6              {
00015edc                  pContext->meRB.samples = 0;
00015ee7                  pContext->meRB.head = &pContext->meRB.buf;
00015eea                  pContext->meRB.tail = &pContext->meRB.buf;
000160e1                  _me_Transition(pContext, rcx - 1, param);
00015ed6              }
00015ebc          }
00015e74      }
00015e74      else if (meSignal == 2)
00015e79      {
00015ea0          pContext->meRB.samples = 0;
00015ead          pContext->meRB.head = &pContext->meRB.buf;
00015eb0          pContext->meRB.tail = &pContext->meRB.buf;
000160e1          _me_Transition(pContext, ME_RIGHT_CLICK_STATE, param);
00015e79      }
00015e79      else if (meSignal == 4)
00015e7e      {
00015e84          pContext->RightClick_tmr.f = nullptr;
00015e8c          pContext->RightClick_tmr.param = nullptr;
00015e94          pContext->RightClick_tmr.enabled = 0;
00015e7e      }
00015e54  }

000160f6                                                                    cc cc cc cc cc cc                                    ......

000160fc    void _me_Release(struct meContext_t* pContext, enum MOUSE_ENGINE_SIGNALS meSignal, void* param)

000160fc  {
0001610e      if (!meSignal)
0001610e      {
00016213          pContext->initTouchDown.state = 1;
0001621d          _me_PushBuffer(pContext, &pContext->initTouchDown);
0001622c          pContext->initTouchDown.state = 3;
00016236          _me_PushBuffer(pContext, &pContext->initTouchDown);
0001623e          _me_PlayBuffer(pContext);
0001624a          pContext->DoubleClick_tmr.elapsedTime = 0;
00016258          pContext->DoubleClick_tmr.expiredTime = pContext->Settings.DoubleClickTime;
0001625f          pContext->DoubleClick_tmr.enabled = 1;
00016266          pContext->DoubleClick_tmr.periodic = 0;
0001626d          pContext->DoubleClick_tmr.param = pContext;
00016274          pContext->DoubleClick_tmr.f = _me_DoubleClickTimerExpire;
0001610e      }
0001610e      else if (meSignal == ME_TOUCH_SIG)
00016117      {
00016157          if (param && *(uint32_t*)param == 1)
00016157          {
00016160              uint128_t zmm2 = 0x7fffffffffffffff;
0001616d              int32_t var_28_1 = *(uint32_t*)param;
0001617d              int32_t rax_3 = *(uint32_t*)((char*)param + 8);
0001618b              float zmm0[0x4] = *(uint32_t*)((char*)param + 4);
00016191              enum MOUSE_INPUT_STATE state = pContext->initTouchDown.state;
0001619f              uint16_t DragThreshold = pContext->Settings.DragThreshold;
000161a6              zmm0[0] = zmm0[0] - pContext->initTouchDown.pt.x;
000161b6              int16_t rax_7 = (int16_t)(int64_t)_mm_and_pd(
000161b6                  _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]), zmm2)[0];
000161be              int16_t rax_8;
000161be              
000161be              if (rax_7 <= DragThreshold)
000161be              {
000161c0                  zmm0 = rax_3;
000161c6                  zmm0[0] = zmm0[0] - pContext->initTouchDown.pt.y;
000161d6                  rax_8 = (int16_t)(int64_t)_mm_and_pd(
000161d6                      _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]), zmm2)[0];
000161be              }
000161be              
000161de              enum MOUSE_ENGINE_STATES newState;
000161de              
000161de              if (rax_7 > DragThreshold || rax_8 > DragThreshold)
00016205                  newState = ME_TOUCH_STATE;
000161de              else
000161de              {
000161e3                  pContext->initTouchDown.state = 1;
000161e9                  _me_PushBuffer(pContext, &pContext->initTouchDown);
000161f1                  _me_PlayBuffer(pContext);
000161f9                  newState = ME_IDLE_STATE;
000161de              }
000161de              
000161fe              _me_Transition(pContext, newState, param);
00016157          }
00016117      }
00016117      else if (meSignal == 3)
000161fe          _me_Transition(pContext, ME_IDLE_STATE, param);
0001611c      else if (meSignal == 4)
00016121      {
00016127          pContext->DoubleClick_tmr.f = nullptr;
0001612f          pContext->DoubleClick_tmr.param = nullptr;
00016137          pContext->DoubleClick_tmr.enabled = 0;
00016121      }
000160fc  }

00016286                    cc cc cc cc cc cc                                                                    ......

0001628c    void _me_RightClick(struct meContext_t* pContext, enum MOUSE_ENGINE_SIGNALS meSignal, void* param)

0001628c  {
0001629e      void (* OutputCB_2)(void*, struct mouseReport_t*);
0001629e      
0001629e      if (!meSignal)
0001629e      {
00016337          void (* OutputCB_3)(void*, struct mouseReport_t*) = pContext->OutputCB;
0001633e          pContext->initTouchDown.state = 4;
0001633e          
0001634b          if (OutputCB_3)
0001635b              OutputCB_3(pContext->OutputParam, &pContext->initTouchDown);
0001635b          
0001635d          OutputCB_2 = pContext->OutputCB;
00016364          pContext->initTouchDown.state = 3;
00016364          
00016371          if (OutputCB_2)
00016381              OutputCB_2(pContext->OutputParam, &pContext->initTouchDown);
0001629e      }
0001629e      else if (meSignal == ME_TOUCH_SIG && param)
000162b6      {
000162bc          int32_t rcx = *(uint32_t*)param;
000162bc          
000162c2          if (rcx == 1)
00016330              _me_Transition(pContext, ME_TOUCH_STATE, param);
000162c2          else if (rcx == 2)
000162c7          {
00016312              *(uint32_t*)param = 5;
00016319              OutputCB_2 = pContext->OutputCB;
00016319              
00016323              if (OutputCB_2)
00016381                  OutputCB_2(pContext->OutputParam, param);
000162c7          }
000162c7          else if (rcx == 3)
000162cc          {
000162d2              *(uint32_t*)param = 1;
000162d5              void (* OutputCB)(void*, struct mouseReport_t*) = pContext->OutputCB;
000162d5              
000162df              if (OutputCB)
000162eb                  OutputCB(pContext->OutputParam, param);
000162eb              
000162ed              *(uint32_t*)param = 3;
000162f3              void (* OutputCB_1)(void*, struct mouseReport_t*) = pContext->OutputCB;
000162f3              
000162fd              if (OutputCB_1)
00016309                  OutputCB_1(pContext->OutputParam, param);
00016309              
00016330              _me_Transition(pContext, ME_IDLE_STATE, param);
000162cc          }
000162b6      }
0001628c  }

0001638e                                            cc cc cc cc cc cc                                                    ......

00016394    uint8_t __convention("sysv") SendDigitizer(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext @ rcx, uint16_t X @ rdx, uint16_t Y @ r8, uint8_t touchState @ r9)

00016394  {
000163a4      uint16_t X_1 = X;
000163a9      uint32_t touchState_1 = (uint32_t)touchState;
000163b2      uint16_t Y_1 = Y;
000163c8      char entry_r10;
000163c8      char arg_8 = ((entry_r10 - entry_r10) & 0xa) + 4;
000163cd      char arg_9;
000163cd      char rax_1;
000163cd      
000163cd      if (touchState_1 == 1)
000163cd      {
00016438          uint8_t (* SendInputReportCallback_2)(struct _NW_TRANSLIB_USERMODE_CONTEXT*, 
00016438              uint8_t*, int32_t) = SendInputReportCallback;
0001643f          arg_9 = 1;
00016447          int512_t entry_zmm0;
00016447          
00016447          if (!SendInputReportCallback_2)
00016447          {
0001646c              onBug__(
0001646c                  "TransLibInputDist.c: TLSendInput SendInputReportCallback not assigned!", 
0001646c                  "c:\development_work\csf_release_hp\driver\wincommon\translibinputdist.c", 
0001646c                  0x22);
00016471              rax_1 = 0;
00016447          }
00016447          else
00016454              rax_1 = SendInputReportCallback_2(entry_zmm0, &arg_8, 0x41);
00016454          
00016475          if (!rax_1)
00016477              return 0;
00016477          
0001647b          arg_9 |= 2;
000163cd      }
000163cd      else if (touchState_1 == 2)
00016431          arg_9 = 3;
000163d2      else if (touchState_1 == 3)
000163d7      {
000163ec          uint8_t (* SendInputReportCallback_1)(struct _NW_TRANSLIB_USERMODE_CONTEXT*, 
000163ec              uint8_t*, int32_t) = SendInputReportCallback;
000163f3          arg_9 = 1;
000163f3          
000163fb          if (!SendInputReportCallback_1)
000163fb          {
00016420              onBug__(
00016420                  "TransLibInputDist.c: TLSendInput SendInputReportCallback not assigned!", 
00016420                  "c:\development_work\csf_release_hp\driver\wincommon\translibinputdist.c", 
00016420                  0x22);
00016425              rax_1 = 0;
000163fb          }
000163fb          else
00016408              rax_1 = SendInputReportCallback_1(PTransLibUserModeContext, &arg_8, 6);
00016408          
00016429          if (!rax_1)
00016477              return 0;
00016477          
0001642b          arg_9 = 0;
000163d7      }
000163d7      else if (touchState_1 == 5)
000163e2          arg_9 = 1;
00016480      uint8_t (* SendInputReportCallback_3)(struct _NW_TRANSLIB_USERMODE_CONTEXT*, 
00016480          uint8_t*, int32_t) = SendInputReportCallback;
00016480      
0001648a      if (SendInputReportCallback_3)
0001649c          return SendInputReportCallback_3(PTransLibUserModeContext, &arg_8, 6);
0001649c      
000164b4      onBug__("TransLibInputDist.c: TLSendInput SendInputReportCallback not assigned!", 
000164b4          "c:\development_work\csf_release_hp\driver\wincommon\translibinputdist.c", 0x22);
000164b9      return 0;
00016394  }

000164c6                    cc cc cc cc cc cc                                                                    ......

000164cc    int32_t SetMultiTouchProps(int32_t round, struct csf_touch_t* csfTouch, struct TOUCH* touch)

000164cc  {
000164cc      enum touch_state_t touchState = csfTouch->touchState;
000164d3      int32_t result;
000164d3      
000164d3      if (touchState == TS_TOUCH_DOWN)
000164d3      {
000164eb          result = 2;
000164eb          
000164f3          if (round != 1)
000164f3          {
000164fd              if (round == 2)
000164ff                  touch->Status = 7;
000164ff              
00016503              result = 0;
000164f3          }
000164f3          else
000164f5              touch->Status = 6;
000164d3      }
000164d3      else
000164d3      {
000164d5          result = 0;
000164d5          
000164db          if (touchState == 2)
000164e5              touch->Status = 7;
000164db          else if (touchState == 3)
000164f5              touch->Status = 6;
000164d3      }
000164d3      
00016505      (uint8_t)round = csfTouch->id;
00016508      touch->ContactID = (uint8_t)round;
00016512      touch->XValue = (int16_t)(int64_t)(long double)csfTouch->pt.x;
0001651d      touch->YValue = (int16_t)(int64_t)(long double)csfTouch->pt.y;
00016528      touch->Width = (int16_t)(int64_t)(long double)csfTouch->width;
00016533      touch->Height = (int16_t)(int64_t)(long double)csfTouch->height;
00016538      return result;
000164cc  }

00016539                                                                             cc cc cc cc cc cc cc                           .......

00016540    uint8_t SendWin7MultiTouch(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, struct csf_touch_report_t* touchReport)

00016540  {
00016558      int32_t arg_18 = 0;
0001655c      int32_t arg_1c = 0;
00016560      char var_38 = 1;
00016564      int32_t rax;
00016564      (uint8_t)rax = 0;
00016566      int32_t rdi = 0;
00016568      struct csf_touch_report_t* touchReport_1 = touchReport;
0001656e      int32_t* r11 = &arg_18;
00016573      struct csf_touch_report_t* touchReport_2 = touchReport;
00016576      int64_t i_2 = 2;
00016579      char var_23 = 0;
000165b8      void var_58;
000165b8      int64_t i;
000165b8      
000165b8      do
000165b8      {
00016581          if (touchReport_2->touch[0].touchState)
00016581          {
00016583              (uint8_t)rax += 1;
00016585              char var_23_1 = (uint8_t)rax;
00016589              int64_t rax_1 = (int64_t)rdi;
0001659f              rdi += 1;
000165a1              *(uint32_t*)r11 =
000165a1                  SetMultiTouchProps(1, touchReport, &var_58 + rax_1 * 0xa + 0x21);
000165a4              (uint8_t)rax = var_23_1;
00016581          }
00016581          
000165a8          touchReport = &touchReport->touch[1];
000165ac          touchReport_2 = &touchReport_2->touch[1];
000165b0          r11 = &r11[1];
000165b4          i = i_2;
000165b4          i_2 -= 1;
000165b8      } while (i != 1);
000165ba      uint8_t (* SendInputReportCallback_1)(struct _NW_TRANSLIB_USERMODE_CONTEXT*, 
000165ba          uint8_t*, int32_t) = SendInputReportCallback;
000165c4      int64_t i_1;
000165c4      
000165c4      if (!SendInputReportCallback_1)
000165c4      {
000165ea          onBug__("TransLibInputDist.c: TLSendInput SendInputReportCallback not assigned!", 
000165ea              "c:\development_work\csf_release_hp\driver\wincommon\translibinputdist.c", 
000165ea              0x22);
000165ef          (uint8_t)i_1 = 0;
000165c4      }
000165c4      else
000165d2          i_1 = SendInputReportCallback_1(PTransLibUserModeContext, &var_38, 
000165d2              (uint64_t)(uint32_t)(i_2 + 0x16));
000165d2      
000165f3      if (!(uint8_t)i_1)
000165f3      {
00016694      label_16694:
00016694          (uint8_t)i_1 = 0;
000165f3      }
000165f3      else
000165f3      {
00016609          for (i_1 = 0; i_1 < 2; i_1 += 1)
00016609          {
00016600              if ((&arg_18)[i_1] > 0)
00016600              {
00016610                  int32_t r12_1 = 0;
00016613                  int32_t* rsi_1 = &arg_18;
00016618                  struct csf_touch_report_t* touchReport_3 = touchReport_1;
00016618                  
0001668e                  for (int32_t j = 0; j < 2; )
0001668e                  {
00016620                      if (touchReport_3->touch[0].touchState)
00016620                      {
0001663c                          SetMultiTouchProps(*(uint32_t*)rsi_1, 
0001663c                              &touchReport_1->touch[(int64_t)j], 
0001663c                              &var_58 + (int64_t)r12_1 * 0xa + 0x21);
00016641                          r12_1 += 1;
00016620                      }
00016620                      
00016644                      uint8_t (* SendInputReportCallback_2)(
00016644                          struct _NW_TRANSLIB_USERMODE_CONTEXT*, uint8_t*, int32_t) =
00016644                          SendInputReportCallback;
00016644                      
0001664e                      if (!SendInputReportCallback_2)
0001664e                      {
00016676                          onBug__(
00016676                              "TransLibInputDist.c: TLSendInput SendInputReportCallback not "
00016676                          "assigned!", 
00016676                              "c:\development_work\csf_release_hp\driver\wincommon\t"
00016676                          "ranslibinputdist.c", 0x22);
0001667b                          (uint8_t)i_1 = 0;
0001664e                      }
0001664e                      else
0001665e                          i_1 = SendInputReportCallback_2(PTransLibUserModeContext, 
0001665e                              &var_38, 0x16);
0001665e                      
0001667f                      if (!(uint8_t)i_1)
0001667f                          goto label_16694;
0001667f                      
00016681                      j += 1;
00016683                      touchReport_3 = &touchReport_3->touch[1];
00016687                      rsi_1 = &rsi_1[1];
0001668e                  }
0001668e                  
0001664e                  break;
00016600              }
00016609          }
00016609          
00016690          (uint8_t)i_1 = 1;
000165f3      }
000165f3      
000166ae      return (uint8_t)i_1;
00016540  }

000166af                                               cc cc cc cc cc cc cc cc cc                                         .........

000166b8    void TLInputDistProcessTouch(void* PTransLibUserModeContext, uint8_t preferMouse, struct csf_touch_report_t* touchReport)

000166b8  {
000166bc      int16_t r9 = *(uint16_t*)((char*)PTransLibUserModeContext + 0x450);
000166bc      
000166d1      if ((uint8_t)r9 & 0x40)
000166d1      {
000166d3          int32_t r8 = *(uint32_t*)((char*)PTransLibUserModeContext + 0x454);
000166d3          
000166dd          if (r8 == 1)
00016703              r9 = (r9 & 0xfffe) | 4;
000166dd          else if (r8 == 2)
000166f3              r9 = (r9 & 0xfffa) | 0x20;
000166e2          else
000166e4              r9 |= 1;
000166d1      }
000166d1      
00016713      if (preferMouse || 1 & (uint8_t)r9)
00016713      {
0001674b          int16_t rax_1 = (int16_t)(int64_t)(long double)touchReport->touch[0].pt.x;
00016751          char arg_8 = 3;
00016756          char arg_e = 0;
0001675b          int16_t arg_a = rax_1;
00016766          int16_t arg_c = (int16_t)(int64_t)(long double)touchReport->touch[0].pt.y;
0001676b          char temp1_1 = touchReport->touch[0].touchState;
0001676b          
0001676e          if (temp1_1)
0001676e          {
00016770              if (temp1_1 > 0)
00016770              {
00016776                  if (touchReport->touch[0].touchState <= 2)
00016798                      char arg_9 = 1;
00016776                  else if (touchReport->touch[0].touchState == 3)
0001678a                      arg_9 = 0;
0001677c                  else if (touchReport->touch[0].touchState == 4)
00016791                      arg_9 = 2;
00016782                  else if (touchReport->touch[0].touchState == 5)
0001678a                      arg_9 = 0;
00016770              }
00016770              
0001679d              uint8_t (* SendInputReportCallback_1)(struct _NW_TRANSLIB_USERMODE_CONTEXT*, 
0001679d                  uint8_t*, int32_t) = SendInputReportCallback;
0001679d              
000167a7              if (!SendInputReportCallback_1)
000167cc                  onBug__(
000167cc                      "TransLibInputDist.c: TLSendInput SendInputReportCallback not assigned!", 
000167cc                      "c:\development_work\csf_release_hp\driver\wincommon\translibinputdist.c", 
000167cc                      0x22);
000167a7              else
000167b4                  SendInputReportCallback_1(PTransLibUserModeContext, &arg_8, 7);
0001676e          }
00016713      }
00016713      else if ((uint8_t)r9 & 4)
00016719      {
00016727          (uint8_t)r9 = touchReport->touch[0].touchState;
0001672a          SendDigitizer(PTransLibUserModeContext, 
0001672a              (int16_t)(int64_t)(long double)touchReport->touch[0].pt.x, 
0001672a              (int16_t)(int64_t)(long double)touchReport->touch[0].pt.y, (uint8_t)r9);
00016719      }
00016719      else if ((uint8_t)r9 & 0x20)
00016741          SendWin7MultiTouch(PTransLibUserModeContext, touchReport);
000166b8  }

000167d6                                                                    cc cc cc cc cc cc                                    ......

000167dc    void fw_Init(struct FwSettings_t* pContext, struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext)

000167dc  {
0001680c      int16_t var_1d4 = 0x300;
00016819      int16_t var_1cd = 0x200;
0001681e      int16_t var_1cb = 0x200;
00016823      int32_t var_1b7 = 0x3356bf95;
00016831      int32_t var_154 = 0x3e4ccccd;
00016848      int32_t var_1d8 = 0;
0001684c      int32_t var_158 = 0x40400000;
0001685d      int32_t var_1b1;
0001685d      __builtin_memset(&var_1b1, 0, 0x40);
00016863      int16_t var_1c3 = 0x19;
0001686b      char var_1d2 = 0;
00016870      int32_t var_14e = 0x4000a3d7;
00016887      int16_t var_1c1 = 1;
0001688f      int32_t var_1d1 = 0;
000168a5      int16_t var_1bf = 0xa;
000168af      char var_1c9 = 0;
000168c6      int16_t var_171 = 0x129f;
000168eb      int16_t var_16f = 0xbb8;
000168f8      char var_1c8 = 0;
0001690f      int16_t var_16d = 0x190;
00016917      int16_t var_16b = 0x190;
0001691f      int16_t var_169 = 0x190;
00016930      int32_t var_14a = 0x4d0583b0;
00016939      int32_t var_13a = 0;
00016942      int16_t var_167 = 0x190;
0001694f      int32_t var_1c7 = 0xff;
00016957      int32_t var_136 = 0;
00016960      int32_t var_132 = 0;
00016969      int32_t var_12e = 0;
00016972      int32_t var_15c = 0xc8;
00016979      int16_t var_150 = 0xc8;
00016986      int16_t var_142 = 0x258;
00016993      int32_t var_1bd = 0x4e20;
0001699b      int16_t var_1b9 = 0x32;
000169a0      char var_1b3 = 0x4b;
000169a5      char var_1b2 = 4;
000169aa      int16_t var_140 = 0x960;
000169b2      int16_t var_165 = 0;
000169ba      int16_t var_163 = 0;
000169c2      int16_t var_161 = 0;
000169ca      int16_t var_15f = 0;
000169d2      char var_15d = 0;
000169da      int16_t var_146 = 0x32;
000169e2      int16_t var_144 = 0x32;
000169ea      int32_t var_13e = 0x9c40;
000169fd      int32_t var_12a = 0x3dcccccd;
00016a0e      char var_122 = 2;
00016a16      char var_11e = 0;
00016a34      int32_t var_126 = 0x41200000;
00016a3d      int16_t var_11d = 0x3e8;
00016a45      int16_t var_11b = 0x1f40;
00016a4d      int16_t var_119 = 0;
00016a55      int32_t var_115 = 0;
00016a5e      int32_t var_111 = 0x3f800000;
00016a67      int32_t var_10d;
00016a67      __builtin_memset(&var_10d, 0, 0x18);
00016a70      int16_t var_117 = 0x1f4;
00016a78      int16_t var_ed = 0x12c;
00016a80      char var_d9 = 0;
00016ab5      int32_t var_f5 = 0x3f800000;
00016ac3      int16_t var_db = 0x4b0;
00016acb      int32_t var_f1 = 0;
00016ad4      int32_t var_eb = 0;
00016add      int32_t var_e7 = 0;
00016ae6      int32_t var_e3 = 0;
00016aef      int32_t var_df = 0;
00016af8      int16_t var_d8 = 0x3e8;
00016b00      int16_t var_d6 = 0x1f40;
00016b08      int16_t var_d4 = 0;
00016b10      int32_t var_d0 = 0;
00016b19      int32_t var_cc = 0x3f800000;
00016b22      int32_t var_c8;
00016b22      __builtin_memset(&var_c8, 0, 0x18);
00016b2b      int16_t var_d2 = 0x1f4;
00016b33      int16_t var_a8 = 0x12c;
00016b3b      int16_t var_96 = 0x4b0;
00016b5e      char var_94 = 0;
00016b78      int32_t var_b0 = 0x3f800000;
00016b81      int32_t var_ac = 0;
00016b8a      int32_t var_a6 = 0x3f800000;
00016b93      int32_t var_a2 = 0;
00016b9c      int32_t var_9e = 0;
00016ba5      int32_t var_9a = 0;
00016bae      int16_t var_93 = 0x3e8;
00016bb6      int16_t var_91 = 0x1f40;
00016bbe      int16_t var_8f = 0;
00016bc6      int32_t var_8b = 0;
00016bcf      int32_t var_87 = 0x3f800000;
00016bd8      int32_t var_83;
00016bd8      __builtin_memset(&var_83, 0, 0x18);
00016be1      int16_t var_8d = 0x1f4;
00016be9      int16_t var_63 = 0x12c;
00016bee      int16_t var_51 = 0x4b0;
00016c05      char var_4f = 0;
00016c09      int16_t var_4e = 0x3e8;
00016c0e      int16_t var_4c = 0x1f40;
00016c1f      int32_t var_6b = 0x3f800000;
00016c25      int16_t var_4a = 0;
00016c2a      int16_t var_48 = 0x1f4;
00016c2f      int32_t var_67 = 0;
00016c35      int32_t var_61 = 0x3f800000;
00016c3b      int32_t var_5d = 0x3f800000;
00016c41      int32_t var_59 = 0;
00016c47      int32_t var_55 = 0;
00016c4d      int32_t var_46 = 0;
00016c53      int32_t var_42 = 0x3f800000;
00016c59      int32_t var_3e;
00016c59      __builtin_memset(&var_3e, 0, 0x18);
00016c5f      int16_t var_1e = 0x12c;
00016c85      int16_t var_c = 0x4b0;
00016c96      int32_t var_26 = 0x3f800000;
00016c9c      int32_t var_22 = 0;
00016ca2      int32_t var_1c = 0;
00016ca8      int32_t var_18 = 0x3f800000;
00016cae      int32_t var_14 = 0;
00016cb4      int32_t var_10 = 0;
00016cba      memmove(&pContext->st_Device, &var_1d8, 0x1ce);
00016cc7      pContext->FWTVLoadCallback = 0;
00016cca      pContext->FWVersionCallback = nullptr;
00016cce      pContext->st_data_lock.initialised = 0;
00016cd5      pContext->NumberOfSettings = 0;
00016cdb      pContext->GotSettingsFromFW = 0;
00016ce2      pContext->lastTreeSize = 0;
00016ce8      pContext->lastValueSize = 0;
00016cee      pContext->lastRewriteSize = 0;
00016cf8      pContext->pUserModeContext = pUserModeContext;
000167dc  }

00016d08                          cc cc cc cc cc cc cc cc                                                          ........

00016d10    void fw_UpdatePenShutter(void* pContext, uint8_t cam, uint16_t shutter)

00016d10  {
00016d22      void var_98;
00016d22      int64_t rax_1 = __security_cookie ^ &var_98;
00016d2a      int64_t rbx;
00016d2a      (uint8_t)rbx = cam;
00016d3e      uint8_t data = 0x43;
00016d43      char var_67 = 4;
00016d48      char var_66 = 0x48;
00016d4d      char var_65;
00016d4d      memset(&var_65, 0, 0x3d);
00016d68      uint16_t rdx;
00016d68      (uint8_t)rdx = (shutter >> 8) ^ (uint8_t)shutter;
00016d6e      var_65 = (uint8_t)rbx;
00016d72      char rax_2 = *(uint8_t*)((char*)shutter)[1] ^ (uint8_t)rdx;
00016d74      (uint8_t)rdx ^= rax_2;
00016d76      uint16_t var_78;
00016d76      *(uint8_t*)((char*)var_78)[1] = rax_2;
00016d7a      (uint8_t)var_78 = (uint8_t)rdx;
00016d88      uint16_t var_64 = var_78;
00016d8d      DSI_OutputReport(pContext, &data, 0x40);
00016d9a      __security_check_cookie(rax_1 ^ &var_98);
00016d10  }

00016daa                                cc cc cc cc cc cc                                                            ......

00016db0    void __convention("sysv") fw_ProcessSettings(struct FwSettings_t* pContext @ rcx, uint8_t* dataBuf @ rdx, uint32_t dataLength @ r8, int32_t cmd @ r9)

00016db0  {
00016de4      if (cmd < 0 || cmd <= 1 || cmd != 2
00016de4              || !ST_AcquireLock(&pContext->st_data_lock, cmd + 0x30))
00016dfc          return;
00016dfc      
00016e02      int64_t rsi;
00016e02      (uint8_t)rsi = pContext->GotSettingsFromFW;
00016e02      
00016e19      if (LoadFWTreeAndValues(pContext, dataBuf, dataLength))
00016e19      {
00016e25          fw_loadStDevice(pContext, &pContext->st_data);
00016e25          
00016e2d          if (!(uint8_t)rsi)
00016e2d          {
00016e2f              uint8_t GotSettingsFromFW = pContext->GotSettingsFromFW;
00016e2f              
00016e37              if (GotSettingsFromFW)
00016e37              {
00016e4f                  drv_LoadSettingsFromFile(&pContext->pUserModeContext->DrvSettingsContext, 
00016e4f                      GotSettingsFromFW, *(uint32_t*)((char*)pContext->st_Device + 0), 
00016e4f                      *(uint32_t*)((char*)pContext->st_Device + 7));
00016e54                  void (* FWVersionCallback)(uint16_t) = pContext->FWVersionCallback;
00016e54                  
00016e5b                  if (FWVersionCallback)
00016e61                      FWVersionCallback((uint64_t)
00016e61                          *(uint16_t*)((char*)pContext->st_Device + 4));
00016e37              }
00016e2d          }
00016e2d          
00016e64          void (* FWTVLoadCallback)(struct tv_item_t*, uint32_t, uint8_t*, uint32_t) =
00016e64              pContext->FWTVLoadCallback;
00016e6a          int64_t entry_rdi;
00016e6a          
00016e6a          if (FWTVLoadCallback)
00016e85              FWTVLoadCallback(&pContext->st_fw, 0x1f4, &pContext->st_data, 0x7d00, 
00016e85                  entry_rdi);
00016e19      }
00016e19      
00016e90      KeReleaseMutex(&pContext->st_data_lock.mutex, 0);
00016db0  }

00016eab                                   cc cc cc cc cc cc cc cc cc                                                 .........

00016eb4    uint8_t LoadFWTreeAndValues(struct FwSettings_t* pContext, uint8_t* dataBuf, uint32_t dataLength)

00016eb4  {
00016ee6      uint64_t r13_2 = (uint64_t)((uint32_t)*(uint8_t*)dataBuf << 8) | (uint64_t)dataBuf[1];
00016ef8      char r9 = 0;
00016ef8      
00016eff      if ((uint32_t)r13_2 != pContext->lastTreeSize)
00016eff          r9 = 1;
00016eff      
00016f06      uint32_t rbp_2 = (uint32_t)dataBuf[2] << 8 | (uint32_t)dataBuf[3];
00016f08      uint32_t rax_2 = (uint32_t)dataBuf[5];
00016f0c      char r12 = r9;
00016f0c      
00016f16      if (rbp_2 != pContext->lastValueSize)
00016f16          r12 = 1;
00016f16      
00016f1a      uint32_t rcx = (uint32_t)dataBuf[4];
00016f1e      pContext->lastTreeSize = (uint32_t)r13_2;
00016f28      pContext->lastValueSize = rbp_2;
00016f30      pContext->lastRewriteSize = rcx << 8 | rax_2;
00016f49      int32_t rax_5;
00016f49      
00016f49      if ((uint32_t)r13_2 > 0x7d0 || rbp_2 > 0x7d00)
00016f49      {
0001700d          onError__("LoadFWTreeAndValues: TreeSize or ValueSize too large\n", 
0001700d              "c:\development_work\csf_release_hp\driver\translib\fwsettings.c", 0x213);
00017012          (uint8_t)rax_5 = 0;
00016f49      }
00016f49      else if (dataLength >= rbp_2 + (uint32_t)r13_2 + 6)
00016f57      {
00016f6e          if (r12)
00016f6e          {
00016fc7          label_16fc7:
00016fc7              pContext->NumberOfSettings = (uint32_t)r13_2 >> 2;
00016fd4              memmove(&pContext->st_fw, &dataBuf[6], (uint64_t)(uint32_t)r13_2);
00016fe8              memmove(&pContext->st_data, &dataBuf[r13_2 + 6], (uint64_t)rbp_2);
00016fed              pContext->GotSettingsFromFW = 1;
00016f6e          }
00016f6e          else
00016f6e          {
00016f83              char rbx_1 = r12;
00016f83              
00016f9f              if (memcmp(&pContext->st_fw, &dataBuf[6], (uint64_t)(uint32_t)r13_2))
00016f9f                  rbx_1 = 1;
00016f9f              
00016fa8              char rcx_6 = rbx_1;
00016fa8              
00016fae              if (memcmp(&pContext->st_data, &dataBuf[r13_2 + 6], (uint64_t)rbp_2))
00016fae                  rcx_6 = 1;
00016fae              
00016fb2              r12 = rcx_6;
00016fb2              
00016fb8              if (rcx_6)
00016fb8                  goto label_16fc7;
00016f6e          }
00016f6e          
00016ff4          (uint8_t)rax_5 = r12;
00016f57      }
00016f57      else
00016f57      {
0001700d          onError__("LoadFWTreeAndValues: dataLength too large small\n", 
0001700d              "c:\development_work\csf_release_hp\driver\translib\fwsettings.c", 0x219);
00017012          (uint8_t)rax_5 = 0;
00016f57      }
00016f57      
00017030      return (uint8_t)rax_5;
00016eb4  }

00017031                                                     cc cc cc cc cc cc cc                                           .......

00017038    void fw_SetAngleOffset(struct FwSettings_t* pContext, int32_t Cam, float Value)

00017038  {
0001704a      *(uint32_t*)((int64_t)Cam * 0x45 + pContext + 0x105) = Value * 0.0174532924f;
0001704a      
00017053      if (Cam == 1)
00017053      {
000170c5          *(uint32_t*)((char*)pContext->st_Device + 0x13a) =
000170c5              1.57079637f - *(uint32_t*)((char*)pContext->st_Device + 0x13a) * 1f;
000170c5          return;
00017053      }
00017053      
00017058      if (Cam == 2)
00017058      {
000170a0          *(uint32_t*)((char*)pContext->st_Device + 0x17f) =
000170a0              3.14159274f - *(uint32_t*)((char*)pContext->st_Device + 0x17f) * 1f;
000170a8          return;
00017058      }
00017058      
0001705d      if (Cam == 3)
0001707b          *(uint32_t*)((char*)pContext->st_Device + 0x1c4) =
0001707b              4.71238899f - *(uint32_t*)((char*)pContext->st_Device + 0x1c4) * 1f;
00017038  }

000170ce                                            cc cc cc cc cc cc                                                    ......

000170d4    void fw_loadStDeviceCam(struct FwSettings_t* pContext, uint8_t* _st_data_ptr, int32_t ParentId, int32_t Cam)

000170d4  {
000170f0      int64_t Cam_1 = (int64_t)Cam;
0001710f      int64_t rbx_1 = Cam_1 * 0x45;
0001712d      void var_248;
0001712d      
0001712d      if (ST_GetU8(&pContext->st_fw, &var_248 + rbx_1 + 0xfa, _st_data_ptr, ParentId, 0x21))
00017133          *(uint8_t*)(rbx_1 + pContext + 0xca) = *(uint8_t*)(&var_248 + rbx_1 + 0xfa);
00017133      
00017159      if (ST_GetU8(&pContext->st_fw, &var_248 + rbx_1 + 0xfa, _st_data_ptr, ParentId, 0x65))
0001715f          *(uint8_t*)(rbx_1 + pContext + 0xca) = *(uint8_t*)(&var_248 + rbx_1 + 0xfa);
0001715f      
0001718d      uint16_t arg_8;
0001718d      
0001718d      if (ST_GetU16(&pContext->st_fw, &var_248 + rbx_1 + 0xfb, _st_data_ptr, ParentId, 
0001718d          0x24))
0001718d      {
0001718f          uint16_t rax_3 = *(uint16_t*)(&var_248 + rbx_1 + 0xfb);
000171a7          char rcx_3 = (uint8_t)rax_3 ^ (rax_3 >> 8);
000171a9          (uint8_t)rax_3 = *(uint8_t*)((char*)rax_3)[1];
000171b0          (uint8_t)rax_3 ^= rcx_3;
000171b4          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_3;
000171bb          (uint8_t)arg_8 = rcx_3 ^ (uint8_t)rax_3;
000171ca          *(uint16_t*)(rbx_1 + pContext + 0xcb) = arg_8;
0001718d      }
0001718d      
000171fc      if (ST_GetU16(&pContext->st_fw, &var_248 + rbx_1 + 0xfd, _st_data_ptr, 0x10, 0x20))
000171fc      {
000171fe          uint16_t rax_6 = *(uint16_t*)(&var_248 + rbx_1 + 0xfd);
00017216          char rcx_5 = (uint8_t)rax_6 ^ (rax_6 >> 8);
00017218          (uint8_t)rax_6 = *(uint8_t*)((char*)rax_6)[1];
0001721f          (uint8_t)rax_6 ^= rcx_5;
00017223          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_6;
0001722a          (uint8_t)arg_8 = rcx_5 ^ (uint8_t)rax_6;
00017239          *(uint16_t*)(rbx_1 + pContext + 0xcd) = arg_8;
000171fc      }
000171fc      
00017268      if (ST_GetU16(&pContext->st_fw, &var_248 + rbx_1 + 0xff, _st_data_ptr, ParentId, 0x27)
00017268          && ST_GetU16(&pContext->st_fw, &var_248 + rbx_1 + 0x101, _st_data_ptr, ParentId, 
00017268          0x28))
00017268      {
0001729b          uint16_t rax_10 = *(uint16_t*)(&var_248 + rbx_1 + 0xff);
000172b8          char rcx_8 = (uint8_t)rax_10 ^ (rax_10 >> 8);
000172ba          (uint8_t)rax_10 = *(uint8_t*)((char*)rax_10)[1];
000172c1          (uint8_t)rax_10 ^= rcx_8;
000172c5          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_10;
000172cc          uint16_t rax_11 = *(uint16_t*)(&var_248 + rbx_1 + 0x101);
000172d1          (uint8_t)arg_8 = rcx_8 ^ (uint8_t)rax_10;
000172d8          uint16_t rdx_6 = arg_8;
000172f3          *(uint16_t*)(rbx_1 + pContext + 0xcf) = rdx_6;
000172fb          rcx_8 = (uint8_t)rax_11 ^ (rax_11 >> 8);
000172fd          (uint8_t)rax_11 = *(uint8_t*)((char*)rax_11)[1];
00017304          (uint8_t)rax_11 ^= rcx_8;
00017308          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_11;
0001730f          (uint8_t)arg_8 = rcx_8 ^ (uint8_t)rax_11;
0001731f          *(uint16_t*)(rbx_1 + pContext + 0xd1) = arg_8;
0001731f          
00017330          if (*(uint8_t*)(rbx_1 + pContext + 0xca) & 1)
00017330          {
00017332              int16_t rcx_9 = *(uint16_t*)((char*)pContext->st_Device + 0xb);
00017348              *(uint16_t*)(rbx_1 + pContext + 0xd1) = rcx_9 - rdx_6 - 1;
00017350              *(uint16_t*)(rbx_1 + pContext + 0xcf) = rcx_9 - arg_8 - 1;
00017330          }
00017268      }
00017268      
00017387      uint8_t arg_a;
00017387      char arg_b;
00017387      
00017387      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x103, _st_data_ptr, ParentId, 
00017387          0x29))
00017387      {
0001738f          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x103);
00017398          int32_t rcx_11 = arg_8;
0001739f          arg_b = (uint8_t)rcx_11;
000173ab          (uint8_t)arg_8 = (char)(rcx_11 >> 0x18);
000173b7          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_11 >> 0x10);
000173c3          arg_a = (char)(rcx_11 >> 8);
000173d1          arg_8 = arg_8;
000173e1          *(uint32_t*)(rbx_1 + pContext + 0xd3) = arg_8;
00017387      }
00017387      
00017411      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x107, _st_data_ptr, ParentId, 
00017411          0x2a))
00017411      {
00017419          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x107);
00017422          int32_t rcx_13 = arg_8;
00017429          arg_b = (uint8_t)rcx_13;
00017435          (uint8_t)arg_8 = (char)(rcx_13 >> 0x18);
00017441          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_13 >> 0x10);
0001744d          arg_a = (char)(rcx_13 >> 8);
0001745b          arg_8 = arg_8;
0001746b          *(uint32_t*)(rbx_1 + pContext + 0xd7) = arg_8;
00017411      }
00017411      
0001749b      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x10b, _st_data_ptr, ParentId, 
0001749b          0x2b))
0001749b      {
000174a3          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x10b);
000174ac          int32_t rcx_15 = arg_8;
000174b3          arg_b = (uint8_t)rcx_15;
000174bf          (uint8_t)arg_8 = (char)(rcx_15 >> 0x18);
000174cb          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_15 >> 0x10);
000174d7          arg_a = (char)(rcx_15 >> 8);
000174e5          arg_8 = arg_8;
000174f5          *(uint32_t*)(rbx_1 + pContext + 0xdb) = arg_8;
0001749b      }
0001749b      
00017525      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x10f, _st_data_ptr, ParentId, 
00017525          0x2c))
00017525      {
0001752d          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x10f);
00017536          int32_t rcx_17 = arg_8;
0001753f          arg_b = (uint8_t)rcx_17;
00017549          (uint8_t)arg_8 = (char)(rcx_17 >> 0x18);
00017555          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_17 >> 0x10);
00017561          arg_a = (char)(rcx_17 >> 8);
0001756f          arg_8 = arg_8;
00017587          *(uint32_t*)(&pContext->st_Device + (Cam_1 + 3) * 0x45) = arg_8;
00017525      }
00017525      
000175b4      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x113, _st_data_ptr, ParentId, 
000175b4          0x2d))
000175b4      {
000175bc          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x113);
000175c5          int32_t rcx_19 = arg_8;
000175cc          arg_b = (uint8_t)rcx_19;
000175d8          (uint8_t)arg_8 = (char)(rcx_19 >> 0x18);
000175e4          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_19 >> 0x10);
000175f0          arg_a = (char)(rcx_19 >> 8);
000175fe          arg_8 = arg_8;
0001760e          *(uint32_t*)(rbx_1 + pContext + 0xe3) = arg_8;
000175b4      }
000175b4      
0001763e      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x117, _st_data_ptr, ParentId, 
0001763e          0x2e))
0001763e      {
00017646          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x117);
0001764f          int32_t rcx_21 = arg_8;
00017656          arg_b = (uint8_t)rcx_21;
00017662          (uint8_t)arg_8 = (char)(rcx_21 >> 0x18);
0001766e          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_21 >> 0x10);
0001767a          arg_a = (char)(rcx_21 >> 8);
00017688          arg_8 = arg_8;
00017698          *(uint32_t*)(rbx_1 + pContext + 0xe7) = arg_8;
0001763e      }
0001763e      
000176c8      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x11b, _st_data_ptr, ParentId, 
000176c8          0x2f))
000176c8      {
000176d0          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x11b);
000176d9          int32_t rcx_23 = arg_8;
000176e0          arg_b = (uint8_t)rcx_23;
000176ec          (uint8_t)arg_8 = (char)(rcx_23 >> 0x18);
000176f8          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_23 >> 0x10);
00017704          arg_a = (char)(rcx_23 >> 8);
00017712          arg_8 = arg_8;
00017722          *(uint32_t*)(rbx_1 + pContext + 0xeb) = arg_8;
000176c8      }
000176c8      
00017752      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x123, _st_data_ptr, ParentId, 
00017752          0xde))
00017752      {
0001775a          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x123);
00017763          int32_t rcx_25 = arg_8;
0001776a          arg_b = (uint8_t)rcx_25;
00017776          (uint8_t)arg_8 = (char)(rcx_25 >> 0x18);
00017782          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_25 >> 0x10);
0001778e          arg_a = (char)(rcx_25 >> 8);
0001779c          arg_8 = arg_8;
000177ac          *(uint32_t*)(rbx_1 + pContext + 0xf3) = arg_8;
00017752      }
00017752      
000177dc      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x127, _st_data_ptr, ParentId, 
000177dc          0xdd))
000177dc      {
000177e4          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x127);
000177ed          int32_t rcx_27 = arg_8;
000177f4          arg_b = (uint8_t)rcx_27;
00017800          (uint8_t)arg_8 = (char)(rcx_27 >> 0x18);
0001780c          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_27 >> 0x10);
00017818          arg_a = (char)(rcx_27 >> 8);
00017826          arg_8 = arg_8;
00017836          *(uint32_t*)(rbx_1 + pContext + 0xf7) = arg_8;
000177dc      }
000177dc      
00017866      if (ST_GetU16(&pContext->st_fw, &var_248 + rbx_1 + 0x12b, _st_data_ptr, ParentId, 
00017866          0x1f))
00017866      {
00017868          uint16_t rax_88 = *(uint16_t*)(&var_248 + rbx_1 + 0x12b);
00017880          char rcx_29 = (uint8_t)rax_88 ^ (rax_88 >> 8);
00017882          (uint8_t)rax_88 = *(uint8_t*)((char*)rax_88)[1];
00017889          (uint8_t)rax_88 ^= rcx_29;
0001788d          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_88;
00017894          (uint8_t)arg_8 = rcx_29 ^ (uint8_t)rax_88;
000178a3          *(uint16_t*)(rbx_1 + pContext + 0xfb) = arg_8;
00017866      }
00017866      
000178ab      int32_t rdx_17 = 0;
000178ad      uint8_t* rcx_30 = &pContext->st_fw[0].treepath1;
000178b4      int64_t r8_17 = 0;
000178b4      
000178bf      while (true)
000178bf      {
000178bf          if (*((char*)ADJ(rcx_30) + 0x7f22))
000178bf          {
000178cc              if (*((char*)ADJ(rcx_30) + 0x7f21) != 0x22
000178cc                  || ParentId != (uint32_t)*((char*)ADJ(rcx_30) + 0x7f20))
000178cc              {
000178ce                  r8_17 += 1;
000178d1                  rdx_17 += 1;
000178d4                  rcx_30 = &rcx_30[4];
000178d4                  
000178df                  if (r8_17 < 0x1f4)
000178df                      continue;
000178df                  else
000178e1                      rdx_17 = -1;
000178cc              }
000178cc              
000178e7              if (rdx_17 != 0xffffffff)
000178e7              {
000178ec                  (uint8_t)rcx_30 = pContext->st_fw[(int64_t)rdx_17].typespec;
000178f3                  (uint8_t)rcx_30 &= 0x3f;
000178f6                  break;
000178e7              }
000178bf          }
000178bf          
000178f8          (uint8_t)rcx_30 = 0;
000178f8          break;
000178bf      }
000178bf      
000178fa      (uint8_t)rcx_30 &= 0x3f;
000178fa      
00017900      if ((uint8_t)rcx_30 == 5)
00017900      {
00017924          uint16_t var_218[0xf0];
00017924          
00017924          if (ST_GetU16(&pContext->st_fw, &var_218, _st_data_ptr, ParentId, 0x22))
00017924          {
00017926              uint16_t rax_93 = var_218[0];
0001793a              uint16_t rcx_32;
0001793a              (uint8_t)rcx_32 = (rax_93 >> 8) ^ (uint8_t)rax_93;
0001793c              (uint8_t)rax_93 = *(uint8_t*)((char*)rax_93)[1];
00017943              (uint8_t)rax_93 ^= (uint8_t)rcx_32;
00017945              (uint8_t)rcx_32 ^= (uint8_t)rax_93;
00017947              *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_93;
0001794e              (uint8_t)arg_8 = (uint8_t)rcx_32;
00017964              *(uint32_t*)(rbx_1 + pContext + 0xfd) =
00017964                  _mm_cvtepi32_ps((uint128_t)(int32_t)arg_8);
00017924          }
00017924          
0001798e          if (ST_GetU16(&pContext->st_fw, &var_218, _st_data_ptr, ParentId, 0x23))
0001798e          {
00017994              uint16_t rax_96 = var_218[0];
000179a8              uint16_t rcx_34;
000179a8              (uint8_t)rcx_34 = (rax_96 >> 8) ^ (uint8_t)rax_96;
000179aa              (uint8_t)rax_96 = *(uint8_t*)((char*)rax_96)[1];
000179b1              (uint8_t)rax_96 ^= (uint8_t)rcx_34;
000179b3              (uint8_t)rcx_34 ^= (uint8_t)rax_96;
000179b5              *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_96;
000179bc              (uint8_t)arg_8 = (uint8_t)rcx_34;
00017ae8              *(uint32_t*)(rbx_1 + pContext + 0x101) =
00017ae8                  _mm_cvtepi32_ps((uint128_t)(int32_t)arg_8);
0001798e          }
00017900      }
00017900      else if ((uint8_t)rcx_30 == 7)
000179da      {
00017a04          if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x12d, _st_data_ptr, 
00017a04              ParentId, 0x22))
00017a04          {
00017a0c              arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x12d);
00017a15              int32_t rcx_36 = arg_8;
00017a1c              arg_b = (uint8_t)rcx_36;
00017a28              (uint8_t)arg_8 = (char)(rcx_36 >> 0x18);
00017a34              *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_36 >> 0x10);
00017a40              arg_a = (char)(rcx_36 >> 8);
00017a4e              arg_8 = arg_8;
00017a5e              *(uint32_t*)(rbx_1 + pContext + 0xfd) = arg_8;
00017a04          }
00017a04          
00017a8e          if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x131, _st_data_ptr, 
00017a8e              ParentId, 0x23))
00017a8e          {
00017a96              arg_8 = (*(uint32_t*)(&var_248 + rbx_1 + 0x131));
00017a9f              int32_t rcx_38 = arg_8;
00017aa6              arg_b = (uint8_t)rcx_38;
00017ab2              (uint8_t)arg_8 = (char)(rcx_38 >> 0x18);
00017abe              *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_38 >> 0x10);
00017aca              arg_a = (char)(rcx_38 >> 8);
00017ad8              arg_8 = arg_8;
00017ae8              *(uint32_t*)(rbx_1 + pContext + 0x101) = arg_8;
00017a8e          }
000179da      }
000179da      
00017b18      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x135, _st_data_ptr, ParentId, 
00017b18          0x26))
00017b18      {
00017b27          arg_8 = *(uint32_t*)(&var_248 + rbx_1 + 0x135);
00017b30          int32_t rcx_40 = arg_8;
00017b39          arg_b = (uint8_t)rcx_40;
00017b43          (uint8_t)arg_8 = (char)(rcx_40 >> 0x18);
00017b4f          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_40 >> 0x10);
00017b5e          arg_a = (char)(rcx_40 >> 8);
00017b6c          arg_8 = arg_8;
00017b7c          fw_SetAngleOffset(pContext, Cam, arg_8);
00017b18      }
00017b18      
00017ba0      int32_t arg_20;
00017ba0      
00017ba0      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x135, _st_data_ptr, ParentId, 
00017ba0          0x95))
00017ba0      {
00017ba2          int32_t zmm0_14 = *(uint32_t*)(&var_248 + rbx_1 + 0x135);
00017bb8          *(uint8_t*)((char*)arg_20)[3] = (uint8_t)zmm0_14;
00017bc4          (uint8_t)arg_20 = (char)(zmm0_14 >> 0x18);
00017bd0          *(uint8_t*)((char*)arg_20)[1] = (char)(zmm0_14 >> 0x10);
00017bdc          *(uint8_t*)((char*)arg_20)[2] = (char)(zmm0_14 >> 8);
00017bfa          *(uint32_t*)(rbx_1 + pContext + 0x105) = arg_20;
00017ba0      }
00017ba0      
00017c2a      if (ST_GetFloat(&pContext->st_fw, &var_248 + rbx_1 + 0x139, _st_data_ptr, ParentId, 
00017c2a          0xd4))
00017c2a      {
00017c2c          int32_t zmm0_15 = *(uint32_t*)(&var_248 + rbx_1 + 0x139);
00017c42          *(uint8_t*)((char*)arg_20)[3] = (uint8_t)zmm0_15;
00017c4e          (uint8_t)arg_20 = (char)(zmm0_15 >> 0x18);
00017c5a          *(uint8_t*)((char*)arg_20)[1] = (char)(zmm0_15 >> 0x10);
00017c66          *(uint8_t*)((char*)arg_20)[2] = (char)(zmm0_15 >> 8);
00017c84          *(uint32_t*)(rbx_1 + pContext + 0x109) = arg_20;
00017c2a      }
00017c2a      
00017cb4      if (!ST_GetU16(&pContext->st_fw, &var_248 + rbx_1 + 0x13d, _st_data_ptr, ParentId, 
00017cb4              0xca))
00017cb4          return;
00017cb4      
00017cb6      uint16_t rax_139 = *(uint16_t*)(&var_248 + rbx_1 + 0x13d);
00017cbb      (uint16_t)arg_20 = rax_139;
00017cce      char rcx_46 = (uint8_t)arg_20 ^ (rax_139 >> 8);
00017cd0      (uint8_t)rax_139 = *(uint8_t*)((char*)arg_20)[1];
00017cd7      (uint8_t)rax_139 ^= rcx_46;
00017cdb      *(uint8_t*)((char*)arg_20)[1] = (uint8_t)rax_139;
00017ce2      (uint8_t)arg_20 = rcx_46 ^ (uint8_t)rax_139;
00017cf1      *(uint16_t*)(rbx_1 + pContext + 0x10d) = (uint16_t)arg_20;
000170d4  }

00017d14                                                              cc cc cc cc cc cc cc cc                                  ........

00017d1c    void fw_loadStDevice(struct FwSettings_t* pContext, uint8_t* _st_data_ptr)

00017d1c  {
00017d5f      uint16_t arg_8;
00017d5f      
00017d5f      if (ST_GetU16(&pContext->st_fw, &arg_8, _st_data_ptr, 0x10, 0x12))
00017d5f      {
00017d61          uint16_t rax_1 = arg_8;
00017d69          arg_8 = rax_1;
00017d78          uint16_t rcx_1;
00017d78          (uint8_t)rcx_1 = (rax_1 >> 8) ^ (uint8_t)rax_1;
00017d7a          (uint8_t)rax_1 = *(uint8_t*)((char*)arg_8)[1];
00017d81          (uint8_t)rax_1 ^= (uint8_t)rcx_1;
00017d83          (uint8_t)rcx_1 ^= (uint8_t)rax_1;
00017d85          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_1;
00017d8c          (uint8_t)arg_8 = (uint8_t)rcx_1;
00017d9b          *(uint32_t*)((char*)pContext->st_Device + 0) = (uint32_t)arg_8;
00017d5f      }
00017d5f      
00017dbf      uint8_t var_1f8;
00017dbf      uint8_t arg_a;
00017dbf      uint8_t arg_b;
00017dbf      
00017dbf      if (ST_GetU32(&pContext->st_fw, &var_1f8, _st_data_ptr, 0xf0, 0x12))
00017dbf      {
00017dc5          uint8_t var_1f5;
00017dc5          (uint8_t)arg_8 = var_1f5;
00017dd0          uint8_t var_1f6;
00017dd0          *(uint8_t*)((char*)arg_8)[1] = var_1f6;
00017ddb          uint8_t var_1f7;
00017ddb          arg_a = var_1f7;
00017de6          arg_b = var_1f8;
00017df4          *(uint32_t*)((char*)pContext->st_Device + 0) = arg_8;
00017dbf      }
00017dbf      
00017e18      uint16_t var_1f4;
00017e18      
00017e18      if (ST_GetU16(&pContext->st_fw, &var_1f4, _st_data_ptr, 0x10, 0x13))
00017e18      {
00017e1a          uint16_t rax_6 = var_1f4;
00017e1f          arg_8 = rax_6;
00017e2e          uint16_t rcx_4;
00017e2e          (uint8_t)rcx_4 = (rax_6 >> 8) ^ (uint8_t)rax_6;
00017e30          (uint8_t)rax_6 = *(uint8_t*)((char*)arg_8)[1];
00017e37          (uint8_t)rax_6 ^= (uint8_t)rcx_4;
00017e39          (uint8_t)rcx_4 ^= (uint8_t)rax_6;
00017e3b          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_6;
00017e42          (uint8_t)arg_8 = (uint8_t)rcx_4;
00017e51          *(uint16_t*)((char*)pContext->st_Device + 4) = arg_8;
00017e18      }
00017e18      
00017e76      uint8_t var_1f2;
00017e76      
00017e76      if (ST_GetU8(&pContext->st_fw, &var_1f2, _st_data_ptr, 0x10, 0x17))
00017e7c          *(uint8_t*)((char*)pContext->st_Device + 6) = var_1f2;
00017e7c      
00017ea3      uint8_t var_1f1;
00017ea3      uint8_t var_1f0;
00017ea3      uint8_t var_1ef;
00017ea3      uint8_t var_1ee;
00017ea3      
00017ea3      if (ST_GetU32(&pContext->st_fw, &var_1f1, _st_data_ptr, 0x10, 0x11))
00017ea3      {
00017ea9          (uint8_t)arg_8 = var_1ee;
00017eb4          *(uint8_t*)((char*)arg_8)[1] = var_1ef;
00017ebf          arg_a = var_1f0;
00017eca          arg_b = var_1f1;
00017ed8          *(uint32_t*)((char*)pContext->st_Device + 7) = arg_8;
00017ea3      }
00017ea3      
00017efc      if (ST_GetU32(&pContext->st_fw, &var_1f1, _st_data_ptr, 0xf0, 0x11))
00017efc      {
00017f02          (uint8_t)arg_8 = var_1ee;
00017f0d          *(uint8_t*)((char*)arg_8)[1] = var_1ef;
00017f18          arg_a = var_1f0;
00017f23          arg_b = var_1f1;
00017f31          *(uint32_t*)((char*)pContext->st_Device + 7) = arg_8;
00017efc      }
00017efc      
00017f55      uint16_t var_1ed;
00017f55      
00017f55      if (ST_GetU16(&pContext->st_fw, &var_1ed, _st_data_ptr, 0x10, 0x54))
00017f55      {
00017f57          uint16_t rax_14 = var_1ed;
00017f5c          arg_8 = rax_14;
00017f6b          uint16_t rcx_9;
00017f6b          (uint8_t)rcx_9 = (rax_14 >> 8) ^ (uint8_t)rax_14;
00017f6d          (uint8_t)rax_14 = *(uint8_t*)((char*)arg_8)[1];
00017f74          (uint8_t)rax_14 ^= (uint8_t)rcx_9;
00017f76          (uint8_t)rcx_9 ^= (uint8_t)rax_14;
00017f78          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_14;
00017f7f          (uint8_t)arg_8 = (uint8_t)rcx_9;
00017f8e          *(uint16_t*)((char*)pContext->st_Device + 0xb) = arg_8;
00017f55      }
00017f55      
00017fb3      uint16_t var_1eb;
00017fb3      
00017fb3      if (ST_GetU16(&pContext->st_fw, &var_1eb, _st_data_ptr, 0x10, 0x4c))
00017fb3      {
00017fb5          uint16_t rax_17 = var_1eb;
00017fba          arg_8 = rax_17;
00017fc9          uint16_t rcx_11;
00017fc9          (uint8_t)rcx_11 = (rax_17 >> 8) ^ (uint8_t)rax_17;
00017fcb          (uint8_t)rax_17 = *(uint8_t*)((char*)arg_8)[1];
00017fd2          (uint8_t)rax_17 ^= (uint8_t)rcx_11;
00017fd4          (uint8_t)rcx_11 ^= (uint8_t)rax_17;
00017fd6          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_17;
00017fdd          (uint8_t)arg_8 = (uint8_t)rcx_11;
00017fec          *(uint16_t*)((char*)pContext->st_Device + 0xd) = arg_8;
00017fb3      }
00017fb3      
00017ff5      if (!*(uint16_t*)((char*)pContext->st_Device + 0xd))
00017ffc          *(uint16_t*)((char*)pContext->st_Device + 0xd) = 0x200;
00017ffc      
00018021      uint8_t var_1e9;
00018021      
00018021      if (ST_GetU8(&pContext->st_fw, &var_1e9, _st_data_ptr, 0x10, 0x21))
00018027          *(uint8_t*)((char*)pContext->st_Device + 0xf) = var_1e9;
00018027      
0001804b      uint8_t var_1e8;
0001804b      
0001804b      if (ST_GetU8(&pContext->st_fw, &var_1e8, _st_data_ptr, 0x10, 0x4b))
00018051          *(uint8_t*)((char*)pContext->st_Device + 0x10) = var_1e8;
00018051      
00018080      uint8_t arg_19;
00018080      uint8_t var_1e7;
00018080      
00018080      if (!ST_GetU8(&pContext->st_fw, &arg_8, _st_data_ptr, 0x10, 0x1a))
00018080      {
000180aa          if (ST_GetU32(&pContext->st_fw, &var_1e7, _st_data_ptr, 0x41, 0x1a))
000180aa          {
000180bb              uint8_t var_1e5;
000180bb              arg_19 = var_1e5;
000180c6              uint8_t var_1e6;
000180c6              uint8_t arg_1a = var_1e6;
000180d1              uint8_t arg_1b = var_1e7;
000180df              uint8_t var_1e4;
000180df              *(uint32_t*)((char*)pContext->st_Device + 0x11) = var_1e4;
000180aa          }
00018080      }
00018080      else
000180df          *(uint32_t*)((char*)pContext->st_Device + 0x11) = (uint32_t)(uint8_t)arg_8;
00018109      uint8_t arg_18;
00018109      uint16_t var_1e3;
00018109      
00018109      if (!ST_GetU8(&pContext->st_fw, &arg_8, _st_data_ptr, 0x10, 0x1b))
00018109      {
00018133          if (ST_GetU16(&pContext->st_fw, &var_1e3, _st_data_ptr, 0x41, 0x1b))
00018133          {
00018135              uint16_t rax_27 = var_1e3;
0001813a              arg_18 = rax_27;
00018149              uint16_t rcx_18;
00018149              (uint8_t)rcx_18 = (rax_27 >> 8) ^ (uint8_t)rax_27;
0001814b              (uint8_t)rax_27 = arg_19;
00018152              (uint8_t)rax_27 ^= (uint8_t)rcx_18;
00018154              (uint8_t)rcx_18 ^= (uint8_t)rax_27;
00018156              arg_19 = (uint8_t)rax_27;
0001816c              *(uint16_t*)((char*)pContext->st_Device + 0x15) = (uint8_t)rcx_18;
00018133          }
00018109      }
00018109      else
0001816c          *(uint16_t*)((char*)pContext->st_Device + 0x15) = (uint16_t)(uint8_t)arg_8;
00018194      uint16_t var_1e1;
00018194      
00018194      if (!ST_GetU8(&pContext->st_fw, &arg_8, _st_data_ptr, 0x10, 0x1c))
00018194      {
000181c1          if (ST_GetU16(&pContext->st_fw, &var_1e1, _st_data_ptr, 0x41, 0x1c))
000181c1          {
000181c3              uint16_t rax_31 = var_1e1;
000181c8              arg_18 = rax_31;
000181d7              uint16_t rcx_21;
000181d7              (uint8_t)rcx_21 = (rax_31 >> 8) ^ (uint8_t)rax_31;
000181d9              (uint8_t)rax_31 = arg_19;
000181e0              (uint8_t)rax_31 ^= (uint8_t)rcx_21;
000181e2              (uint8_t)rcx_21 ^= (uint8_t)rax_31;
000181e4              arg_19 = (uint8_t)rax_31;
000181fa              *(uint16_t*)((char*)pContext->st_Device + 0x17) = (uint8_t)rcx_21;
000181c1          }
00018194      }
00018194      else
000181fa          *(uint16_t*)((char*)pContext->st_Device + 0x17) = (uint16_t)(uint8_t)arg_8;
00018222      uint16_t var_1df;
00018222      
00018222      if (!ST_GetU8(&pContext->st_fw, &arg_8, _st_data_ptr, 0x10, 0x1d))
00018222      {
0001824f          if (ST_GetU16(&pContext->st_fw, &var_1df, _st_data_ptr, 0x41, 0x6b))
0001824f          {
00018251              uint16_t rax_35 = var_1df;
00018256              arg_8 = rax_35;
00018265              uint16_t rcx_24;
00018265              (uint8_t)rcx_24 = (rax_35 >> 8) ^ (uint8_t)rax_35;
00018267              (uint8_t)rax_35 = *(uint8_t*)((char*)arg_8)[1];
0001826e              (uint8_t)rax_35 ^= (uint8_t)rcx_24;
00018270              (uint8_t)rcx_24 ^= (uint8_t)rax_35;
00018272              *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_35;
00018279              (uint8_t)arg_8 = (uint8_t)rcx_24;
00018288              *(uint16_t*)((char*)pContext->st_Device + 0x19) = arg_8;
0001824f          }
00018222      }
00018222      else
00018288          *(uint16_t*)((char*)pContext->st_Device + 0x19) = (uint16_t)(uint8_t)arg_8;
000182ad      uint8_t var_1dd;
000182ad      
000182ad      if (ST_GetU32(&pContext->st_fw, &var_1dd, _st_data_ptr, 0x41, 0xa3))
000182ad      {
000182b3          uint8_t var_1da;
000182b3          (uint8_t)arg_8 = var_1da;
000182be          uint8_t var_1db;
000182be          *(uint8_t*)((char*)arg_8)[1] = var_1db;
000182c9          uint8_t var_1dc;
000182c9          arg_a = var_1dc;
000182d4          arg_b = var_1dd;
000182e2          *(uint32_t*)((char*)pContext->st_Device + 0x1b) = arg_8;
000182ad      }
000182ad      
00018306      uint16_t var_1d9;
00018306      
00018306      if (ST_GetU16(&pContext->st_fw, &var_1d9, _st_data_ptr, 0x41, 0xa4))
00018306      {
00018308          uint16_t rax_39 = var_1d9;
0001830d          arg_8 = rax_39;
0001831c          uint16_t rcx_27;
0001831c          (uint8_t)rcx_27 = (rax_39 >> 8) ^ (uint8_t)rax_39;
0001831e          (uint8_t)rax_39 = *(uint8_t*)((char*)arg_8)[1];
00018325          (uint8_t)rax_39 ^= (uint8_t)rcx_27;
00018327          (uint8_t)rcx_27 ^= (uint8_t)rax_39;
00018329          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_39;
00018330          (uint8_t)arg_8 = (uint8_t)rcx_27;
0001833f          *(uint16_t*)((char*)pContext->st_Device + 0x1f) = arg_8;
00018306      }
00018306      
00018364      float var_1d7;
00018364      
00018364      if (ST_GetFloat(&pContext->st_fw, &var_1d7, _st_data_ptr, 0x41, 0xa5))
00018364      {
0001836c          arg_8 = var_1d7;
00018375          int32_t rcx_29 = arg_8;
0001837c          arg_b = (uint8_t)rcx_29;
00018388          (uint8_t)arg_8 = (char)(rcx_29 >> 0x18);
00018394          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_29 >> 0x10);
000183a0          arg_a = (char)(rcx_29 >> 8);
000183ae          arg_8 = arg_8;
000183be          *(uint32_t*)((char*)pContext->st_Device + 0x21) = arg_8;
00018364      }
00018364      
000183e7      uint8_t rdx_22 = -1;
000183f6      uint8_t var_1d3;
000183f6      
000183f6      if (ST_GetU8(&pContext->st_fw, &var_1d3, _st_data_ptr, 0x41, 0x4d))
000183f6          rdx_22 = var_1d3;
000183f6      
00018403      *(uint8_t*)((char*)pContext->st_Device + 0x25) = rdx_22;
0001841d      uint16_t var_191;
0001841d      
0001841d      if (ST_GetU16(&pContext->st_fw, &var_191, _st_data_ptr, 0x80, 0x22))
0001841d      {
0001841f          uint16_t rax_51 = var_191;
00018427          arg_8 = rax_51;
00018436          uint16_t rcx_33;
00018436          (uint8_t)rcx_33 = (rax_51 >> 8) ^ (uint8_t)rax_51;
00018438          (uint8_t)rax_51 = *(uint8_t*)((char*)arg_8)[1];
0001843f          (uint8_t)rax_51 ^= (uint8_t)rcx_33;
00018441          (uint8_t)rcx_33 ^= (uint8_t)rax_51;
00018443          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_51;
0001844a          (uint8_t)arg_8 = (uint8_t)rcx_33;
00018459          *(uint16_t*)((char*)pContext->st_Device + 0x67) = arg_8;
0001841d      }
0001841d      
00018484      uint16_t var_18f;
00018484      
00018484      if (ST_GetU16(&pContext->st_fw, &var_18f, _st_data_ptr, 0x80, 0x23))
00018484      {
00018486          uint16_t rax_54 = var_18f;
0001848e          arg_8 = rax_54;
0001849d          uint16_t rcx_35;
0001849d          (uint8_t)rcx_35 = (rax_54 >> 8) ^ (uint8_t)rax_54;
0001849f          (uint8_t)rax_54 = *(uint8_t*)((char*)arg_8)[1];
000184a6          (uint8_t)rax_54 ^= (uint8_t)rcx_35;
000184a8          (uint8_t)rcx_35 ^= (uint8_t)rax_54;
000184aa          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_54;
000184b1          (uint8_t)arg_8 = (uint8_t)rcx_35;
000184c0          *(uint16_t*)((char*)pContext->st_Device + 0x69) = arg_8;
00018484      }
00018484      
000184ed      uint16_t var_18d;
000184ed      
000184ed      if (ST_GetU16(&pContext->st_fw, &var_18d, _st_data_ptr, 0x90, 0x78))
000184ed      {
000184ef          uint16_t rax_57 = var_18d;
000184f7          arg_8 = rax_57;
00018506          uint16_t rcx_37;
00018506          (uint8_t)rcx_37 = (rax_57 >> 8) ^ (uint8_t)rax_57;
00018508          (uint8_t)rax_57 = *(uint8_t*)((char*)arg_8)[1];
0001850f          (uint8_t)rax_57 ^= (uint8_t)rcx_37;
00018511          (uint8_t)rcx_37 ^= (uint8_t)rax_57;
00018513          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_57;
0001851a          (uint8_t)arg_8 = (uint8_t)rcx_37;
00018529          *(uint16_t*)((char*)pContext->st_Device + 0x6b) = arg_8;
000184ed      }
000184ed      
00018551      uint16_t var_18b;
00018551      
00018551      if (ST_GetU16(&pContext->st_fw, &var_18b, _st_data_ptr, 0x90, 0x79))
00018551      {
00018553          uint16_t rax_60 = var_18b;
0001855b          arg_8 = rax_60;
0001856a          uint16_t rcx_39;
0001856a          (uint8_t)rcx_39 = (rax_60 >> 8) ^ (uint8_t)rax_60;
0001856c          (uint8_t)rax_60 = *(uint8_t*)((char*)arg_8)[1];
00018573          (uint8_t)rax_60 ^= (uint8_t)rcx_39;
00018575          (uint8_t)rcx_39 ^= (uint8_t)rax_60;
00018577          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_60;
0001857e          (uint8_t)arg_8 = (uint8_t)rcx_39;
0001858d          *(uint16_t*)((char*)pContext->st_Device + 0x6d) = arg_8;
00018551      }
00018551      
000185b5      uint16_t var_189;
000185b5      
000185b5      if (ST_GetU16(&pContext->st_fw, &var_189, _st_data_ptr, 0x90, 0x7a))
000185b5      {
000185b7          uint16_t rax_63 = var_189;
000185bf          arg_8 = rax_63;
000185ce          uint16_t rcx_41;
000185ce          (uint8_t)rcx_41 = (rax_63 >> 8) ^ (uint8_t)rax_63;
000185d0          (uint8_t)rax_63 = *(uint8_t*)((char*)arg_8)[1];
000185d7          (uint8_t)rax_63 ^= (uint8_t)rcx_41;
000185d9          (uint8_t)rcx_41 ^= (uint8_t)rax_63;
000185db          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_63;
000185e2          (uint8_t)arg_8 = (uint8_t)rcx_41;
000185f1          *(uint16_t*)((char*)pContext->st_Device + 0x6f) = arg_8;
000185b5      }
000185b5      
00018619      uint16_t var_187;
00018619      
00018619      if (ST_GetU16(&pContext->st_fw, &var_187, _st_data_ptr, 0x90, 0x7b))
00018619      {
0001861b          uint16_t rax_66 = var_187;
00018623          arg_8 = rax_66;
00018632          uint16_t rcx_43;
00018632          (uint8_t)rcx_43 = (rax_66 >> 8) ^ (uint8_t)rax_66;
00018634          (uint8_t)rax_66 = *(uint8_t*)((char*)arg_8)[1];
0001863b          (uint8_t)rax_66 ^= (uint8_t)rcx_43;
0001863d          (uint8_t)rcx_43 ^= (uint8_t)rax_66;
0001863f          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_66;
00018646          (uint8_t)arg_8 = (uint8_t)rcx_43;
00018655          *(uint16_t*)((char*)pContext->st_Device + 0x71) = arg_8;
00018619      }
00018619      
00018685      uint16_t var_185;
00018685      
00018685      if (ST_GetU16(&pContext->st_fw, &var_185, _st_data_ptr, 0x20, 0x22))
00018685      {
00018687          uint16_t rax_69 = var_185;
0001868f          arg_8 = rax_69;
0001869e          uint16_t rcx_45;
0001869e          (uint8_t)rcx_45 = (rax_69 >> 8) ^ (uint8_t)rax_69;
000186a0          (uint8_t)rax_69 = *(uint8_t*)((char*)arg_8)[1];
000186a7          (uint8_t)rax_69 ^= (uint8_t)rcx_45;
000186a9          (uint8_t)rcx_45 ^= (uint8_t)rax_69;
000186ab          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_69;
000186b2          (uint8_t)arg_8 = (uint8_t)rcx_45;
000186c1          *(uint16_t*)((char*)pContext->st_Device + 0x73) = arg_8;
00018685      }
00018685      
000186e9      uint16_t var_183;
000186e9      
000186e9      if (ST_GetU16(&pContext->st_fw, &var_183, _st_data_ptr, 0x20, 0x23))
000186e9      {
000186eb          uint16_t rax_72 = var_183;
000186f3          arg_8 = rax_72;
00018702          uint16_t rcx_47;
00018702          (uint8_t)rcx_47 = (rax_72 >> 8) ^ (uint8_t)rax_72;
00018704          (uint8_t)rax_72 = *(uint8_t*)((char*)arg_8)[1];
0001870b          (uint8_t)rax_72 ^= (uint8_t)rcx_47;
0001870d          (uint8_t)rcx_47 ^= (uint8_t)rax_72;
0001870f          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_72;
00018716          (uint8_t)arg_8 = (uint8_t)rcx_47;
00018725          *(uint16_t*)((char*)pContext->st_Device + 0x75) = arg_8;
000186e9      }
000186e9      
00018750      uint16_t var_181;
00018750      
00018750      if (ST_GetU16(&pContext->st_fw, &var_181, _st_data_ptr, 0x20, 0x98))
00018750      {
00018752          uint16_t rax_75 = var_181;
0001875a          arg_8 = rax_75;
00018769          uint16_t rcx_49;
00018769          (uint8_t)rcx_49 = (rax_75 >> 8) ^ (uint8_t)rax_75;
0001876b          (uint8_t)rax_75 = *(uint8_t*)((char*)arg_8)[1];
00018772          (uint8_t)rax_75 ^= (uint8_t)rcx_49;
00018774          (uint8_t)rcx_49 ^= (uint8_t)rax_75;
00018776          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_75;
0001877d          (uint8_t)arg_8 = (uint8_t)rcx_49;
0001878c          *(uint16_t*)((char*)pContext->st_Device + 0x77) = arg_8;
00018750      }
00018750      
000187b7      uint16_t var_17f;
000187b7      
000187b7      if (ST_GetU16(&pContext->st_fw, &var_17f, _st_data_ptr, 0x20, 0x99))
000187b7      {
000187b9          uint16_t rax_78 = var_17f;
000187c1          arg_8 = rax_78;
000187d0          uint16_t rcx_51;
000187d0          (uint8_t)rcx_51 = (rax_78 >> 8) ^ (uint8_t)rax_78;
000187d2          (uint8_t)rax_78 = *(uint8_t*)((char*)arg_8)[1];
000187d9          (uint8_t)rax_78 ^= (uint8_t)rcx_51;
000187db          (uint8_t)rcx_51 ^= (uint8_t)rax_78;
000187dd          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_78;
000187e4          (uint8_t)arg_8 = (uint8_t)rcx_51;
000187f3          *(uint16_t*)((char*)pContext->st_Device + 0x79) = arg_8;
000187b7      }
000187b7      
00018823      uint8_t var_17d;
00018823      
00018823      if (ST_GetU8(&pContext->st_fw, &var_17d, _st_data_ptr, 2, 0x84))
0001882c          *(uint8_t*)((char*)pContext->st_Device + 0x7b) = var_17d;
0001882c      
00018856      uint8_t var_17c;
00018856      
00018856      if (ST_GetU32(&pContext->st_fw, &var_17c, _st_data_ptr, 2, 0xcf))
00018856      {
0001885f          uint8_t var_179;
0001885f          (uint8_t)arg_8 = var_179;
0001886d          uint8_t var_17a;
0001886d          *(uint8_t*)((char*)arg_8)[1] = var_17a;
0001887b          uint8_t var_17b;
0001887b          arg_a = var_17b;
00018889          arg_b = var_17c;
00018897          *(uint32_t*)((char*)pContext->st_Device + 0x7c) = arg_8;
00018856      }
00018856      
000188c1      float var_178;
000188c1      
000188c1      if (ST_GetFloat(&pContext->st_fw, &var_178, _st_data_ptr, 2, 0x1b))
000188c1      {
000188cc          arg_8 = var_178;
000188d5          int32_t rcx_55 = arg_8;
000188dc          arg_b = (uint8_t)rcx_55;
000188e8          (uint8_t)arg_8 = (char)(rcx_55 >> 0x18);
000188f4          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_55 >> 0x10);
00018900          arg_a = (char)(rcx_55 >> 8);
0001890e          arg_8 = arg_8;
0001891e          *(uint32_t*)((char*)pContext->st_Device + 0x80) = arg_8;
000188c1      }
000188c1      
0001894a      float var_174;
0001894a      
0001894a      if (ST_GetFloat(&pContext->st_fw, &var_174, _st_data_ptr, 2, 0x1c))
0001894a      {
00018955          arg_8 = var_174;
0001895e          int32_t rcx_57 = arg_8;
00018965          arg_b = (uint8_t)rcx_57;
00018971          (uint8_t)arg_8 = (char)(rcx_57 >> 0x18);
0001897d          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_57 >> 0x10);
00018989          arg_a = (char)(rcx_57 >> 8);
00018997          arg_8 = arg_8;
000189a7          *(uint32_t*)((char*)pContext->st_Device + 0x84) = arg_8;
0001894a      }
0001894a      
000189d3      uint16_t var_170;
000189d3      
000189d3      if (ST_GetU16(&pContext->st_fw, &var_170, _st_data_ptr, 2, 0x6b))
000189d3      {
000189d5          uint16_t rax_100 = var_170;
000189dd          arg_8 = rax_100;
000189ec          uint16_t rcx_59;
000189ec          (uint8_t)rcx_59 = (rax_100 >> 8) ^ (uint8_t)rax_100;
000189ee          (uint8_t)rax_100 = *(uint8_t*)((char*)arg_8)[1];
000189f5          (uint8_t)rax_100 ^= (uint8_t)rcx_59;
000189f7          (uint8_t)rcx_59 ^= (uint8_t)rax_100;
000189f9          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_100;
00018a00          (uint8_t)arg_8 = (uint8_t)rcx_59;
00018a0f          *(uint16_t*)((char*)pContext->st_Device + 0x88) = arg_8;
000189d3      }
000189d3      
00018a3a      float var_16e;
00018a3a      
00018a3a      if (ST_GetFloat(&pContext->st_fw, &var_16e, _st_data_ptr, 2, 0xd5))
00018a3a      {
00018a45          arg_8 = var_16e;
00018a4e          int32_t rcx_61 = arg_8;
00018a55          arg_b = (uint8_t)rcx_61;
00018a61          (uint8_t)arg_8 = (char)(rcx_61 >> 0x18);
00018a6d          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_61 >> 0x10);
00018a79          arg_a = (char)(rcx_61 >> 8);
00018a87          arg_8 = arg_8;
00018a97          *(uint32_t*)((char*)pContext->st_Device + 0x8a) = arg_8;
00018a3a      }
00018a3a      
00018ac3      float var_16a;
00018ac3      
00018ac3      if (ST_GetFloat(&pContext->st_fw, &var_16a, _st_data_ptr, 2, 0xd6))
00018ac3      {
00018ace          arg_8 = var_16a;
00018ad7          int32_t rcx_63 = arg_8;
00018ade          arg_b = (uint8_t)rcx_63;
00018aea          (uint8_t)arg_8 = (char)(rcx_63 >> 0x18);
00018af6          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_63 >> 0x10);
00018b02          arg_a = (char)(rcx_63 >> 8);
00018b10          arg_8 = arg_8;
00018b20          *(uint32_t*)((char*)pContext->st_Device + 0x8e) = arg_8;
00018ac3      }
00018ac3      
00018b4c      uint16_t var_166;
00018b4c      
00018b4c      if (ST_GetU16(&pContext->st_fw, &var_166, _st_data_ptr, 2, 0xd7))
00018b4c      {
00018b4e          uint16_t rax_119 = var_166;
00018b56          arg_8 = rax_119;
00018b65          uint16_t rcx_65;
00018b65          (uint8_t)rcx_65 = (rax_119 >> 8) ^ (uint8_t)rax_119;
00018b67          (uint8_t)rax_119 = *(uint8_t*)((char*)arg_8)[1];
00018b6e          (uint8_t)rax_119 ^= (uint8_t)rcx_65;
00018b70          (uint8_t)rcx_65 ^= (uint8_t)rax_119;
00018b72          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_119;
00018b79          (uint8_t)arg_8 = (uint8_t)rcx_65;
00018b88          *(uint16_t*)((char*)pContext->st_Device + 0x92) = arg_8;
00018b4c      }
00018b4c      
00018bb3      uint16_t var_164;
00018bb3      
00018bb3      if (ST_GetU16(&pContext->st_fw, &var_164, _st_data_ptr, 2, 0xd8))
00018bb3      {
00018bb5          uint16_t rax_122 = var_164;
00018bbd          arg_8 = rax_122;
00018bcc          uint16_t rcx_67;
00018bcc          (uint8_t)rcx_67 = (rax_122 >> 8) ^ (uint8_t)rax_122;
00018bce          (uint8_t)rax_122 = *(uint8_t*)((char*)arg_8)[1];
00018bd5          (uint8_t)rax_122 ^= (uint8_t)rcx_67;
00018bd7          (uint8_t)rcx_67 ^= (uint8_t)rax_122;
00018bd9          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_122;
00018be0          (uint8_t)arg_8 = (uint8_t)rcx_67;
00018bef          *(uint16_t*)((char*)pContext->st_Device + 0x94) = arg_8;
00018bb3      }
00018bb3      
00018c1a      uint16_t var_162;
00018c1a      
00018c1a      if (ST_GetU16(&pContext->st_fw, &var_162, _st_data_ptr, 2, 0xd9))
00018c1a      {
00018c1c          uint16_t rax_125 = var_162;
00018c24          arg_8 = rax_125;
00018c33          uint16_t rcx_69;
00018c33          (uint8_t)rcx_69 = (rax_125 >> 8) ^ (uint8_t)rax_125;
00018c35          (uint8_t)rax_125 = *(uint8_t*)((char*)arg_8)[1];
00018c3c          (uint8_t)rax_125 ^= (uint8_t)rcx_69;
00018c3e          (uint8_t)rcx_69 ^= (uint8_t)rax_125;
00018c40          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_125;
00018c47          (uint8_t)arg_8 = (uint8_t)rcx_69;
00018c56          *(uint16_t*)((char*)pContext->st_Device + 0x96) = arg_8;
00018c1a      }
00018c1a      
00018c81      uint16_t var_160;
00018c81      
00018c81      if (ST_GetU16(&pContext->st_fw, &var_160, _st_data_ptr, 2, 0xda))
00018c81      {
00018c83          uint16_t rax_128 = var_160;
00018c8b          arg_8 = rax_128;
00018c9a          uint16_t rcx_71;
00018c9a          (uint8_t)rcx_71 = (rax_128 >> 8) ^ (uint8_t)rax_128;
00018c9c          (uint8_t)rax_128 = *(uint8_t*)((char*)arg_8)[1];
00018ca3          (uint8_t)rax_128 ^= (uint8_t)rcx_71;
00018ca5          (uint8_t)rcx_71 ^= (uint8_t)rax_128;
00018ca7          *(uint8_t*)((char*)arg_8)[1] = (uint8_t)rax_128;
00018cae          (uint8_t)arg_8 = (uint8_t)rcx_71;
00018cbd          *(uint16_t*)((char*)pContext->st_Device + 0x98) = arg_8;
00018c81      }
00018c81      
00018ce8      uint8_t var_15e;
00018ce8      
00018ce8      if (ST_GetU32(&pContext->st_fw, &var_15e, _st_data_ptr, 2, 0xdb))
00018ce8      {
00018cf1          uint8_t var_15b;
00018cf1          (uint8_t)arg_8 = var_15b;
00018cff          uint8_t var_15c;
00018cff          *(uint8_t*)((char*)arg_8)[1] = var_15c;
00018d0d          uint8_t var_15d;
00018d0d          arg_a = var_15d;
00018d1b          arg_b = var_15e;
00018d29          *(uint32_t*)((char*)pContext->st_Device + 0x9a) = arg_8;
00018ce8      }
00018ce8      
00018d59      float var_15a;
00018d59      
00018d59      if (ST_GetFloat(&pContext->st_fw, &var_15a, _st_data_ptr, 0xf1, 0xd3))
00018d59      {
00018d64          arg_8 = var_15a;
00018d6d          int32_t rcx_74 = arg_8;
00018d74          arg_b = (uint8_t)rcx_74;
00018d80          (uint8_t)arg_8 = (char)(rcx_74 >> 0x18);
00018d8c          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_74 >> 0x10);
00018d98          arg_a = (char)(rcx_74 >> 8);
00018da6          arg_8 = arg_8;
00018db6          *(uint32_t*)((char*)pContext->st_Device + 0x9e) = arg_8;
00018d59      }
00018d59      
00018de2      float var_152;
00018de2      
00018de2      if (ST_GetFloat(&pContext->st_fw, &var_152, _st_data_ptr, 0xf1, 0x29))
00018de2      {
00018ded          arg_8 = var_152;
00018df6          int32_t rcx_76 = arg_8;
00018dfd          arg_b = (uint8_t)rcx_76;
00018e09          (uint8_t)arg_8 = (char)(rcx_76 >> 0x18);
00018e15          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_76 >> 0x10);
00018e21          arg_a = (char)(rcx_76 >> 8);
00018e2f          arg_8 = arg_8;
00018e3f          *(uint32_t*)((char*)pContext->st_Device + 0xa6) = arg_8;
00018de2      }
00018de2      
00018e6b      float var_14e;
00018e6b      
00018e6b      if (ST_GetFloat(&pContext->st_fw, &var_14e, _st_data_ptr, 0xf1, 0x2a))
00018e6b      {
00018e76          arg_8 = var_14e;
00018e7f          int32_t rcx_78 = arg_8;
00018e86          arg_b = (uint8_t)rcx_78;
00018e92          (uint8_t)arg_8 = (char)(rcx_78 >> 0x18);
00018e9e          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_78 >> 0x10);
00018eaa          arg_a = (char)(rcx_78 >> 8);
00018eb8          arg_8 = arg_8;
00018ec8          *(uint32_t*)((char*)pContext->st_Device + 0xaa) = arg_8;
00018e6b      }
00018e6b      
00018ef4      float var_156;
00018ef4      
00018ef4      if (ST_GetFloat(&pContext->st_fw, &var_156, _st_data_ptr, 0xf1, 0xbd))
00018ef4      {
00018eff          arg_8 = var_156;
00018f08          int32_t rcx_80 = arg_8;
00018f0f          arg_b = (uint8_t)rcx_80;
00018f1b          (uint8_t)arg_8 = (char)(rcx_80 >> 0x18);
00018f27          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_80 >> 0x10);
00018f33          arg_a = (char)(rcx_80 >> 8);
00018f41          arg_8 = arg_8;
00018f51          *(uint32_t*)((char*)pContext->st_Device + 0xa2) = arg_8;
00018ef4      }
00018ef4      
00018f83      uint8_t var_142[0x11a];
00018f83      
00018f83      if (ST_GetU8(&pContext->st_fw, &var_142, _st_data_ptr, 0x82, 0x65))
00018f8c          *(uint8_t*)((char*)pContext->st_Device + 0xb6) = var_142[0];
00018f8c      
00018fb6      float var_146;
00018fb6      
00018fb6      if (ST_GetFloat(&pContext->st_fw, &var_146, _st_data_ptr, 0x82, 0xd3))
00018fb6      {
00018fc1          arg_8 = var_146;
00018fca          int32_t rcx_83 = arg_8;
00018fd1          arg_b = (uint8_t)rcx_83;
00018fdd          (uint8_t)arg_8 = (char)(rcx_83 >> 0x18);
00018fe9          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_83 >> 0x10);
00018ff5          arg_a = (char)(rcx_83 >> 8);
00019003          arg_8 = arg_8;
00019013          *(uint32_t*)((char*)pContext->st_Device + 0xb2) = arg_8;
00018fb6      }
00018fb6      
0001903f      float var_14a;
0001903f      
0001903f      if (ST_GetFloat(&pContext->st_fw, &var_14a, _st_data_ptr, 0x82, 0xcf))
0001903f      {
0001904a          arg_8 = var_14a;
00019053          int32_t rcx_85 = arg_8;
0001905a          arg_b = (uint8_t)rcx_85;
00019066          (uint8_t)arg_8 = (char)(rcx_85 >> 0x18);
00019072          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_85 >> 0x10);
0001907e          arg_a = (char)(rcx_85 >> 8);
0001908c          arg_8 = arg_8;
0001909c          *(uint32_t*)((char*)pContext->st_Device + 0xae) = arg_8;
0001903f      }
0001903f      
000190b1      fw_loadStDeviceCam(pContext, _st_data_ptr, 0x30, 0);
000190c9      fw_loadStDeviceCam(pContext, _st_data_ptr, 0x40, 1);
000190dc      fw_loadStDeviceCam(pContext, _st_data_ptr, 0x50, 2);
000190f1      fw_loadStDeviceCam(pContext, _st_data_ptr, 0x60, 3);
0001911c      uint8_t var_1d2;
0001911c      
0001911c      if (ST_GetU8(&pContext->st_fw, &var_1d2, _st_data_ptr, 0x70, 0x3a))
00019122          *(uint8_t*)((char*)pContext->st_Device + 0x26) = var_1d2;
00019122      
00019146      float var_1d1;
00019146      
00019146      if (ST_GetFloat(&pContext->st_fw, &var_1d1, _st_data_ptr, 0x70, 0x3b))
00019146      {
0001914e          arg_8 = var_1d1;
00019157          int32_t rcx_92 = arg_8;
0001915e          arg_b = (uint8_t)rcx_92;
0001916a          (uint8_t)arg_8 = (char)(rcx_92 >> 0x18);
00019176          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_92 >> 0x10);
00019182          arg_a = (char)(rcx_92 >> 8);
00019190          arg_8 = arg_8;
000191a0          *(uint32_t*)((char*)pContext->st_Device + 0x27) = arg_8;
00019146      }
00019146      
000191c6      float var_1cd;
000191c6      
000191c6      if (ST_GetFloat(&pContext->st_fw, &var_1cd, _st_data_ptr, 0x70, 0x3c))
000191c6      {
000191ce          arg_8 = var_1cd;
000191d7          int32_t rcx_94 = arg_8;
000191de          arg_b = (uint8_t)rcx_94;
000191ea          (uint8_t)arg_8 = (char)(rcx_94 >> 0x18);
000191f6          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_94 >> 0x10);
00019202          arg_a = (char)(rcx_94 >> 8);
00019210          arg_8 = arg_8;
00019220          *(uint32_t*)((char*)pContext->st_Device + 0x2b) = arg_8;
000191c6      }
000191c6      
00019246      float var_1c9;
00019246      
00019246      if (ST_GetFloat(&pContext->st_fw, &var_1c9, _st_data_ptr, 0x70, 0x3d))
00019246      {
0001924e          arg_8 = var_1c9;
00019257          int32_t rcx_96 = arg_8;
0001925e          arg_b = (uint8_t)rcx_96;
0001926a          (uint8_t)arg_8 = (char)(rcx_96 >> 0x18);
00019276          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_96 >> 0x10);
00019282          arg_a = (char)(rcx_96 >> 8);
00019290          arg_8 = arg_8;
000192a0          *(uint32_t*)((char*)pContext->st_Device + 0x2f) = arg_8;
00019246      }
00019246      
000192c6      float var_1c5;
000192c6      
000192c6      if (ST_GetFloat(&pContext->st_fw, &var_1c5, _st_data_ptr, 0x70, 0x3e))
000192c6      {
000192ce          arg_8 = var_1c5;
000192d7          int32_t rcx_98 = arg_8;
000192de          arg_b = (uint8_t)rcx_98;
000192ea          (uint8_t)arg_8 = (char)(rcx_98 >> 0x18);
000192f6          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_98 >> 0x10);
00019302          arg_a = (char)(rcx_98 >> 8);
00019310          arg_8 = arg_8;
00019320          *(uint32_t*)((char*)pContext->st_Device + 0x33) = arg_8;
000192c6      }
000192c6      
00019346      float var_1c1;
00019346      
00019346      if (ST_GetFloat(&pContext->st_fw, &var_1c1, _st_data_ptr, 0x70, 0x3f))
00019346      {
0001934e          arg_8 = var_1c1;
00019357          int32_t rcx_100 = arg_8;
0001935e          arg_b = (uint8_t)rcx_100;
0001936a          (uint8_t)arg_8 = (char)(rcx_100 >> 0x18);
00019376          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_100 >> 0x10);
00019382          arg_a = (char)(rcx_100 >> 8);
00019390          arg_8 = arg_8;
000193a0          *(uint32_t*)((char*)pContext->st_Device + 0x37) = arg_8;
00019346      }
00019346      
000193c3      float var_1bd;
000193c3      
000193c3      if (ST_GetFloat(&pContext->st_fw, &var_1bd, _st_data_ptr, 0x70, 0x40))
000193c3      {
000193cb          arg_8 = var_1bd;
000193d4          int32_t rcx_102 = arg_8;
000193db          arg_b = (uint8_t)rcx_102;
000193e7          (uint8_t)arg_8 = (char)(rcx_102 >> 0x18);
000193f3          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_102 >> 0x10);
000193ff          arg_a = (char)(rcx_102 >> 8);
0001940d          arg_8 = arg_8;
0001941d          *(uint32_t*)((char*)pContext->st_Device + 0x3b) = arg_8;
000193c3      }
000193c3      
00019440      float var_1b9;
00019440      
00019440      if (ST_GetFloat(&pContext->st_fw, &var_1b9, _st_data_ptr, 0x70, 0x41))
00019440      {
00019448          arg_8 = var_1b9;
00019451          int32_t rcx_104 = arg_8;
00019458          arg_b = (uint8_t)rcx_104;
00019464          (uint8_t)arg_8 = (char)(rcx_104 >> 0x18);
00019470          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_104 >> 0x10);
0001947c          arg_a = (char)(rcx_104 >> 8);
0001948a          arg_8 = arg_8;
0001949a          *(uint32_t*)((char*)pContext->st_Device + 0x3f) = arg_8;
00019440      }
00019440      
000194c0      float var_1b5;
000194c0      
000194c0      if (ST_GetFloat(&pContext->st_fw, &var_1b5, _st_data_ptr, 0x70, 0x42))
000194c0      {
000194c8          arg_8 = var_1b5;
000194d1          int32_t rcx_106 = arg_8;
000194d8          arg_b = (uint8_t)rcx_106;
000194e4          (uint8_t)arg_8 = (char)(rcx_106 >> 0x18);
000194f0          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_106 >> 0x10);
000194fc          arg_a = (char)(rcx_106 >> 8);
0001950a          arg_8 = arg_8;
0001951a          *(uint32_t*)((char*)pContext->st_Device + 0x43) = arg_8;
000194c0      }
000194c0      
00019540      float var_1b1;
00019540      
00019540      if (ST_GetFloat(&pContext->st_fw, &var_1b1, _st_data_ptr, 0x70, 0x43))
00019540      {
00019548          arg_8 = var_1b1;
00019551          int32_t rcx_108 = arg_8;
00019558          arg_b = (uint8_t)rcx_108;
00019564          (uint8_t)arg_8 = (char)(rcx_108 >> 0x18);
00019570          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_108 >> 0x10);
0001957c          arg_a = (char)(rcx_108 >> 8);
0001958a          arg_8 = arg_8;
0001959a          *(uint32_t*)((char*)pContext->st_Device + 0x47) = arg_8;
00019540      }
00019540      
000195c0      float var_1ad;
000195c0      
000195c0      if (ST_GetFloat(&pContext->st_fw, &var_1ad, _st_data_ptr, 0x70, 0x44))
000195c0      {
000195c8          arg_8 = var_1ad;
000195d1          int32_t rcx_110 = arg_8;
000195d8          arg_b = (uint8_t)rcx_110;
000195e4          (uint8_t)arg_8 = (char)(rcx_110 >> 0x18);
000195f0          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_110 >> 0x10);
000195fc          arg_a = (char)(rcx_110 >> 8);
0001960a          arg_8 = arg_8;
0001961a          *(uint32_t*)((char*)pContext->st_Device + 0x4b) = arg_8;
000195c0      }
000195c0      
00019640      float var_1a9;
00019640      
00019640      if (ST_GetFloat(&pContext->st_fw, &var_1a9, _st_data_ptr, 0x70, 0x45))
00019640      {
00019648          arg_8 = var_1a9;
00019651          int32_t rcx_112 = arg_8;
00019658          arg_b = (uint8_t)rcx_112;
00019664          (uint8_t)arg_8 = (char)(rcx_112 >> 0x18);
00019670          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_112 >> 0x10);
0001967c          arg_a = (char)(rcx_112 >> 8);
0001968a          arg_8 = arg_8;
0001969a          *(uint32_t*)((char*)pContext->st_Device + 0x4f) = arg_8;
00019640      }
00019640      
000196c3      float var_1a5;
000196c3      
000196c3      if (ST_GetFloat(&pContext->st_fw, &var_1a5, _st_data_ptr, 0x70, 0x46))
000196c3      {
000196ce          arg_8 = var_1a5;
000196d7          int32_t rcx_114 = arg_8;
000196de          arg_b = (uint8_t)rcx_114;
000196ea          (uint8_t)arg_8 = (char)(rcx_114 >> 0x18);
000196f6          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_114 >> 0x10);
00019702          arg_a = (char)(rcx_114 >> 8);
00019710          arg_8 = arg_8;
00019720          *(uint32_t*)((char*)pContext->st_Device + 0x53) = arg_8;
000196c3      }
000196c3      
00019749      float var_1a1;
00019749      
00019749      if (ST_GetFloat(&pContext->st_fw, &var_1a1, _st_data_ptr, 0x70, 0x47))
00019749      {
00019754          arg_8 = var_1a1;
0001975d          int32_t rcx_116 = arg_8;
00019764          arg_b = (uint8_t)rcx_116;
00019770          (uint8_t)arg_8 = (char)(rcx_116 >> 0x18);
0001977c          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_116 >> 0x10);
00019788          arg_a = (char)(rcx_116 >> 8);
00019796          arg_8 = arg_8;
000197a6          *(uint32_t*)((char*)pContext->st_Device + 0x57) = arg_8;
00019749      }
00019749      
000197cf      float var_19d;
000197cf      
000197cf      if (ST_GetFloat(&pContext->st_fw, &var_19d, _st_data_ptr, 0x70, 0x48))
000197cf      {
000197da          arg_8 = var_19d;
000197e3          int32_t rcx_118 = arg_8;
000197ea          arg_b = (uint8_t)rcx_118;
000197f6          (uint8_t)arg_8 = (char)(rcx_118 >> 0x18);
00019802          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_118 >> 0x10);
0001980e          arg_a = (char)(rcx_118 >> 8);
0001981c          arg_8 = arg_8;
0001982c          *(uint32_t*)((char*)pContext->st_Device + 0x5b) = arg_8;
000197cf      }
000197cf      
00019855      float var_199;
00019855      
00019855      if (ST_GetFloat(&pContext->st_fw, &var_199, _st_data_ptr, 0x70, 0x49))
00019855      {
00019860          arg_8 = var_199;
00019869          int32_t rdx_72 = arg_8;
00019870          arg_b = (uint8_t)rdx_72;
0001987c          (uint8_t)arg_8 = (char)(rdx_72 >> 0x18);
00019888          *(uint8_t*)((char*)arg_8)[1] = (char)(rdx_72 >> 0x10);
00019894          arg_a = (char)(rdx_72 >> 8);
000198a2          arg_8 = arg_8;
000198b2          *(uint32_t*)((char*)pContext->st_Device + 0x5f) = arg_8;
00019855      }
00019855      
000198db      float var_195;
000198db      
000198db      if (ST_GetFloat(&pContext->st_fw, &var_195, _st_data_ptr, 0x70, 0x4a))
000198db      {
000198e6          arg_8 = var_195;
000198ef          int32_t rcx_121 = arg_8;
000198f6          arg_b = (uint8_t)rcx_121;
00019902          (uint8_t)arg_8 = (char)(rcx_121 >> 0x18);
0001990e          *(uint8_t*)((char*)arg_8)[1] = (char)(rcx_121 >> 0x10);
0001991a          arg_a = (char)(rcx_121 >> 8);
00019928          arg_8 = arg_8;
00019938          *(uint32_t*)((char*)pContext->st_Device + 0x63) = arg_8;
000198db      }
000198db      
00019956      /* tailcall */
00019956      return fw_UpdateCSFDeviceSettings(pContext);
00017d1c  }

0001995b                                                                                   cc cc cc cc cc                             .....
00019960  cc cc cc cc                                                                                      ....

00019964    void fw_UpdateCSFDeviceSettings(struct FwSettings_t* pContext)

00019964  {
00019990      struct fe_device_settings_t settings;
00019990      memset(&settings, 0, 0x184);
00019995      int64_t rsi;
00019995      (uint8_t)rsi = *(uint8_t*)((char*)pContext->st_Device + 0x10);
00019999      int64_t rbp;
00019999      (uint8_t)rbp = *(uint8_t*)((char*)pContext->st_Device + 0xf);
0001999d      (uint8_t)rbp &= 3;
000199a1      settings.numSensors = (uint8_t)rsi;
000199a1      
000199aa      if ((uint8_t)rsi > 4)
000199aa      {
000199c0          onError__("fw_UpdateCSFDeviceSettings: fe_dev_settings.numSensors > MAX_SENSORS", 
000199c0              "c:\development_work\csf_release_hp\driver\translib\fwsettings.c", 0x431);
000199c5          (uint8_t)rsi = 4;
000199c8          settings.numSensors = 4;
000199aa      }
000199aa      
000199cd      char i_1 = 0;
000199cd      
000199d7      if (*(uint8_t*)((char*)pContext->st_Device + 0x25) == 0xff)
000199d7      {
000199e6          uint32_t rcx_1 = (uint32_t)(uint8_t)rbp;
000199e6          
000199ec          if (!rcx_1)
00019a4c              settings.triggers.trigPercentage = 0x42480000;
000199ec          else if (rcx_1 == 1)
00019a4c              settings.triggers.trigPercentage = 0x42840000;
000199f1          else if (rcx_1 == 2)
00019a4c              settings.triggers.trigPercentage = 0x42960000;
000199f6          else if (rcx_1 == 3)
00019a4c              settings.triggers.trigPercentage = 0x42a60000;
000199fb          else
000199fb          {
00019a11              onBug__(
00019a11                  "pSt_Device->Properties has unrecognised trigger level, setting to 75%", 
00019a11                  "c:\development_work\csf_release_hp\driver\translib\fwsettings.c", 0x44b);
00019a1e              settings.triggers.trigPercentage = 0x42960000;
000199fb          }
000199d7      }
000199d7      else
00019a4c          settings.triggers.trigPercentage =
00019a4c              _mm_cvtepi32_ps((uint128_t)*(uint8_t*)((char*)pContext->st_Device + 0x25));
00019a4c      
00019a52      char i = 0;
00019a58      uint128_t zmm0;
00019a58      
00019a58      if ((uint8_t)rsi > 0)
00019a58      {
00019b00          do
00019b00          {
00019a5e              uint64_t i_3 = (uint64_t)i;
00019a62              i += 1;
00019a68              int64_t rdx_1 = i_3 * 0x34;
00019a6c              int64_t rcx_5 = i_3 * 0x45;
00019a81              (uint32_t)zmm0 = (*(uint32_t*)(rcx_5 + pContext + 0xf3)) - 1f;
00019a89              var_170;
00019a89              *(uint16_t*)(&var_170 + rdx_1) = *(uint16_t*)(rcx_5 + pContext + 0xcf);
00019a96              var_16e;
00019a96              *(uint16_t*)(&var_16e + rdx_1) = *(uint16_t*)(rcx_5 + pContext + 0xd1);
00019aa3              var_16c;
00019aa3              *(uint64_t*)(&var_16c + rdx_1) = *(uint64_t*)(rcx_5 + pContext + 0xd3);
00019ab0              var_164;
00019ab0              *(uint64_t*)(&var_164 + rdx_1) = *(uint64_t*)(rcx_5 + pContext + 0xdb);
00019abd              var_15c;
00019abd              *(uint64_t*)(&var_15c + rdx_1) = *(uint64_t*)(rcx_5 + pContext + 0xe3);
00019aca              var_154;
00019aca              *(uint64_t*)(&var_154 + rdx_1) = *(uint64_t*)(rcx_5 + pContext + 0xeb);
00019ad6              var_148;
00019ad6              *(uint32_t*)(&var_148 + rdx_1) = *(uint32_t*)(rcx_5 + pContext + 0xf7);
00019ada              int32_t rax_9 = *(uint32_t*)(rcx_5 + pContext + 0x109);
00019ae1              var_14c;
00019ae1              *(uint32_t*)(&var_14c + rdx_1) = (uint32_t)zmm0;
00019ae7              var_144;
00019ae7              *(uint32_t*)(&var_144 + rdx_1) = rax_9;
00019af3              var_140;
00019af3              *(uint16_t*)(&var_140 + rdx_1) = *(uint16_t*)(rcx_5 + pContext + 0x10d);
00019af8              (uint8_t)rsi = settings.numSensors;
00019b00          } while (i < (uint8_t)rsi);
00019a58      }
00019a58      
00019b0c      uint128_t zmm1;
00019b0c      float y;
00019b0c      
00019b0c      if ((uint8_t)rsi > 0)
00019b0c      {
00019b68          do
00019b68          {
00019b0e              uint64_t i_2 = (uint64_t)i_1;
00019b15              uint64_t r9_1 = i_2 * 3;
00019b19              int64_t r8_1 = i_2 * 0x45;
00019b25              var_a0;
00019b25              *(uint64_t*)(&var_a0 + (r9_1 << 2)) = *(uint64_t*)(r8_1 + pContext + 0xfd);
00019b34              y = pContext->pUserModeContext->DrvSettingsContext.st_Driver.AngleOffset[i_2];
00019b3d              y - 0f;
00019b3d              
00019b42              if (FCMP_UO(y, 0f) || !(y == 0f))
00019b4b                  zmm0 = fw_SetAngleOffset(pContext, (uint32_t)i_1, y);
00019b4b              
00019b58              i_1 += 1;
00019b5b              var_98;
00019b5b              *(uint32_t*)(&var_98 + (r9_1 << 2)) = *(uint32_t*)(r8_1 + pContext + 0x105);
00019b68          } while (i_1 < settings.numSensors);
00019b0c      }
00019b0c      
00019b6a      (uint32_t)zmm1 = settings.sensorInfo[0].position.x;
00019b6a      *(uint32_t*)((char*)zmm1)[4] = settings.sensorInfo[0].position.x;
00019b6a      *(uint32_t*)((char*)zmm1)[8] = settings.sensorInfo[0].position.x;
00019b6a      *(uint32_t*)((char*)zmm1)[0xc] = settings.sensorInfo[0].position.x;
00019b73      settings.sensorInfo[1];
00019b73      settings.sensorInfo[1];
00019b73      settings.sensorInfo[1];
00019b73      float y_1 = settings.sensorInfo[1].position.y;
00019b7c      settings.sensorInfo[0];
00019b7c      settings.sensorInfo[0];
00019b7c      settings.sensorInfo[0];
00019b7c      y = settings.sensorInfo[0].position.y;
00019b85      (uint32_t)zmm1 - 0f;
00019b85      
00019b8a      if (!FCMP_UO((uint32_t)zmm1, 0f) && !((uint32_t)zmm1 != 0f))
00019b8c          y - 0f;
00019b8c      
00019b91      if (FCMP_UO((uint32_t)zmm1, 0f) || (uint32_t)zmm1 != 0f || FCMP_UO(y, 0f) || y != 0f)
00019b91      {
00019bc3          (uint32_t)zmm0 = settings.sensorInfo[1].position.x;
00019bc3          *(uint32_t*)((char*)zmm0)[4] = settings.sensorInfo[1].position.x;
00019bc3          *(uint32_t*)((char*)zmm0)[8] = settings.sensorInfo[1].position.x;
00019bc3          *(uint32_t*)((char*)zmm0)[0xc] = settings.sensorInfo[1].position.x;
00019b91      }
00019b91      else
00019b91      {
00019b93          (uint32_t)zmm0 = settings.sensorInfo[1].position.x;
00019b93          *(uint32_t*)((char*)zmm0)[4] = settings.sensorInfo[1].position.x;
00019b93          *(uint32_t*)((char*)zmm0)[8] = settings.sensorInfo[1].position.x;
00019b93          *(uint32_t*)((char*)zmm0)[0xc] = settings.sensorInfo[1].position.x;
00019b9c          (uint32_t)zmm0 - 0f;
00019b9c          
00019ba1          if (!FCMP_UO((uint32_t)zmm0, 0f) && !((uint32_t)zmm0 != 0f))
00019ba1          {
00019ba3              y_1 - 0f;
00019ba3              
00019ba8              if (!FCMP_UO(y_1, 0f) && !(y_1 != 0f))
00019ba8              {
00019bb5                  zmm0 = _mm_cvtepi32_ps((uint128_t)
00019bb5                      *(uint16_t*)((char*)pContext->st_Device + 0x73));
00019bb8                  settings.sensorInfo[1].position.x = (uint32_t)zmm0;
00019ba8              }
00019ba1          }
00019b91      }
00019b91      
00019bd4      (uint32_t)zmm1 - -1f;
00019bd4      
00019bd9      if (!FCMP_UO((uint32_t)zmm1, -1f) && !((uint32_t)zmm1 != -1f))
00019bd9      {
00019bdb          y - -1f;
00019bdb          
00019be0          if (!FCMP_UO(y, -1f) && !(y != -1f))
00019be0          {
00019be2              (uint32_t)zmm0 - -1f;
00019be2              
00019be7              if (!FCMP_UO((uint32_t)zmm0, -1f) && !((uint32_t)zmm0 != -1f))
00019be7              {
00019be9                  y_1 - -1f;
00019be9                  
00019bee                  if (!FCMP_UO(y_1, -1f) && !(y_1 != -1f))
00019bee                  {
00019bf7                      zmm1 = {0};
00019bfa                      y = (int32_t){0};
00019bfd                      zmm0 = (uint128_t)*(uint16_t*)((char*)pContext->st_Device + 0x73);
00019c01                      y_1 = (int32_t){0};
00019c04                      __builtin_memset(&settings.sensorInfo, 0, 8);
00019c16                      settings.sensorInfo[1].position.y = 0;
00019c1f                      zmm0 = _mm_cvtepi32_ps(zmm0);
00019c22                      settings.sensorInfo[1].position.x = (uint32_t)zmm0;
00019bee                  }
00019be7              }
00019be0          }
00019bd9      }
00019bd9      
00019c2b      (uint32_t)zmm1 - 0f;
00019c2b      
00019c30      if (!FCMP_UO((uint32_t)zmm1, 0f) && !((uint32_t)zmm1 != 0f))
00019c30      {
00019c32          y - 0f;
00019c32          
00019c37          if (!FCMP_UO(y, 0f) && !(y != 0f))
00019c37          {
00019c39              (uint32_t)zmm0 - 1f;
00019c39              
00019c42              if (!FCMP_UO((uint32_t)zmm0, 1f) && !((uint32_t)zmm0 != 1f))
00019c42              {
00019c44                  y_1 - 0f;
00019c44                  
00019c49                  if (!FCMP_UO(y_1, 0f) && !(y_1 != 0f))
00019c59                      settings.sensorInfo[1].position.x = _mm_cvtepi32_ps((uint128_t)
00019c59                          *(uint16_t*)((char*)pContext->st_Device + 0x73));
00019c42              }
00019c37          }
00019c30      }
00019c30      
00019c74      zmm1 = (uint128_t)*(uint16_t*)((char*)pContext->st_Device + 0x75);
00019c78      int32_t rax_19 = *(uint32_t*)((char*)pContext->st_Device + 0x77);
00019c7e      zmm0 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)((char*)pContext->st_Device + 0x73));
00019c81      settings.activeArea.X = (uint16_t)rax_19;
00019c81      settings.activeArea.Y = *(uint16_t*)((char*)rax_19)[2];
00019c88      (uint32_t)zmm0 - 0f;
00019c8b      settings.panelSize.x = (uint32_t)zmm0;
00019c91      zmm1 = _mm_cvtepi32_ps(zmm1);
00019c94      settings.panelSize.y = (uint32_t)zmm1;
00019c94      
00019c9c      if (!FCMP_UO((uint32_t)zmm0, 0f) && !((uint32_t)zmm0 != 0f))
00019c9c      {
00019c9e          (uint32_t)zmm1 - 0f;
00019c9e          
00019ca3          if (!FCMP_UO((uint32_t)zmm1, 0f) && !((uint32_t)zmm1 != 0f))
00019cb5              __builtin_memcpy(&settings.panelSize, "\x00\x00\xfa\x43\x00\x00\x96\x43", 8);
00019c9c      }
00019c9c      
00019cc4      int16_t rcx_7 = *(uint16_t*)((char*)pContext->st_Device + 0x15);
00019cc8      int16_t rdx_3 = *(uint16_t*)((char*)pContext->st_Device + 0x17);
00019cd1      settings.triggers.speedThreshold = *(uint32_t*)((char*)pContext->st_Device + 0x21);
00019cd7      settings.triggers.timeFast = *(uint32_t*)((char*)pContext->st_Device + 0x1b);
00019cdf      settings.triggers.thresholdUp = rcx_7;
00019ce4      settings.triggers.timeSlow = *(uint16_t*)((char*)pContext->st_Device + 0x1f);
00019ced      settings.triggers.thresholdDown = rdx_3;
00019cf2      settings.triggers.thresholdFloor = *(uint16_t*)((char*)pContext->st_Device + 0x19);
00019cf2      
00019d06      if (rcx_7 == 0x19 && rdx_3 == 1)
00019d06      {
00019d08          settings.triggers.thresholdUp = 5;
00019d0d          settings.triggers.thresholdDown = 5;
00019d06      }
00019d06      
00019d28      if (*(uint32_t*)((char*)pContext->st_Device + 0) >= 0xbce
00019d28              && *(uint32_t*)((char*)pContext->st_Device + 0) <= 0xbd1 && rcx_7 == 0x19)
00019d2a          settings.triggers.thresholdUp = 5;
00019d2a      
00019d43      settings.focalLength = *(uint16_t*)((char*)pContext->st_Device + 0xd);
00019d54      settings.penSt.thresholdUp = *(uint32_t*)((char*)pContext->st_Device + 0x80);
00019d65      settings.penSt.thresholdDown = *(uint32_t*)((char*)pContext->st_Device + 0x84);
00019d6e      settings.totalPix = *(uint16_t*)((char*)pContext->st_Device + 0xb);
00019d73      int16_t rax_24;
00019d73      (uint8_t)rax_24 = *(uint8_t*)((char*)pContext->st_Device + 0x7b);
00019d86      settings.penSt.lumiScale = *(uint32_t*)((char*)pContext->st_Device + 0x8e);
00019d8f      settings.penSt.distancePower = *(uint32_t*)((char*)pContext->st_Device + 0x8a);
00019d98      settings.penSt.enabled = (uint8_t)rax_24;
00019da5      settings.penSt.threshold = *(uint32_t*)((char*)pContext->st_Device + 0x7c);
00019db3      settings.penSt.thresholdFloor = *(uint16_t*)((char*)pContext->st_Device + 0x88);
00019dc2      settings.penSt.shutterUp = *(uint16_t*)((char*)pContext->st_Device + 0x92);
00019dd1      settings.penSt.shutterDown = *(uint16_t*)((char*)pContext->st_Device + 0x94);
00019de0      settings.penSt.shutterMin = *(uint16_t*)((char*)pContext->st_Device + 0x96);
00019def      settings.penSt.shutterMax = *(uint16_t*)((char*)pContext->st_Device + 0x98);
00019dfd      settings.penSt.shutterRate = *(uint32_t*)((char*)pContext->st_Device + 0x9a);
00019e04      int64_t rax_32 = *(uint64_t*)((char*)pContext->st_Device + 0xae);
00019e0b      settings.autoCorrect.threshold = (uint32_t)rax_32;
00019e0b      settings.autoCorrect.maxEdgeCorrection = *(uint32_t*)((char*)rax_32)[4];
00019e14      settings.autoCorrect.mode = *(uint32_t*)((char*)pContext->st_Device + 0xb6);
00019e17      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext = pContext->pUserModeContext;
00019e1e      int32_t rax_33;
00019e1e      (uint8_t)rax_33 = pUserModeContext->DrvSettingsContext.st_Driver.AmbientSubON;
00019e28      settings.AmbientSubON = (uint8_t)rax_33;
00019e2c      FE_UpdateDeviceSettings(pUserModeContext->pCSFContext, &settings);
00019e38      struct rect_t r11;
00019e38      r11.left = *(uint16_t*)((char*)pContext->st_Device + 0x6b);
00019e38      r11.top = *(uint16_t*)((char*)pContext->st_Device + 0x6d);
00019e38      r11.right = *(uint16_t*)((char*)pContext->st_Device + 0x6f);
00019e38      r11.bottom = *(uint16_t*)((char*)pContext->st_Device + 0x71);
00019e3c      struct _NW_CSF_CONTEXT* pCSFContext = pContext->pUserModeContext->pCSFContext;
00019e40      pCSFContext->PTContext.Border.left = r11.left;
00019e40      pCSFContext->PTContext.Border.top = r11.top;
00019e40      pCSFContext->PTContext.Border.right = r11.right;
00019e40      pCSFContext->PTContext.Border.bottom = r11.bottom;
00019964  }

00019e65                 cc cc cc cc cc cc cc                                                                   .......

00019e6c    uint8_t DealWithDeltaEncoded(struct Parser_t* pContext, void* DataBuffer, uint32_t DataBufferLength, struct FRAMEHEADER* pFrameHeader, struct SCOPEHEADER* pScopeHeader, uint32_t* dataIdx, uint32_t* waveBufferOffset, uint32_t* waveBufferCount)

00019e6c  {
00019e8a      struct SCOPEHEADER* pScopeHeader_1 = pScopeHeader;
00019eaa      uint64_t pixelStart = (uint64_t)pScopeHeader_1->pixelStart;
00019eaf      int64_t rdi = 0;
00019eb1      struct FRAMEHEADER* pFrameHeader_1 = pFrameHeader;
00019eb4      uint32_t i = DataBufferLength;
00019eba      *(uint32_t*)waveBufferOffset = (uint32_t)pixelStart;
00019ebd      *(uint32_t*)waveBufferCount = 0;
00019ebd      
00019ec9      if (*(uint32_t*)dataIdx < DataBufferLength)
00019ec9      {
00019ed4          void* DataBuffer_1 = DataBuffer;
00019ed9          int64_t rbp_1 = (uint64_t)pFrameHeader->dataSize - 0xb;
00019ed9          
00019f6a          do
00019f6a          {
00019edd              uint64_t r10_1 = (uint64_t)*(uint32_t*)waveBufferCount;
00019edd              
00019ee4              if (r10_1 >= rbp_1)
00019ee4                  break;
00019ee4              
00019eea              DataBuffer = (uint64_t)(uint32_t)(r10_1 + pixelStart);
00019eea              
00019ef0              if ((uint32_t)DataBuffer >= 0x200)
00019ef0                  break;
00019ef0              
00019ef2              uint64_t r9 = (uint64_t)*(uint32_t*)dataIdx;
00019efa              uint64_t rax_1 = (uint64_t)(uint32_t)(r9 + 1);
00019efa              
00019efe              if (*(uint8_t*)(r9 + DataBuffer_1) != 0x80)
00019efe              {
00019f2b                  *(uint32_t*)dataIdx = (uint32_t)rax_1;
00019f2e                  DataBufferLength = 0;
00019f2e                  
00019f35                  if ((uint32_t)r10_1 > 0)
00019f3a                      (uint16_t)DataBufferLength =
00019f3a                          pContext->waveBuffer[(uint64_t)(uint32_t)((char*)DataBuffer - 1)];
00019f3a                  
00019f4a                  if ((uint32_t)(uint16_t)DataBufferLength
00019f4a                          + (int32_t)*(uint8_t*)(r9 + DataBuffer_1) < 0)
00019f5b                      pContext->waveBuffer[DataBuffer] = 0;
00019f4a                  else
00019f55                      pContext->waveBuffer[DataBuffer] =
00019f55                          (int16_t)*(uint8_t*)(r9 + DataBuffer_1)
00019f55                          + (uint16_t)DataBufferLength;
00019efe              }
00019efe              else
00019efe              {
00019f00                  uint64_t r9_1 = (uint64_t)(uint32_t)DataBuffer;
00019f08                  DataBufferLength = (int32_t)(rax_1 + 1);
00019f0c                  (uint16_t)DataBuffer = (uint16_t)*(uint8_t*)(rax_1 + DataBuffer_1) << 8;
00019f14                  pContext->waveBuffer[r9_1] = (uint16_t)DataBuffer;
00019f19                  uint16_t rcx = (uint16_t)*(uint8_t*)(DataBufferLength + DataBuffer_1);
00019f1e                  *(uint32_t*)dataIdx = DataBufferLength + 1;
00019f24                  pContext->waveBuffer[r9_1] = rcx + (uint16_t)DataBuffer;
00019efe              }
00019efe              
00019f63              *(uint32_t*)waveBufferCount = (int32_t)(r10_1 + 1);
00019f6a          } while (*(uint32_t*)dataIdx < i);
00019f6a          
00019f70          pScopeHeader_1 = pScopeHeader;
00019f78          pFrameHeader_1 = pFrameHeader;
00019ec9      }
00019ec9      
00019f80      void (* rawWaveformsCB)(void*, uint8_t, uint8_t, uint16_t*, uint32_t) =
00019f80          pContext->rawWaveformsCB;
00019f80      
00019f8a      if (rawWaveformsCB)
00019f8a      {
00019f8c          (uint8_t)DataBuffer = pScopeHeader_1->camLed;
00019fa5          (uint8_t)DataBufferLength = (uint8_t)DataBuffer & 0xf;
00019fa9          (uint8_t)DataBuffer u>>= 4;
00019fac          rawWaveformsCB(pContext->rawWaveformsCBParam, DataBuffer, DataBufferLength, 
00019fac              &pContext->waveBuffer[pixelStart], *(uint32_t*)waveBufferCount);
00019f8a      }
00019f8a      
00019fb3      if (pScopeHeader_1->frameInfo & 1)
00019fb3      {
00019fb5          int64_t rdx = 0x1ff;
00019fb5          
00019fd3          do
00019fd3          {
00019fbe              int16_t rcx_5 = pContext->waveBuffer[rdi];
00019fc2              pContext->waveBuffer[rdi] = pContext->waveBuffer[rdx];
00019fc6              pContext->waveBuffer[rdx] = rcx_5;
00019fca              rdx -= 1;
00019fcd              rdi += 1;
00019fd3          } while (rdi < rdx);
00019fd3          
00019fe5          uint32_t rax_8 =
00019fe5              (uint32_t)(0x200 - pScopeHeader_1->pixelCount - pScopeHeader_1->pixelStart);
00019fe8          pScopeHeader_1->pixelStart = (uint16_t)rax_8;
00019fec          *(uint16_t*)waveBufferOffset = (uint16_t)rax_8;
00019fec          *(uint16_t*)((char*)waveBufferOffset + 2) = *(uint16_t*)((char*)rax_8)[2];
00019fb3      }
00019fb3      
0001a003      uint64_t rax_9;
0001a003      (uint8_t)rax_9 =
0001a003          (uint64_t)*(uint32_t*)waveBufferCount == (uint64_t)pFrameHeader_1->dataSize - 0xb;
0001a015      return (uint8_t)rax_9;
00019e6c  }

0001a016                                                                    cc cc cc cc cc cc                                    ......

0001a01c    uint8_t DealWithUnpacked(struct Parser_t* pContext, void* DataBuffer, uint32_t DataBufferLength, struct FRAMEHEADER* pFrameHeader, struct SCOPEHEADER* pScopeHeader, uint32_t* dataIdx, uint32_t* waveBufferOffset, uint32_t* waveBufferCount)

0001a01c  {
0001a054      uint64_t rax = (uint64_t)*(uint32_t*)dataIdx;
0001a05f      int64_t rbx = 0;
0001a061      uint32_t rbp_1 = (uint32_t)pScopeHeader->pixelCount * 2;
0001a066      uint32_t r15 = (uint32_t)rax + rbp_1;
0001a06a      *(uint32_t*)waveBufferOffset = 0;
0001a06e      *(uint32_t*)waveBufferCount = 0;
0001a081      uint64_t rawWaveformsCB;
0001a081      
0001a081      if (r15 > DataBufferLength || rbp_1 > 0x418)
0001a081      {
0001a11d          onError__("Invalid frame header!", 
0001a11d              "c:\development_work\csf_release_hp\driver\translib\parser.c", 0xe5);
0001a122          (uint8_t)rawWaveformsCB = 0;
0001a081      }
0001a081      else
0001a081      {
0001a08d          memmove(pContext, (char*)DataBuffer + rax, (uint64_t)rbp_1);
0001a092          rawWaveformsCB = pContext->rawWaveformsCB;
0001a099          uint32_t rbp_2 = rbp_1 >> 1;
0001a09b          *(uint32_t*)dataIdx = r15;
0001a09e          *(uint32_t*)waveBufferCount = rbp_2;
0001a09e          
0001a0a5          if (rawWaveformsCB)
0001a0a5          {
0001a0a7              uint8_t camLed = pScopeHeader->camLed;
0001a0bb              int64_t r8_1;
0001a0bb              (uint8_t)r8_1 = camLed & 0xf;
0001a0c2              rawWaveformsCB(pContext->rawWaveformsCBParam, camLed >> 4, r8_1, pContext, 
0001a0c2                  rbp_2);
0001a0a5          }
0001a0a5          
0001a0c8          if (pScopeHeader->frameInfo & 1)
0001a0c8          {
0001a0d0              int64_t r8_2 = (int64_t)(*(uint32_t*)waveBufferCount - 1);
0001a0d0              
0001a0d6              if (r8_2 > 0)
0001a0d6              {
0001a0f3                  do
0001a0f3                  {
0001a0dd                      int16_t rdx_1 = pContext->waveBuffer[rbx];
0001a0e1                      pContext->waveBuffer[rbx] = pContext->waveBuffer[r8_2];
0001a0e5                      pContext->waveBuffer[r8_2] = rdx_1;
0001a0ea                      r8_2 -= 1;
0001a0ed                      rbx += 1;
0001a0f3                  } while (rbx < r8_2);
0001a0d6              }
0001a0c8          }
0001a0c8          
0001a0f9          (uint8_t)rawWaveformsCB = 1;
0001a0fb          *(uint32_t*)waveBufferOffset = (uint32_t)pScopeHeader->pixelStart;
0001a103          *(uint32_t*)waveBufferCount = (uint32_t)pScopeHeader->pixelCount;
0001a081      }
0001a081      
0001a140      return (uint8_t)rawWaveformsCB;
0001a01c  }

0001a141     cc cc cc cc cc cc cc                                                                           .......

0001a148    int32_t ProcessWaveform(struct Parser_t* pContext, struct _NW_CSF_CONTEXT* pCSFContext, struct FRAMEHEADER* pFrameHeader, void* DataBuffer, uint32_t DataBufferLength, struct Device_Settings_t* deviceSettings)

0001a148  {
0001a15b      uint32_t waveBufferOffset = 0;
0001a160      uint32_t waveBufferCount = 0;
0001a179      memset(pContext, 0, 0x418);
0001a17e      int64_t rax = *(uint64_t*)DataBuffer;
0001a186      uint32_t dataIdx = 0xb;
0001a191      struct SCOPEHEADER scopeHeader;
0001a191      scopeHeader.timeStamp = (uint16_t)rax;
0001a191      scopeHeader.camLed = *(uint8_t*)((char*)rax)[2];
0001a191      scopeHeader.pixelStart = *(uint16_t*)((char*)rax)[3];
0001a191      scopeHeader.pixelCount = *(uint16_t*)((char*)rax)[5];
0001a191      scopeHeader.frameInfo = *(uint8_t*)((char*)rax)[7];
0001a198      scopeHeader.penPressure = *(uint16_t*)((char*)DataBuffer + 8);
0001a19d      int16_t rax_1;
0001a19d      (uint8_t)rax_1 = *(uint8_t*)((char*)DataBuffer + 0xa);
0001a1a0      scopeHeader.black = (uint8_t)rax_1;
0001a1a4      uint16_t timeStamp = scopeHeader.timeStamp;
0001a1a9      uint16_t arg_18 = timeStamp;
0001a1b5      (uint8_t)timeStamp = (timeStamp >> 8) ^ scopeHeader.timeStamp;
0001a1b9      (uint8_t)rax_1 = *(uint8_t*)((char*)arg_18)[1];
0001a1c0      (uint8_t)rax_1 ^= (uint8_t)timeStamp;
0001a1c2      (uint8_t)timeStamp ^= (uint8_t)rax_1;
0001a1c4      *(uint8_t*)((char*)arg_18)[1] = (uint8_t)rax_1;
0001a1cb      (uint8_t)arg_18 = (uint8_t)timeStamp;
0001a1d2      uint16_t pixelStart = scopeHeader.pixelStart;
0001a1d7      uint16_t rax_2 = arg_18;
0001a1df      arg_18 = pixelStart;
0001a1eb      (uint8_t)pixelStart = (pixelStart >> 8) ^ scopeHeader.pixelStart;
0001a1ef      scopeHeader.timeStamp = rax_2;
0001a1f4      (uint8_t)rax_2 = *(uint8_t*)((char*)arg_18)[1];
0001a1fb      (uint8_t)rax_2 ^= (uint8_t)pixelStart;
0001a1fd      (uint8_t)pixelStart ^= (uint8_t)rax_2;
0001a1ff      *(uint8_t*)((char*)arg_18)[1] = (uint8_t)rax_2;
0001a206      (uint8_t)arg_18 = (uint8_t)pixelStart;
0001a20d      uint16_t pixelCount = scopeHeader.pixelCount;
0001a212      uint16_t rax_3 = arg_18;
0001a21a      arg_18 = pixelCount;
0001a226      (uint8_t)pixelCount = (pixelCount >> 8) ^ scopeHeader.pixelCount;
0001a22a      scopeHeader.pixelStart = rax_3;
0001a22f      (uint8_t)rax_3 = *(uint8_t*)((char*)arg_18)[1];
0001a236      (uint8_t)rax_3 ^= (uint8_t)pixelCount;
0001a238      (uint8_t)pixelCount ^= (uint8_t)rax_3;
0001a23a      *(uint8_t*)((char*)arg_18)[1] = (uint8_t)rax_3;
0001a241      (uint8_t)arg_18 = (uint8_t)pixelCount;
0001a248      uint16_t penPressure = scopeHeader.penPressure;
0001a24d      uint16_t rax_4 = arg_18;
0001a255      arg_18 = penPressure;
0001a261      (uint8_t)penPressure = (penPressure >> 8) ^ scopeHeader.penPressure;
0001a265      scopeHeader.pixelCount = rax_4;
0001a26a      (uint8_t)rax_4 = *(uint8_t*)((char*)arg_18)[1];
0001a271      (uint8_t)rax_4 ^= (uint8_t)penPressure;
0001a273      (uint8_t)penPressure ^= (uint8_t)rax_4;
0001a275      *(uint8_t*)((char*)arg_18)[1] = (uint8_t)rax_4;
0001a27c      (uint8_t)arg_18 = (uint8_t)penPressure;
0001a283      uint32_t portNumber = (uint32_t)pFrameHeader->portNumber;
0001a292      scopeHeader.penPressure = arg_18;
0001a297      char* dataIdx_1;
0001a297      uint8_t rax_13;
0001a297      uint32_t DataBufferLength_1;
0001a297      int32_t zmm0;
0001a297      
0001a297      if (portNumber == 1)
0001a297      {
0001a398          DataBufferLength_1 = DataBufferLength;
0001a3d6          rax_13 = DealWithDeltaEncoded(pContext, DataBuffer, DataBufferLength_1, 
0001a3d6              pFrameHeader, &scopeHeader, &dataIdx, &waveBufferOffset, &waveBufferCount);
0001a3db      label_1a3db:
0001a3db          zmm0 = 0x41a00000;
0001a3e3      label_1a3e3:
0001a3e3          
0001a3e5          if (!rax_13)
0001a495              dataIdx_1 = 1;
0001a3e5          else
0001a3e5          {
0001a3eb              dataIdx_1 = (uint64_t)dataIdx;
0001a3eb              
0001a3fa              if ((uint32_t)dataIdx_1 == DataBufferLength_1
0001a3fa                  || *(uint8_t*)(dataIdx_1 + DataBuffer) == 0x5b)
0001a3fa              {
0001a404                  void info;
0001a404                  *(uint32_t*)((char*)info)[8] = zmm0;
0001a412                  struct waveform_t wf;
0001a412                  wf.bufferSize = waveBufferCount;
0001a41b                  wf.pWaveform = &pContext->waveBuffer[(uint64_t)waveBufferOffset];
0001a420                  void* rcx_6;
0001a420                  (uint8_t)rcx_6 = scopeHeader.camLed;
0001a424                  wf.pixelStart = scopeHeader.pixelStart;
0001a42e                  wf.pixelCount = scopeHeader.pixelCount;
0001a438                  info = scopeHeader.timeStamp;
0001a43d                  uint16_t rax_18;
0001a43d                  (uint8_t)rax_18 = pFrameHeader->packetID;
0001a440                  *(uint8_t*)((char*)info)[2] = (uint8_t)rax_18;
0001a444                  (uint8_t)rax_18 = (uint8_t)rcx_6;
0001a446                  (uint8_t)rcx_6 &= 0xf;
0001a449                  (uint8_t)rax_18 u>>= 4;
0001a453                  *(uint8_t*)((char*)info)[4] = (uint8_t)rcx_6;
0001a457                  *(uint8_t*)((char*)info)[3] = (uint8_t)rax_18;
0001a460                  *(uint16_t*)((char*)info)[6] = scopeHeader.penPressure;
0001a465                  uint16_t rax_19;
0001a465                  (uint8_t)rax_19 = scopeHeader.frameInfo;
0001a469                  wf.frameInfo = (uint8_t)rax_19;
0001a469                  
0001a46d                  if (gCSFEnabled && FE_ProcessWaveform(pCSFContext, &wf, 1, 1))
0001a48e                      FE_ProcessEdgesImplicit(pCSFContext, &info);
0001a3fa              }
0001a3fa              else
0001a495                  dataIdx_1 = 1;
0001a3e5          }
0001a297      }
0001a297      else
0001a297      {
0001a2a0          if (portNumber == 4)
0001a2a0          {
0001a353              DataBufferLength_1 = DataBufferLength;
0001a391              rax_13 = DealWithUnpacked(pContext, DataBuffer, DataBufferLength_1, 
0001a391                  pFrameHeader, &scopeHeader, &dataIdx, &waveBufferOffset, 
0001a391                  &waveBufferCount);
0001a396              goto label_1a3db;
0001a2a0          }
0001a2a0          
0001a2a9          if (portNumber == 7)
0001a2a9          {
0001a2b4              DataBufferLength_1 = DataBufferLength;
0001a2be              arg_18 = *(uint32_t*)((char*)DataBuffer + 0xb);
0001a2c7              int32_t rcx_2 = arg_18;
0001a2d3              char arg_1b = (uint8_t)rcx_2;
0001a2e0              dataIdx = 0xf;
0001a2eb              (uint8_t)arg_18 = (char)(rcx_2 >> 0x18);
0001a2f7              *(uint8_t*)((char*)arg_18)[1] = (char)(rcx_2 >> 0x10);
0001a306              uint8_t arg_1a = (char)(rcx_2 >> 8);
0001a343              rax_13 = DealWithUnpacked(pContext, DataBuffer, DataBufferLength_1, 
0001a343                  pFrameHeader, &scopeHeader, &dataIdx, &waveBufferOffset, 
0001a343                  &waveBufferCount);
0001a348              zmm0 = arg_18;
0001a34e              goto label_1a3e3;
0001a2a9          }
0001a2a9          
0001a495          dataIdx_1 = 1;
0001a297      }
0001a4b2      return (uint32_t)dataIdx_1;
0001a148  }

0001a4b3                                                           cc cc cc cc cc cc cc cc cc                                 .........

0001a4bc    void Parser_ProcessStream(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, void* DataBuffer, uint32_t DataBufferLength)

0001a4bc  {
0001a4d2      void (* streamDataCB)(void*, uint32_t) =
0001a4d2          PTransLibUserModeContext->ParserContext.streamDataCB;
0001a4d9      uint64_t rdi = 0;
0001a4db      uint64_t i = (uint64_t)DataBufferLength;
0001a4db      
0001a4e7      if (streamDataCB)
0001a4ef          streamDataCB(DataBuffer, (uint64_t)(uint32_t)i);
0001a4ef      
0001a4f5      if (i < 8)
0001a4f5          return;
0001a4f5      
0001a5f9      do
0001a5f9      {
0001a50c          if (*(uint8_t*)(rdi + DataBuffer) != 0x5b
0001a50c                  || *(uint8_t*)((uint64_t)(uint32_t)(rdi + 1) + DataBuffer) != 0x5d)
0001a5ee              rdi = (uint64_t)((uint32_t)rdi + 1);
0001a50c          else
0001a50c          {
0001a512              int64_t rax_1 = *(uint64_t*)(rdi + DataBuffer);
0001a520              struct FRAMEHEADER frameHeader;
0001a520              frameHeader.syncHeader = (uint16_t)rax_1;
0001a520              frameHeader.packetID = *(uint8_t*)((char*)rax_1)[2];
0001a520              frameHeader.dataSize = *(uint16_t*)((char*)rax_1)[3];
0001a520              frameHeader.portNumber = *(uint8_t*)((char*)rax_1)[5];
0001a520              frameHeader.command = *(uint8_t*)((char*)rax_1)[6];
0001a520              frameHeader.protocolID = *(uint8_t*)((char*)rax_1)[7];
0001a525              ET_Swap16N(&frameHeader.dataSize, 1);
0001a52a              int32_t rax_2;
0001a52a              (uint8_t)rax_2 = frameHeader.portNumber;
0001a52e              rdi = (uint64_t)((uint32_t)rdi + 8);
0001a52e              
0001a533              if ((uint8_t)rax_2 == 1)
0001a533              {
0001a56f              label_1a56f:
0001a56f                  
0001a57a                  if ((uint8_t)rax_2 != 4
0001a57a                          || PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001a5e0                      rdi = (uint64_t)((uint32_t)rdi + ProcessWaveform(
0001a5e0                          &PTransLibUserModeContext->ParserContext, 
0001a5e0                          PTransLibUserModeContext->pCSFContext, &frameHeader, 
0001a5e0                          (uint64_t)(uint32_t)rdi + DataBuffer, 
0001a5e0                          (uint32_t)i - (uint32_t)rdi, 
0001a5e0                          &PTransLibUserModeContext->FwSettingsContext.st_Device));
0001a57a                  else
0001a57a                  {
0001a588                  label_1a588:
0001a588                      *(uint8_t*)(
0001a588                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001a588                          + 0x10) = 4;
0001a58f                      *(uint16_t*)(
0001a58f                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001a58f                          + 0x73) = 0x1f4;
0001a59b                      *(uint16_t*)(
0001a59b                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001a59b                          + 0x75) = 0x12c;
0001a5a7                      *(uint16_t*)(
0001a5a7                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001a5a7                          + 0xb) = 0x20c;
0001a5ae                      fw_UpdateCSFDeviceSettings(
0001a5ae                          &PTransLibUserModeContext->FwSettingsContext);
0001a5e0                      rdi = (uint64_t)((uint32_t)rdi + ProcessWaveform(
0001a5e0                          &PTransLibUserModeContext->ParserContext, 
0001a5e0                          PTransLibUserModeContext->pCSFContext, &frameHeader, 
0001a5e0                          (uint64_t)(uint32_t)rdi + DataBuffer, 
0001a5e0                          (uint32_t)i - (uint32_t)rdi, 
0001a5e0                          &PTransLibUserModeContext->FwSettingsContext.st_Device));
0001a57a                  }
0001a533              }
0001a533              else if ((uint8_t)rax_2 == 4)
0001a537              {
0001a57a                  if (!PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001a57a                      goto label_1a588;
0001a57a                  
0001a5e0                  rdi = (uint64_t)((uint32_t)rdi + ProcessWaveform(
0001a5e0                      &PTransLibUserModeContext->ParserContext, 
0001a5e0                      PTransLibUserModeContext->pCSFContext, &frameHeader, 
0001a5e0                      (uint64_t)(uint32_t)rdi + DataBuffer, (uint32_t)i - (uint32_t)rdi, 
0001a5e0                      &PTransLibUserModeContext->FwSettingsContext.st_Device));
0001a537              }
0001a537              else
0001a537              {
0001a53b                  if ((uint8_t)rax_2 == 7)
0001a53b                      goto label_1a56f;
0001a53b                  
0001a53f                  if ((uint8_t)rax_2 == 2)
0001a53f                  {
0001a545                      uint32_t dataSize = (uint32_t)frameHeader.dataSize;
0001a552                      uint32_t dataLength = dataSize;
0001a552                      
0001a55f                      if ((uint32_t)i < dataSize)
0001a55f                          dataLength = (uint32_t)i;
0001a55f                      
0001a566                      fw_ProcessSettings(&PTransLibUserModeContext->FwSettingsContext, 
0001a566                          (uint64_t)(uint32_t)rdi + DataBuffer, dataLength, 
0001a566                          (uint32_t)frameHeader.command);
0001a56b                      rdi = (uint64_t)((uint32_t)rdi + dataSize);
0001a53f                  }
0001a537              }
0001a537              
0001a5e2              (uint8_t)rax_2 = frameHeader.packetID;
0001a5e6              PTransLibUserModeContext->ParserContext.lastPacketID = (uint8_t)rax_2;
0001a50c          }
0001a5f9      } while ((uint64_t)(uint32_t)rdi + 8 <= i);
0001a4bc  }

0001a616                                                                    cc cc cc cc cc cc                                    ......

0001a61c    uint8_t TransLibUserModeContextInit(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext)

0001a61c  {
0001a636      memset(PTransLibUserModeContext, 0, 0x9050);
0001a648      struct _NW_CSF_CONTEXT* pContext =
0001a648          ExAllocatePoolWithTag(NonPagedPool, 0x8f28, 0x58465343);
0001a648      
0001a656      if (!pContext)
0001a656      {
0001a66a          onError__("TransLibUserModeContextInit: failed to alloc pCSFContext", 
0001a66a              "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0x21);
0001a66f          return 0;
0001a656      }
0001a656      
0001a679      CSF_Init(pContext);
0001a67e      PTransLibUserModeContext->pCSFContext = pContext;
0001a68c      __builtin_memset(&PTransLibUserModeContext->ParserContext.lastPacketID, 0, 0x19);
0001a6a8      fw_Init(&PTransLibUserModeContext->FwSettingsContext, PTransLibUserModeContext);
0001a6b9      PTransLibUserModeContext->DrvSettingsContext.InputDevicesEnabled = 1;
0001a6c0      PTransLibUserModeContext->DrvSettingsContext.InputMode = 0;
0001a6c6      __builtin_memset(&PTransLibUserModeContext->DrvSettingsContext.DriverTVItemsCallback, 
0001a6c6          0, 0x30);
0001a6d4      PTransLibUserModeContext->DrvSettingsContext.ReportMode = 0x40;
0001a6f7      PTransLibUserModeContext->DrvSettingsContext.pUserModeContext =
0001a6f7          PTransLibUserModeContext;
0001a6fe      drv_StDriverInit(&PTransLibUserModeContext->DrvSettingsContext);
0001a70c      drv_StDriverUpdated(&PTransLibUserModeContext->DrvSettingsContext, 0);
0001a71f      __builtin_memset(&PTransLibUserModeContext->TLIOContext, 0, 0x28);
0001a734      PTransLibUserModeContext->TLIOContext.pUserModeContext = PTransLibUserModeContext;
0001a73b      return 1;
0001a61c  }

0001a74d                                         cc cc cc cc cc cc cc                                                   .......

0001a754    uint8_t TLIO_ReceiveTLReport(struct _TLIO_CONTEXT* pContext, uint8_t* buf, int32_t size)

0001a754  {
0001a758      uint8_t (* ReceiveTLReportCallback)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001a758          pContext->ReceiveTLReportCallback;
0001a758      
0001a75f      if (ReceiveTLReportCallback)
0001a761          return ReceiveTLReportCallback();
0001a761      
0001a779      onBug__("TransLibIO.c: ReceiveTLReportCallback not assigned", 
0001a779          "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0xa5);
0001a77e      return 0;
0001a754  }

0001a785                 cc cc cc cc cc cc cc                                                                   .......

0001a78c    void TLIO_TransLibBulkConnect(struct _TLIO_CONTEXT* pContext)

0001a78c  {
0001a799      void var_38;
0001a799      int64_t rax_1 = __security_cookie ^ &var_38;
0001a7a1      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext = pContext->pUserModeContext;
0001a7b7      uint8_t data = 0x54;
0001a7bc      char var_17 = 6;
0001a7c1      char var_16;
0001a7c1      __builtin_strncpy(&var_16, "reload", 6);
0001a7df      DSI_OutputReport(&pUserModeContext->FwSettingsContext, &data, 8);
0001a7e4      pUserModeContext->FwSettingsContext.GotSettingsFromFW = 0;
0001a7f3      __security_check_cookie(rax_1 ^ &var_38);
0001a78c  }

0001a7fe                                                                                            cc cc                                ..
0001a800  cc cc cc cc                                                                                      ....

0001a804    void TLIO_TransLibBulkDisconnect(struct _TLIO_CONTEXT* pContext)

0001a804  {
0001a80a      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext = pContext->pUserModeContext;
0001a81d      pUserModeContext->FwSettingsContext.GotSettingsFromFW = 0;
0001a824      memset(&pUserModeContext->FwSettingsContext.st_fw, 0, 0x7d0);
0001a83d      /* tailcall */
0001a83d      return memset(&pUserModeContext->FwSettingsContext.st_data, 0, 0x7d00);
0001a804  }

0001a842        cc cc cc cc cc cc                                                                            ......

0001a848    void TLIO_CSFTouchPointVendor(void* PTLIOContext, uint8_t preferMouse, struct csf_touch_report_t* touchReport)

0001a848  {
0001a85f      struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext =
0001a85f          *(uint64_t*)((char*)PTLIOContext + 0x28);
0001a863      int64_t i_1 = 2;
0001a868      char ReportMode = (char)PTransLibUserModeContext->DrvSettingsContext.ReportMode;
0001a868      
0001a875      if (2 & ReportMode)
0001a87a          SendXMultiTouch(PTransLibUserModeContext, touchReport);
0001a87a      
0001a882      if (ReportMode >= 0)
0001a882          return;
0001a882      
0001a888      int16_t rax_1 = 0;
0001a88d      int64_t data;
0001a88d      void* rcx = &*(uint64_t*)((char*)data)[2];
0001a892      data = 0;
0001a897      char var_12_1 = 0;
0001a89b      (uint8_t)data = 0x59;
0001a8a0      *(uint8_t*)((char*)data)[1] = 0;
0001a8a5      char var_12_2 = 0;
0001a8a9      int64_t var_20_1 = 0;
0001a8ae      int32_t var_18_1 = 0;
0001a8b2      int16_t var_14_1 = 0;
0001a8b7      struct fpoint_t* rdx_1 = &touchReport->touch[0].pt;
0001a8ff      int64_t i;
0001a8ff      
0001a8ff      do
0001a8ff      {
0001a8bf          if (ADJ(rdx_1)->touch[0].touchState)
0001a8bf          {
0001a8c1              (uint8_t)rax_1 += 1;
0001a8c3              char var_12_3 = (uint8_t)rax_1;
0001a8c7              (uint8_t)rax_1 = *((char*)rdx_1 + 0x10);
0001a8ca              *(uint16_t*)((char*)rcx + 6) = 0;
0001a8cf              *(uint8_t*)((char*)rcx + 1) = (uint8_t)rax_1;
0001a8d2              (uint8_t)rax_1 = ADJ(rdx_1)->touch[0].touchState;
0001a8d5              *(uint16_t*)((char*)rcx + 8) = 0;
0001a8da              *(uint8_t*)rcx = (uint8_t)rax_1;
0001a8dc              rcx += 0xa;
0001a8e5              *(uint16_t*)((char*)rcx - 8) = (int16_t)(int64_t)(long double)rdx_1->x;
0001a8ef              *(uint16_t*)((char*)rcx - 6) = (int16_t)(int64_t)(long double)rdx_1->y;
0001a8f3              (uint8_t)rax_1 = var_12_3;
0001a8bf          }
0001a8bf          
0001a8f7          rdx_1 = &rdx_1[3];
0001a8fb          i = i_1;
0001a8fb          i_1 -= 1;
0001a8ff      } while (i != 1);
0001a8ff      
0001a904      if ((uint8_t)rax_1)
0001a913          SI_Output_Report(*(uint64_t*)((char*)PTLIOContext + 0x28), &data, 
0001a913              (int32_t)(i_1 + 0x40));
0001a848  }

0001a92d                                         cc cc cc cc cc cc cc                                                   .......

0001a934    void TLIO_CSFTouchPointOffscreen(void* PTLIOContext, uint8_t preferMouse, struct csf_touch_report_t* touchReport)

0001a934  {
0001a938      struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext =
0001a938          *(uint64_t*)((char*)PTLIOContext + 0x28);
0001a938      
0001a948      if (PTransLibUserModeContext->DrvSettingsContext.ReportMode & 0x200)
0001a94d          SendOffscreenTouch(PTransLibUserModeContext, touchReport);
0001a934  }

0001a957                                                                       cc cc cc cc cc cc cc cc cc                         .........

0001a960    uint8_t DSI_InputReport(struct _TLIO_CONTEXT* pContext, uint8_t* data, int32_t size)

0001a960  {
0001a964      uint32_t r9 = (uint32_t)*(uint8_t*)data;
0001a964      
0001a96c      if (r9 == 0x45)
0001a96c      {
0001a980      label_1a980:
0001a980          
0001a984          if (size > 0x40)
0001a9e6              onBug__("Size cannot exceed USB_PACKET_SIZE", 
0001a9e6                  "c:\development_work\csf_release_hp\driver\translib\devsettingsinterface.c", 
0001a9e6                  0x53);
0001a984          else
0001a984          {
0001a98a              struct _TLIO_CONTEXT* rcx_1 = &pContext->pUserModeContext->TLIOContext;
0001a991              uint8_t (* SendTLReportCallback)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001a991                  rcx_1->SendTLReportCallback;
0001a991              
0001a998              if (!SendTLReportCallback)
0001a9e6                  onBug__("TransLibIO.c: SendTLReportCallback not assigned", 
0001a9e6                      "c:\development_work\csf_release_hp\driver\translib\translibio.c", 
0001a9e6                      0x93);
0001a998              else
0001a9a0                  SendTLReportCallback(rcx_1, data, 0x40);
0001a984          }
0001a96c      }
0001a96c      else if (r9 == 0x53)
0001a972      {
0001a9a8          if (data[2] == 0x73)
0001a9b5              HandleSetSettingConfirmed(&pContext->pUserModeContext->FwSettingsContext, 
0001a9b5                  data, size);
0001a972      }
0001a972      else if (r9 == 0x54 || r9 == 0x69)
0001a978          goto label_1a980;
0001a978      
0001a9eb      int64_t rax;
0001a9eb      (uint8_t)rax = 1;
0001a9f1      return 1;
0001a960  }

0001a9f2                                                        cc cc cc cc cc cc                                            ......

0001a9f8    void HandleSetSettingConfirmed(struct FwSettings_t* pContext, uint8_t* data, int32_t size)

0001a9f8  {
0001aa14      if (size < 0x18)
0001aa2a          onError__("HandleSetSettingConfirmed: data size is too small\n", 
0001aa2a              "c:\development_work\csf_release_hp\driver\translib\devsettingsinterface.c", 
0001aa2a              0x8c);
0001aa14      else if (pContext->GotSettingsFromFW && ST_AcquireLock(&pContext->st_data_lock, 0x32))
0001aa3b      {
0001aa5a          uint16_t rax_2 = *(uint16_t*)(data + 4);
0001aa5e          uint32_t rbx_1 = (uint32_t)data[8];
0001aa62          uint16_t arg_18 = rax_2;
0001aa6f          char rcx_1 = (uint8_t)arg_18 ^ (rax_2 >> 8);
0001aa71          (uint8_t)rax_2 = *(uint8_t*)((char*)arg_18)[1];
0001aa75          (uint8_t)rax_2 ^= rcx_1;
0001aa79          *(uint8_t*)((char*)arg_18)[1] = (uint8_t)rax_2;
0001aa7d          (uint8_t)arg_18 = rcx_1 ^ (uint8_t)rax_2;
0001aa85          int32_t rax_3 = ST_GetSettingSize(data[9]);
0001aa85          
0001aa90          if (rbx_1 != 1)
0001ab6e              onError__("HandleSetSettingConfirmed: result not ok", 
0001ab6e                  "c:\development_work\csf_release_hp\driver\translib\devsettingsinterface.c", 
0001ab6e                  0xbd);
0001aa90          else if (rax_3 <= 0)
0001ab6e              onError__("HandleSetSettingConfirmed: dataSize = 0", 
0001ab6e                  "c:\development_work\csf_release_hp\driver\translib\devsettingsinterface.c", 
0001ab6e                  0xb8);
0001aa98          else
0001aa98          {
0001aa9e              uint64_t rbx_2 = (uint64_t)arg_18;
0001aaa9              char** pdata_ret;
0001aaa9              uint8_t* is_esym;
0001aaa9              char* arg_20;
0001aaa9              int32_t rax_6;
0001aaa9              
0001aaa9              if ((uint32_t)rbx_2 < pContext->NumberOfSettings)
0001aaa9              {
0001aad5                  is_esym = &arg_18;
0001aadf                  pdata_ret = &arg_20;
0001aae4                  rax_6 = ST_GetSettingIndex2(&pContext->st_fw, &pContext->st_data, 
0001aae4                      (uint32_t)pContext->st_fw[rbx_2].treepath0, 
0001aae4                      (uint32_t)(uint8_t)(pContext->st_fw[rbx_2].treepath0 >> 8), 
0001aae4                      pdata_ret, is_esym);
0001aaa9              }
0001aaa9              
0001aaeb              char* rcx_4;
0001aaeb              
0001aaeb              if ((uint32_t)rbx_2 >= pContext->NumberOfSettings || rax_6 != (uint32_t)rbx_2)
0001aaf4                  rcx_4 = nullptr;
0001aaeb              else
0001aaed                  rcx_4 = arg_20;
0001aaed              
0001aaf9              if (!rcx_4)
0001ab6e                  onError__("HandleSetSettingConfirmed: Could not find dataPtr", 
0001ab6e                      "c:\development_work\csf_release_hp\driver\translib\devsettingsinterface.c", 
0001ab6e                      0xb3);
0001aaf9              else
0001aaf9              {
0001ab02                  memmove(rcx_4, &data[0xa], (int64_t)rax_3);
0001ab11                  fw_loadStDevice(pContext, &pContext->st_data);
0001ab16                  void (* FWTVLoadCallback)(struct tv_item_t*, uint32_t, uint8_t*, 
0001ab16                      uint32_t) = pContext->FWTVLoadCallback;
0001ab16                  
0001ab1c                  if (FWTVLoadCallback)
0001ab37                      FWTVLoadCallback(&pContext->st_fw, 0x1f4, &pContext->st_data, 0x7d00, 
0001ab37                          pdata_ret, is_esym);
0001aaf9              }
0001aa98          }
0001aa98          
0001ab7c          KeReleaseMutex(&pContext->st_data_lock.mutex, 0);
0001aa3b      }
0001a9f8  }

0001ab95                                                                 cc cc cc cc cc cc cc                                   .......

0001ab9c    void DSI_OutputReport(struct FwSettings_t* pContext, uint8_t* data, int32_t size)

0001ab9c  {
0001aba4      if (size > 0x40)
0001aba4      {
0001abf5          onBug__("Size cannot exceed USB_PACKET_SIZE", 
0001abf5              "c:\development_work\csf_release_hp\driver\translib\devsettingsinterface.c", 
0001abf5              0xd5);
0001abf5          return;
0001aba4      }
0001aba4      
0001abad      struct _TLIO_CONTEXT* rcx_1 = &pContext->pUserModeContext->TLIOContext;
0001abb4      uint8_t (* SendHWReportCallback)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001abb4          rcx_1->SendHWReportCallback;
0001abb4      
0001abba      if (!SendHWReportCallback)
0001abda          onError__("TransLibIO.c: SendHWReportCallback not assigned", 
0001abda              "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0x6f);
0001abba      else
0001abc2          SendHWReportCallback(rcx_1, data, 0x40);
0001ab9c  }

0001abff                                                                                               cc                                 .
0001ac00  cc cc cc cc cc cc cc cc                                                                          ........

0001ac08    void drv_LoadSettingsFromFile(struct DrvSettings_t* pContext, uint8_t GotSettingsFromFW, uint32_t ModelNumber, uint32_t SerialNumber)

0001ac08  {
0001ac16      uint8_t (* GetDefaultSettingsDataCallback)(struct tv_item_t**, int32_t*, uint8_t**, 
0001ac16          int32_t*) = pContext->GetDefaultSettingsDataCallback;
0001ac20      int64_t rdi;
0001ac20      (uint8_t)rdi = GotSettingsFromFW;
0001ac33      uint8_t* var_28;
0001ac33      uint8_t* var_20;
0001ac33      int32_t arg_8;
0001ac33      int32_t arg_10;
0001ac33      
0001ac33      if (!GetDefaultSettingsDataCallback || !pContext->FreeSettingsDataCallback)
0001ac8c          onBug__("LoadSettingsFromFile - GetDefaultSettingsDataCallback not assigned!\n", 
0001ac8c              "c:\development_work\csf_release_hp\driver\translib\drvsettings.c", 0x11c);
0001ac33      else if (GetDefaultSettingsDataCallback(&var_20, &arg_8, &var_28, &arg_10))
0001ac49      {
0001ac58          drv_loadStDriver(pContext, var_20, var_28);
0001ac70          pContext->FreeSettingsDataCallback(var_20, (uint64_t)arg_8, var_28, 
0001ac70              (uint64_t)arg_10);
0001ac49      }
0001ac49      
0001ac94      if ((uint8_t)rdi)
0001ac94      {
0001ac9a          uint8_t (* GetSettingsDataCallback)(uint32_t, uint32_t, struct tv_item_t**, 
0001ac9a              int32_t*, uint8_t**, int32_t*) = pContext->GetSettingsDataCallback;
0001ac9a          
0001acab          if (!GetSettingsDataCallback || !pContext->FreeSettingsDataCallback)
0001ad16              onBug__("LoadSettingsFromFile - GetSettingsDataCallback not assigned!\n", 
0001ad16                  "c:\development_work\csf_release_hp\driver\translib\drvsettings.c", 
0001ad16                  0x133);
0001acab          else if (GetSettingsDataCallback((uint64_t)ModelNumber, (uint64_t)SerialNumber, 
0001acab              &var_28, &arg_8, &var_20, &arg_10))
0001acd3          {
0001ace2              drv_loadStDriver(pContext, var_28, var_20);
0001acfa              pContext->FreeSettingsDataCallback(var_28, (uint64_t)arg_8, var_20, 
0001acfa                  (uint64_t)arg_10);
0001acd3          }
0001ac94      }
0001ac94      
0001ad35      if (pContext->st_Driver.VersionMajor != 3 || pContext->st_Driver.VersionMinor != 1
0001ad35              || pContext->st_Driver.VersionRelease != 0xc
0001ad35              || pContext->st_Driver.VersionBuild != 7)
0001ad3a          drv_StDriverInit(pContext);
0001ad3a      
0001ad50      /* tailcall */
0001ad50      return drv_StDriverUpdated(pContext, 1);
0001ac08  }

0001ad55                                                                 cc cc cc cc cc cc cc                                   .......

0001ad5c    void drv_WriteSettingsToFile(struct DrvSettings_t* pContext, uint8_t GotSettingsFromFW, uint32_t ModelNumber, uint32_t SerialNumber)

0001ad5c  {
0001ad6a      if (!GotSettingsFromFW)
0001ad6a      {
0001ad80          onError__("No serial number received from device, cannot write settings file.", 
0001ad80              "c:\development_work\csf_release_hp\driver\translib\drvsettings.c", 0x152);
0001ad80          return;
0001ad6a      }
0001ad6a      
0001ad87      void (* SetSettingsDataCallback)(uint32_t, uint32_t, struct tv_item_t*, int32_t, 
0001ad87          uint8_t*, int32_t) = pContext->SetSettingsDataCallback;
0001ad87      
0001ad91      if (!SetSettingsDataCallback)
0001adcf          onBug__(
0001adcf              "Settings.c: WriteSettingsToFile - SetSetSettingsDataCallback not assigned!", 
0001adcf              "c:\development_work\csf_release_hp\driver\translib\drvsettings.c", 0x161);
0001ad91      else
0001adb6          SetSettingsDataCallback((uint64_t)ModelNumber, (uint64_t)SerialNumber, 
0001adb6              &drv_tv_Items, 0x80, &pContext->st_Driver, 0x5d);
0001ad5c  }

0001adda                                                                                cc cc cc cc cc cc                            ......

0001ade0    void drv_StDriverUpdated(struct DrvSettings_t* pContext, uint8_t updateTreeview)

0001ade0  {
0001adf8      char rdi = 0;
0001adfd      pContext->st_Driver.VersionMajor = 3;
0001ae07      pContext->st_Driver.VersionMinor = 1;
0001ae0b      pContext->st_Driver.VersionRelease = 0xc;
0001ae12      pContext->st_Driver.VersionBuild = 7;
0001ae19      void (* DriverTVItemsCallback)(struct tv_item_t*, uint32_t, uint8_t*, uint32_t);
0001ae19      
0001ae19      if (updateTreeview)
0001ae19      {
0001ae1b          DriverTVItemsCallback = pContext->DriverTVItemsCallback;
0001ae22          int512_t entry_zmm2;
0001ae22          
0001ae22          if (DriverTVItemsCallback)
0001ae32              DriverTVItemsCallback(&drv_tv_Items, 0x80, entry_zmm2, 0x5d);
0001ae19      }
0001ae19      
0001ae34      void* Pts = &pContext->st_Driver.Pts;
0001ae38      float zmm0 = *(uint32_t*)Pts;
0001ae3c      zmm0 - 0f;
0001ae45      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext_1;
0001ae45      
0001ae45      if (FCMP_UO(zmm0, 0f) || zmm0 != 0f)
0001ae57          pUserModeContext_1 = pContext->pUserModeContext;
0001ae45      else
0001ae45      {
0001ae47          pUserModeContext_1 = pContext->pUserModeContext;
0001ae4e          Pts =
0001ae4e              &*(uint64_t*)((char*)pUserModeContext_1->FwSettingsContext.st_Device + 0x27);
0001ae45      }
0001ae45      
0001ae5e      (uint8_t)DriverTVItemsCallback =
0001ae5e          *(uint8_t*)((char*)pUserModeContext_1->FwSettingsContext.st_Device + 0x26);
0001ae77      CSF_InitTransform(pUserModeContext_1->pCSFContext, Pts, 
0001ae77          &*(uint64_t*)((char*)pUserModeContext_1->FwSettingsContext.st_Device + 0x47), 
0001ae77          pContext->st_Driver.CamOrientation, (uint8_t)DriverTVItemsCallback);
0001ae84      uint8_t Enabled = pContext->st_Driver.MouseEngine.Enabled;
0001ae9f      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext = pContext->pUserModeContext;
0001aead      struct _NW_CSF_CONTEXT* pCSFContext = pUserModeContext->pCSFContext;
0001aeb4      pCSFContext->meContext.Settings.RightClickDelay =
0001aeb4          pContext->st_Driver.MouseEngine.RightClickDelay;
0001aebe      pCSFContext->meContext.Settings.DoubleClickTime =
0001aebe          pContext->st_Driver.MouseEngine.DoubleClickTime;
0001aec4      int32_t rax_6 = pContext->st_Driver.MouseEngine.DragThreshold;
0001aec8      pCSFContext->meContext.Settings.DragThreshold = (uint16_t)rax_6;
0001aec8      pCSFContext->meContext.Settings.Enabled = *(uint8_t*)((char*)rax_6)[2];
0001aedb      uint128_t DragThreshold = (uint128_t)pCSFContext->meContext.Settings.DragThreshold;
0001aedf      uint128_t zmm1 = _mm_cvtepi32_ps((uint128_t)
0001aedf          *(uint16_t*)((char*)pUserModeContext->FwSettingsContext.st_Device + 0x73));
0001aef7      pCSFContext->meContext.Settings.DragThreshold = (int16_t)(int64_t)(
0001aef7          _divide(_mm_cvtepi32_ps(DragThreshold), (uint32_t)zmm1) * 32767f);
0001aefe      uint16_t ReportMode = pContext->st_Driver.ReportMode;
0001aefe      
0001af04      if ((uint8_t)ReportMode & 0x40)
0001af0b          ReportMode &= 0xffda;
0001af0b      
0001af0e      pContext->ReportMode = ReportMode;
0001af0e      
0001af13      if (!((uint8_t)ReportMode & 0x40))
0001af13      {
0001af1d          if (1 & (uint8_t)ReportMode)
0001af1f              rdi = 1;
0001af13      }
0001af13      else if (!pContext->InputMode || 1 & (uint8_t)ReportMode)
0001af1f          rdi = 1;
0001af1f      
0001af35      pContext->pUserModeContext->pCSFContext->PTContext.MouseMode = rdi;
0001af4c      float zmm0_1 = pContext->st_Driver.dragThreshold.pen * 0.5f;
0001af54      pContext->pUserModeContext->pCSFContext->ctlContext.radiusThreshold.pen =
0001af54          zmm0_1 * zmm0_1;
0001af68      zmm0_1 = pContext->st_Driver.dragThreshold.doubleTouch * 0.5f;
0001af74      pContext->pUserModeContext->pCSFContext->ctlContext.radiusThreshold.doubleTouch =
0001af74          zmm0_1 * zmm0_1;
0001af88      float zmm1_1 = pContext->st_Driver.dragThreshold.singleTouch * 0.5f;
0001af94      pContext->pUserModeContext->pCSFContext->ctlContext.radiusThreshold.singleTouch =
0001af94          zmm1_1 * zmm1_1;
0001afb9      /* tailcall */
0001afb9      return fw_UpdateCSFDeviceSettings(&pContext->pUserModeContext->FwSettingsContext);
0001ade0  }

0001afbe                                                                                            cc cc                                ..
0001afc0  cc cc cc cc                                                                                      ....

0001afc4    void drv_StDriverInit(struct DrvSettings_t* pContext)

0001afc4  {
0001afe1      int16_t var_68 = 3;
0001afe6      int16_t var_66 = 1;
0001afef      char var_5d = 0;
0001aff3      int32_t var_5c = 0x40800000;
0001aff9      int32_t var_58 = 0x40800000;
0001afff      int32_t var_54 = 0x40800000;
0001b005      int16_t var_64 = 0xc;
0001b00e      char var_5e = 2;
0001b016      int16_t var_62 = 7;
0001b01f      int32_t var_50 = 0x3e8;
0001b027      int16_t var_60 = 0x40;
0001b02f      int32_t var_4c = 0x15e;
0001b037      int16_t var_48 = 8;
0001b03c      char var_46 = 1;
0001b040      int16_t var_45 = 0;
0001b045      int32_t var_40;
0001b045      __builtin_memset(&var_40, 0, 0x20);
0001b057      int16_t var_43 = 0;
0001b05c      char var_41 = 4;
0001b083      char var_20 = 1;
0001b08e      int32_t var_1f = 0;
0001b094      int32_t var_1b = 0;
0001b09a      int32_t var_17 = 0;
0001b0a0      int32_t var_f = 0xabcd;
0001b0a8      int32_t var_13 = 0;
0001b0ae      memmove(&pContext->st_Driver.VersionMajor, &var_68, 0x5d);
0001afc4  }

0001b0bb                                                                                   cc cc cc cc cc                             .....
0001b0c0  cc cc cc cc                                                                                      ....

0001b0c4    enum SETSETTINGS_FEEDBACK_STATES drv_UpdateNewSetting(struct DrvSettings_t* pContext, uint16_t tree_index, uint8_t** new_val_ptr)

0001b0c4  {
0001b0ca      struct Driver_Settings_t* r9 = &pContext->st_Driver;
0001b0ca      
0001b0db      if (0 < tree_index)
0001b0db      {
0001b0dd          uint8_t* rax_1 = &drv_tv_Items[0].typespec;
0001b0e0          pContext = (uint64_t)tree_index;
0001b130          struct DrvSettings_t* i;
0001b130          
0001b130          do
0001b130          {
0001b0e6              if (*(uint8_t*)rax_1 == 1)
0001b125                  r9 = &r9->VersionMajor + 1;
0001b0e6              else if (*(uint8_t*)rax_1 == 2)
0001b11f                  r9 = &r9->VersionMinor;
0001b0eb              else if (*(uint8_t*)rax_1 == 3)
0001b119                  r9 = &r9->VersionRelease;
0001b0f0              else if (*(uint8_t*)rax_1 == 4)
0001b125                  r9 = &r9->VersionMajor + 1;
0001b0f5              else
0001b0f5              {
0001b0f7                  uint8_t temp1_1 = *(uint8_t*)rax_1;
0001b0f7                  
0001b0fa                  if (temp1_1 == 5)
0001b11f                      r9 = &r9->VersionMinor;
0001b0fa                  else if (temp1_1 > 5)
0001b0fc                  {
0001b101                      if (*(uint8_t*)rax_1 <= 7)
0001b119                          r9 = &r9->VersionRelease;
0001b101                      else if (*(uint8_t*)rax_1 == 8)
0001b113                          r9 = &r9->dragThreshold.pen + 2;
0001b106                      else if (*(uint8_t*)rax_1 == 9)
0001b10d                          r9 = &r9->ReportMode + 1;
0001b0fc                  }
0001b0f5              }
0001b0f5              
0001b128              rax_1 = &rax_1[4];
0001b12c              i = pContext;
0001b12c              pContext -= 1;
0001b130          } while (i != 1);
0001b0db      }
0001b0db      
0001b135      (uint8_t)pContext = drv_tv_Items[(uint64_t)tree_index].typespec;
0001b135      
0001b13c      if ((uint8_t)pContext == 1)
0001b13c      {
0001b1e7          (uint8_t)tree_index = **(uint8_t**)new_val_ptr;
0001b1e9          r9->VersionMajor = (uint8_t)tree_index;
0001b13c      }
0001b13c      else
0001b13c      {
0001b145          uint64_t rax_7;
0001b145          
0001b145          if ((uint8_t)pContext == 2)
0001b145          {
0001b1d3          label_1b1d3:
0001b1d3              char* rcx_1 = *(uint64_t*)new_val_ptr;
0001b1d6              (uint8_t)rax_7 = rcx_1[1];
0001b1d9              r9->VersionMajor = (uint8_t)rax_7;
0001b1dc              (uint8_t)rax_7 = *(uint8_t*)rcx_1;
0001b1de              *(uint8_t*)((char*)r9->VersionMajor)[1] = (uint8_t)rax_7;
0001b145          }
0001b145          else if ((uint8_t)pContext == 3)
0001b14e          {
0001b1b4          label_1b1b4:
0001b1b4              char* rcx = *(uint64_t*)new_val_ptr;
0001b1b7              (uint8_t)rax_7 = rcx[3];
0001b1ba              r9->VersionMajor = (uint8_t)rax_7;
0001b1bd              (uint8_t)rax_7 = rcx[2];
0001b1c0              *(uint8_t*)((char*)r9->VersionMajor)[1] = (uint8_t)rax_7;
0001b1c4              (uint8_t)rax_7 = rcx[1];
0001b1c7              r9->VersionMinor = (uint8_t)rax_7;
0001b1cb              (uint8_t)rax_7 = *(uint8_t*)rcx;
0001b1cd              *(uint8_t*)((char*)r9->VersionMinor)[1] = (uint8_t)rax_7;
0001b14e          }
0001b14e          else if ((uint8_t)pContext == 4)
0001b153          {
0001b1e7              (uint8_t)tree_index = **(uint8_t**)new_val_ptr;
0001b1e9              r9->VersionMajor = (uint8_t)tree_index;
0001b153          }
0001b153          else
0001b153          {
0001b15c              if ((uint8_t)pContext == 5)
0001b15c                  goto label_1b1d3;
0001b15c              
0001b15e              if ((uint8_t)pContext > 5)
0001b15e              {
0001b167                  if ((uint8_t)pContext <= 7)
0001b167                      goto label_1b1b4;
0001b167                  
0001b16c                  if ((uint8_t)pContext == 8)
0001b16c                  {
0001b19a                      uint8_t* rax_4 = *(uint64_t*)new_val_ptr;
0001b19d                      r9->VersionMajor = (uint16_t)rax_4;
0001b19d                      r9->VersionMinor = *(uint16_t*)((char*)rax_4)[2];
0001b19d                      r9->VersionRelease = *(uint16_t*)((char*)rax_4)[4];
0001b19d                      r9->VersionBuild = *(uint16_t*)((char*)rax_4)[6];
0001b1a0                      int32_t rax_5 = new_val_ptr[1];
0001b1a4                      r9->ReportMode = (uint16_t)rax_5;
0001b1a4                      r9->Hardware = *(uint8_t*)((char*)rax_5)[2];
0001b1a4                      r9->CamOrientation = *(uint8_t*)((char*)rax_5)[3];
0001b1ad                      r9->dragThreshold.pen = *(uint16_t*)((char*)new_val_ptr + 0xc);
0001b16c                  }
0001b16c                  else if ((uint8_t)pContext == 9)
0001b171                  {
0001b181                      char var_10_1 = new_val_ptr[1];
0001b181                      
0001b188                      if ((char)*(uint64_t*)new_val_ptr & 0x7f)
0001b188                      {
0001b18a                          uint8_t* rax_3 = *(uint64_t*)new_val_ptr;
0001b18d                          r9->VersionMajor = (uint16_t)rax_3;
0001b18d                          r9->VersionMinor = *(uint16_t*)((char*)rax_3)[2];
0001b18d                          r9->VersionRelease = *(uint16_t*)((char*)rax_3)[4];
0001b18d                          r9->VersionBuild = *(uint16_t*)((char*)rax_3)[6];
0001b190                          (uint8_t)rax_3 = new_val_ptr[1];
0001b194                          r9->ReportMode = (uint8_t)rax_3;
0001b188                      }
0001b171                  }
0001b15e              }
0001b153          }
0001b13c      }
0001b13c      
0001b1ec      *(uint64_t*)new_val_ptr = r9;
0001b1f8      return 1;
0001b0c4  }

0001b1f9                                                                             cc cc cc cc cc cc cc                           .......

0001b200    void drv_CSFTouchPoint(void* pDrvSettingsContext, uint8_t preferMouse, struct csf_touch_report_t* touchReport)

0001b200  {
0001b21d      if (!*(uint8_t*)((char*)pDrvSettingsContext + 2) && !*(uint8_t*)(
0001b21d              *(uint64_t*)(*(uint64_t*)((char*)pDrvSettingsContext + 0xa0) + 0x10)
0001b21d              + 0x8bc0))
0001b208          return;
0001b208      
0001b21f      int64_t rax_2 = *(uint64_t*)((char*)pDrvSettingsContext + 0x90);
0001b21f      
0001b229      if (rax_2)
0001b232          rax_2(*(uint64_t*)((char*)pDrvSettingsContext + 0x98));
0001b200  }

0001b239                                                                             cc cc cc cc cc cc cc                           .......

0001b240    void drv_loadStDriver(struct DrvSettings_t* pContext, struct tv_item_t* st_tree, uint8_t* st_data)

0001b240  {
0001b279      ST_GetU16(st_tree, &pContext->st_Driver.ReportMode, st_data, 0x10, 0x73);
0001b293      ST_GetU8(st_tree, &pContext->st_Driver.Hardware, st_data, 0x10, 0x57);
0001b2ad      ST_GetU8(st_tree, &pContext->st_Driver.CamOrientation, st_data, 0x10, 0x5a);
0001b2cc      ST_GetFloat(st_tree, &pContext->st_Driver.dragThreshold, st_data, 0xc0, 0x7f);
0001b2e6      ST_GetFloat(st_tree, &pContext->st_Driver.dragThreshold.singleTouch, st_data, 0xc0, 
0001b2e6          0x80);
0001b300      ST_GetFloat(st_tree, &pContext->st_Driver.dragThreshold.doubleTouch, st_data, 0xc0, 
0001b300          0x81);
0001b31f      ST_GetU32(st_tree, &pContext->st_Driver.MouseEngine, st_data, 0xe0, 0x5d);
0001b339      ST_GetU32(st_tree, &pContext->st_Driver.MouseEngine.DoubleClickTime, st_data, 0xe0, 
0001b339          0x5e);
0001b353      ST_GetU16(st_tree, &pContext->st_Driver.MouseEngine.DragThreshold, st_data, 0xe0, 
0001b353          0x5f);
0001b36d      ST_GetU8(st_tree, &pContext->st_Driver.MouseEngine.Enabled, st_data, 0xe0, 0x84);
0001b38b      ST_GetU16(st_tree, &pContext->st_Driver.Panel, st_data, 0x20, 0x22);
0001b3a5      ST_GetU16(st_tree, &pContext->st_Driver.Panel.Y, st_data, 0x20, 0x23);
0001b3c3      ST_GetU8(st_tree, &pContext->st_Driver.NumofCalPoints, st_data, 0x70, 0x3a);
0001b3dd      ST_GetFloat(st_tree, &pContext->st_Driver.Pts, st_data, 0x70, 0x3b);
0001b3f7      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[0].y, st_data, 0x70, 0x3c);
0001b411      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[1], st_data, 0x70, 0x3d);
0001b42b      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[1].y, st_data, 0x70, 0x3e);
0001b445      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[2], st_data, 0x70, 0x3f);
0001b45f      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[2].y, st_data, 0x70, 0x40);
0001b479      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[3], st_data, 0x70, 0x41);
0001b493      ST_GetFloat(st_tree, &pContext->st_Driver.Pts[3].y, st_data, 0x70, 0x42);
0001b4ad      ST_GetU8(st_tree, &pContext->st_Driver.AmbientSubON, st_data, 0x10, 0x91);
0001b4c8      ST_GetFloat(st_tree, &pContext->st_Driver.AngleOffset, st_data, 0x30, 0x26);
0001b4df      ST_GetFloat(st_tree, &pContext->st_Driver.AngleOffset[1], st_data, 0x40, 0x26);
0001b4f6      ST_GetFloat(st_tree, &pContext->st_Driver.AngleOffset[2], st_data, 0x50, 0x26);
0001b50d      ST_GetFloat(st_tree, &pContext->st_Driver.AngleOffset[3], st_data, 0x60, 0x26);
0001b527      ST_GetU32(st_tree, &pContext->st_Driver.Test_ID, st_data, 0x10, 0x6f);
0001b240  }

0001b547                       cc cc cc cc cc cc cc cc cc                                                         .........

0001b550    int32_t __convention("sysv") RtlStringCbPrintfA(char* pszDest @ rcx, uint64_t cbDest @ rdx, char const* pszFormat @ r8, ...)

0001b550  {
0001b550      char const* pszFormat_1 = pszFormat;
0001b555      int64_t entry_r9;
0001b555      int64_t arg_20 = entry_r9;
0001b561      int32_t result = 0;
0001b561      
0001b572      if (!cbDest || cbDest > 0x7fffffff)
0001b574          result = -0x3ffffff3;
0001b574      
0001b57b      if (result >= 0)
0001b57b      {
0001b586          result = 0;
0001b58b          int64_t entry_rsi;
0001b58b          int64_t entry_rdi;
0001b58b          int32_t rax_1 =
0001b58b              j__vsnprintf(pszDest, cbDest - 1, pszFormat, &arg_20, entry_rdi, entry_rsi);
0001b592          int64_t rax_2;
0001b592          
0001b592          if (rax_1 >= 0)
0001b594              rax_2 = (int64_t)rax_1;
0001b594          
0001b599          if (rax_1 < 0 || rax_2 > cbDest - 1)
0001b599          {
0001b5a2              *(uint8_t*)(cbDest - 1 + pszDest) = 0;
0001b5a5              return -0x7ffffffb;
0001b599          }
0001b599          
0001b59b          if (rax_2 == cbDest - 1)
0001b59d              *(uint8_t*)(cbDest - 1 + pszDest) = 0;
0001b57b      }
0001b57b      
0001b5b3      return result;
0001b550  }

0001b5b4                                                              cc cc cc cc cc cc cc cc                                  ........

0001b5bc    uint8_t SI_Input_Report(struct _TLIO_CONTEXT* pContext, uint8_t* data, int32_t size)

0001b5bc  {
0001b5c0      uint32_t r9 = (uint32_t)*(uint8_t*)data;
0001b5c4      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext = pContext->pUserModeContext;
0001b5c4      
0001b5cc      if (r9 == 0x43)
0001b62a          USB_Handle_Command(pUserModeContext, data, size);
0001b5cc      else if (r9 == 0x47)
0001b623          USB_Handle_Scope(pUserModeContext, data, size);
0001b5d2      else if (r9 == 0x4c)
0001b5d8      {
0001b617          (uint8_t)size = 0x10;
0001b602          SendText(pUserModeContext, "Not implemented", (uint8_t)size);
0001b5d8      }
0001b5d8      else if (r9 == 0x53)
0001b610          USB_Handle_New_Settings(pUserModeContext, data, size);
0001b5de      else if (r9 == 0x54)
0001b609          USB_Handle_Text(pUserModeContext, data, size);
0001b5e4      else
0001b5e4      {
0001b5ea          char* str;
0001b5ea          
0001b5ea          if (r9 == 0x73)
0001b5ea          {
0001b5f8              (uint8_t)size = 0x12;
0001b5fb              str = "Error: Unsupported";
0001b5ea          }
0001b5ea          else
0001b5ea          {
0001b5ec              (uint8_t)size = 9;
0001b5ef              str = "Unknown ";
0001b5ea          }
0001b5ea          
0001b602          SendText(pUserModeContext, str, (uint8_t)size);
0001b5e4      }
0001b5e4      
0001b62f      int64_t rax;
0001b62f      (uint8_t)rax = 1;
0001b635      return 1;
0001b5bc  }

0001b636                                                                    cc cc cc cc cc cc                                    ......

0001b63c    void SI_CalibrationFinished(void* param, uint8_t Completed, uint8_t CamOrientation, struct fpoint_t* Pts)

0001b63c  {
0001b64e      int64_t rbx;
0001b64e      (uint8_t)rbx = CamOrientation;
0001b64e      
0001b656      if (!Completed)
0001b656      {
0001b6b3          USB_Put_ErrCode(param, 0x15);
0001b6b3          return;
0001b656      }
0001b656      
0001b658      Completed = 0x21;
0001b658      
0001b65d      if ((uint8_t)rbx != 1)
0001b65f          Completed = 0x22;
0001b65f      
0001b661      USB_Put_ErrCode(param, Completed);
0001b676      memmove((char*)param + 0x480, Pts, 0x20);
0001b67b      uint32_t SerialNumber = *(uint32_t*)((char*)param + 0x50f);
0001b682      uint32_t ModelNumber = *(uint32_t*)((char*)param + 0x508);
0001b689      uint8_t GotSettingsFromFW = *(uint8_t*)((char*)param + 0x8bec);
0001b696      *(uint8_t*)((char*)param + 0x463) = (uint8_t)rbx;
0001b69c      drv_WriteSettingsToFile((char*)param + 0x450, GotSettingsFromFW, ModelNumber, 
0001b69c          SerialNumber);
0001b6aa      drv_StDriverUpdated((char*)param + 0x450, 1);
0001b63c  }

0001b6c8                          cc cc cc cc cc cc cc cc                                                          ........

0001b6d0    void SI_Output_Report(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t* data, int32_t size)

0001b6d0  {
0001b6db      uint8_t (* SendTLReportCallback)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001b6db          PTransLibUserModeContext->TLIOContext.SendTLReportCallback;
0001b6db      
0001b6e2      if (!SendTLReportCallback)
0001b702          onBug__("TransLibIO.c: SendTLReportCallback not assigned", 
0001b702              "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0x93);
0001b6e2      else
0001b6ea          SendTLReportCallback(&PTransLibUserModeContext->TLIOContext, data, 0x40);
0001b6d0  }

0001b70c                                      cc cc cc cc cc cc cc cc                                                  ........

0001b714    void USB_Handle_Scope(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t* InData, uint32_t size)

0001b714  {
0001b734      if (size < 3)
0001b734      {
0001b922          onError__("USB_Handle_Scope: data size not big enough\n", 
0001b922              "c:\development_work\csf_release_hp\driver\translib\settingsinterface.c", 
0001b922              0x108);
0001b922          return;
0001b734      }
0001b734      
0001b73a      ScopeData[5] = 0x10;
0001b741      __builtin_memcpy(&ScopeData, "\x47\x3d", 2);
0001b74f      uint8_t rax_1 = InData[2];
0001b752      ScopeData[4] = rax_1;
0001b758      char rdx = rax_1 - 0x31;
0001b758      
0001b75d      if (rax_1 < 0x31)
0001b75d          return;
0001b75d      
0001b763      int32_t rdi_1 = 0;
0001b765      uint32_t rsi_1 = 0x20c;
0001b76c      uint8_t trigger;
0001b76c      uint16_t (* destBuffer)[0x20c];
0001b76c      uint8_t lit;
0001b76c      
0001b76c      if (rax_1 <= 0x34)
0001b76c      {
0001b827          lit = 0;
0001b82a      label_1b82a:
0001b82a          int32_t var_18_2 = 0x20c;
0001b835          destBuffer = &PTransLibUserModeContext->waveformBuffer;
0001b83a          trigger = 0;
0001b849      label_1b849:
0001b849          CSF_CopyWaveform(PTransLibUserModeContext->pCSFContext, (uint32_t)rdx, 0, lit, 
0001b849              trigger, destBuffer, 0x20c);
0001b84e      label_1b84e:
0001b84e          int16_t rax_7 = *(uint16_t*)(
0001b84e              (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 0xb);
0001b84e          
0001b858          if (rax_7 > 0x20c)
0001b85a              rsi_1 = (uint32_t)rax_7;
0001b85a          
0001b86f          int32_t rbp_3 = rsi_1 / 0x1c;
0001b86f          
0001b873          if (rbp_3 >= 0)
0001b873          {
0001b906              do
0001b906              {
0001b87c                  uint8_t* i = &ScopeData[7];
0001b883                  uint16_t rcx_4 = (uint16_t)rdi_1 * 0x1c;
0001b88a                  ScopeData[3] = (uint8_t)rcx_4;
0001b894                  ScopeData[2] = (rcx_4 >> 8);
0001b89d                  void* rcx_5 = &PTransLibUserModeContext->waveformBuffer[(uint64_t)rcx_4];
0001b89d                  
0001b8bd                  do
0001b8bd                  {
0001b8a5                      int16_t rax_12 = *(uint16_t*)rcx_5;
0001b8a8                      rcx_5 += 2;
0001b8ac                      *(uint16_t*)i = rax_12;
0001b8b6                      i = &i[2];
0001b8bd                  } while (i < &ScopeData[0x3f]);
0001b8bd                  
0001b8cb                  ET_Swap16N(&ScopeData[7], 0x1c);
0001b8cb                  
0001b8d2                  if (rdi_1 == rbp_3)
0001b8d2                  {
0001b8d9                      ScopeData[0] = 0x67;
0001b8e7                      ScopeData[1] = ((uint8_t)rsi_1 + 3) * 2 - 0x38 * (uint8_t)rbp_3;
0001b8d2                  }
0001b8d2                  
0001b8fd                  SI_Output_Report(PTransLibUserModeContext, &ScopeData, 0x40);
0001b902                  rdi_1 += 1;
0001b906              } while (rdi_1 <= rbp_3);
0001b873          }
0001b76c      }
0001b76c      else if (rax_1 > 0x3a)
0001b774      {
0001b77c          if (rax_1 <= 0x3e)
0001b77c          {
0001b80a              int32_t var_18_1 = 0x20c;
0001b815              rdx -= 0xa;
0001b818              destBuffer = &PTransLibUserModeContext->waveformBuffer;
0001b81d              trigger = 1;
0001b822              lit = 0;
0001b825              goto label_1b849;
0001b77c          }
0001b77c          
0001b784          if (rax_1 > 0x44)
0001b784          {
0001b78c              if (rax_1 <= 0x48)
0001b78c              {
0001b802                  rdx -= 0x14;
0001b805                  lit = 1;
0001b808                  goto label_1b82a;
0001b78c              }
0001b78c              
0001b798              if (rax_1 > 0x4e && rax_1 <= 0x52)
0001b798              {
0001b79e                  struct _NW_CSF_CONTEXT* pCSFContext =
0001b79e                      PTransLibUserModeContext->pCSFContext;
0001b7a5                  uint64_t r12_1 = (uint64_t)(rdx - 0x1e);
0001b7a5                  
0001b7ad                  if ((uint32_t)r12_1 <= 3
0001b7ad                      && ST_AcquireLock(&pCSFContext->ctlContext.waveformLock, 0x3e8))
0001b7ad                  {
0001b7ec                      memmove(&PTransLibUserModeContext->waveformBuffer, 
0001b7ec                          &pCSFContext->ctlContext.waveforms[r12_1].ambient, 0x418);
0001b7fa                      KeReleaseMutex(&pCSFContext->ctlContext.waveformLock.mutex, 0);
0001b7ad                  }
0001b7ad                  
0001b7ad                  goto label_1b84e;
0001b798              }
0001b784          }
0001b774      }
0001b714  }

0001b942        cc cc cc cc cc cc                                                                            ......

0001b948    void USB_Handle_Text(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t* InData, uint32_t size)

0001b948  {
0001b95b      void var_48;
0001b95b      int64_t rax_1 = __security_cookie ^ &var_48;
0001b963      uint32_t rdi = (uint32_t)InData[1];
0001b980      RtlStringCbPrintfA(&loctempstr, 0x64, &InData[2]);
0001b985      int32_t rcx = (int32_t)loctempstr[0];
0001b985      
0001b98f      if (rcx == 0x4c)
0001b98f      {
0001bb40          if (rdi == 1)
0001bb40          {
0001bb49          label_1bb49:
0001bb49              drv_StDriverInit(&PTransLibUserModeContext->DrvSettingsContext);
0001bb4e              struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext_1 =
0001bb4e                  PTransLibUserModeContext->DrvSettingsContext.pUserModeContext;
0001bb5c              uint32_t SerialNumber =
0001bb5c                  *(uint32_t*)((char*)pUserModeContext_1->FwSettingsContext.st_Device + 7);
0001bb63              uint32_t ModelNumber =
0001bb63                  *(uint32_t*)((char*)pUserModeContext_1->FwSettingsContext.st_Device + 0);
0001bb6a              (uint8_t)pUserModeContext_1 =
0001bb6a                  pUserModeContext_1->FwSettingsContext.GotSettingsFromFW;
0001bb70              drv_WriteSettingsToFile(&PTransLibUserModeContext->DrvSettingsContext, 
0001bb70                  (uint8_t)pUserModeContext_1, ModelNumber, SerialNumber);
0001bb7e              drv_StDriverUpdated(&PTransLibUserModeContext->DrvSettingsContext, 1);
0001bb88              USB_Put_ErrCode(PTransLibUserModeContext, 0x24);
0001bb40          }
0001b98f      }
0001b98f      else if (rcx != 0x4d)
0001b998      {
0001b99e          bool cond:1_1 = rcx == 0x52;
0001b99e          bool cond:4_1 = rcx != 0x52;
0001b99e          bool cond:6_1 = rcx != 0x52;
0001b99e          
0001b9a1          if (rcx == 0x52)
0001b9a1          {
0001ba5a              char* const rsi_1 = "RestoreDefaults";
0001ba61              char* rdi_2 = &loctempstr;
0001ba64              int64_t i = 0x10;
0001ba64              
0001ba69              while (i)
0001ba69              {
0001ba69                  char temp6_1 = *(uint8_t*)rsi_1;
0001ba69                  char temp7_1 = *(uint8_t*)rdi_2;
0001ba69                  cond:1_1 = temp6_1 == temp7_1;
0001ba69                  cond:4_1 = temp6_1 != temp7_1;
0001ba69                  cond:6_1 = temp6_1 != temp7_1;
0001ba69                  rsi_1 = &rsi_1[1];
0001ba69                  rdi_2 = &rdi_2[1];
0001ba69                  i -= 1;
0001ba69                  
0001ba69                  if (temp6_1 != temp7_1)
0001ba69                      break;
0001ba69              }
0001ba69              
0001ba6b              if (cond:1_1)
0001ba6b                  goto label_1bb49;
0001ba6b              
0001ba71              char* const rsi_2 = "ResetUSB";
0001ba78              char* rdi_3 = &loctempstr;
0001ba7b              int64_t i_1 = 9;
0001ba7b              
0001ba80              while (i_1)
0001ba80              {
0001ba80                  char temp8_1 = *(uint8_t*)rsi_2;
0001ba80                  char temp9_1 = *(uint8_t*)rdi_3;
0001ba80                  cond:4_1 = temp8_1 != temp9_1;
0001ba80                  cond:6_1 = temp8_1 != temp9_1;
0001ba80                  rsi_2 = &rsi_2[1];
0001ba80                  rdi_3 = &rdi_3[1];
0001ba80                  i_1 -= 1;
0001ba80                  
0001ba80                  if (temp8_1 != temp9_1)
0001ba80                      break;
0001ba80              }
0001ba80              
0001ba82              if (cond:4_1)
0001ba82              {
0001bab1                  char* const rsi_3 = "Reset";
0001bab8                  char* rdi_4 = &loctempstr;
0001babb                  int64_t i_2 = 6;
0001babb                  
0001bac0                  while (i_2)
0001bac0                  {
0001bac0                      char temp10_1 = *(uint8_t*)rsi_3;
0001bac0                      char temp11_1 = *(uint8_t*)rdi_4;
0001bac0                      cond:6_1 = temp10_1 != temp11_1;
0001bac0                      rsi_3 = &rsi_3[1];
0001bac0                      rdi_4 = &rdi_4[1];
0001bac0                      i_2 -= 1;
0001bac0                      
0001bac0                      if (temp10_1 != temp11_1)
0001bac0                          break;
0001bac0                  }
0001bac0                  
0001bac2                  if (!cond:6_1)
0001bac2                  {
0001bac8                      struct _NW_TRANSLIB_USERMODE_CONTEXT* pUserModeContext =
0001bac8                          PTransLibUserModeContext->DrvSettingsContext.pUserModeContext;
0001baea                      drv_LoadSettingsFromFile(
0001baea                          &PTransLibUserModeContext->DrvSettingsContext, 
0001baea                          pUserModeContext->FwSettingsContext.GotSettingsFromFW, 
0001baea                          *(uint32_t*)((char*)pUserModeContext->FwSettingsContext.st_Device
0001baea                              + 0), 
0001baea                          *(uint32_t*)((char*)pUserModeContext->FwSettingsContext.st_Device
0001baea                          + 7));
0001bafa                      CTL_Init_Triggers(PTransLibUserModeContext->DrvSettingsContext.
0001bafa                          pUserModeContext->pCSFContext);
0001bac2                  }
0001ba82              }
0001ba82              else
0001ba82              {
0001ba84                  struct _NW_CSF_CONTEXT* pCSFContext =
0001ba84                      PTransLibUserModeContext->pCSFContext;
0001ba88                  gStreamStatusTime = 0;
0001ba93                  *(uint64_t*)((char*)pCSFContext->PTContext.ProcessTouchStatusTime + 0) =
0001ba93                      0;
0001ba9b                  pCSFContext->PTContext.ProcessTouchStatus = 0;
0001baa2                  gStreamStatus = 0;
0001baa9                  PTransLibUserModeContext->pTransLibResetUSB(PTransLibUserModeContext);
0001ba82              }
0001b9a1          }
0001b9a1          else if (rcx == 0x6b)
0001b9aa          {
0001ba21              uint8_t rax_2 = loctempstr[1][0];
0001ba21              
0001ba29              if (rax_2 == 0x31)
0001ba29              {
0001ba2f                  CSF_StartCalibration(PTransLibUserModeContext->pCSFContext);
0001bb88                  USB_Put_ErrCode(PTransLibUserModeContext, 0x14);
0001ba29              }
0001ba29              else if (rax_2 == 0x30)
0001ba3d              {
0001ba4e                  Calib_CancelCalibration(
0001ba4e                      &PTransLibUserModeContext->pCSFContext->CalibContext);
0001bb88                  USB_Put_ErrCode(PTransLibUserModeContext, 0x15);
0001ba3d              }
0001b9aa          }
0001b9aa          else
0001b9aa          {
0001b9af              if (rcx == 0x6d)
0001b9af              {
0001b9f8                  PTransLibUserModeContext->DrvSettingsContext.InputDevicesEnabled = 0;
0001b9f8                  goto label_1b9ff;
0001b9af              }
0001b9af              
0001b9b4              if (rcx == 0x75)
0001b9b4              {
0001b9be                  CTL_Init_Triggers(PTransLibUserModeContext->pCSFContext);
0001b9ca                  void (* UpdateCamerasCallback)(struct _TLIO_CONTEXT*) =
0001b9ca                      PTransLibUserModeContext->TLIOContext.UpdateCamerasCallback;
0001b9ca                  
0001b9d1                  if (!UpdateCamerasCallback)
0001b9ee                      onBug__("TransLibIO.c: UpdateCamerasCallback not assigned", 
0001b9ee                          "c:\development_work\csf_release_hp\driver\translib\translibio.c", 
0001b9ee                          0xb4);
0001b9d1                  else
0001b9d3                      UpdateCamerasCallback(&PTransLibUserModeContext->TLIOContext);
0001b9b4              }
0001b9aa          }
0001b998      }
0001b998      else if (InData[1] != 2 || loctempstr[1][0] != 0x3f)
0001bb11      {
0001bb31          PTransLibUserModeContext->DrvSettingsContext.InputDevicesEnabled = 1;
0001b9ff      label_1b9ff:
0001b9ff          int64_t i_3 = -1;
0001ba05          char* rdi_1 = &loctempstr;
0001ba05          
0001ba08          while (i_3)
0001ba08          {
0001ba08              bool cond:2_1 = 0 != *(uint8_t*)rdi_1;
0001ba08              rdi_1 = &rdi_1[1];
0001ba08              i_3 -= 1;
0001ba08              
0001ba08              if (!cond:2_1)
0001ba08                  break;
0001ba08          }
0001ba08          
0001ba17          SendText(PTransLibUserModeContext, &loctempstr, (char)~i_3 - 1);
0001bb11      }
0001bb11      else
0001bb11      {
0001bb1e          int32_t rcx_2;
0001bb1e          (uint8_t)rcx_2 = (rcx - 0x4d) - (rcx - 0x4d);
0001bb20          (uint8_t)rcx_2 &= 0xe0;
0001bb23          (uint8_t)rcx_2 += 0x6d;
0001bb26          loctempstr[0] = (uint8_t)rcx_2;
0001ba17          SendText(PTransLibUserModeContext, &loctempstr, 1);
0001bb11      }
0001bb11      
0001bb95      __security_check_cookie(rax_1 ^ &var_48);
0001b948  }

0001bba7                       cc cc cc cc cc cc cc cc cc                                                         .........

0001bbb0    void USB_Handle_New_Settings(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t* data, uint32_t size)

0001bbb0  {
0001bbcb      void var_468;
0001bbcb      int64_t rax_1 = __security_cookie ^ &var_468;
0001bbd9      struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext_1 =
0001bbd9          PTransLibUserModeContext;
0001bbdc      (uint8_t)PTransLibUserModeContext = data[2];
0001bbdf      uint32_t rdx = (uint32_t)data[1];
0001bbe6      int16_t data_1;
0001bbe6      char var_432;
0001bbe6      
0001bbe6      if (rdx == 0x72)
0001bbe6      {
0001bd18          int32_t rdx_1;
0001bd18          
0001bd18          if ((uint8_t)PTransLibUserModeContext == 0x41)
0001bd18          {
0001be0e              int16_t var_448_1 = 0x80;
0001be14              *(uint8_t*)((char*)var_448_1)[1] = 0x80;
0001be19              (uint8_t)var_448_1 = 0;
0001be26              int16_t var_434_1 = 0;
0001be2b              int16_t var_448_2 = 0x5d;
0001be31              *(uint8_t*)((char*)var_448_2)[1] = 0x5d;
0001be36              (uint8_t)var_448_2 = 0;
0001be3a              data_1 = 0;
0001be4e              int16_t var_436_1 = var_448_2;
0001be53              memmove(&var_432, &drv_tv_Items, 0x80);
0001be6a              uint8_t var_3b2[0x37a];
0001be6a              ST_EndianSwap(&var_3b2, 
0001be6a                  &PTransLibUserModeContext_1->DrvSettingsContext.st_Driver, &drv_tv_Items);
0001be75              (uint8_t)rdx_1 = 0x41;
0001be7f              USB_Send_New_Settings_Blob(PTransLibUserModeContext_1, (uint8_t)rdx_1, 
0001be7f                  &data_1, 0xe3);
0001bd18          }
0001bd18          else
0001bd18          {
0001bd1e              (uint8_t)rdx_1 = 0x52;
0001bd1e              
0001bd22              if ((uint8_t)PTransLibUserModeContext == 0x52)
0001bd22              {
0001bddf                  __builtin_memset(&data_1, 0xff, 0x1f);
0001be7f                  USB_Send_New_Settings_Blob(PTransLibUserModeContext_1, (uint8_t)rdx_1, 
0001be7f                      &data_1, 0x1f);
0001bd22              }
0001bd22              else
0001bd22              {
0001bd28                  (uint8_t)rdx_1 = 0x54;
0001bd28                  
0001bd2c                  switch ((uint8_t)PTransLibUserModeContext)
0001bd2c                  {
0001bd2a                      case 0x54:
0001bd2a                      {
0001be7f                          USB_Send_New_Settings_Blob(PTransLibUserModeContext_1, 
0001be7f                              (uint8_t)rdx_1, &drv_tv_Items, 0x80);
0001bd2a                          break;
0001bd2a                      }
0001bd32                      case 0x56:
0001bd32                      {
0001bdb7                          ST_EndianSwap(&data_1, 
0001bdb7                              &PTransLibUserModeContext_1->DrvSettingsContext.st_Driver, 
0001bdb7                              &drv_tv_Items);
0001bdc2                          (uint8_t)rdx_1 = 0x56;
0001be7f                          USB_Send_New_Settings_Blob(PTransLibUserModeContext_1, 
0001be7f                              (uint8_t)rdx_1, &data_1, 0x5d);
0001bd32                          break;
0001bd32                      }
0001bd37                      case 0x61:
0001bd37                      {
0001bd72                          onError__(
0001bd72                              "Send all settings to BULK Not supported. No BULK connection !", 
0001bd72                              "c:\development_work\csf_release_hp\driver\translib\s"
0001bd72                          "ettingsinterface.c", 0x1bf);
0001bd7c                          USB_Put_ErrCode(PTransLibUserModeContext_1, 0xff);
0001bd37                          break;
0001bd37                      }
0001bd3c                      case 0x72:
0001bd3c                      {
0001bd72                          onError__(
0001bd72                              "Send rewrites to BULK Not supported. No BULK connection !", 
0001bd72                              "c:\development_work\csf_release_hp\driver\translib\s"
0001bd72                          "ettingsinterface.c", 
0001bd72                              0x1bb);
0001bd7c                          USB_Put_ErrCode(PTransLibUserModeContext_1, 0xff);
0001bd3c                          break;
0001bd3c                      }
0001bd41                      case 0x74:
0001bd41                      {
0001bd72                          onError__(
0001bd72                              "Send tree to BULK Not supported. No BULK connection !", 
0001bd72                              "c:\development_work\csf_release_hp\driver\translib\s"
0001bd72                          "ettingsinterface.c", 
0001bd72                              0x1b3);
0001bd7c                          USB_Put_ErrCode(PTransLibUserModeContext_1, 0xff);
0001bd41                          break;
0001bd41                      }
0001bd46                      case 0x76:
0001bd46                      {
0001bd72                          onError__(
0001bd72                              "Send values to BULK Not supported. No BULK connection !", 
0001bd72                              "c:\development_work\csf_release_hp\driver\translib\s"
0001bd72                          "ettingsinterface.c", 
0001bd72                              0x1b7);
0001bd7c                          USB_Put_ErrCode(PTransLibUserModeContext_1, 0xff);
0001bd46                          break;
0001bd46                      }
0001bd2c                  }
0001bd22              }
0001bd18          }
0001bbe6      }
0001bbe6      else if (rdx == 0x73)
0001bbef      {
0001bbf5          uint16_t rax_2 = *(uint16_t*)(data + 2);
0001bc0d          uint8_t* new_val_ptr = &data[6];
0001bc12          (uint8_t)PTransLibUserModeContext = (uint8_t)rax_2;
0001bc16          (uint8_t)PTransLibUserModeContext ^= (rax_2 >> 8);
0001bc18          (uint8_t)rax_2 = *(uint8_t*)((char*)rax_2)[1];
0001bc1c          (uint8_t)rax_2 ^= (uint8_t)PTransLibUserModeContext;
0001bc1e          (uint8_t)PTransLibUserModeContext ^= (uint8_t)rax_2;
0001bc20          uint16_t tree_index;
0001bc20          *(uint8_t*)((char*)tree_index)[1] = (uint8_t)rax_2;
0001bc24          (uint8_t)tree_index = (uint8_t)PTransLibUserModeContext;
0001bc2d          char typespec = drv_tv_Items[(uint64_t)tree_index].typespec;
0001bc33          (uint8_t)PTransLibUserModeContext = typespec;
0001bc41          int64_t r14_1 = (int64_t)ST_GetSettingSize((uint8_t)PTransLibUserModeContext);
0001bc44          char rax_5;
0001bc44          
0001bc44          if (tree_index <= 0x7f)
0001bc5e              rax_5 = drv_UpdateNewSetting(&PTransLibUserModeContext_1->DrvSettingsContext, 
0001bc5e                  tree_index, &new_val_ptr);
0001bc44          else
0001bc46              rax_5 = 2;
0001bc46          
0001bc6c          *(uint8_t*)((char*)data_1)[1] = (char)(r14_1 + 8);
0001bc76          int16_t var_434;
0001bc76          (uint8_t)var_434 = data[2];
0001bc7d          (uint8_t)data_1 = 0x53;
0001bc82          *(uint8_t*)((char*)var_434)[1] = data[3];
0001bc8b          int16_t var_436;
0001bc8b          (uint8_t)var_436 = 0x73;
0001bc90          *(uint8_t*)((char*)var_436)[1] = 1;
0001bc95          var_432 = 0xff;
0001bc9a          char var_431_1 = 0;
0001bc9e          int64_t var_430;
0001bc9e          (uint8_t)var_430 = rax_5;
0001bca2          *(uint8_t*)((char*)var_430)[1] = typespec;
0001bca7          memmove(&*(uint64_t*)((char*)var_430)[2], &data[6], r14_1);
0001bcb3          uint8_t (* SendTLReportCallback)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001bcb3              PTransLibUserModeContext_1->TLIOContext.SendTLReportCallback;
0001bcb3          
0001bcba          if (!SendTLReportCallback)
0001bcdd              onBug__("TransLibIO.c: SendTLReportCallback not assigned", 
0001bcdd                  "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0x93);
0001bcba          else
0001bcc5              SendTLReportCallback(&PTransLibUserModeContext_1->TLIOContext, &data_1, 0x40);
0001bcc5          
0001bceb          drv_StDriverUpdated(&PTransLibUserModeContext_1->DrvSettingsContext, 1);
0001bd0b          drv_WriteSettingsToFile(&PTransLibUserModeContext_1->DrvSettingsContext, 
0001bd0b              PTransLibUserModeContext_1->FwSettingsContext.GotSettingsFromFW, 
0001bd0b              *(uint32_t*)((char*)PTransLibUserModeContext_1->FwSettingsContext.st_Device
0001bd0b                  + 0), 
0001bd0b              *(uint32_t*)((char*)PTransLibUserModeContext_1->FwSettingsContext.st_Device
0001bd0b              + 7));
0001bbef      }
0001be8f      __security_check_cookie(rax_1 ^ &var_468);
0001bbb0  }

0001beac                                      cc cc cc cc cc cc cc cc                                                  ........

0001beb4    void Read_Setting(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, int32_t Setting)

0001beb4  {
0001beca      void var_78;
0001beca      int64_t rax_1 = __security_cookie ^ &var_78;
0001bee2      uint8_t data = 0x43;
0001bee7      char var_57;
0001bee7      memset(&var_57, 0, 0x3f);
0001beef      char var_56 = (uint8_t)Setting;
0001bef8      char r11;
0001bef8      uint16_t DragThreshold;
0001bef8      
0001bef8      if (Setting > 0x36)
0001bef8      {
0001c00e          if (Setting > 0x80)
0001c00e          {
0001c1d7              if (Setting == 0x81)
0001c1d7              {
0001c244                  (uint8_t)DragThreshold =
0001c244                      PTransLibUserModeContext->pCSFContext->meContext.Settings.Enabled;
0001c248                  r11 = 1;
0001c1d7              }
0001c1d7              else if (Setting == 0x83)
0001c1dc              {
0001c200                  uint8_t gStreamStatus_1 = gStreamStatus;
0001c206                  struct _NW_CSF_CONTEXT* pCSFContext =
0001c206                      PTransLibUserModeContext->pCSFContext;
0001c20a                  var_57 = 9;
0001c20f                  (uint8_t)DragThreshold = gStreamStatus_1;
0001c21a                  r11 = 0x12;
0001c21d                  *(uint64_t*)((char*)DragThreshold)[1] = gStreamStatusTime;
0001c222                  int64_t rax_16;
0001c222                  (uint8_t)rax_16 = pCSFContext->PTContext.ProcessTouchStatus;
0001c228                  char var_4c_1 = (uint8_t)rax_16;
0001c233                  int64_t var_4b_1 = *
0001c233                      (uint64_t*)((char*)pCSFContext->PTContext.ProcessTouchStatusTime + 0);
0001c1dc              }
0001c1dc              else if (Setting == 0x84)
0001c1e0              {
0001bf98                  (uint8_t)DragThreshold =
0001bf98                      PTransLibUserModeContext->pCSFContext->PTContext.OffscreenMode;
0001c248                  r11 = 1;
0001c1e0              }
0001c1e0              else if (Setting != 0x85)
0001c1ca                  r11 = var_57;
0001c1e4              else
0001c1e4              {
0001bf34                  (uint8_t)DragThreshold = gCSFEnabled;
0001c248                  r11 = 1;
0001c1e4              }
0001c00e          }
0001c00e          else if (Setting == 0x80)
0001c014          {
0001c19b              int16_t var_53_1 = 1;
0001c1a0              DragThreshold = 3;
0001c1aa              var_57 = 8;
0001c1af              int16_t var_51_1 = 0xc;
0001c1bd              int16_t var_4f_1 = 7;
0001c1c5              ET_Swap16N(&DragThreshold, 4);
0001c1ca              r11 = var_57;
0001c014          }
0001c014          else
0001c014          {
0001c01d              void* __offset(_NW_TRANSLIB_USERMODE_CONTEXT, 0x52f) rdx_4;
0001c01d              
0001c01d              if (Setting == 0x43)
0001c01d              {
0001c163                  rdx_4 = &*(uint64_t*)(
0001c163                      (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 0x47);
0001c175              label_1c175:
0001c175                  memmove(&DragThreshold, rdx_4, 0x20);
0001c184                  ET_Swap32N(&DragThreshold, 8);
0001c189                  r11 = 0x20;
0001c01d              }
0001c01d              else
0001c01d              {
0001c025                  if (Setting == 0x44)
0001c025                  {
0001c144                      rdx_4 = &PTransLibUserModeContext->DrvSettingsContext.st_Driver.Pts;
0001c14b                      float zmm0 = *(uint32_t*)(
0001c14b                          (char*)ADJ(rdx_4)->FwSettingsContext.st_Device + 0x27);
0001c14f                      zmm0 - 0f;
0001c14f                      
0001c158                      if (!FCMP_UO(zmm0, 0f) && !(zmm0 != 0f))
0001c15a                          rdx_4 = &*(uint64_t*)(
0001c15a                              (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c15a                              + 0x27);
0001c15a                      
0001c158                      goto label_1c175;
0001c025                  }
0001c025                  
0001c02d                  if (Setting == 0x45)
0001c02d                  {
0001bf34                      (uint8_t)DragThreshold = PTransLibUserModeContext->DrvSettingsContext.
0001bf34                          st_Driver.CamOrientation;
0001c248                      r11 = 1;
0001c02d                  }
0001c02d                  else if (Setting == 0x50)
0001c036                  {
0001c12b                      DragThreshold = *(uint32_t*)(
0001c12b                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c12b                          + 0x67);
0001c12f                      ET_Swap16N(&DragThreshold, 2);
0001bf83                      r11 = 4;
0001c036                  }
0001c036                  else if (Setting != 0x70)
0001c1ca                      r11 = var_57;
0001c03f                  else
0001c03f                  {
0001c053                      (uint8_t)DragThreshold = *(uint8_t*)(
0001c053                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c053                          + 0xba);
0001c057                      int32_t rax_7 = *(uint32_t*)(
0001c057                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c057                          + 0xbf);
0001c05d                      var_57 = 1;
0001c062                      *(uint32_t*)((char*)DragThreshold)[1] = rax_7;
0001c066                      ET_Swap16N(&*(uint16_t*)((char*)DragThreshold)[1], Setting - 0x6e);
0001c06b                      int32_t rdx_2;
0001c06b                      (uint8_t)rdx_2 = var_57;
0001c06f                      char rax_8 = *(uint8_t*)(
0001c06f                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c06f                          + 0xff);
0001c079                      (uint8_t)rdx_2 += (Setting - 0x50) - 0x1c;
0001c07c                      var_57 = (uint8_t)rdx_2;
0001c086                      *(uint8_t*)(&DragThreshold + (uint64_t)(uint8_t)rdx_2) = rax_8;
0001c091                      uint64_t rcx_9 = (uint64_t)(var_57 + 1);
0001c094                      var_57 += 1;
0001c09e                      *(uint32_t*)(&DragThreshold + rcx_9) = *(uint32_t*)(
0001c09e                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c09e                          + 0x104);
0001c0ac                      ET_Swap16N(&var_78 + (uint64_t)var_57 + 0x23, Setting - 0x6e);
0001c0b1                      int32_t rdx_3;
0001c0b1                      (uint8_t)rdx_3 = var_57;
0001c0b5                      int16_t rax_11 = *(uint16_t*)(
0001c0b5                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c0b5                          + 0x19);
0001c0bc                      (uint8_t)rdx_3 += (Setting - 0x50) - 0x1c;
0001c0bf                      var_57 = (uint8_t)rdx_3;
0001c0c8                      *(uint16_t*)(&DragThreshold + (uint64_t)(uint8_t)rdx_3) = rax_11;
0001c0cd                      (uint8_t)rax_11 = var_57;
0001c0d1                      (uint8_t)rax_11 += 2;
0001c0d3                      var_57 = (uint8_t)rax_11;
0001c0d7                      uint64_t rcx_12 = (uint64_t)(uint8_t)rax_11;
0001c0da                      (uint8_t)rax_11 = *(uint8_t*)(
0001c0da                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c0da                          + 0xf);
0001c0e0                      *(uint8_t*)(&DragThreshold + rcx_12) = (uint8_t)rax_11;
0001c0e4                      (uint8_t)rax_11 = var_57;
0001c0e8                      (uint8_t)rax_11 += 1;
0001c0ee                      var_57 = (uint8_t)rax_11;
0001c0f9                      *(uint16_t*)(&DragThreshold + (uint64_t)(uint8_t)rax_11) = *(uint16_t
0001c0f9                          *)((char*)PTransLibUserModeContext->FwSettingsContext.st_Device
0001c0f9                          + 0xb);
0001c108                      ET_Swap16N(&var_78 + (uint64_t)var_57 + 0x23, 1);
0001c112                      r11 = var_57 + 2;
0001c03f                  }
0001c01d              }
0001c014          }
0001bef8      }
0001bef8      else
0001bef8      {
0001befe          uint16_t ReportMode;
0001befe          
0001befe          if (Setting == 0x36)
0001befe          {
0001bffb              ReportMode = PTransLibUserModeContext->DrvSettingsContext.ReportMode;
0001bf54          label_1bf54:
0001bf54              DragThreshold = ReportMode;
0001bf60              ET_Swap16N(&DragThreshold, 1);
0001bf65              r11 = 2;
0001befe          }
0001befe          else if (Setting > 0x21)
0001bf07          {
0001bfa4              int32_t rdx_1;
0001bfa4              
0001bfa4              if (Setting == 0x30)
0001bfa4              {
0001bff3                  int32_t temp6_1;
0001bff3                  int32_t temp7_1;
0001bff3                  temp6_1 = HIGHD(0xd1b71759 * PTransLibUserModeContext->pCSFContext->
0001bff3                      meContext.Settings.RightClickDelay);
0001bff3                  temp7_1 = LOWD(0xd1b71759 * PTransLibUserModeContext->pCSFContext->
0001bff3                      meContext.Settings.RightClickDelay);
0001bff3                  rdx_1 = temp6_1;
0001bfe2              label_1bfe2:
0001c244                  (uint8_t)DragThreshold = (char)(rdx_1 >> 0xd);
0001c248                  r11 = 1;
0001bfa4              }
0001bfa4              else
0001bfa4              {
0001bfa8                  if (Setting == 0x31)
0001bfa8                  {
0001bfdc                      int32_t temp12_1;
0001bfdc                      int32_t temp13_1;
0001bfdc                      temp12_1 = HIGHD(0xd1b71759 * PTransLibUserModeContext->pCSFContext->
0001bfdc                          meContext.Settings.DoubleClickTime);
0001bfdc                      temp13_1 = LOWD(0xd1b71759 * PTransLibUserModeContext->pCSFContext->
0001bfdc                          meContext.Settings.DoubleClickTime);
0001bfdc                      rdx_1 = temp12_1;
0001bfdc                      goto label_1bfe2;
0001bfa8                  }
0001bfa8                  
0001bfac                  if (Setting == 0x32)
0001bfac                  {
0001bf34                      (uint8_t)DragThreshold =
0001bf34                          PTransLibUserModeContext->DrvSettingsContext.ReportMode;
0001c248                      r11 = 1;
0001bfac                  }
0001bfac                  else if (Setting != 0x33)
0001c1ca                      r11 = var_57;
0001bfb0                  else
0001bfb0                  {
0001bfc1                      DragThreshold = PTransLibUserModeContext->pCSFContext->meContext.
0001bfc1                          Settings.DragThreshold;
0001bf60                      ET_Swap16N(&DragThreshold, 1);
0001bf65                      r11 = 2;
0001bfb0                  }
0001bfa4              }
0001bf07          }
0001bf07          else if (Setting == 0x21)
0001bf0d          {
0001bf98              (uint8_t)DragThreshold =
0001bf98                  PTransLibUserModeContext->pCSFContext->CalibContext.CalibrateMode;
0001c248              r11 = 1;
0001bf0d          }
0001bf0d          else
0001bf0d          {
0001bf12              int32_t rax_2;
0001bf12              
0001bf12              if (Setting == 0x10)
0001bf12              {
0001bf6d                  rax_2 = *(uint32_t*)(
0001bf6d                      (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 0);
0001bf7a              label_1bf7a:
0001bf7a                  DragThreshold = rax_2;
0001bf7e                  ET_Swap32N(&DragThreshold, 1);
0001bf83                  r11 = 4;
0001bf12              }
0001bf12              else
0001bf12              {
0001bf16                  if (Setting == 0x11)
0001bf16                  {
0001bf4d                      ReportMode = *(uint16_t*)(
0001bf4d                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 4);
0001bf4d                      goto label_1bf54;
0001bf16                  }
0001bf16                  
0001bf1a                  if (Setting == 0x12)
0001bf1a                  {
0001bf45                      rax_2 = *(uint32_t*)(
0001bf45                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 7);
0001bf4b                      goto label_1bf7a;
0001bf1a                  }
0001bf1a                  
0001bf23                  if (Setting == 0x16)
0001bf23                  {
0001bf34                      (uint8_t)DragThreshold = *(uint8_t*)(
0001bf34                          (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 6);
0001c248                      r11 = 1;
0001bf23                  }
0001bf23                  else if (Setting != 0x20)
0001c1ca                      r11 = var_57;
0001bf28                  else
0001bf28                  {
0001bf34                      (uint8_t)DragThreshold =
0001bf34                          PTransLibUserModeContext->DrvSettingsContext.st_Driver.Hardware;
0001c248                      r11 = 1;
0001bf28                  }
0001bf12              }
0001bf0d          }
0001bef8      }
0001c25c      var_57 = r11 + 1;
0001c261      SI_Output_Report(PTransLibUserModeContext, &data, 0x40);
0001c26e      __security_check_cookie(rax_1 ^ &var_78);
0001beb4  }

0001c285                 cc cc cc cc cc cc cc                                                                   .......

0001c28c    void Write_Setting(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, int32_t Setting, uint8_t* data)

0001c28c  {
0001c292      uint8_t r9 = data[3];
0001c296      struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext_1 =
0001c296          PTransLibUserModeContext;
0001c299      (uint8_t)PTransLibUserModeContext = data[1];
0001c2a3      (uint8_t)PTransLibUserModeContext -= 1;
0001c2a3      
0001c2a9      if (Setting == 0x21)
0001c2a9      {
0001c46a          if ((uint8_t)PTransLibUserModeContext == 1)
0001c46a          {
0001c46c              struct _NW_CSF_CONTEXT* pCSFContext_1 =
0001c46c                  PTransLibUserModeContext_1->pCSFContext;
0001c475              uint8_t message;
0001c475              
0001c475              if (!r9)
0001c475              {
0001c487                  Calib_CancelCalibration(&pCSFContext_1->CalibContext);
0001c48c                  message = 0x15;
0001c475              }
0001c475              else
0001c475              {
0001c477                  CSF_StartCalibration(pCSFContext_1);
0001c47c                  message = 0x14;
0001c475              }
0001c475              
0001c491              USB_Put_ErrCode(PTransLibUserModeContext_1, message);
0001c46a          }
0001c2a9      }
0001c2a9      else if (Setting == 0x30)
0001c2b2      {
0001c44f          if ((uint8_t)PTransLibUserModeContext == 1)
0001c45f              PTransLibUserModeContext_1->pCSFContext->meContext.Settings.RightClickDelay =
0001c45f                  (uint32_t)r9 * 0x2710;
0001c2b2      }
0001c2b2      else if (Setting == 0x31)
0001c2bb      {
0001c434          if ((uint8_t)PTransLibUserModeContext == 1)
0001c444              PTransLibUserModeContext_1->pCSFContext->meContext.Settings.DoubleClickTime =
0001c444                  (uint32_t)r9 * 0x2710;
0001c2bb      }
0001c2bb      else
0001c2bb      {
0001c2c4          char rdx_8;
0001c2c4          bool cond:0_1;
0001c2c4          
0001c2c4          if (Setting == 0x32)
0001c2c4          {
0001c3d7              if ((uint8_t)PTransLibUserModeContext == 1)
0001c3d7              {
0001c3f0                  uint16_t rcx = (PTransLibUserModeContext_1->DrvSettingsContext.ReportMode
0001c3f0                      & 0xff00) | (uint16_t)r9;
0001c3f0                  
0001c3f6                  if ((uint8_t)rcx & 0x40)
0001c3fd                      rcx &= 0xffda;
0001c3fd                  
0001c400                  rdx_8 = 0;
0001c402                  PTransLibUserModeContext_1->DrvSettingsContext.ReportMode = rcx;
0001c402                  
0001c414                  if (!((uint8_t)rcx & 0x40)
0001c414                      || PTransLibUserModeContext_1->DrvSettingsContext.InputMode)
0001c414                  {
0001c416                      cond:0_1 = !(1 & (uint8_t)rcx);
0001c419                  label_1c419:
0001c419                      
0001c419                      if (cond:0_1)
0001c429                          PTransLibUserModeContext_1->DrvSettingsContext.pUserModeContext->
0001c429                              pCSFContext->PTContext.MouseMode = rdx_8;
0001c419                      else
0001c429                          PTransLibUserModeContext_1->DrvSettingsContext.pUserModeContext->
0001c429                              pCSFContext->PTContext.MouseMode = 1;
0001c414                  }
0001c414                  else
0001c429                      PTransLibUserModeContext_1->DrvSettingsContext.pUserModeContext->
0001c429                          pCSFContext->PTContext.MouseMode = 1;
0001c3d7              }
0001c2c4          }
0001c2c4          else
0001c2c4          {
0001c2cd              uint16_t arg_10;
0001c2cd              
0001c2cd              if (Setting == 0x33)
0001c2cd              {
0001c395                  if ((uint8_t)PTransLibUserModeContext == 2)
0001c395                  {
0001c39b                      uint16_t rax_5 = *(uint16_t*)(data + 3);
0001c3a9                      (uint8_t)PTransLibUserModeContext = (uint8_t)rax_5;
0001c3ad                      (uint8_t)PTransLibUserModeContext ^= (rax_5 >> 8);
0001c3af                      (uint8_t)rax_5 = *(uint8_t*)((char*)rax_5)[1];
0001c3b3                      (uint8_t)rax_5 ^= (uint8_t)PTransLibUserModeContext;
0001c3b5                      (uint8_t)PTransLibUserModeContext ^= (uint8_t)rax_5;
0001c3b7                      *(uint8_t*)((char*)arg_10)[1] = (uint8_t)rax_5;
0001c3bb                      (uint8_t)arg_10 = (uint8_t)PTransLibUserModeContext;
0001c3bf                      struct _NW_CSF_CONTEXT* pCSFContext =
0001c3bf                          PTransLibUserModeContext_1->pCSFContext;
0001c3c8                      pCSFContext->meContext.Settings.DragThreshold = (uint8_t)arg_10;
0001c3c8                      *(uint8_t*)((char*)pCSFContext->meContext.Settings.DragThreshold)[
0001c3c8                          1] = *(uint8_t*)((char*)arg_10)[1];
0001c395                  }
0001c2cd              }
0001c2cd              else if (Setting == 0x36)
0001c2d6              {
0001c335                  if ((uint8_t)PTransLibUserModeContext == 2)
0001c335                  {
0001c33b                      uint16_t rax_3 = *(uint16_t*)(data + 3);
0001c349                      (uint8_t)PTransLibUserModeContext = (uint8_t)rax_3;
0001c34d                      (uint8_t)PTransLibUserModeContext ^= (rax_3 >> 8);
0001c34f                      (uint8_t)rax_3 = *(uint8_t*)((char*)rax_3)[1];
0001c353                      (uint8_t)rax_3 ^= (uint8_t)PTransLibUserModeContext;
0001c355                      (uint8_t)PTransLibUserModeContext ^= (uint8_t)rax_3;
0001c357                      *(uint8_t*)((char*)arg_10)[1] = (uint8_t)rax_3;
0001c35b                      (uint8_t)arg_10 = (uint8_t)PTransLibUserModeContext;
0001c35f                      uint16_t rax_4 = arg_10;
0001c35f                      
0001c367                      if ((uint8_t)PTransLibUserModeContext & 0x40)
0001c36e                          rax_4 &= 0xffda;
0001c36e                      
0001c371                      rdx_8 = 0;
0001c373                      PTransLibUserModeContext_1->DrvSettingsContext.ReportMode = rax_4;
0001c373                      
0001c384                      if (!((uint8_t)rax_4 & 0x40)
0001c384                          || PTransLibUserModeContext_1->DrvSettingsContext.InputMode)
0001c384                      {
0001c38a                          cond:0_1 = !(1 & (uint8_t)rax_4);
0001c38d                          goto label_1c419;
0001c384                      }
0001c384                      
0001c429                      PTransLibUserModeContext_1->DrvSettingsContext.pUserModeContext->
0001c429                          pCSFContext->PTContext.MouseMode = 1;
0001c335                  }
0001c2d6              }
0001c2d6              else if (Setting == 0x81)
0001c2db              {
0001c31c                  if ((uint8_t)PTransLibUserModeContext == 1)
0001c326                      PTransLibUserModeContext_1->pCSFContext->meContext.Settings.Enabled =
0001c326                          r9;
0001c2db              }
0001c2db              else if (Setting == 0x84)
0001c2e0              {
0001c303                  if ((uint8_t)PTransLibUserModeContext == 1)
0001c30d                      PTransLibUserModeContext_1->pCSFContext->PTContext.OffscreenMode = r9;
0001c2e0              }
0001c2e0              else if (Setting == 0x85 && (uint8_t)PTransLibUserModeContext == 1)
0001c2f4                  gCSFEnabled = r9;
0001c2c4          }
0001c2bb      }
0001c28c  }

0001c49c                                                                                      cc cc cc cc                              ....
0001c4a0  cc cc cc cc                                                                                      ....

0001c4a4    void USB_Handle_Command(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t* InData, uint32_t size)

0001c4a4  {
0001c4bd      uint32_t Setting_1 = (uint32_t)InData[2];
0001c4c2      char rax = InData[1];
0001c4d3      uint32_t Setting = 0x43;
0001c4d6      int64_t rsi;
0001c4d6      (uint8_t)rsi = 1;
0001c4d6      
0001c4dc      if (Setting_1 > 0x43)
0001c4dc      {
0001c614          if (Setting_1 > 0x80)
0001c614          {
0001c66b              if (Setting_1 >= 0x81)
0001c66b              {
0001c673                  if (Setting_1 <= 0x82)
0001c673                  {
0001c691                  label_1c691:
0001c691                      (uint8_t)rsi = 0;
0001c691                      
0001c696                      if (rax > 1)
0001c6a0                          Write_Setting(PTransLibUserModeContext, Setting_1, InData);
0001c6a0                      
0001c6aa                      Read_Setting(PTransLibUserModeContext, Setting_1);
0001c673                  }
0001c673                  else if (Setting_1 == 0x83)
0001c67b                  {
0001c702                      (uint8_t)rsi = 0;
0001c6aa                      Read_Setting(PTransLibUserModeContext, Setting_1);
0001c67b                  }
0001c67b                  else if (Setting_1 == 0x84 || Setting_1 == 0x85)
0001c687                      goto label_1c691;
0001c66b              }
0001c614          }
0001c614          else if (Setting_1 == 0x80)
0001c616          {
0001c57c              (uint8_t)rsi = 0;
0001c6aa              Read_Setting(PTransLibUserModeContext, 0x80);
0001c616          }
0001c616          else if (Setting_1 == 0x44)
0001c623          {
0001c57c              (uint8_t)rsi = 0;
0001c6aa              Read_Setting(PTransLibUserModeContext, 0x44);
0001c623          }
0001c623          else if (Setting_1 == 0x45)
0001c62b          {
0001c65b              (uint8_t)rsi = 0;
0001c6aa              Read_Setting(PTransLibUserModeContext, 0x45);
0001c62b          }
0001c62b          else if (Setting_1 == 0x50)
0001c630          {
0001c64f              if (PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001c64f              {
0001c651                  (uint8_t)rsi = 0;
0001c6aa                  Read_Setting(PTransLibUserModeContext, 0x50);
0001c64f              }
0001c630          }
0001c630          else if (Setting_1 == 0x70
0001c630              && PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001c63e          {
0001c640              (uint8_t)rsi = 0;
0001c6aa              Read_Setting(PTransLibUserModeContext, Setting_1);
0001c63e          }
0001c4dc      }
0001c4dc      else if (Setting_1 == 0x43)
0001c4e4      {
0001c56f      label_1c56f:
0001c56f          
0001c576          if (PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001c576          {
0001c57c              (uint8_t)rsi = 0;
0001c6aa              Read_Setting(PTransLibUserModeContext, Setting);
0001c576          }
0001c4e4      }
0001c4e4      else if (Setting_1 > 0x21)
0001c4ed      {
0001c5a8          if (Setting_1 >= 0x30)
0001c5a8          {
0001c5b1              if (Setting_1 <= 0x31)
0001c5b1                  goto label_1c691;
0001c5b1              
0001c5ba              if (Setting_1 == 0x32)
0001c5ba              {
0001c5ec                  (uint8_t)rsi = 0;
0001c5ec                  
0001c5f1                  if (rax > 1)
0001c5fe                      Write_Setting(PTransLibUserModeContext, 0x32, InData);
0001c5fe                  
0001c6aa                  Read_Setting(PTransLibUserModeContext, 0x32);
0001c5ba              }
0001c5ba              else
0001c5ba              {
0001c5bf                  if (Setting_1 == 0x33)
0001c5bf                      goto label_1c691;
0001c5bf                  
0001c5c8                  if (Setting_1 == 0x36)
0001c5c8                  {
0001c5ce                      (uint8_t)rsi = 0;
0001c5ce                      
0001c5d3                      if (rax > 1)
0001c5dd                          Write_Setting(PTransLibUserModeContext, Setting_1, InData);
0001c5dd                      
0001c6aa                      Read_Setting(PTransLibUserModeContext, 0x36);
0001c5c8                  }
0001c5ba              }
0001c5a8          }
0001c4ed      }
0001c4ed      else if (Setting_1 == 0x21)
0001c4f3      {
0001c584          (uint8_t)rsi = 0;
0001c584          
0001c589          if (rax > 1)
0001c596              Write_Setting(PTransLibUserModeContext, 0x21, InData);
0001c596          
0001c6aa          Read_Setting(PTransLibUserModeContext, 0x21);
0001c4f3      }
0001c4f3      else
0001c4f3      {
0001c4f9          Setting = 0x10;
0001c4f9          
0001c4fe          if (Setting_1 == 0x10)
0001c4fe              goto label_1c56f;
0001c4fe          
0001c502          if (Setting_1 == 0x11)
0001c502          {
0001c55c              if (PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001c55c              {
0001c562                  (uint8_t)rsi = 0;
0001c6aa                  Read_Setting(PTransLibUserModeContext, 0x11);
0001c55c              }
0001c502          }
0001c502          else if (Setting_1 == 0x12)
0001c506          {
0001c542              if (PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001c542              {
0001c548                  (uint8_t)rsi = 0;
0001c6aa                  Read_Setting(PTransLibUserModeContext, 0x12);
0001c542              }
0001c506          }
0001c506          else if (Setting_1 == 0x16)
0001c50b          {
0001c528              if (PTransLibUserModeContext->FwSettingsContext.GotSettingsFromFW)
0001c528              {
0001c52e                  (uint8_t)rsi = 0;
0001c6aa                  Read_Setting(PTransLibUserModeContext, 0x16);
0001c528              }
0001c50b          }
0001c50b          else if (Setting_1 == 0x20)
0001c510          {
0001c516              (uint8_t)rsi = 0;
0001c6aa              Read_Setting(PTransLibUserModeContext, 0x20);
0001c510          }
0001c4f3      }
0001c4f3      
0001c6bf      if ((uint8_t)Setting_1 >= 0x60
0001c6bf          && ((uint8_t)Setting_1 <= 0x61 || (uint8_t)Setting_1 == 0xf0))
0001c6bf      {
0001c6d0          (uint8_t)rsi = 0;
0001c6d3          DSI_OutputReport(&PTransLibUserModeContext->FwSettingsContext, InData, 
0001c6d3              (uint32_t)InData[1]);
0001c6bf      }
0001c6bf      
0001c6db      if ((uint8_t)rsi)
0001c6db      {
0001c6dd          (uint8_t)Setting = 0xff;
0001c6e2          USB_Put_ErrCode(PTransLibUserModeContext, (uint8_t)Setting);
0001c6db      }
0001c4a4  }

0001c707                       cc cc cc cc cc cc cc cc cc                                                         .........

0001c710    void SendText(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, char* str, uint8_t Length)

0001c710  {
0001c71d      void var_78;
0001c71d      int64_t rax_1 = __security_cookie ^ &var_78;
0001c728      uint32_t Length_2 = 0x3e;
0001c728      
0001c730      if (Length <= 0x3e)
0001c730      {
0001c754          uint8_t Length_1 = Length;
0001c754          
0001c759          if (Length < 0x3e)
0001c759              Length_2 = (uint32_t)Length;
0001c759          
0001c75c          uint8_t data = 0x54;
0001c769          char var_56[0x3e];
0001c769          memmove(&var_56, str, (int64_t)Length_2);
0001c77c          SI_Output_Report(PTransLibUserModeContext, &data, 0x40);
0001c730      }
0001c730      else
0001c746          onError__("SendText: Length is too large\n", 
0001c746              "c:\development_work\csf_release_hp\driver\translib\settingsinterface.c", 
0001c746              0x3e4);
0001c746      
0001c789      __security_check_cookie(rax_1 ^ &var_78);
0001c710  }

0001c794                                                              cc cc cc cc cc cc cc cc                                  ........

0001c79c    void USB_Put_ErrCode(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t message)

0001c79c  {
0001c7ad      void var_78;
0001c7ad      int64_t rax_1 = __security_cookie ^ &var_78;
0001c7b5      int64_t rbx;
0001c7b5      (uint8_t)rbx = message;
0001c7c5      uint8_t data = 0x45;
0001c7ca      char var_57 = 1;
0001c7cf      char var_56;
0001c7cf      memset(&var_56, 0, 0x3e);
0001c7e2      var_56 = (uint8_t)rbx;
0001c7e6      SI_Output_Report(PTransLibUserModeContext, &data, 0x40);
0001c7f3      __security_check_cookie(rax_1 ^ &var_78);
0001c79c  }

0001c806                    cc cc cc cc cc cc                                                                    ......

0001c80c    void SendXMultiTouch(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, struct csf_touch_report_t* touchReport)

0001c80c  {
0001c828      uint8_t data = 0x58;
0001c82c      struct csf_touch_report_t* touchReport_1 = touchReport;
0001c82f      char rax = 0;
0001c835      void var_25;
0001c835      void* rsi = &var_25;
0001c83a      int32_t rbp = 0;
0001c83d      int64_t i_1 = 2;
0001c842      char var_27 = 0;
0001c8a5      int64_t i;
0001c8a5      
0001c8a5      do
0001c8a5      {
0001c849          if (touchReport_1->touch[0].touchState)
0001c849          {
0001c855              char var_27_1 = rax + 0xd;
0001c859              rax = touchReport_1->touch[0].touchState;
0001c85c              *(uint16_t*)((char*)rsi + 8) = 0;
0001c861              int64_t r10_2 = (uint64_t)rbp * 0xd;
0001c865              *(uint8_t*)((char*)rsi - 1) = rax;
0001c871              *(uint32_t*)rsi = touchReport_1->touch[0].pt.x;
0001c873              float y = touchReport_1->touch[0].pt.y;
0001c877              *(uint16_t*)((char*)rsi + 0xa) = 0;
0001c87c              *(uint32_t*)((char*)rsi + 4) = y;
0001c87f              void var_48;
0001c87f              ET_Swap32N(&var_48 + r10_2 + 0x23, 2);
0001c88e              ET_Swap16N(&var_48 + r10_2 + 0x2b, 2);
0001c893              rax = var_27_1;
0001c897              rbp += 1;
0001c899              rsi += 0xd;
0001c849          }
0001c849          
0001c89d          touchReport_1 = &touchReport_1->touch[1];
0001c8a1          i = i_1;
0001c8a1          i_1 -= 1;
0001c8a5      } while (i != 1);
0001c8a5      
0001c8aa      if (rax)
0001c8b8          SI_Output_Report(PTransLibUserModeContext, &data, (int32_t)(i_1 + 0x40));
0001c80c  }

0001c8d8                                                                          cc cc cc cc cc cc cc cc                          ........

0001c8e0    void SendOffscreenTouch(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, struct csf_touch_report_t* touchReport)

0001c8e0  {
0001c8ef      uint8_t rax = 0;
0001c8f4      int64_t data;
0001c8f4      __builtin_memset(&data, 0, 0x1f);
0001c900      char var_a = 0;
0001c914      (uint8_t)data = 0x4f;
0001c919      *(uint8_t*)((char*)data)[1] = 0x1d;
0001c91e      void* r8 = &*(uint64_t*)((char*)data)[2];
0001c922      struct fpoint_t* rdx = &touchReport->touch[0].pt;
0001c926      int64_t i_1 = 2;
0001c979      int64_t i;
0001c979      
0001c979      do
0001c979      {
0001c92d          if (ADJ(rdx)->touch[0].touchState)
0001c92d          {
0001c92f              rdx->x
0001c92f              rdx->x
0001c92f              rdx->x
0001c92f              float x = rdx->x;
0001c933              rdx->y
0001c933              float y = rdx->y;
0001c93a              uint8_t var_a_1 = rax + 1;
0001c93e              rax = *((char*)rdx + 0x10);
0001c941              *(uint16_t*)((char*)r8 + 0xa) = 0;
0001c94e              *(uint8_t*)((char*)r8 + 1) = rax;
0001c952              rax = ADJ(rdx)->touch[0].touchState;
0001c955              *(uint16_t*)((char*)r8 + 0xc) = 0;
0001c95a              *(uint8_t*)r8 = rax;
0001c95d              r8 += 0xe;
0001c961              *(uint32_t*)((char*)r8 - 0xc) = x / 32767f;
0001c967              *(uint32_t*)((char*)r8 - 8) = y / 32767f;
0001c96d              rax = var_a_1;
0001c92d          }
0001c92d          
0001c971          rdx = &rdx[3];
0001c975          i = i_1;
0001c975          i_1 -= 1;
0001c979      } while (i != 1);
0001c979      
0001c97e      if (rax)
0001c98c          SI_Output_Report(PTransLibUserModeContext, &data, (int32_t)(i_1 + 0x40));
0001c8e0  }

0001c996                                                                    cc cc cc cc cc cc                                    ......

0001c99c    void SendPuck(struct _NW_TRANSLIB_USERMODE_CONTEXT* pContext, struct edgeStruct_t* edges)

0001c99c  {
0001c9b2      void var_228;
0001c9b2      int64_t rax_1 = __security_cookie ^ &var_228;
0001c9cd      uint8_t data = 0x50;
0001c9d2      char var_57 = 0x22;
0001c9d7      char var_56;
0001c9d7      memset(&var_56, 0, 0x3e);
0001c9ea      char var_1f8[0x20];
0001c9ea      memmove(&var_1f8, edges, 0x1a0);
0001c9f5      int64_t var_1d8;
0001c9f5      int64_t* r11 = &var_1d8;
0001ca02      int64_t i_1 = 4;
0001ca6d      int64_t j_1;
0001ca6d      int64_t i;
0001ca6d      
0001ca6d      do
0001ca6d      {
0001ca05          int64_t* rdx_1 = r11;
0001ca08          j_1 = 4;
0001ca63          int64_t j;
0001ca63          
0001ca63          do
0001ca63          {
0001ca0e              if (!(-511f <= *(uint32_t*)rdx_1))
0001ca10                  *(uint32_t*)rdx_1 = 0xc4000000;
0001ca10              
0001ca16              *(uint32_t*)rdx_1;
0001ca16              *(uint32_t*)rdx_1;
0001ca16              *(uint32_t*)rdx_1;
0001ca16              
0001ca21              if (!(*(uint32_t*)rdx_1 <= 511f))
0001ca23                  *(uint32_t*)rdx_1 = 0x44000000;
0001ca23              
0001ca29              *(uint32_t*)rdx_1;
0001ca29              *(uint32_t*)rdx_1;
0001ca29              *(uint32_t*)rdx_1;
0001ca29              int32_t zmm0 = *(uint32_t*)rdx_1;
0001ca39              char var_205_1 = (uint8_t)zmm0;
0001ca49              uint8_t var_207_1 = (char)(zmm0 >> 0x10);
0001ca52              uint8_t var_206_1 = (char)(zmm0 >> 8);
0001ca5a              *(uint32_t*)rdx_1 = ((char)(zmm0 >> 0x18));
0001ca5c              rdx_1 += 4;
0001ca5f              j = j_1;
0001ca5f              j_1 -= 1;
0001ca63          } while (j != 1);
0001ca65          r11 = &r11[0xd];
0001ca69          i = i_1;
0001ca69          i_1 -= 1;
0001ca6d      } while (i != 1);
0001ca6f      char var_193;
0001ca6f      int32_t rax_8;
0001ca6f      (uint8_t)rax_8 = var_193;
0001ca82      (uint8_t)rax_8 u>>= 1;
0001ca87      var_56 = (uint8_t)rax_8;
0001ca93      int64_t var_55 = var_1d8;
0001ca9b      char var_12b;
0001ca9b      int64_t rax_9;
0001ca9b      (uint8_t)rax_9 = var_12b;
0001caa2      (uint8_t)rax_9 u>>= 1;
0001caa4      char var_4d = (uint8_t)rax_9;
0001cab3      int64_t var_170;
0001cab3      int64_t var_4c = var_170;
0001cac0      int64_t var_1d0;
0001cac0      int64_t var_44 = var_1d0;
0001cad0      int64_t var_168;
0001cad0      int64_t var_3c = var_168;
0001cad8      SI_Output_Report(pContext, &data, (int32_t)(j_1 + 0x40));
0001cae8      __security_check_cookie(rax_1 ^ &var_228);
0001c99c  }

0001cafe                                                                                            cc cc                                ..
0001cb00  cc cc cc cc                                                                                      ....

0001cb04    void SendPuck2(struct _NW_TRANSLIB_USERMODE_CONTEXT* pContext, uint32_t timestamp, uint8_t cam, struct edgeStruct_t* edges)

0001cb04  {
0001cb1a      void var_a8;
0001cb1a      int64_t rax_1 = __security_cookie ^ &var_a8;
0001cb22      int64_t rbp;
0001cb22      (uint8_t)rbp = edges->Num_Edges;
0001cb29      int64_t r13;
0001cb29      (uint8_t)r13 = cam;
0001cb2c      (uint8_t)rbp += 2;
0001cb35      (uint8_t)rbp <<= 2;
0001cb35      
0001cb3d      if ((uint8_t)rbp <= 0x40)
0001cb3d      {
0001cb4a          uint8_t data = 0x52;
0001cb53          char var_77;
0001cb53          memset(&var_77, 0, 0x3f);
0001cb5a          char var_85_1 = (uint8_t)timestamp;
0001cb61          var_77 = (uint8_t)rbp;
0001cb66          char var_76_1 = (uint8_t)r13;
0001cb74          uint8_t var_87_1 = (char)(timestamp >> 0x10);
0001cb7d          uint8_t var_86_1 = (char)(timestamp >> 8);
0001cb85          int32_t var_75_1 = ((char)(timestamp >> 0x18));
0001cb89          int32_t rax_8;
0001cb89          (uint8_t)rax_8 = edges->Num_Edges;
0001cb8c          (uint8_t)rax_8 u>>= 1;
0001cb92          char var_71_1 = (uint8_t)rax_8;
0001cb92          
0001cb96          if (edges->Num_Edges > 0)
0001cb96          {
0001cb98              uint32_t Num_Edges_1 = 4;
0001cba0              uint32_t Num_Edges;
0001cba0              
0001cba0              if (edges->Num_Edges >= 4)
0001cba8                  Num_Edges = 4;
0001cba0              else
0001cba2                  Num_Edges = (uint32_t)edges->Num_Edges;
0001cba2              
0001cbba              void buf;
0001cbba              memmove(&buf, &edges->Interpolated_Edges, (int64_t)Num_Edges << 2);
0001cbba              
0001cbc2              if (edges->Num_Edges < 4)
0001cbc4                  Num_Edges_1 = (uint32_t)edges->Num_Edges;
0001cbc4              
0001cbcf              ET_Swap32N(&buf, Num_Edges_1);
0001cb96          }
0001cb96          
0001cbe2          SI_Output_Report(pContext, &data, 0x40);
0001cb3d      }
0001cb3d      
0001cbef      __security_check_cookie(rax_1 ^ &var_a8);
0001cb04  }

0001cc03           cc cc cc cc cc cc cc cc cc                                                                 .........

0001cc0c    float PixToAngle(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, uint8_t cam, float pixel)

0001cc0c  {
0001cc1a      pixel = pixel / _mm_cvtepi32_ps((uint128_t)
0001cc1a          *(uint16_t*)((char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 0xd));
0001cc1a      
0001cc20      if (cam)
0001cc4c          pixel = (pixel + *(uint32_t*)(
0001cc4c              (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 0x13a)
0001cc4c              - 3.92699099f) * -10000f;
0001cc20      else
0001cc32          pixel = (pixel + *(uint32_t*)(
0001cc32              (char*)PTransLibUserModeContext->FwSettingsContext.st_Device + 0xf5)
0001cc32              + 0.785398185f) * 10000f;
0001cc32      
0001cc62      if (!(0f <= pixel))
0001cc64          pixel = pixel + 62831.8555f;
0001cc64      
0001cc6b      if (!(pixel <= 62831.8555f))
0001cc6b      {
0001cc6d          uint128_t zmm0;
0001cc6d          (uint32_t)zmm0 = 0f - 62831.8555f;
0001cc71          pixel = pixel + (uint32_t)zmm0;
0001cc6b      }
0001cc6b      
0001cc78      return pixel;
0001cc0c  }

0001cc79                                                                             cc cc cc cc cc cc cc                           .......

0001cc80    void SendAngles(struct _NW_TRANSLIB_USERMODE_CONTEXT* pContext, struct edgeStruct_t* edges)

0001cc80  {
0001cca0      void var_98;
0001cca0      uint64_t var_38 = __security_cookie ^ &var_98;
0001cca5      int32_t rdi = 0;
0001ccad      uint8_t* rcx = &edges->Num_Edges;
0001ccb1      int64_t i_1 = 4;
0001ccb8      uint64_t rax_1;
0001ccb8      (uint8_t)rax_1 = 0;
0001cccc      int64_t i;
0001cccc      
0001cccc      do
0001cccc      {
0001ccbe          rax_1 = (uint64_t)(uint8_t)rax_1;
0001ccbe          
0001ccc1          if (ADJ(rcx)->Num_Edges > 0)
0001ccc1              rax_1 = 1;
0001ccc1          
0001ccc5          rcx = &rcx[0x68];
0001ccc9          i = i_1;
0001ccc9          i_1 -= 1;
0001cccc      } while (i != 1);
0001cccc      
0001ccd1      if ((uint8_t)rax_1)
0001ccd1      {
0001cce0          uint8_t data;
0001cce0          memset(&data, i_1, (uint64_t)(uint32_t)(i_1 + 0x40));
0001cce5          uint32_t Num_Edges = (uint32_t)edges->Num_Edges;
0001cce9          data = 0x51;
0001ccf1          char var_77_1 = 0x3e;
0001ccf6          char var_76_1 = 0;
0001ccff          char var_72_1 = 0;
0001cd04          char var_55_1 = 1;
0001cd09          int32_t r13_1 = 0;
0001cd0c          uint8_t var_71_1 = (uint8_t)Num_Edges >> 1;
0001cd0c          
0001cd10          if (Num_Edges > 0)
0001cd10          {
0001cd12              float* r12_1 = &edges->Lin_Edges[1];
0001cd12              
0001cd87              do
0001cd87              {
0001cd23                  int32_t temp1_1;
0001cd23                  int32_t temp2_1;
0001cd23                  temp1_1 = HIGHD((int64_t)r13_1);
0001cd23                  temp2_1 = LOWD((int64_t)r13_1);
0001cd2a                  int64_t r11_1 = (int64_t)((temp2_1 - temp1_1) >> 1);
0001cd32                  int16_t* buf = &var_98 + r11_1 + 0x2a + (r11_1 << 2);
0001cd46                  *(uint16_t*)buf =
0001cd46                      (int16_t)(int64_t)PixToAngle(pContext, 0, ADJ(r12_1)->Lin_Edges[0]);
0001cd4a                  ET_Swap16N(buf, 1);
0001cd5d                  int16_t* buf_1 = &var_98 + r11_1 + 0x2c + (r11_1 << 2);
0001cd73                  *(uint16_t*)buf_1 =
0001cd73                      (int16_t)(int64_t)PixToAngle(pContext, 0, ADJ(r12_1)->Lin_Edges[1]);
0001cd77                  ET_Swap16N(buf_1, 1);
0001cd7c                  r13_1 += 2;
0001cd80                  r12_1 = &r12_1[2];
0001cd87              } while (r13_1 < Num_Edges);
0001cd10          }
0001cd10          
0001cd89          uint32_t rsi_1 = (uint32_t)*((char*)edges + 0xcd);
0001cd97          uint8_t var_54_1 = (uint8_t)rsi_1 >> 1;
0001cd97          
0001cd9b          if (rsi_1 > 0)
0001cd9b          {
0001cd9d              void* __offset(edgeStruct_t, 0x9c) r12_2 = &edges->Raw_Edges[0x27];
0001cd9d              
0001ce0b              do
0001ce0b              {
0001cdb0                  int32_t temp3_1;
0001cdb0                  int32_t temp4_1;
0001cdb0                  temp3_1 = HIGHD((int64_t)rdi);
0001cdb0                  temp4_1 = LOWD((int64_t)rdi);
0001cdb3                  int32_t rdx_2;
0001cdb3                  (uint8_t)rdx_2 = 1;
0001cdb8                  int64_t rbx_1 = (int64_t)((temp4_1 - temp3_1) >> 1);
0001cdd5                  *(uint16_t*)(&var_98 + rbx_1 + 0x20 + (rbx_1 << 2) + 0x29) = (int16_t)(
0001cdd5                      int64_t)PixToAngle(pContext, (uint8_t)rdx_2, 
0001cdd5                      *(int32_t*)((char*)ADJ(r12_2) + 0x98));
0001cdd9                  ET_Swap16N(&var_98 + rbx_1 + 0x20 + (rbx_1 << 2) + 0x29, 1);
0001cdf9                  *(uint16_t*)(&var_98 + rbx_1 + 0x20 + (rbx_1 << 2) + 0x27) = (int16_t)(
0001cdf9                      int64_t)PixToAngle(pContext, 1, *(int32_t*)((char*)ADJ(r12_2) + 0x9c));
0001cdfd                  ET_Swap16N(&var_98 + rbx_1 + 0x20 + (rbx_1 << 2) + 0x27, 1);
0001ce02                  rdi += 2;
0001ce05                  r12_2 += 8;
0001ce0b              } while (rdi < rsi_1);
0001cd9b          }
0001cd9b          
0001ce1b          SI_Output_Report(pContext, &data, 0x40);
0001ccd1      }
0001ccd1      
0001ce28      __security_check_cookie(var_38 ^ &var_98);
0001cc80  }

0001ce46                    cc cc cc cc cc cc                                                                    ......

0001ce4c    void SI_SendEdges(void* param, uint32_t timestamp, uint8_t cam, struct edgeStruct_t* edges)

0001ce4c  {
0001ce65      int16_t rsi = *(uint16_t*)((char*)param + 0x450);
0001ce74      int64_t rbp;
0001ce74      (uint8_t)rbp = cam;
0001ce74      
0001ce80      if (0x100 & rsi)
0001ce85          SendPuck(param, edges);
0001ce85      
0001ce92      if (0x400 & rsi)
0001cea8          SendPuck2(param, timestamp, (uint8_t)rbp, (uint64_t)(uint8_t)rbp * 0x68 + edges);
0001cea8      
0001ceb1      if ((uint8_t)rsi & 8)
0001ceb9          SendAngles(param, edges);
0001ce4c  }

0001ced9                                                                             cc cc cc cc cc cc cc                           .......

0001cee0    void USB_Send_New_Settings_Blob(struct _NW_TRANSLIB_USERMODE_CONTEXT* PTransLibUserModeContext, char type, uint8_t* data, uint32_t size)

0001cee0  {
0001cefb      void var_d8;
0001cefb      int64_t rax_1 = __security_cookie ^ &var_d8;
0001cf21      char r14 = 0;
0001cf25      uint32_t size_1 = size;
0001cf34      uint16_t rbp = 0;
0001cf38      char var_b0 = 0x4e;
0001cf3d      uint32_t rdi_4 = size / 0x39;
0001cf40      char var_af = 0x3e;
0001cf45      char type_1 = type;
0001cf4e      char var_ac = (uint8_t)rdi_4;
0001cf4e      
0001cf59      if ((uint32_t)(uint8_t)rdi_4 * 0x39 != size)
0001cf59          r14 = 1;
0001cf59      
0001cf60      if (r14)
0001cf65          var_ac = (1 + rdi_4);
0001cf65      
0001cf69      int64_t rbx;
0001cf69      (uint8_t)rbx = 0;
0001cf6c      uint16_t var_ab = 0;
0001cf72      char var_ad = 0;
0001cf79      int32_t var_98;
0001cf79      char var_91[0x39];
0001cf79      
0001cf79      if ((uint8_t)rdi_4 > 0)
0001cf79      {
0001d023          do
0001d023          {
0001cf93              var_98 = var_b0;
0001cf99              int16_t var_94_1 = var_ac;
0001cf9d              int16_t rax_5;
0001cf9d              (uint8_t)rax_5 = *(uint8_t*)((char*)var_ab)[1];
0001cfa5              char var_92_1 = (uint8_t)rax_5;
0001cfae              memmove(&var_91, &data[(uint64_t)rbp], 0x39);
0001cfb3              rbp += 0x39;
0001cfc6              uint16_t rcx_1;
0001cfc6              (uint8_t)rcx_1 = (rbp >> 8) ^ (uint8_t)rbp;
0001cfc9              char rax_6 = *(uint8_t*)((char*)rbp)[1] ^ (uint8_t)rcx_1;
0001cfcb              (uint8_t)rcx_1 ^= rax_6;
0001cfcd              uint16_t var_b8_1;
0001cfcd              *(uint8_t*)((char*)var_b8_1)[1] = rax_6;
0001cfd1              (uint8_t)var_b8_1 = (uint8_t)rcx_1;
0001cfda              var_ab = var_b8_1;
0001cfdf              uint8_t (* SendTLReportCallback)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001cfdf                  PTransLibUserModeContext->TLIOContext.SendTLReportCallback;
0001cfdf              
0001cfe9              if (!SendTLReportCallback)
0001d015                  onBug__("TransLibIO.c: SendTLReportCallback not assigned", 
0001d015                      "c:\development_work\csf_release_hp\driver\translib\translibio.c", 
0001d015                      0x93);
0001cfe9              else
0001cffd                  SendTLReportCallback(&PTransLibUserModeContext->TLIOContext, &var_98, 
0001cffd                      0x40);
0001cffd              
0001d01a              (uint8_t)rbx += 1;
0001d01c              char var_ad_1 = (uint8_t)rbx;
0001d023          } while ((uint8_t)rbx < (uint8_t)rdi_4);
0001d023          
0001d029          size_1 = size;
0001cf79      }
0001cf79      
0001d02d      int32_t rax_3;
0001d02d      (uint8_t)rax_3 = (uint8_t)size_1;
0001d030      (uint8_t)rax_3 -= (uint8_t)rbp;
0001d033      (uint8_t)rax_3 += 5;
0001d035      char var_af_1 = (uint8_t)rax_3;
0001d035      
0001d03c      if (r14)
0001d03c      {
0001d04a          var_98 = var_b0;
0001d050          int16_t var_94_2 = var_ac;
0001d054          int16_t rax_9;
0001d054          (uint8_t)rax_9 = *(uint8_t*)((char*)var_ab)[1];
0001d05c          char var_92_2 = (uint8_t)rax_9;
0001d06d          memmove(&var_91, &data[(uint64_t)rbp], (uint64_t)(size_1 - (uint32_t)rbp));
0001d079          uint8_t (* SendTLReportCallback_1)(struct _TLIO_CONTEXT*, uint8_t*, int32_t) =
0001d079              PTransLibUserModeContext->TLIOContext.SendTLReportCallback;
0001d079          
0001d080          if (!SendTLReportCallback_1)
0001d0a5              onBug__("TransLibIO.c: SendTLReportCallback not assigned", 
0001d0a5                  "c:\development_work\csf_release_hp\driver\translib\translibio.c", 0x93);
0001d080          else
0001d08d              SendTLReportCallback_1(&PTransLibUserModeContext->TLIOContext, &var_98, 0x40);
0001d03c      }
0001d03c      
0001d0b5      __security_check_cookie(rax_1 ^ &var_d8);
0001cee0  }

0001d0ce                                            cc cc cc cc cc cc                                                    ......

0001d0d4    int32_t ST_GetSettingIndex2(struct tv_item_t* tree, void* pst_data, int32_t parentId, int32_t childId, char** pdata_ret, uint8_t* is_esym)

0001d0d4  {
0001d0e3      struct tv_item_t* tree_1 = tree;
0001d0f6      uint8_t* is_esym_1 = is_esym;
0001d0fe      void* pst_data_1 = pst_data;
0001d0fe      
0001d107      if (is_esym_1)
0001d109          *(uint8_t*)is_esym_1 = 0;
0001d109      
0001d10c      uint8_t* rbp = &tree->typespec;
0001d110      void* pst_data_2 = pst_data;
0001d113      int64_t rdi = 0;
0001d115      uint8_t* rbx = rbp;
0001d115      
0001d122      while (ADJ(rbx)->treepath0 || ADJ(rbx)->treepath1)
0001d122      {
0001d124          int32_t rax;
0001d124          (uint8_t)rax = ADJ(rbx)->typespec;
0001d126          (uint8_t)rax = ~(uint8_t)rax;
0001d128          (uint8_t)rax &= 0xc0;
0001d128          
0001d130          if ((uint8_t)rax == 0xc0 || (uint8_t)rax == 0x40)
0001d130          {
0001d132              (uint8_t)tree = ADJ(rbx)->typespec;
0001d13c              pst_data_2 += (int64_t)ST_GetSettingSize((uint8_t)tree);
0001d130          }
0001d130          
0001d13f          rdi += 1;
0001d142          rbx = &rbx[4];
0001d142          
0001d14d          if (rdi >= 0x1f4)
0001d14d              break;
0001d122      }
0001d122      
0001d153      int32_t result = 0;
0001d153      
0001d1b0      for (int64_t i = 0; i < 0x1f4; )
0001d1b0      {
0001d158          (uint8_t)tree = ADJ(rbp)->typespec;
0001d158          
0001d15d          if (!(uint8_t)tree)
0001d15d              break;
0001d15d          
0001d15f          int32_t rax_1 = ST_GetSettingSize((uint8_t)tree);
0001d164          int64_t r13_1 = (int64_t)rax_1;
0001d164          
0001d169          if (!rax_1)
0001d169              break;
0001d169          
0001d17b          if (childId == (uint32_t)ADJ(rbp)->treepath1
0001d17b              && parentId == (uint32_t)ADJ(rbp)->treepath0)
0001d17b          {
0001d1ca              void** pdata_ret_1 = pdata_ret;
0001d1ca              
0001d1d5              if (!pdata_ret_1)
0001d290                  return result;
0001d290              
0001d1e0              void* result_1 = (int64_t)result;
0001d1e3              (uint8_t)tree = tree_1[result_1].typespec;
0001d1e7              (uint8_t)rax_1 = (uint8_t)tree;
0001d1e9              (uint8_t)rax_1 = ~(uint8_t)rax_1;
0001d1eb              (uint8_t)rax_1 &= 0xc0;
0001d1eb              
0001d1f7              if ((uint8_t)rax_1 == 0xc0 || (uint8_t)rax_1 == 0x40)
0001d1f7              {
0001d285                  *(uint64_t*)pdata_ret_1 = pst_data_1;
0001d285                  
0001d28b                  if (is_esym_1)
0001d28d                      *(uint8_t*)is_esym_1 = 0;
0001d28d                  
0001d290                  return result;
0001d1f7              }
0001d1f7              
0001d1ff              if ((uint8_t)rax_1 != 0x80)
0001d1d5                  break;
0001d1d5              
0001d201              (uint32_t)is_esym = 0xffffffff;
0001d209              *(uint64_t*)pdata_ret_1 = pst_data_2;
0001d20c              int32_t rax_5 = ST_GetSettingSize((uint8_t)tree);
0001d211              uint32_t writecount_1 = (uint32_t)tree_1[result_1].writecount;
0001d216              int64_t r12 = (int64_t)rax_5;
0001d223              *(uint64_t*)pdata_ret_1 += (int64_t)(writecount_1 - 1) * r12;
0001d223              
0001d24d              while (writecount_1 > 1)
0001d24d              {
0001d228                  result_1 = *(uint64_t*)pdata_ret_1;
0001d228                  
0001d240                  if (memcmp(result_1, &is_esym, r12))
0001d240                      break;
0001d240                  
0001d245                  writecount_1 -= 1;
0001d247                  *(uint64_t*)pdata_ret_1 = (char*)result_1 - r12;
0001d24d              }
0001d24d              
0001d252              if (is_esym_1)
0001d252              {
0001d254                  void* r12_1 = *(uint64_t*)pdata_ret_1;
0001d257                  (uint8_t)result_1 = 0;
0001d25a                  void* rbx_1 = r12_1;
0001d25a                  
0001d278                  while (true)
0001d278                  {
0001d278                      rbx_1 -= r13_1;
0001d278                      
0001d27e                      if (rbx_1 < pst_data_2)
0001d27e                          break;
0001d27e                      
0001d26f                      if (memcmp(r12_1, rbx_1, r13_1))
0001d26f                          break;
0001d26f                      
0001d274                      (uint8_t)result_1 = !(uint8_t)result_1;
0001d278                  }
0001d278                  
0001d280                  *(uint8_t*)is_esym_1 = (uint8_t)result_1;
0001d252              }
0001d252              
0001d290              return result;
0001d17b          }
0001d17b          
0001d17d          (uint8_t)tree = ADJ(rbp)->typespec;
0001d180          (uint8_t)tree = ~(uint8_t)tree;
0001d182          (uint8_t)tree &= 0xc0;
0001d182          
0001d18d          if ((uint8_t)tree == 0xc0 || (uint8_t)tree == 0x40)
0001d18f              pst_data_1 += r13_1;
0001d18f          
0001d192          uint32_t writecount = (uint32_t)ADJ(rbp)->writecount;
0001d196          i += 1;
0001d199          result += 1;
0001d19c          rbp = &rbp[4];
0001d1a6          pst_data_2 += (int64_t)(writecount * (uint32_t)r13_1);
0001d1b0      }
0001d1b0      
0001d1b2      return -1;
0001d0d4  }

0001d298                                                                          cc cc cc cc cc cc cc cc                          ........

0001d2a0    uint8_t ST_GetU8(struct tv_item_t* tree, uint8_t* dst, uint8_t* pst_data, int32_t parentId, int32_t childId)

0001d2a0  {
0001d2da      uint8_t is_esym = 0;
0001d2e4      char* pdata_ret;
0001d2e4      int64_t r11 = (int64_t)ST_GetSettingIndex2(tree, pst_data, parentId, childId, 
0001d2e4          &pdata_ret, &is_esym);
0001d2eb      uint8_t* pdata_ret_1;
0001d2eb      
0001d2eb      if ((uint32_t)r11 != 0xffffffff)
0001d2eb      {
0001d2f8          uint8_t rcx_1 = tree[r11].typespec & 0x3f;
0001d2fe          int32_t rdx_1;
0001d2fe          (uint8_t)rdx_1 = rcx_1 == 4;
0001d306          int32_t rax_1;
0001d306          (uint8_t)rax_1 = rcx_1 == 1;
0001d324          pdata_ret_1 = pdata_ret;
0001d324          
0001d32c          if (pdata_ret_1)
0001d32c          {
0001d34c              if (dst)
0001d34c              {
0001d353                  if (!is_esym)
0001d35c                      *(uint8_t*)dst = *(uint8_t*)pdata_ret_1;
0001d353                  else
0001d355                      *(uint8_t*)dst = 0xff;
0001d34c              }
0001d34c              
0001d35e              (uint8_t)pdata_ret_1 = 1;
0001d32c          }
0001d32c          else
0001d32c          {
0001d342              onWarning__("index could not be found", 
0001d342                  "c:\development_work\csf_release_hp\driver\translib\settings.c", 0x13d);
0001d2ed              (uint8_t)pdata_ret_1 = 0;
0001d32c          }
0001d2eb      }
0001d2eb      else
0001d2ed          (uint8_t)pdata_ret_1 = 0;
0001d2ed      
0001d36f      return (uint8_t)pdata_ret_1;
0001d2a0  }

0001d370                                                  cc cc cc cc cc cc cc cc                                          ........

0001d378    uint8_t ST_GetU16(struct tv_item_t* tree, uint16_t* dst, uint8_t* pst_data, int32_t parentId, int32_t childId)

0001d378  {
0001d3b2      uint8_t is_esym = 0;
0001d3bc      char* pdata_ret;
0001d3bc      int64_t r11 = (int64_t)ST_GetSettingIndex2(tree, pst_data, parentId, childId, 
0001d3bc          &pdata_ret, &is_esym);
0001d3c3      char* pdata_ret_1;
0001d3c3      
0001d3c3      if ((uint32_t)r11 != 0xffffffff)
0001d3c3      {
0001d3d0          char rcx_1 = tree[r11].typespec & 0x3f;
0001d3d6          int32_t rdx_1;
0001d3d6          (uint8_t)rdx_1 = rcx_1 == 5;
0001d3de          int32_t rax_1;
0001d3de          (uint8_t)rax_1 = rcx_1 == 2;
0001d3fc          pdata_ret_1 = pdata_ret;
0001d3fc          
0001d404          if (pdata_ret_1)
0001d404          {
0001d424              if (dst)
0001d424              {
0001d42b                  if (!is_esym)
0001d434                      pdata_ret_1 = (uint64_t)*(uint16_t*)pdata_ret_1;
0001d42b                  else
0001d42d                      pdata_ret_1 = 0xffff;
0001d42d                  
0001d437                  *(uint16_t*)dst = (uint16_t)pdata_ret_1;
0001d424              }
0001d424              
0001d43a              (uint8_t)pdata_ret_1 = 1;
0001d404          }
0001d404          else
0001d404          {
0001d41a              onWarning__("index could not be found", 
0001d41a                  "c:\development_work\csf_release_hp\driver\translib\settings.c", 0x165);
0001d3c5              (uint8_t)pdata_ret_1 = 0;
0001d404          }
0001d3c3      }
0001d3c3      else
0001d3c5          (uint8_t)pdata_ret_1 = 0;
0001d3c5      
0001d44b      return (uint8_t)pdata_ret_1;
0001d378  }

0001d44c                                      cc cc cc cc cc cc cc cc                                                  ........

0001d454    uint8_t ST_GetU32(struct tv_item_t* tree, uint32_t* dst, uint8_t* pst_data, int32_t parentId, int32_t childId)

0001d454  {
0001d48e      uint8_t is_esym = 0;
0001d498      char* pdata_ret;
0001d498      int64_t r11 = (int64_t)ST_GetSettingIndex2(tree, pst_data, parentId, childId, 
0001d498          &pdata_ret, &is_esym);
0001d49f      char* pdata_ret_1;
0001d49f      
0001d49f      if ((uint32_t)r11 != 0xffffffff)
0001d49f      {
0001d4ac          char rcx_1 = tree[r11].typespec & 0x3f;
0001d4b2          int32_t rdx_1;
0001d4b2          (uint8_t)rdx_1 = rcx_1 == 6;
0001d4ba          int32_t rax_1;
0001d4ba          (uint8_t)rax_1 = rcx_1 == 3;
0001d4d8          pdata_ret_1 = pdata_ret;
0001d4d8          
0001d4e0          if (pdata_ret_1)
0001d4e0          {
0001d500              if (dst)
0001d500              {
0001d507                  if (!is_esym)
0001d510                      *(uint32_t*)dst = *(uint32_t*)pdata_ret_1;
0001d507                  else
0001d509                      *(uint32_t*)dst = 0xffffffff;
0001d500              }
0001d500              
0001d512              (uint8_t)pdata_ret_1 = 1;
0001d4e0          }
0001d4e0          else
0001d4e0          {
0001d4f6              onWarning__("index could not be found", 
0001d4f6                  "c:\development_work\csf_release_hp\driver\translib\settings.c", 0x18d);
0001d4a1              (uint8_t)pdata_ret_1 = 0;
0001d4e0          }
0001d49f      }
0001d49f      else
0001d4a1          (uint8_t)pdata_ret_1 = 0;
0001d4a1      
0001d523      return (uint8_t)pdata_ret_1;
0001d454  }

0001d524              cc cc cc cc cc cc cc cc                                                                  ........

0001d52c    uint8_t ST_GetFloat(struct tv_item_t* tree, float* dst, uint8_t* pst_data, int32_t parentId, int32_t childId)

0001d52c  {
0001d566      uint8_t is_esym = 0;
0001d570      char* pdata_ret;
0001d570      int64_t rdx_1 = (int64_t)ST_GetSettingIndex2(tree, pst_data, parentId, childId, 
0001d570          &pdata_ret, &is_esym);
0001d576      char* pdata_ret_1;
0001d576      
0001d576      if ((uint32_t)rdx_1 != 0xffffffff)
0001d576      {
0001d57c          tree[rdx_1].typespec;
0001d59c          pdata_ret_1 = pdata_ret;
0001d59c          
0001d5a4          if (pdata_ret_1)
0001d5a4          {
0001d5c4              if (dst)
0001d5c4              {
0001d5cb                  if (!is_esym)
0001d5d4                      *(uint32_t*)dst = *(uint32_t*)pdata_ret_1;
0001d5cb                  else
0001d5cd                      *(uint32_t*)dst = nanf;
0001d5c4              }
0001d5c4              
0001d5d6              (uint8_t)pdata_ret_1 = 1;
0001d5a4          }
0001d5a4          else
0001d5a4          {
0001d5ba              onWarning__("index could not be found", 
0001d5ba                  "c:\development_work\csf_release_hp\driver\translib\settings.c", 0x1b5);
0001d578              (uint8_t)pdata_ret_1 = 0;
0001d5a4          }
0001d576      }
0001d576      else
0001d578          (uint8_t)pdata_ret_1 = 0;
0001d578      
0001d5e7      return (uint8_t)pdata_ret_1;
0001d52c  }

0001d5e8                          cc cc cc cc cc cc cc cc                                                          ........

0001d5f0    int32_t ST_GetSettingSize(uint8_t typespec)

0001d5f0  {
0001d5fc      int32_t rdx_1 = (uint32_t)typespec & 0x3f;
0001d5fc      
0001d601      if (rdx_1 != 1)
0001d601      {
0001d605          if (rdx_1 == 2)
0001d655              return 2;
0001d655          
0001d609          if (rdx_1 == 3)
0001d64e              return 4;
0001d64e          
0001d60d          if (rdx_1 != 4)
0001d60d          {
0001d611              if (rdx_1 == 5)
0001d655                  return 2;
0001d655              
0001d619              if (rdx_1 == 6 || rdx_1 == 7)
0001d64e                  return 4;
0001d64e              
0001d61d              if (rdx_1 == 8)
0001d647                  return 0xe;
0001d647              
0001d621              if (rdx_1 == 9)
0001d640                  return 9;
0001d640              
0001d637              onError__("Unsupported data type.", 
0001d637                  "c:\development_work\csf_release_hp\driver\translib\settings.c", 0x216);
0001d63c              return 0;
0001d60d          }
0001d601      }
0001d601      
0001d65e      return 1;
0001d5f0  }

0001d65f                                                                                               cc                                 .
0001d660  cc cc cc cc cc cc cc cc                                                                          ........

0001d668    void ST_EndianSwap(uint8_t* dst, uint8_t* src, struct tv_item_t* tree)

0001d668  {
0001d672      uint8_t* src_1 = src;
0001d675      uint8_t* buf = dst;
0001d678      uint8_t* rbx = &tree->typespec;
0001d678      
0001d691      while (true)
0001d691      {
0001d691          if (!ADJ(rbx)->treepath0 && !ADJ(rbx)->treepath1 && !ADJ(rbx)->typespec
0001d691                  && !ADJ(rbx)->writecount)
0001d7a1              return;
0001d7a1          
0001d697          (uint8_t)src = 0;
0001d69c          uint64_t rax;
0001d69c          
0001d69c          if (ADJ(rbx)->typespec == 1)
0001d69c          {
0001d77e          label_1d77e:
0001d77e              (uint8_t)rax = *(uint8_t*)src_1;
0001d780              (uint8_t)src = 1;
0001d782              *(uint8_t*)buf = (uint8_t)rax;
0001d69c          }
0001d69c          else if (ADJ(rbx)->typespec == 2)
0001d6a5          {
0001d771          label_1d771:
0001d771              *(uint16_t*)buf = *(uint16_t*)src_1;
0001d775              ET_Swap16N(buf, 1);
0001d77a              (uint8_t)src = 2;
0001d6a5          }
0001d6a5          else if (ADJ(rbx)->typespec == 3)
0001d6ae          {
0001d75a          label_1d75a:
0001d75a              *(uint32_t*)buf = *(uint32_t*)src_1;
0001d75d              ET_Swap32N(buf, 1);
0001d762              (uint8_t)src = 4;
0001d6ae          }
0001d6ae          else
0001d6ae          {
0001d6b7              if (ADJ(rbx)->typespec == 4)
0001d6b7                  goto label_1d77e;
0001d6b7              
0001d6bd              uint8_t typespec = ADJ(rbx)->typespec;
0001d6bd              
0001d6c0              if (typespec == 5)
0001d6c0                  goto label_1d771;
0001d6c0              
0001d6c6              if (typespec > 5)
0001d6c6              {
0001d6cf                  if (ADJ(rbx)->typespec <= 7)
0001d6cf                      goto label_1d75a;
0001d6cf                  
0001d6d4                  if (ADJ(rbx)->typespec == 8)
0001d6d4                  {
0001d73b                      *(uint64_t*)buf = *(uint64_t*)src_1;
0001d741                      *(uint32_t*)(buf + 8) = *(uint32_t*)(src_1 + 8);
0001d749                      *(uint16_t*)(buf + 0xc) = *(uint16_t*)(src_1 + 0xc);
0001d6d4                  }
0001d6d4                  else if (ADJ(rbx)->typespec == 9)
0001d6d9                  {
0001d6df                      int64_t rax_1 = *(uint64_t*)src_1;
0001d6ed                      int32_t var_10_1 = *(uint32_t*)(src_1 + 8);
0001d6ed                      
0001d6f5                      if (!((uint8_t)rax_1 & 0x7f))
0001d6f5                      {
0001d70c                          uint8_t arg_19 = (char)(var_10_1 >> 0x10);
0001d714                          uint8_t arg_1a = (char)(var_10_1 >> 8);
0001d718                          uint8_t arg_1b = (uint8_t)var_10_1;
0001d720                          var_10_1 = ((char)(var_10_1 >> 0x18));
0001d6f5                      }
0001d6f5                      
0001d72c                      *(uint64_t*)buf = rax_1;
0001d732                      *(uint32_t*)(buf + 8) = var_10_1;
0001d6d9                  }
0001d6c6              }
0001d6ae          }
0001d6ae          
0001d785          rax = (uint64_t)(uint8_t)src;
0001d788          buf = &buf[rax];
0001d78b          src_1 = &src_1[rax];
0001d78e          rbx = &rbx[4];
0001d691      }
0001d668  }

0001d7a2        cc cc cc cc cc cc                                                                            ......

0001d7a8    void ET_Swap16N(uint8_t* buf, int32_t count)

0001d7a8  {
0001d7a8      int64_t r8 = 0;
0001d7ab      int64_t count_1 = (int64_t)count;
0001d7ae      uint8_t* buf_1 = buf;
0001d7ae      
0001d7b4      if (count_1 <= 0)
0001d7b4          return;
0001d7b4      
0001d7ea      do
0001d7ea      {
0001d7b6          uint16_t rax_1 = *(uint16_t*)(buf_1 + (r8 << 1));
0001d7c4          (uint8_t)buf = (uint8_t)rax_1;
0001d7c8          (uint8_t)buf ^= (rax_1 >> 8);
0001d7ca          (uint8_t)rax_1 = *(uint8_t*)((char*)rax_1)[1];
0001d7ce          (uint8_t)rax_1 ^= (uint8_t)buf;
0001d7d0          (uint8_t)buf ^= (uint8_t)rax_1;
0001d7d2          uint16_t arg_10;
0001d7d2          *(uint8_t*)((char*)arg_10)[1] = (uint8_t)rax_1;
0001d7d6          (uint8_t)arg_10 = (uint8_t)buf;
0001d7df          *(uint16_t*)(buf_1 + (r8 << 1)) = arg_10;
0001d7e4          r8 += 1;
0001d7ea      } while (r8 < count_1);
0001d7a8  }

0001d7ee                                            cc cc cc cc cc cc                                                    ......

0001d7f4    void ET_Swap32N(uint8_t* buf, int32_t count)

0001d7f4  {
0001d7f4      int64_t r8 = 0;
0001d7f7      int64_t count_1 = (int64_t)count;
0001d7f7      
0001d7fd      if (count_1 <= 0)
0001d7fd          return;
0001d7fd      
0001d830      do
0001d830      {
0001d7ff          int32_t rdx = *(uint32_t*)(buf + (r8 << 2));
0001d805          char arg_13 = (uint8_t)rdx;
0001d815          uint8_t arg_11 = (char)(rdx >> 0x10);
0001d81e          uint8_t arg_12 = (char)(rdx >> 8);
0001d826          *(uint32_t*)(buf + (r8 << 2)) = ((char)(rdx >> 0x18));
0001d82a          r8 += 1;
0001d830      } while (r8 < count_1);
0001d7f4  }

0001d834                                                              cc cc cc cc cc cc cc cc                                  ........

0001d83c    uint8_t ST_AcquireLock(struct lock_t* lock, int32_t timeout)

0001d83c  {
0001d84e      if (!lock->initialised)
0001d84e      {
0001d856          KeInitializeMutex(&lock->mutex, 0);
0001d85c          lock->initialised = 1;
0001d84e      }
0001d84e      
0001d868      BOOLEAN Alertable = 1;
0001d86d      NTSTATUS rax_2;
0001d86d      
0001d86d      if (timeout <= 0)
0001d86d      {
0001d89e          KeWaitForSingleObject(&lock->mutex, Executive, 0, Alertable, nullptr);
0001d8a4          (uint8_t)rax_2 = 1;
0001d86d      }
0001d86d      else
0001d86d      {
0001d87b          int64_t Timeout = -((int64_t)(timeout * 0x2710));
0001d87b          
0001d892          if (!KeWaitForSingleObject(&lock->mutex, Executive, 0, Alertable, &Timeout))
0001d8a4              (uint8_t)rax_2 = 1;
0001d892          else
0001d894              (uint8_t)rax_2 = 0;
0001d86d      }
0001d86d      
0001d8b0      return (uint8_t)rax_2;
0001d83c  }

0001d8b1                                                     cc cc cc cc cc cc cc                                           .......

0001d8b8    uint8_t ST_TickSoftTimer(struct SOFT_TIMER* st, uint32_t dt)

0001d8b8  {
0001d8bc      bool cond:0 = st->enabled != 1;
0001d8c0      uint32_t elapsedTime = st->elapsedTime;
0001d8c5      st->elapsedTime = elapsedTime + 0xa;
0001d8d0      int32_t rax;
0001d8d0      
0001d8d0      if (cond:0
0001d8d0              || (elapsedTime <= elapsedTime + 0xa && elapsedTime + 0xa < st->expiredTime))
0001d8f3          (uint8_t)rax = 0;
0001d8d0      else
0001d8d0      {
0001d8d7          if (st->periodic)
0001d8de              st->elapsedTime = 0;
0001d8d7          else
0001d8d9              st->enabled = 0;
0001d8d9          
0001d8e0          void (* f)(void*) = st->f;
0001d8e0          
0001d8e7          if (f)
0001d8ed              f(st->param);
0001d8ed          
0001d8ef          (uint8_t)rax = 1;
0001d8d0      }
0001d8d0      
0001d8f9      return (uint8_t)rax;
0001d8b8  }

0001d8fa                                                                                cc cc cc cc cc cc                            ......

0001d900    float DistanceSquare(struct fpoint_t const* A, struct fpoint_t const* B)

0001d900  {
0001d918      if (!A || !B)
0001d926          onVerify__("c:\development_work\csf_release_hp\driver\tlcommon\safefloatpoint.c", 
0001d926              0x1a);
0001d926      
0001d939      float zmm0 = B->y - A->y;
0001d93e      float zmm1 = B->x - A->x;
0001d953      return zmm0 * zmm0 + zmm1 * zmm1;
0001d900  }

0001d954                                                              cc cc cc cc cc cc cc cc                                  ........

0001d95c    float _divide(float a, float b) __pure

0001d95c  {
0001d973      if (!(9.99999997e-07f <= b) && !(b <= -9.99999997e-07f))
0001d975          b = (int32_t){0};
0001d975      
0001d978      b - 0f;
0001d978      
0001d97d      if (!FCMP_UO(b, 0f) && !(b != 0f))
0001d987          return 0x4b18967f;
0001d987      
0001d98c      return a / b;
0001d95c  }

0001d98d                                         cc cc cc cc cc cc cc                                                   .......

0001d994    float _safeTan(float angle)

0001d994  {
0001d9a0      uint128_t zmm5 = 0x7fffffffffffffff;
0001d9a8      uint64_t zmm1[0x2] = angle;
0001d9b0      float x = angle;
0001d9bb      zmm1[0] = zmm1[0] - 1.57079637f;
0001d9bf      zmm1 = _mm_unpacklo_ps(zmm1, zmm1[0]);
0001d9c5      double zmm2[0x2] = _mm_and_pd(_mm_cvtps_pd(zmm1[0]), zmm5);
0001d9c9      zmm1[0] = (float)zmm2[0];
0001d9c9      
0001d9d0      if (!(1.00000001e-07f <= zmm1[0]))
0001d9d2          return 9999999f;
0001d9d2      
0001d9df      angle = angle + 1.57079637f;
0001d9ed      zmm2[0] = (float)_mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(angle, angle)), zmm5)[0];
0001d9ed      
0001d9f4      if (1.00000001e-07f <= zmm2[0])
0001da03          return tanf(x);
0001da03      
0001d9f6      return -9999999f;
0001d994  }

0001da12                                                        cc cc cc cc cc cc                                            ......

0001da18    uint8_t SFP_IntersectSegments(struct fpoint_t const* p1, struct fpoint_t const* p2, struct fpoint_t const* p3, struct fpoint_t const* p4, struct fpoint_t* intersect)

0001da18  {
0001da4c      int64_t rbx;
0001da4c      (uint8_t)rbx = 1;
0001da4c      
0001da6a      if (!p1 || !p2 || !p3 || !p4 || !intersect)
0001da78          onVerify__("c:\development_work\csf_release_hp\driver\tlcommon\safefloatpoint.c", 
0001da78              0xee);
0001da78      
0001da7d      float zmm2[0x4];
0001da7d      zmm2[0] = p2->x;
0001da7d      zmm2[1] = p2->x;
0001da7d      zmm2[2] = p2->x;
0001da7d      zmm2[3] = p2->x;
0001da81      double zmm8[0x2];
0001da81      zmm8[0] = p4->x;
0001da81      *(uint32_t*)((char*)zmm8[0])[4] = p4->x;
0001da81      zmm8[1] = p4;
0001da87      int128_t y_1 = p4->y;
0001da8e      zmm2[0] = zmm2[0] - p1->x;
0001da93      zmm8[0] = zmm8[0] - p3->x;
0001da99      float y = p1->y;
0001daa5      int128_t y_2 = p2->y;
0001daaa      (uint32_t)y_1 = (uint32_t)y_1 - p3->y;
0001dab0      zmm2[0] = zmm2[0] * (uint32_t)y_1;
0001dab4      (uint32_t)y_2 = (uint32_t)y_2 - y;
0001dab8      zmm8[0] = zmm8[0] * (uint32_t)y_2;
0001dabc      zmm2[0] = zmm2[0] - zmm8[0];
0001dac0      float temp0[0x4] = _mm_unpacklo_ps(zmm2, *(uint64_t*)&zmm2[0]);
0001dace      double zmm1[0x2];
0001dace      zmm1[0] = (float)__andpd_xmmxuq_memxuq(_mm_cvtps_pd(*(uint64_t*)&temp0[0]), 
0001dace          __mask@@AbsDouble@)[0];
0001dace      
0001dadd      if (1.00000001e-07f > zmm1[0])
0001db66          (uint8_t)rbx = 0;
0001dadd      else
0001dadd      {
0001dae3          y = y - p3->y;
0001dae9          zmm1[0] = p1->x;
0001dae9          *(uint32_t*)((char*)zmm1[0])[4] = p1->x;
0001dae9          zmm1[1] = p1;
0001daee          zmm1[0] = zmm1[0] - p3->x;
0001daf4          float y_3 = y;
0001db03          zmm1[0] = zmm1[0] * (uint32_t)y_2;
0001db07          zmm1[0] = zmm1[0] * (uint32_t)y_1;
0001db17          y = (y * zmm2[0] - zmm1[0]) / temp0[0];
0001db1f          y_3 = (y_3 * zmm8[0] - zmm1[0]) / temp0[0];
0001db1f          
0001db3d          if (y_3 <= -1.00000001e-07f || 1.00000012f <= y_3 || y <= -1.00000001e-07f
0001db3d                  || 1.00000012f <= y)
0001db66              (uint8_t)rbx = 0;
0001db3d          else
0001db3d          {
0001db3f              zmm1[0] = p2->y;
0001db3f              zmm1[1] = p2;
0001db44              zmm2[0] = zmm2[0] * y_3;
0001db48              zmm1[0] = zmm1[0] - p1->y;
0001db4d              zmm2[0] = zmm2[0] + p1->x;
0001db52              zmm1[0] = zmm1[0] * y_3;
0001db56              zmm1[0] = zmm1[0] + p1->y;
0001db5b              intersect->x = zmm2[0];
0001db5f              intersect->y = zmm1[0];
0001db3d          }
0001dadd      }
0001dadd      
0001db92      return (uint8_t)rbx;
0001da18  }

0001db93                                                           cc cc cc cc cc cc cc cc cc                                 .........

0001db9c    uint8_t TestIntersect(struct fpoint_t p1, struct fpoint_t p2, struct fpoint_t p3, struct fpoint_t p4) __pure

0001db9c  {
0001db9f      int64_t arg_20;
0001db9f      (uint32_t)arg_20 = p4.x;
0001db9f      *(uint32_t*)((char*)arg_20)[4] = p4.y;
0001dba3      int64_t arg_18;
0001dba3      (uint32_t)arg_18 = p3.x;
0001dba3      *(uint32_t*)((char*)arg_18)[4] = p3.y;
0001dba7      int64_t arg_10;
0001dba7      (uint32_t)arg_10 = p2.x;
0001dba7      *(uint32_t*)((char*)arg_10)[4] = p2.y;
0001dbac      int64_t arg_8;
0001dbac      (uint32_t)arg_8 = p1.x;
0001dbac      *(uint32_t*)((char*)arg_8)[4] = p1.y;
0001dbb8      float zmm5 = *(uint32_t*)((char*)arg_8)[4];
0001dbbe      int128_t zmm4 = (uint32_t)arg_18;
0001dbc4      float zmm3 = *(uint32_t*)((char*)arg_18)[4];
0001dbdb      int128_t zmm6 = (uint32_t)arg_8;
0001dbe1      int128_t zmm8 = *(uint32_t*)((char*)arg_10)[4];
0001dbe7      int128_t zmm7 = *(uint32_t*)((char*)arg_20)[4];
0001dbfc      int128_t zmm10 = (uint32_t)arg_10;
0001dc02      int128_t zmm9 = (uint32_t)arg_20;
0001dc25      int128_t zmm15;
0001dc25      (uint32_t)zmm15 = (uint32_t)zmm6 - (uint32_t)zmm10;
0001dc2a      int128_t zmm2;
0001dc2a      (uint32_t)zmm2 = (uint32_t)zmm4 - (uint32_t)zmm9;
0001dc3a      int128_t zmm14;
0001dc3a      (uint32_t)zmm14 = (uint32_t)zmm8 - zmm5;
0001dc3f      int128_t zmm11;
0001dc3f      (uint32_t)zmm11 = (uint32_t)zmm7 - zmm3;
0001dc54      int128_t zmm13;
0001dc54      (uint32_t)zmm13 = (uint32_t)zmm15 * zmm5;
0001dc5d      int128_t zmm12;
0001dc5d      (uint32_t)zmm12 = (uint32_t)zmm2 * (uint32_t)zmm14;
0001dc62      (uint32_t)zmm13 = (uint32_t)zmm13 + (uint32_t)zmm6 * (uint32_t)zmm14;
0001dc6f      float zmm1 = (uint32_t)zmm2 * zmm3 + (uint32_t)zmm4 * (uint32_t)zmm11;
0001dc7c      (uint32_t)zmm12 = (uint32_t)zmm12 - (uint32_t)zmm11 * (uint32_t)zmm15;
0001dc84      0f - (uint32_t)zmm12;
0001dc84      
0001dc8a      if (FCMP_UO(0f, (uint32_t)zmm12) || !(0f == (uint32_t)zmm12))
0001dc8a      {
0001dc97          (uint32_t)zmm2 = (uint32_t)zmm2 * (uint32_t)zmm13;
0001dca1          (uint32_t)zmm11 = (uint32_t)zmm11 * (uint32_t)zmm13;
0001dcab          (uint32_t)zmm2 = (uint32_t)zmm2 - zmm1 * (uint32_t)zmm15;
0001dcb4          (uint32_t)zmm2 = (uint32_t)zmm2 / (uint32_t)zmm12;
0001dcb9          zmm1 = (zmm1 * (uint32_t)zmm14 - (uint32_t)zmm11) / (uint32_t)zmm12;
0001dcbe          float zmm0;
0001dcbe          
0001dcbe          zmm0 = (uint32_t)zmm10 <= (uint32_t)zmm6 ? (uint32_t)zmm10 : (uint32_t)zmm6;
0001dcbe          
0001dccd          if (!((uint32_t)zmm6 > (uint32_t)zmm10))
0001dccf              zmm6 = zmm10;
0001dccf          
0001dcdb          if (!((uint32_t)zmm2 < zmm0) && !((uint32_t)zmm6 < (uint32_t)zmm2))
0001dcdb          {
0001dce1              zmm0 = (uint32_t)zmm8 <= zmm5 ? (uint32_t)zmm8 : zmm5;
0001dce1              
0001dcf0              if (!(zmm5 > (uint32_t)zmm8))
0001dcf2                  zmm5 = (uint32_t)zmm8;
0001dcf2              
0001dcfe              if (!(zmm1 < zmm0) && !(zmm5 < zmm1))
0001dcfe              {
0001dd04                  zmm0 = (uint32_t)zmm9 <= (uint32_t)zmm4 ? (uint32_t)zmm9 : (uint32_t)zmm4;
0001dd04                  
0001dd13                  if (!((uint32_t)zmm4 > (uint32_t)zmm9))
0001dd15                      zmm4 = zmm9;
0001dd15                  
0001dd21                  if (!((uint32_t)zmm2 < zmm0) && !((uint32_t)zmm4 < (uint32_t)zmm2))
0001dd21                  {
0001dd26                      zmm0 = (uint32_t)zmm7 <= zmm3 ? (uint32_t)zmm7 : zmm3;
0001dd26                      
0001dd33                      if (!(zmm3 > (uint32_t)zmm7))
0001dd35                          zmm3 = (uint32_t)zmm7;
0001dd35                      
0001dd40                      if (!(zmm1 < zmm0) && !(zmm3 < zmm1))
0001dd42                          return 1;
0001dd21                  }
0001dcfe              }
0001dcdb          }
0001dc8a      }
0001dc8a      
0001dd83      return 0;
0001db9c  }

0001dd84              cc cc cc cc cc cc cc cc                                                                  ........

0001dd8c    uint8_t IsPointInPolygon(struct fpoint_t pt, struct fpoint_t* polygon, uint8_t numPoints)

0001dd8c  {
0001dd8c      int64_t arg_8;
0001dd8c      (uint32_t)arg_8 = pt.x;
0001dd8c      *(uint32_t*)((char*)arg_8)[4] = pt.y;
0001dd95      int64_t rax;
0001dd95      (uint32_t)rax = polygon->x;
0001dd95      *(uint32_t*)((char*)rax)[4] = polygon->y;
0001dd9c      float zmm6[0x4] = *(uint32_t*)((char*)arg_8)[4];
0001dda5      numPoints = 0;
0001dda8      pt.x = 1;
0001ddaa      int64_t arg_10 = rax;
0001ddaa      
0001de8c      do
0001de8c      {
0001ddaf          float zmm3[0x4] = *(uint32_t*)((char*)arg_10)[4];
0001ddb8          int32_t temp0_1;
0001ddb8          int32_t temp1_1;
0001ddb8          temp0_1 = HIGHD((int64_t)(uint32_t)pt.x);
0001ddb8          temp1_1 = LOWD((int64_t)(uint32_t)pt.x);
0001ddb9          int32_t rdx_1 = temp0_1 & 3;
0001ddc5          int64_t rax_7 = polygon[(int64_t)(((temp1_1 + rdx_1) & 3) - rdx_1)].x;
0001ddce          float zmm2[0x4] = *(uint32_t*)((char*)rax_7)[4];
0001ddd7          float zmm0[0x4];
0001ddd7          
0001ddd7          if (zmm2[0] <= zmm3[0])
0001ddde              zmm0 = zmm2;
0001ddd7          else
0001ddd9              zmm0 = zmm3;
0001ddd9          
0001dde4          if (!(zmm6[0] <= zmm0[0]))
0001dde4          {
0001dded              if (zmm3[0] <= zmm2[0])
0001ddf4                  zmm0 = zmm2;
0001dded              else
0001ddef                  zmm0 = zmm3;
0001ddef              
0001ddfa              if (!(zmm0[0] < zmm6[0]))
0001ddfa              {
0001de00                  float zmm4[0x4] = (uint32_t)arg_10;
0001de06                  uint64_t zmm5[0x2] = (uint32_t)rax_7;
0001de06                  
0001de0f                  if (zmm4[0] <= zmm5[0])
0001de16                      zmm0 = zmm5;
0001de0f                  else
0001de11                      zmm0 = zmm4;
0001de11                  
0001de1e                  if (!(zmm0[0] < (uint32_t)arg_8))
0001de1e                  {
0001de20                      zmm3[0] - zmm2[0];
0001de20                      
0001de25                      if (FCMP_UO(zmm3[0], zmm2[0]) || !(zmm3[0] == zmm2[0]))
0001de25                      {
0001de27                          zmm2[0] = zmm2[0] - zmm3[0];
0001de2e                          zmm2[0] = zmm2[0] + zmm4[0];
0001de32                          zmm0 = _mm_unpacklo_ps(zmm2, *(uint64_t*)&zmm2[0]);
0001de40                          zmm0[0] = (float)__andpd_xmmxuq_memxuq(
0001de40                              _mm_cvtps_pd(*(uint64_t*)&zmm0[0]), __mask@@AbsDouble@)[0];
0001de4b                          uint64_t zmm1[0x2];
0001de4b                          
0001de4b                          if (zmm0[0] <= 1.00000001e-07f)
0001de69                              zmm1 = 0xcb18967f;
0001de4b                          else
0001de4b                          {
0001de4d                              zmm1 = zmm5;
0001de53                              zmm1[0] = zmm1[0] - zmm4[0];
0001de57                              zmm6[0] = zmm6[0] - zmm3[0];
0001de5b                              zmm1[0] = zmm1[0] * zmm6[0];
0001de5f                              zmm1[0] = zmm1[0] / zmm2[0];
0001de63                              zmm1[0] = zmm1[0] + zmm4[0];
0001de4b                          }
0001de4b                          
0001de71                          zmm4[0] - zmm5[0];
0001de71                          
0001de74                          if (FCMP_UO(zmm4[0], zmm5[0]))
0001de74                          {
0001de7d                              if (!(zmm1[0] < (uint32_t)arg_8))
0001de7f                                  numPoints += 1;
0001de74                          }
0001de74                          else if (zmm4[0] == zmm5[0] || !(zmm1[0] < (uint32_t)arg_8))
0001de7f                              numPoints += 1;
0001de25                      }
0001de1e                  }
0001ddfa              }
0001dde4          }
0001dde4          
0001de82          pt.x += 1;
0001de84          arg_10 = rax_7;
0001de8c      } while (pt.x <= 4);
0001de8c      
0001de9a      int32_t temp2;
0001de9a      int32_t temp3;
0001de9a      temp2 = HIGHD((int64_t)(uint32_t)numPoints);
0001de9a      temp3 = LOWD((int64_t)(uint32_t)numPoints);
0001dea2      int32_t rax_11;
0001dea2      (uint8_t)rax_11 = ((temp3 & 1) ^ temp2) != temp2;
0001dea9      return (uint8_t)rax_11;
0001dd8c  }

0001deaa                                cc cc cc cc cc cc                                                            ......

0001deb0    uint8_t SFP_Lerp(uint32_t x1, float y1, uint32_t x2, float y2, uint32_t xi, float* yi)

0001deb0  {
0001decb      uint64_t x1_1 = (uint64_t)x1;
0001ded0      int128_t zmm6 = y1;
0001ded0      
0001dede      if (x1 >= xi || xi >= x2)
0001deec          onVerify__("c:\development_work\csf_release_hp\driver\tlcommon\safefloatpoint.c", 
0001deec              0x1ad);
0001deec      
0001def9      if (!yi)
0001df07          onVerify__("c:\development_work\csf_release_hp\driver\tlcommon\safefloatpoint.c", 
0001df07              0x1ae);
0001df07      
0001df0c      int128_t zmm7;
0001df0c      (uint32_t)zmm7 = y2 - (uint32_t)zmm6;
0001df2f      (uint32_t)zmm7 = (uint32_t)zmm7 / (float)(uint64_t)(x2 - (uint32_t)x1_1);
0001df33      uint64_t rax_1;
0001df33      (uint8_t)rax_1 = 1;
0001df50      (uint32_t)zmm6 = (uint32_t)zmm6 - (float)x1_1 * (uint32_t)zmm7;
0001df54      (uint32_t)zmm6 = (uint32_t)zmm6 + (float)(uint64_t)xi * (uint32_t)zmm7;
0001df58      *(uint32_t*)yi = (uint32_t)zmm6;
0001df66      return 1;
0001deb0  }

0001df67                       cc cc cc cc cc cc cc cc cc                                                         .........

0001df70    struct fpoint_t SFP_LineIntersect(struct line_def_t* lineA, struct line_def_t* lineB)

0001df70  {
0001df74      lineA->m
0001df74      lineA->m
0001df74      float m = lineA->m;
0001df78      float m_1 = lineB->m;
0001df78      m - m_1;
0001df7d      float zmm0;
0001df7d      float arg_c;
0001df7d      
0001df7d      if (FCMP_UO(m, m_1) || m != m_1)
0001df7d      {
0001dfa0          zmm0 = _divide(lineB->c - lineA->c, m - lineB->m);
0001dfae          arg_c = m * zmm0 + lineA->c;
0001df7d      }
0001df7d      else
0001df7d      {
0001df7f          zmm0 = 9999999f;
0001df87          arg_c = 9999999f;
0001df7d      }
0001dfc3      return zmm0;
0001df70  }

0001dfc4              cc cc cc cc cc cc cc cc                                                                  ........

0001dfcc    float CalculateAngleBetweenPoints(struct fpoint_t const pt1, struct fpoint_t const pt2)

0001dfcc  {
0001dfcf      int64_t arg_10;
0001dfcf      (uint32_t)arg_10 = pt2.x;
0001dfcf      *(uint32_t*)((char*)arg_10)[4] = pt2.y;
0001dfd3      int64_t arg_8;
0001dfd3      (uint32_t)arg_8 = pt1.x;
0001dfd3      *(uint32_t*)((char*)arg_8)[4] = pt1.y;
0001dfdb      float zmm1[0x4] = (uint32_t)arg_8;
0001dfe0      float zmm0[0x4] = *(uint32_t*)((char*)arg_8)[4];
0001dfe9      zmm1[0] = zmm1[0] - (uint32_t)arg_10;
0001dfee      int128_t zmm6 = {0};
0001dff1      zmm0[0] = zmm0[0] - *(uint32_t*)((char*)arg_10)[4];
0001dff6      zmm1[0] - 0f;
0001dff6      bool cond:0 = zmm1[0] == 0f;
0001dff6      
0001dffb      if (FCMP_UO(zmm1[0], 0f) || !cond:0)
0001dffd          zmm0[0] - 0f;
0001dffd      
0001e002      if ((FCMP_UO(zmm1[0], 0f) || !cond:0) && (FCMP_UO(zmm0[0], 0f) || zmm0[0] != 0f))
0001e002      {
0001e009          float temp0_1[0x4] = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
0001e00c          float temp0_2[0x4] = _mm_unpacklo_ps(zmm1, *(uint64_t*)&zmm1[0]);
0001e00f          zmm0 = _mm_cvtps_pd(*(uint64_t*)&temp0_1[0]);
0001e012          zmm1 = _mm_cvtps_pd(*(uint64_t*)&temp0_2[0]);
0001e015          zmm0 = atan2(*(uint64_t*)&zmm0[0], *(uint64_t*)&zmm1[0]);
0001e01a          zmm0[0] = (float)*(uint64_t*)&zmm0[0];
0001e002      }
0001e002      else
0001e004          zmm0 = {0};
0001e004      
0001e021      if (!((uint32_t)zmm6 <= zmm0[0]))
0001e023          zmm0[0] = zmm0[0] + 6.28318548f;
0001e023      
0001e034      return zmm0[0];
0001dfcc  }

0001e035                                                                 cc cc cc cc cc cc cc                                   .......

0001e03c    void Log_DebugPrintf(char const* str, ...) __pure

0001e03c  {
0001e03c      int64_t rdx;
0001e03c      int64_t arg_10 = rdx;
0001e041      int64_t r8;
0001e041      int64_t arg_18 = r8;
0001e046      int64_t r9;
0001e046      int64_t arg_20 = r9;
0001e03c  }

0001e04c                                      cc cc cc cc cc cc cc cc                                                  ........

0001e054    void onVerify__(char const* file, int32_t line)

0001e054  {
0001e061      j_strrchr(file, 0x5c);
0001e07a      Error_Count.cnt_verifies += 1;
0001e054  }

0001e097                                                                       cc cc cc cc cc cc cc cc cc                         .........

0001e0a0    void __convention("sysv") onError__(char const* text @ rcx, char const* file @ rdx, int32_t line @ r8)

0001e0a0  {
0001e0bb      j_strrchr(file, 0x5c);
0001e0d4      Error_Count.cnt_errors += 1;
0001e0a0  }

0001e0f9                                                                             cc cc cc cc cc cc cc                           .......

0001e100    void __convention("sysv") onWarning__(char const* text @ rcx, char const* file @ rdx, int32_t line @ r8)

0001e100  {
0001e11b      j_strrchr(file, 0x5c);
0001e134      Error_Count.cnt_warnings += 1;
0001e100  }

0001e159                                                                             cc cc cc cc cc cc cc                           .......

0001e160    void __convention("sysv") onBug__(char const* text @ rcx, char const* file @ rdx, int32_t line @ r8)

0001e160  {
0001e17b      j_strrchr(file, 0x5c);
0001e194      Error_Count.cnt_bugs += 1;
0001e160  }

0001e1b9                                                                             cc cc cc cc cc cc cc                           .......

0001e1c0    void InitSubmodules(struct _ctl_context_t* pContext)

0001e1c0  {
0001e1d4      int64_t rdi;
0001e1d4      (uint8_t)rdi = pContext->settings.numSensors;
0001e1f0      memset(&pContext->subSamplerStruct, 0, 0x92c);
0001e1f5      pContext->subSamplerStruct.newest = (uint8_t)rdi;
0001e1fc      pContext->subSamplerStruct.numSensors = (uint8_t)rdi;
0001e203      pContext->subSamplerStruct.oldest = 0;
0001e20a      pContext->subSamplerStruct.state = SS_START;
0001e214      struct sub_sampler_working_t* rbx;
0001e214      (uint8_t)rbx = pContext->settings.numSensors;
0001e214      
0001e22d      if ((uint8_t)rbx <= 4 && pContext != -0x56f8)
0001e22d      {
0001e23e          int64_t rbp;
0001e23e          (uint8_t)rbp = 0;
0001e241          memset(&pContext->triangulateStatics, 0, 0x1180);
0001e246          char i = 0;
0001e249          pContext->triangulateStatics.numSensors = (uint8_t)rbx;
0001e249          
0001e251          if ((uint8_t)rbx)
0001e251          {
0001e2b7              do
0001e2b7              {
0001e253                  char j = 0;
0001e253                  
0001e2af                  do
0001e2af                  {
0001e263                      if (i < (uint8_t)rbx && j < (uint8_t)rbx && i != j)
0001e263                      {
0001e265                          char r8_1 = i + j;
0001e265                          
0001e271                          if (!i || !j)
0001e273                              r8_1 -= 1;
0001e273                          
0001e27a                          if (r8_1 != 0xff)
0001e27a                          {
0001e288                              char r8_2 = r8_1;
0001e28c                              char* rax_2 = (int64_t)r8_1 * 0xcc;
0001e295                              *(uint8_t*)(rax_2 + &pContext->triangulateStatics) = i;
0001e299                              *(uint8_t*)(
0001e299                                  &pContext->triangulateStatics.trigs[0].sensorB + rax_2) = j;
0001e299                              
0001e2a2                              if ((uint32_t)(uint8_t)rbp > (int32_t)r8_1)
0001e2a2                                  r8_2 = (uint8_t)rbp;
0001e2a2                              
0001e2a6                              (uint8_t)rbp = r8_2;
0001e27a                          }
0001e263                      }
0001e263                      
0001e2a9                      j += 1;
0001e2af                  } while (j < (uint8_t)rbx);
0001e2af                  
0001e2b1                  i += 1;
0001e2b7              } while (i < (uint8_t)rbx);
0001e251          }
0001e251          
0001e2c4          pContext->triangulateStatics.snsInfo = &pContext->settings.sensorInfo;
0001e2cb          struct sensor_info_t (* rax_4)[0x4];
0001e2cb          (uint8_t)rax_4 =
0001e2cb              (&pContext->settings.sensorInfo) - (&pContext->settings.sensorInfo);
0001e2cd          (uint8_t)rax_4 &= (uint8_t)rbp;
0001e2d0          pContext->triangulateStatics.numTrigs = (uint8_t)rax_4;
0001e22d      }
0001e22d      
0001e2df      pContext->twoSensorTriangulation.unStableFrameCnt = 0;
0001e2ea      pContext->twoSensorTriangulation.orientation = O_HORIZONTAL;
0001e2f4      memset(&pContext->twoSensorTriangulation.quickTapSavedFrames, 0, 0x48);
0001e2f9      pContext->twoSensorTriangulation.triangulationType = NO_TRIANGULATION;
0001e30f      pContext->filterData.decisionFilter = NO_DECISION_FILTER;
0001e319      memset(&pContext->filterData.quadraticTTFilter, 0, 0x460);
0001e32f      memset(&pContext->filterData.oneTrueTouchFilter, 0, 0x10);
0001e33d      __builtin_memset(&pContext->filterData.offBezelFilter, 0, 0x18);
0001e367      memset(&pContext->filterData.pivotFilter, 0, 0x18);
0001e378      memset(&pContext->filterData.symmetryFilter, 0, 0x10);
0001e38c      memset(&pContext->filterData.simTwoTouchFilter, 0, 0x3cc);
0001e39e      memset(&pContext->filterData.predictionFilter, 0, 0x1c);
0001e3b2      memset(&pContext->filterData.doubleOcclusionFilter, 0, 0x1c8);
0001e3c0      pContext->filterData.awesomeLogicFilter.orientation = 0;
0001e3cc      pContext->filterData.awesomeLogicFilter.confidence = 0f;
0001e3d2      memset(&pContext->filterData.straightLineFilter, 0, 0x30);
0001e3e4      memset(&pContext->filterData.unstableFirstFilter, 0, 0x60);
0001e3e9      pContext->penStatics.dynamicCamNum = 0;
0001e3f7      pContext->penStatics.dynamicShutters[0] = pContext->settings.sensor[0].penShutter;
0001e408      pContext->penStatics.dynamicShutters[1] = pContext->settings.sensor[1].penShutter;
0001e416      pContext->penStatics.dynamicShutters[2] = pContext->settings.sensor[2].penShutter;
0001e424      pContext->penStatics.dynamicShutters[3] = pContext->settings.sensor[3].penShutter;
0001e43f      /* tailcall */
0001e43f      return AutoCorrect_Init_Data(pContext);
0001e1c0  }

0001e444              cc cc cc cc cc cc cc cc                                                                  ........

0001e44c    void FE_UpdateDeviceSettings(struct _ctl_context_t* pContext, struct fe_device_settings_t* pSettings)

0001e44c  {
0001e458      int128_t zmm7;
0001e458      int128_t var_28 = zmm7;
0001e476      memmove(&pContext->settings, pSettings, 0x184);
0001e47b      uint8_t numSensors = pContext->settings.numSensors;
0001e486      int128_t zmm4;
0001e486      int128_t zmm5;
0001e486      
0001e486      if (numSensors == 2)
0001e486      {
0001e606          (uint32_t)zmm5 = pContext->settings.panelSize.y;
0001e606          *(uint16_t*)((char*)zmm5)[4] = pContext->settings.triggers.thresholdUp;
0001e606          *(uint16_t*)((char*)zmm5)[6] = pContext->settings.triggers.thresholdDown;
0001e606          *(uint16_t*)((char*)zmm5)[8] = pContext->settings.triggers.thresholdFloor;
0001e606          *(uint32_t*)((char*)zmm5)[0xc] = pContext->settings.panelSize.y;
0001e60e          (uint32_t)zmm4 = pContext->settings.panelSize.x;
0001e60e          *(uint32_t*)((char*)zmm4)[4] = pContext->settings.panelSize.x;
0001e60e          *(uint16_t*)((char*)zmm4)[8] = pContext->settings.triggers.thresholdUp;
0001e60e          *(uint16_t*)((char*)zmm4)[0xa] = pContext->settings.triggers.thresholdDown;
0001e60e          *(uint16_t*)((char*)zmm4)[0xc] = pContext->settings.triggers.thresholdFloor;
0001e61c          float zmm0_2 = _divide((uint32_t)zmm4, (uint32_t)zmm5);
0001e621          pContext->settings.camMin.x = 0;
0001e628          pContext->settings.camMin.y = 0f;
0001e62f          pContext->settings.camMax.x = (uint32_t)zmm4;
0001e637          pContext->settings.camMax.y = (uint32_t)zmm5;
0001e63f          pContext->settings.aspectRatio = zmm0_2;
0001e486      }
0001e486      else if (numSensors == 4)
0001e490      {
0001e4a6          int128_t zmm0_1 =
0001e4a6              _divide(pContext->settings.panelSize.x, pContext->settings.panelSize.y);
0001e4ab          (uint32_t)zmm4 = pContext->settings.sensorInfo[0].position.x;
0001e4ab          *(uint32_t*)((char*)zmm4)[4] = pContext->settings.sensorInfo[0].position.x;
0001e4ab          *(uint32_t*)((char*)zmm4)[8] = pContext->settings.sensorInfo[0].position.x;
0001e4ab          *(uint32_t*)((char*)zmm4)[0xc] = pContext->settings.sensorInfo[0].position.x;
0001e4b3          (uint32_t)zmm5 = pContext->settings.sensorInfo[1].position.x;
0001e4b3          *(uint32_t*)((char*)zmm5)[4] = pContext->settings.sensorInfo[1].position.x;
0001e4b3          *(uint32_t*)((char*)zmm5)[8] = pContext->settings.sensorInfo[1].position.x;
0001e4b3          *(uint32_t*)((char*)zmm5)[0xc] = pContext->settings.sensorInfo[1].position.x;
0001e4be          pContext->settings.aspectRatio = (uint32_t)zmm0_1;
0001e4be          
0001e4c6          zmm0_1 = (uint32_t)zmm5 <= (uint32_t)zmm4 ? zmm5 : zmm4;
0001e4c6          
0001e4d0          int128_t zmm2;
0001e4d0          (uint32_t)zmm2 = pContext->settings.sensorInfo[2].position.x;
0001e4d0          *(uint32_t*)((char*)zmm2)[4] = pContext->settings.sensorInfo[2].position.x;
0001e4d0          *(uint32_t*)((char*)zmm2)[8] = pContext->settings.sensorInfo[2].position.x;
0001e4d0          *(uint32_t*)((char*)zmm2)[0xc] = pContext->settings.sensorInfo[2].position.x;
0001e4d8          int128_t zmm3;
0001e4d8          (uint32_t)zmm3 = pContext->settings.sensorInfo[3].position.x;
0001e4d8          *(uint32_t*)((char*)zmm3)[4] = pContext->settings.sensorInfo[3].position.x;
0001e4d8          *(uint32_t*)((char*)zmm3)[8] = pContext->settings.sensorInfo[3].position.x;
0001e4d8          *(uint32_t*)((char*)zmm3)[0xc] = pContext->settings.sensorInfo[3].position.x;
0001e4e3          int128_t zmm1_1;
0001e4e3          
0001e4e3          zmm1_1 = (uint32_t)zmm3 <= (uint32_t)zmm2 ? zmm3 : zmm2;
0001e4e3          
0001e4f0          if ((uint32_t)zmm1_1 <= (uint32_t)zmm0_1)
0001e4f0          {
0001e504              if ((uint32_t)zmm3 <= (uint32_t)zmm2)
0001e50b                  zmm0_1 = zmm3;
0001e504              else
0001e506                  zmm0_1 = zmm2;
0001e4f0          }
0001e4f0          else if ((uint32_t)zmm5 <= (uint32_t)zmm4)
0001e4fc              zmm0_1 = zmm5;
0001e4f5          else
0001e4f7              zmm0_1 = zmm4;
0001e4f7          
0001e50e          (uint32_t)zmm1_1 = pContext->settings.sensorInfo[1].position.y;
0001e50e          *(uint32_t*)((char*)zmm1_1)[4] = pContext->settings.sensorInfo[1].position.y;
0001e50e          *(uint32_t*)((char*)zmm1_1)[8] = pContext->settings.sensorInfo[1].position.y;
0001e50e          *(uint32_t*)((char*)zmm1_1)[0xc] = pContext->settings.sensorInfo[1].position.y;
0001e516          pContext->settings.camMin.x = (uint32_t)zmm0_1;
0001e51e          (uint32_t)zmm0_1 = pContext->settings.sensorInfo[0].position.y;
0001e51e          *(uint32_t*)((char*)zmm0_1)[4] = pContext->settings.sensorInfo[0].position.y;
0001e51e          *(uint32_t*)((char*)zmm0_1)[8] = pContext->settings.sensorInfo[0].position.y;
0001e51e          *(uint32_t*)((char*)zmm0_1)[0xc] = pContext->settings.sensorInfo[0].position.y;
0001e529          int128_t zmm8;
0001e529          
0001e529          zmm8 = (uint32_t)zmm1_1 <= (uint32_t)zmm0_1 ? zmm1_1 : zmm0_1;
0001e529          
0001e535          int128_t zmm6;
0001e535          (uint32_t)zmm6 = pContext->settings.sensorInfo[2].position.y;
0001e535          *(uint32_t*)((char*)zmm6)[4] = pContext->settings.sensorInfo[2].position.y;
0001e535          *(uint32_t*)((char*)zmm6)[8] = pContext->settings.sensorInfo[2].position.y;
0001e535          *(uint32_t*)((char*)zmm6)[0xc] = pContext->settings.sensorInfo[2].position.y;
0001e53d          (uint32_t)zmm7 = pContext->settings.sensorInfo[3].position.y;
0001e53d          *(uint32_t*)((char*)zmm7)[4] = pContext->settings.sensorInfo[3].position.y;
0001e53d          *(uint32_t*)((char*)zmm7)[8] = pContext->settings.sensorInfo[3].position.y;
0001e53d          *(uint32_t*)((char*)zmm7)[0xc] = pContext->settings.sensorInfo[3].position.y;
0001e548          int128_t zmm9;
0001e548          
0001e548          zmm9 = (uint32_t)zmm7 <= (uint32_t)zmm6 ? zmm7 : zmm6;
0001e548          
0001e558          if ((uint32_t)zmm9 <= (uint32_t)zmm8)
0001e558          {
0001e56e              if ((uint32_t)zmm7 <= (uint32_t)zmm6)
0001e576                  zmm8 = zmm7;
0001e56e              else
0001e570                  zmm8 = zmm6;
0001e558          }
0001e558          else if ((uint32_t)zmm1_1 <= (uint32_t)zmm0_1)
0001e565              zmm8 = zmm1_1;
0001e55d          else
0001e55f              zmm8 = zmm0_1;
0001e55f          
0001e57d          pContext->settings.camMin.y = (uint32_t)zmm8;
0001e57d          
0001e586          zmm9 = (uint32_t)zmm4 <= (uint32_t)zmm5 ? zmm5 : zmm4;
0001e586          
0001e595          zmm8 = (uint32_t)zmm2 <= (uint32_t)zmm3 ? zmm3 : zmm2;
0001e595          
0001e5a5          if ((uint32_t)zmm9 <= (uint32_t)zmm8)
0001e5a5          {
0001e5b4              if ((uint32_t)zmm2 <= (uint32_t)zmm3)
0001e5bb                  zmm4 = zmm3;
0001e5b4              else
0001e5b6                  zmm4 = zmm2;
0001e5a5          }
0001e5a5          else if (!((uint32_t)zmm4 > (uint32_t)zmm5))
0001e5ac              zmm4 = zmm5;
0001e5ac          
0001e5c1          pContext->settings.camMax.x = (uint32_t)zmm4;
0001e5c1          
0001e5c9          zmm3 = (uint32_t)zmm0_1 <= (uint32_t)zmm1_1 ? zmm1_1 : zmm0_1;
0001e5c9          
0001e5d6          zmm2 = (uint32_t)zmm6 <= (uint32_t)zmm7 ? zmm7 : zmm6;
0001e5d6          
0001e5e3          if ((uint32_t)zmm3 <= (uint32_t)zmm2)
0001e5e3          {
0001e5f2              if ((uint32_t)zmm6 <= (uint32_t)zmm7)
0001e5f9                  zmm0_1 = zmm7;
0001e5f2              else
0001e5f4                  zmm0_1 = zmm6;
0001e5e3          }
0001e5e3          else if (!((uint32_t)zmm0_1 > (uint32_t)zmm1_1))
0001e5ea              zmm0_1 = zmm1_1;
0001e5ea          
0001e5fc          pContext->settings.camMax.y = (uint32_t)zmm0_1;
0001e490      }
0001e64a      InitSubmodules(pContext);
0001e66d      /* tailcall */
0001e66d      return CTL_Init_Triggers(pContext);
0001e44c  }

0001e672                                                        cc cc cc cc cc cc                                            ......

0001e678    uint8_t CheckApertureSanity(uint16_t startAperture, uint16_t stopAperture)

0001e678  {
0001e684      char* const text;
0001e684      int32_t line;
0001e684      
0001e684      if (startAperture >= 0x20b)
0001e684      {
0001e686          line = 0x12a;
0001e68c          text = "startAperture >= MAX_PIXELS - 1";
0001e684      }
0001e684      else if (stopAperture > startAperture)
0001e6a6      {
0001e6bf          if (stopAperture < 0x20c)
0001e6d0              return 1;
0001e6d0          
0001e6c1          line = 0x134;
0001e6c7          text = "stopAperture >= MAX_PIXELS";
0001e6a6      }
0001e6a6      else
0001e6a6      {
0001e6a8          line = 0x12f;
0001e6ae          text = "stopAperture <= startAperture";
0001e6a6      }
0001e6a6      
0001e69a      onError__(text, "c:\development_work\csf_release_hp\driver\foureyes\ctl_waveform.c", 
0001e69a          line);
0001e69f      return 0;
0001e678  }

0001e6d7                                                                       cc cc cc cc cc cc cc cc cc                         .........

0001e6e0    enum peak_search_res_t FindPeakInBetween(uint16_t* pScope, float* edges, uint16_t* minima, uint16_t* pPeakRet, uint16_t peakNoiseFloor, uint16_t peakMinHeight, uint16_t maxMinimaDiff)

0001e6e0  {
0001e70d      int32_t result = 0;
0001e716      uint64_t rdi;
0001e716      (uint8_t)rdi = 0;
0001e72a      float zmm2 = (*(uint32_t*)edges + 512f) * 0.5f;
0001e72e      float zmm3 = (edges[1] + 512f) * 0.5f;
0001e735      int16_t r9;
0001e735      
0001e735      r9 = zmm3 <= zmm2 ? -1 : 1;
0001e735      
0001e740      int16_t rsi = (int16_t)(int64_t)zmm3;
0001e745      int16_t i_2 = (int16_t)(int64_t)zmm2;
0001e745      
0001e74d      if (i_2 != rsi)
0001e74d      {
0001e753          uint16_t rdx = r9 + i_2;
0001e757          *(uint16_t*)minima = i_2;
0001e757          
0001e75e          if (rdx != rsi)
0001e75e          {
0001e767              while (!(uint8_t)rdi)
0001e767              {
0001e769                  uint64_t r12_1 = (uint64_t)*(uint16_t*)minima;
0001e770                  int16_t rbp_1 = pScope[(uint64_t)rdx];
0001e770                  
0001e77a                  if (rbp_1 < pScope[r12_1])
0001e77c                      *(uint16_t*)minima = rdx;
0001e77a                  else if ((uint32_t)rbp_1
0001e77a                      > (uint32_t)pScope[r12_1] + (uint32_t)peakNoiseFloor)
0001e793                  {
0001e795                      rdi = (uint64_t)(uint8_t)rdi;
0001e795                      
0001e79d                      if ((uint16_t)r12_1 != i_2)
0001e79d                          rdi = 1;
0001e793                  }
0001e793                  
0001e7a1                  rdx += r9;
0001e7a1                  
0001e7a8                  if (rdx == rsi)
0001e7a8                      break;
0001e767              }
0001e767              
0001e7ad              if ((uint8_t)rdi == 1)
0001e7ad              {
0001e7b3                  i_2 = *(uint16_t*)minima;
0001e7ba                  (uint8_t)rdi = 0;
0001e7bd                  int16_t rdx_1 = rsi - r9;
0001e7c1                  minima[1] = rsi;
0001e7c1                  
0001e7c9                  if (rdx_1 != i_2)
0001e7c9                  {
0001e7d2                      while (!(uint8_t)rdi)
0001e7d2                      {
0001e7d4                          uint64_t r12_2 = (uint64_t)minima[1];
0001e7dc                          int16_t rbp_2 = pScope[(uint64_t)rdx_1];
0001e7dc                          
0001e7e6                          if (rbp_2 < pScope[r12_2])
0001e7e8                              minima[1] = rdx_1;
0001e7e6                          else if ((uint32_t)rbp_2
0001e7e6                              > (uint32_t)pScope[r12_2] + (uint32_t)peakNoiseFloor)
0001e800                          {
0001e802                              rdi = (uint64_t)(uint8_t)rdi;
0001e802                              
0001e80a                              if ((uint16_t)r12_2 != rsi)
0001e80a                                  rdi = 1;
0001e800                          }
0001e800                          
0001e80e                          rdx_1 -= r9;
0001e80e                          
0001e816                          if (rdx_1 == *(uint16_t*)minima)
0001e816                              break;
0001e7d2                      }
0001e7d2                      
0001e81b                      if ((uint8_t)rdi == 1)
0001e81b                      {
0001e821                          (uint16_t)rdi = minima[1];
0001e826                          int16_t i = r9 + i_2;
0001e82a                          *(uint16_t*)pPeakRet = i_2;
0001e82a                          
0001e832                          if (i != (uint16_t)rdi)
0001e832                          {
0001e837                              int16_t i_1 = i_2;
0001e837                              
0001e858                              do
0001e858                              {
0001e84c                                  if (pScope[(uint64_t)i] > pScope[(uint64_t)i_1])
0001e84c                                      i_1 = i;
0001e84c                                  
0001e851                                  i += r9;
0001e858                              } while (i != (uint16_t)rdi);
0001e858                              
0001e85a                              *(uint16_t*)pPeakRet = i_1;
0001e832                          }
0001e832                          
0001e85f                          uint64_t r8 = (uint64_t)*(uint16_t*)pPeakRet;
0001e867                          int16_t r9_1 = pScope[(uint64_t)i_2];
0001e867                          
0001e871                          if (r9_1 < pScope[r8])
0001e871                          {
0001e876                              int16_t rdx_2 = pScope[(uint64_t)(uint16_t)rdi];
0001e876                              
0001e880                              if (rdx_2 < pScope[r8])
0001e880                              {
0001e882                                  int16_t rcx_5 = pScope[r8];
0001e89b                                  int16_t temp0_1;
0001e89b                                  int16_t temp1_1;
0001e89b                                  temp0_1 = HIGHD((int64_t)((uint32_t)(rcx_5 - rdx_2)
0001e89b                                      - (uint32_t)(rcx_5 - r9_1)));
0001e89b                                  temp1_1 = LOWD((int64_t)((uint32_t)(rcx_5 - rdx_2)
0001e89b                                      - (uint32_t)(rcx_5 - r9_1)));
0001e89b                                  
0001e8a5                                  if ((temp1_1 ^ temp0_1) - temp0_1 < maxMinimaDiff)
0001e8a5                                  {
0001e8a7                                      uint32_t rdx_4 = (uint32_t)pScope[r8];
0001e8b2                                      uint32_t peakMinHeight_1 = (uint32_t)peakMinHeight;
0001e8b2                                      
0001e8bf                                      if (rdx_4 - (uint32_t)pScope[r8 - 2]
0001e8bf                                              > peakMinHeight_1)
0001e8c7                                          result = 1;
0001e8c7                                      
0001e8cf                                      if (rdx_4 - (uint32_t)pScope[r8 - 2]
0001e8cf                                              <= peakMinHeight_1
0001e8cf                                              || rdx_4 - (uint32_t)pScope[r8 + 2]
0001e8cf                                              <= peakMinHeight_1)
0001e8d1                                          return 2;
0001e8a5                                  }
0001e880                              }
0001e871                          }
0001e81b                      }
0001e7c9                  }
0001e7ad              }
0001e75e          }
0001e74d      }
0001e74d      
0001e8f4      return result;
0001e6e0  }

0001e8f5                                                                 cc cc cc cc cc cc cc                                   .......

0001e8fc    float EdgeInterpolate(float wav1, float wav2, float trg1, float trg2, float x1, float x2)

0001e8fc  {
0001e8fc      uint128_t zmm4 = 0xbf800000;
0001e908      int32_t r9 = (int32_t)wav2;
0001e910      int32_t rdx_1 = r9 - (int32_t)wav1;
0001e916      int32_t rcx = (int32_t)trg2;
0001e91d      int32_t r8_1 = rcx - (int32_t)trg1;
0001e91d      
0001e925      if (rdx_1 != r8_1)
0001e925      {
0001e942          (uint32_t)zmm4 =
0001e942              _mm_cvtepi32_ps((uint128_t)(rcx - r9 - r8_1 + rdx_1)) * (x2 - x1);
0001e94d          (uint32_t)zmm4 = (uint32_t)zmm4 / _mm_cvtepi32_ps((rdx_1 - r8_1));
0001e951          (uint32_t)zmm4 = (uint32_t)zmm4 + x1;
0001e925      }
0001e925      
0001e95a      return (uint32_t)zmm4;
0001e8fc  }

0001e95b                                                                                   cc cc cc cc cc                             .....
0001e960  cc cc cc cc                                                                                      ....

0001e964    enum edge_calc_res_t __convention("sysv") CalcEdgesInBetween(uint16_t* minima @ rcx, uint16_t peak @ rdx, struct edgeStruct_t* pEdges @ r8, uint16_t* pWaveform @ r9, uint16_t* pTrigger)

0001e964  {
0001e96f      uint64_t entry_pTrigger;
0001e96f      uint64_t entry_pTrigger_1 = entry_pTrigger;
0001e987      int32_t var_88 = 0;
0001e98c      int32_t var_84 = 0;
0001e991      uint16_t* pTrigger_1 = pTrigger;
0001e999      int128_t zmm6;
0001e999      int128_t var_38 = zmm6;
0001e99d      uint128_t zmm7;
0001e99d      uint128_t var_48 = zmm7;
0001e9a1      uint128_t zmm10;
0001e9a1      uint128_t var_58 = zmm10;
0001e9a6      int64_t r12 = 0;
0001e9a9      uint64_t peak_1 = (uint64_t)peak;
0001e9ad      float (* r15)[0x4] = &pEdges->Interpolated_Edges;
0001e9bb      int64_t i_1 = 2;
0001e9c3      uint16_t* minima_1 = minima;
0001e9c6      int32_t result = 1;
0001e9cb      int64_t i_2 = 2;
0001e9d5      uint128_t zmm11 = _mm_cvtepi32_ps((uint128_t)pWaveform[peak_1]);
0001ec20      int32_t var_78;
0001ec20      uint128_t zmm0;
0001ec20      uint128_t zmm1;
0001ec20      uint128_t zmm2;
0001ec20      int64_t i;
0001ec20      
0001ec20      do
0001ec20      {
0001e9d9          uint64_t rbx_1 = (uint64_t)*(uint16_t*)minima_1;
0001e9dd          (uint32_t)zmm6 = ADJ(r15)->Interpolated_Edges[0];
0001e9dd          *(uint32_t*)((char*)zmm6)[4] = ADJ(r15)->Interpolated_Edges[0];
0001e9dd          *(uint32_t*)((char*)zmm6)[8] = ADJ(r15)->Interpolated_Edges[0];
0001e9dd          *(uint32_t*)((char*)zmm6)[0xc] = ADJ(r15)->Interpolated_Edges[0];
0001e9e2          (uint32_t)zmm6 = (uint32_t)zmm6 + 512f;
0001e9ee          int16_t rdx = (uint16_t)rbx_1;
0001e9fb          entry_pTrigger =
0001e9fb              (uint64_t)((((uint32_t)entry_pTrigger - (uint32_t)entry_pTrigger) & 2) - 1);
0001e9fd          bool cond:1_1 = (uint16_t)rbx_1 == (uint16_t)peak_1;
0001ea01          (uint32_t)zmm6 = (uint32_t)zmm6 * 0.5f;
0001ea10          (uint32_t)zmm7 = _mm_cvtepi32_ps((uint128_t)pWaveform[rbx_1]) + (uint32_t)zmm11;
0001ea15          (uint32_t)zmm7 = (uint32_t)zmm7 * 0.5f;
0001ea15          
0001ea1d          for (; !cond:1_1; cond:1_1 = rdx == (uint16_t)peak_1)
0001ea1d          {
0001ea23              uint64_t rcx_1 = (uint64_t)rdx;
0001ea23              
0001ea35              if (!((uint32_t)zmm7 < _mm_cvtepi32_ps((uint128_t)pWaveform[rcx_1])) &&
0001ea35                  _mm_cvtepi32_ps((uint128_t)pWaveform[(int64_t)(uint32_t)entry_pTrigger
0001ea35                  + rcx_1]) >= (uint32_t)zmm7)
0001ea35              {
0001ea57                  uint32_t rcx_2 = (uint32_t)rdx;
0001ea5a                  uint64_t r10_1 = (uint64_t)rdx;
0001ea72                  uint128_t zmm5 = _mm_cvtepi32_ps((uint128_t)rcx_2);
0001ea7d                  zmm1 = (uint128_t)pWaveform[(int64_t)(uint16_t)entry_pTrigger + r10_1];
0001ea81                  uint32_t rax_10 = (uint32_t)pWaveform[r10_1];
0001ea8a                  float x2 = _mm_cvtepi32_ps((uint128_t)((int32_t)(uint16_t)entry_pTrigger
0001ea8a                      + rcx_2));
0001ea9d                  zmm1 = _mm_cvtepi32_ps(zmm1);
0001eaa3                  uint128_t zmm0_1 = EdgeInterpolate(_mm_cvtepi32_ps((uint128_t)rax_10), 
0001eaa3                      (uint32_t)zmm1, (uint32_t)zmm7, (uint32_t)zmm7, (uint32_t)zmm5, x2);
0001eaa8                  uint32_t rdx_1 = (uint32_t)pTrigger_1[r10_1];
0001eac4                  uint128_t zmm3;
0001eac4                  (uint32_t)zmm3 = (uint32_t)zmm0_1 - (uint32_t)zmm5;
0001eacf                  (uint32_t)zmm3 =
0001eacf                      (uint32_t)zmm3 * _mm_cvtepi32_ps((uint128_t)(uint32_t)entry_pTrigger);
0001eada                  uint128_t zmm1_1;
0001eada                  (uint32_t)zmm1_1 = _mm_cvtepi32_ps((uint128_t)(
0001eada                      (uint32_t)pTrigger_1[(int64_t)(uint32_t)entry_pTrigger + r10_1]
0001eada                      - rdx_1)) * (uint32_t)zmm3;
0001eae5                  (uint32_t)zmm1_1 = (uint32_t)zmm1_1 + _mm_cvtepi32_ps((uint128_t)rdx_1);
0001eaee                  int32_t r9 = 0;
0001eaf5                  int16_t j = (int16_t)(int64_t)(uint32_t)zmm6;
0001eafa                  zmm7 = _divide((uint32_t)zmm7, (uint32_t)zmm1_1);
0001eafd                  int32_t r8;
0001eafd                  
0001eafd                  if ((uint32_t)zmm0_1 <= (uint32_t)zmm6)
0001eafd                  {
0001eb05                      r8 = 1;
0001eb08                      j += 1;
0001eafd                  }
0001eafd                  else
0001eaff                      r8 = -1;
0001eaff                  
0001eb0e                  if ((uint16_t)rbx_1 != j)
0001eb0e                  {
0001eb14                      entry_pTrigger = pTrigger;
0001eb1c                      int64_t r10_2 = (int64_t)r8;
0001eb1c                      
0001eb54                      do
0001eb54                      {
0001eb22                          int64_t rcx_6 = (uint64_t)(uint16_t)rbx_1 + r10_2;
0001eb32                          zmm0 = (uint128_t)*(uint16_t*)(entry_pTrigger + (rcx_6 << 1));
0001eb36                          zmm1 = _mm_cvtepi32_ps((uint128_t)pWaveform[rcx_6]);
0001eb3c                          (uint32_t)zmm0 = _mm_cvtepi32_ps(zmm0) * (uint32_t)zmm7;
0001eb40                          (uint32_t)zmm1 = (uint32_t)zmm1 - (uint32_t)zmm0;
0001eb40                          
0001eb4b                          if ((uint32_t)zmm1 > 0f)
0001eb4b                          {
0001eb5b                              uint64_t rdx_2 = (uint64_t)(uint16_t)rbx_1;
0001eb5e                              (uint16_t)r8 += (uint16_t)rbx_1;
0001eb66                              int64_t rcx_7 = r10_2 + rdx_2;
0001eb75                              uint32_t rax_17 =
0001eb75                                  (uint32_t)*(uint16_t*)(entry_pTrigger + (rcx_7 << 1));
0001eb7c                              float x2_1 = _mm_cvtepi32_ps((uint128_t)(uint16_t)r8);
0001eb86                              uint32_t rax_18 =
0001eb86                                  (uint32_t)*(uint16_t*)(entry_pTrigger + (rdx_2 << 1));
0001eb8d                              float x1 = _mm_cvtepi32_ps((uint128_t)(uint16_t)rbx_1);
0001eb97                              uint32_t rax_19 = (uint32_t)pWaveform[rcx_7];
0001eba3                              (uint32_t)zmm3 =
0001eba3                                  _mm_cvtepi32_ps((uint128_t)rax_17) * (uint32_t)zmm7;
0001eba7                              uint32_t rax_20 = (uint32_t)pWaveform[rdx_2];
0001ebb3                              (uint32_t)zmm2 =
0001ebb3                                  _mm_cvtepi32_ps((uint128_t)rax_18) * (uint32_t)zmm7;
0001ebb7                              zmm1 = _mm_cvtepi32_ps((uint128_t)rax_19);
0001ebbd                              zmm0 = EdgeInterpolate(_mm_cvtepi32_ps((uint128_t)rax_20), 
0001ebbd                                  (uint32_t)zmm1, (uint32_t)zmm2, (uint32_t)zmm3, x1, x2_1);
0001ebc5                              (uint32_t)zmm5 = (uint32_t)zmm0 - (uint32_t)zmm6;
0001ebd7                              (uint32_t)zmm1 = (float)__andpd_xmmxuq_memxuq(
0001ebd7                                  _mm_cvtps_pd(_mm_unpacklo_ps(zmm5, (uint64_t)zmm5)), 
0001ebd7                                  __mask@@AbsDouble@);
0001ebd7                              
0001ebe2                              if ((uint32_t)zmm1 <= 10f)
0001ebe2                              {
0001ebec                                  (uint32_t)zmm0 = (uint32_t)zmm0 + (uint32_t)zmm0_1;
0001ebf1                                  r9 = 1;
0001ebf4                                  (uint32_t)zmm0 = (uint32_t)zmm0 - (uint32_t)zmm6;
0001ebf8                                  *(uint32_t*)(&var_78 + r12) = (uint32_t)zmm0;
0001ebe2                              }
0001ebe2                              else
0001ebe4                                  r9 = 2;
0001ebe4                              
0001ebe2                              break;
0001eb4b                          }
0001eb4b                          
0001eb4d                          (uint16_t)rbx_1 += (uint16_t)r8;
0001eb54                      } while ((uint16_t)rbx_1 != j);
0001eb54                      
0001ebff                      pTrigger_1 = entry_pTrigger;
0001eb0e                  }
0001eb0e                  
0001ec02                  i_1 = i_2;
0001ec07                  *(uint32_t*)(&var_88 + r12) = r9;
0001eb0e                  break;
0001ea35              }
0001ea35              
0001ea4e              rdx += (uint16_t)entry_pTrigger;
0001ea1d          }
0001ea1d          
0001ec0c          minima_1 = &minima_1[1];
0001ec10          r15 = &(*(uint128_t*)r15)[1];
0001ec14          r12 += 4;
0001ec18          i = i_1;
0001ec18          i_1 -= 1;
0001ec1b          i_2 = i_1;
0001ec20      } while (i != 1);
0001ec26      int32_t rax_21 = var_88;
0001ec26      
0001ec40      if (!rax_21 || !var_84)
0001ed1a          return 0;
0001ed1a      
0001ec52      if (rax_21 == 2 || var_84 == 2)
0001ec52      {
0001ecdd          result = 2;
0001ecea          pEdges->Interpolated_Edges[3] = pEdges->Interpolated_Edges[1];
0001ecee          zmm2 = _mm_cvtepi32_ps((uint128_t)(uint16_t)peak_1);
0001ecf1          zmm0 = zmm2;
0001ecf4          (uint32_t)zmm2 = (uint32_t)zmm2 * 2f;
0001ecf8          (uint32_t)zmm0 = (uint32_t)zmm0 * 2f;
0001ecfc          (uint32_t)zmm2 = (uint32_t)zmm2 - 512f;
0001ed04          (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
0001ed0c          pEdges->Interpolated_Edges[2] = (uint32_t)zmm2;
0001ed12          pEdges->Interpolated_Edges[1] = (uint32_t)zmm0;
0001ec52      }
0001ec52      else
0001ec52      {
0001ec58          zmm2 = var_78;
0001ec5e          int32_t var_74;
0001ec5e          zmm1 = var_74;
0001ec64          pEdges->Raw_Edges[3] = pEdges->Raw_Edges[1];
0001ec68          pEdges->Num_Edges = 4;
0001ec70          (uint32_t)zmm0 = (uint32_t)zmm2 + 0.5f;
0001ec78          int16_t rax_23 = (int16_t)(int64_t)(uint32_t)zmm0;
0001ec80          (uint32_t)zmm0 = (uint32_t)zmm1 + 0.5f;
0001ec8b          pEdges->Raw_Edges[1] = (uint32_t)rax_23;
0001ec9c          (uint32_t)zmm2 = (uint32_t)zmm2 * 2f;
0001eca0          (uint32_t)zmm1 = (uint32_t)zmm1 * 2f;
0001eca4          (uint32_t)zmm2 = (uint32_t)zmm2 - 512f;
0001ecac          (uint32_t)zmm1 = (uint32_t)zmm1 - 512f;
0001ecb7          float rax_25 = pEdges->Interpolated_Edges[1];
0001ecbb          pEdges->Raw_Edges[2] = (uint32_t)(uint16_t)(int64_t)(uint32_t)zmm0;
0001ecbf          pEdges->Interpolated_Edges[3] = rax_25;
0001ecc3          pEdges->Interpolated_Edges[1] = (uint32_t)zmm2;
0001ecc9          pEdges->Interpolated_Edges[2] = (uint32_t)zmm1;
0001ec52      }
0001ec52      
0001ed52      return result;
0001e964  }

0001ed53                                                           cc cc cc cc cc cc cc cc cc                                 .........

0001ed5c    uint8_t FindEdgesInbetween(struct _ctl_context_t* pContext, struct waveform_t* wf)

0001ed5c  {
0001ed7c      void var_f8;
0001ed7c      int64_t rax_1 = __security_cookie ^ &var_f8;
0001ed8b      uint16_t* pTrigger;
0001ed8b      (uint8_t)pTrigger = 0;
0001ed94      int64_t rax_3 = (uint64_t)wf->info.cam * 0x68;
0001ed94      
0001edad      if ((&pContext->edges[0].Num_Edges)[rax_3] == 2
0001edad          && !pContext->nearfieldData.nearfieldEdgesAltered)
0001edad      {
0001edba          uint16_t peakNoiseFloor;
0001edba          int64_t r12;
0001edba          uint16_t maxMinimaDiff;
0001edba          void* pEdges;
0001edba          
0001edba          if (pContext->settings.numSensors != 4)
0001edba          {
0001edd5              peakNoiseFloor = 0x14;
0001edeb              (uint16_t)r12 = 0x14;
0001edef              maxMinimaDiff = 0x50;
0001edf3              char var_a8[0x70];
0001edf3              memmove(&var_a8, &pContext->edges + rax_3, 0x68);
0001edf8              pEdges = &var_a8;
0001edba          }
0001edba          else
0001edba          {
0001edbc              peakNoiseFloor = 0x50;
0001edc1              maxMinimaDiff = 0x140;
0001edc7              pEdges = &pContext->edges + rax_3;
0001edcf              r12 = 0x20;
0001edba          }
0001edba          
0001edfd          uint64_t cam = (uint64_t)wf->info.cam;
0001ee43          uint16_t var_b8;
0001ee43          uint16_t minima;
0001ee43          
0001ee43          if (FindPeakInBetween(&pContext->waveforms[cam], 
0001ee43              &pContext->edges[cam].Interpolated_Edges, &minima, &var_b8, peakNoiseFloor, 
0001ee43              (uint16_t)r12, maxMinimaDiff) == 1)
0001ee43          {
0001ee45              wf->info
0001ee6a              uint16_t var_d8_1;
0001ee6a              var_d8_1 = &pContext->waveforms[(uint64_t)
0001ee6a                  *(uint8_t*)((char*)(*(int96_t*)((char*)wf + 0x10)))[3]].trigger;
0001ee6f              rax_3 = CalcEdgesInBetween(&minima, var_b8, pEdges, 
0001ee6f                  &pContext->waveforms[(uint64_t)
0001ee6f                      *(uint8_t*)((char*)(*(int96_t*)((char*)wf + 0x10)))[3]], 
0001ee6f                  pTrigger);
0001ee74              pTrigger = nullptr;
0001ee74              
0001ee7a              if ((uint32_t)rax_3 == 1)
0001ee7a                  pTrigger = 1;
0001ee43          }
0001edad      }
0001edad      
0001ee7d      int32_t rcx_6;
0001ee7d      (uint8_t)rcx_6 = pContext->hasEdgesBetween[1];
0001ee7d      *(uint8_t*)((char*)rcx_6)[1] = pContext->hasEdgesBetween[2];
0001ee7d      *(uint8_t*)((char*)rcx_6)[2] = pContext->hasEdgesBetween[3];
0001ee7d      *(uint8_t*)((char*)rcx_6)[3] = pContext->hasEdgesBetween[4];
0001ee83      (uint8_t)rax_3 = (uint8_t)pTrigger;
0001ee86      pContext->hasEdgesBetween[0] = (uint8_t)rcx_6;
0001ee86      pContext->hasEdgesBetween[1] = *(uint8_t*)((char*)rcx_6)[1];
0001ee86      pContext->hasEdgesBetween[2] = *(uint8_t*)((char*)rcx_6)[2];
0001ee86      pContext->hasEdgesBetween[3] = *(uint8_t*)((char*)rcx_6)[3];
0001ee93      pContext->hasEdgesBetween[(uint64_t)pContext->settings.numSensors] =
0001ee93          (uint8_t)pTrigger;
0001eea6      __security_check_cookie(rax_1 ^ &var_f8);
0001eec6      return (uint8_t)rax_3;
0001ed5c  }

0001eec7                       cc cc cc cc cc cc cc cc cc                                                         .........

0001eed0    void FindEdges(struct _ctl_context_t* pContext, uint8_t cam, uint16_t* pWav, uint16_t* pTrig, struct edgeStruct_t* pEdges, float trigPercentage, uint8_t processNearfield)

0001eed0  {
0001eefa      void var_318;
0001eefa      int64_t rax_1 = __security_cookie ^ &var_318;
0001ef05      struct edgeStruct_t* pEdges_1 = pEdges;
0001ef13      int16_t var_2b6 = 0xffff;
0001ef18      uint32_t cam_1 = (uint32_t)cam;
0001ef1e      int16_t rbx = 0;
0001ef30      int16_t startAperture = pContext->settings.sensor[(uint64_t)cam].startAperture;
0001ef38      int32_t r13 = 0x1ff;
0001ef46      int16_t stopAperture = pContext->settings.sensor[(uint64_t)cam].stopAperture;
0001ef54      uint32_t numSensors = (uint32_t)pContext->settings.numSensors;
0001ef60      uint16_t* pTrig_1 = pTrig;
0001ef68      (uint16_t)pTrig = pContext->settings.triggers.thresholdFloor;
0001ef71      struct edgeStruct_t* pEdges_2 = pEdges_1;
0001ef79      uint32_t numEdges = 0;
0001ef7b      int16_t var_2b0 = (uint16_t)pTrig;
0001ef80      int32_t var_2ac = 0x270f;
0001ef88      uint32_t var_2a0 = 0;
0001ef88      
0001ef9c      if (stopAperture < 0x1ff)
0001ef9c          (uint16_t)r13 = stopAperture;
0001ef9c      
0001efa1      int32_t var_2a4 = r13;
0001efa1      
0001efad      if ((uint16_t)pTrig == 0x14)
0001efaf          var_2b0 = 0xc;
0001efaf      
0001efc0      memset(pEdges_1, 0, 0x68);
0001efe1      memset(
0001efe1          (uint64_t)pContext->filterData.simTwoTouchFilter.currentDipIndex * 0x78 +
0001efe1              &pContext->filterData.simTwoTouchFilter, 
0001efe1          0, 0x78);
0001efe6      uint64_t startAperture_1 = (uint64_t)startAperture;
0001efec      uint16_t* pTrig_2 = pTrig_1;
0001eff4      void* r8 = &pTrig_2[startAperture_1];
0001eff8      int16_t var_2a8 = (uint16_t)startAperture_1;
0001effe      uint8_t r15 = 4;
0001f004      void* var_268 = r8;
0001f010      uint64_t var_230;
0001f010      int32_t rawEdges[0x1f];
0001f010      int32_t interpolatedEdges[0x20];
0001f010      float relSlopes_1[0x20];
0001f010      int16_t var_a8[0x10];
0001f010      uint64_t r12;
0001f010      
0001f010      if ((uint16_t)startAperture_1 <= (uint16_t)r13)
0001f010      {
0001f04b          r12 = (uint64_t)((int64_t)(cam_1 + numSensors - 1) % numSensors) * 0x68;
0001f04f          float (* var_298_1)[0x20] = &relSlopes_1;
0001f05d          int32_t (* rdx_2)[0x20] = &interpolatedEdges;
0001f065          int32_t (* r11_1)[0x1f] = &rawEdges;
0001f070          int16_t r9 = var_2b6;
0001f076          var_230 = r12;
0001f07e          void* r14_3 = (char*)pWav - pTrig_2 + r8;
0001f081          int64_t rax_7 = (char*)pTrig_2 - pWav;
0001f084          int32_t (* var_278_1)[0x20] = &interpolatedEdges;
0001f08c          int32_t (* var_288_1)[0x1f] = &rawEdges;
0001f094          uint16_t adcPix2 = (uint16_t)startAperture_1;
0001f094          
0001f426          do
0001f426          {
0001f0a0              int16_t rcx_11 = var_2b0;
0001f0c0              uint64_t zmm0[0x2];
0001f0c0              uint128_t zmm1;
0001f0c0              
0001f0c0              if (!(&pContext->edges[0].Num_Edges)[r12] && *(uint16_t*)r14_3 > 0
0001f0c0                  && *(uint16_t*)r8 > rcx_11)
0001f0c0              {
0001f0dc                  (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)r8)
0001f0dc                      / _mm_cvtepi32_ps((uint128_t)*(uint16_t*)r14_3)[0];
0001f0dc                  
0001f0e7                  if (!((uint32_t)zmm1 < 0.790000021f))
0001f0e7                  {
0001f0f4                      (uint8_t)r12 = 0;
0001f0fb                      void* r13_1 = &pContext->filterData.simTwoTouchFilter.minWaveformDip[(
0001f0fb                          uint64_t)pContext->filterData.simTwoTouchFilter.currentDipIndex];
0001f0fb                      
0001f11a                      do
0001f11a                      {
0001f111                          if ((uint32_t)zmm1 > *(uint32_t*)((char*)r13_1
0001f111                              + (uint64_t)(uint8_t)r12 * 0x14 + 0xc))
0001f111                          {
0001f121                              uint64_t rax_12;
0001f121                              (uint8_t)rax_12 = cam;
0001f125                              uint16_t trg2 = *(uint16_t*)r8;
0001f129                              uint16_t adc1 = *(uint16_t*)((char*)r14_3 - 2);
0001f12e                              int32_t var_23c_1 = (uint32_t)zmm1;
0001f137                              uint16_t adc2 = *(uint16_t*)r14_3;
0001f13b                              char var_238_1 = (uint8_t)rax_12;
0001f14a                              uint16_t trg1 = *(uint16_t*)(rax_7 + r14_3 - 2);
0001f150                              uint16_t adcPix2_1 = adcPix2;
0001f15d                              zmm0 = Edge_Interpolate(adc2, adc1, trg2, trg1, adcPix2);
0001f162                              zmm0[0] = zmm0[0] * 2f;
0001f166                              zmm0[0] = zmm0[0] - 512f;
0001f16a                              int32_t var_240_1 = zmm0[0];
0001f16a                              
0001f177                              if ((uint8_t)r12 < 5)
0001f177                              {
0001f179                                  uint32_t r9_1 = (uint32_t)(uint8_t)r12;
0001f1ac                                  memmove((char*)r13_1 + (int64_t)(r9_1 + 1) * 0x14, 
0001f1ac                                      (char*)r13_1 + (uint64_t)(uint8_t)r12 * 0x14, 
0001f1ac                                      (int64_t)(5 - r9_1) * 0x14);
0001f177                              }
0001f177                              
0001f1cc                              memmove((char*)r13_1 + (uint64_t)(uint8_t)r12 * 0x14, 
0001f1cc                                  &adcPix2_1, 0x14);
0001f1d1                              rdx_2 = var_278_1;
0001f1d9                              r8 = var_268;
0001f1e1                              r9 = var_2b6;
0001f1e7                              (uint16_t)startAperture_1 = startAperture;
0001f1ed                              r11_1 = var_288_1;
0001f1ed                              break;
0001f111                          }
0001f111                          
0001f113                          (uint8_t)r12 += 1;
0001f11a                      } while ((uint8_t)r12 < 6);
0001f11a                      
0001f1f5                      rcx_11 = var_2b0;
0001f1f9                      r13 = var_2a4;
0001f0e7                  }
0001f0c0              }
0001f0c0              
0001f218              if ((*(uint16_t*)r14_3 - *(uint16_t*)r8) * r9 > 0 && *(uint16_t*)r8 > rcx_11)
0001f218              {
0001f220                  uint32_t adcPix2_2 = (uint32_t)adcPix2;
0001f224                  uint32_t rcx_13 = numEdges >> 1;
0001f226                  *(uint32_t*)r11_1 = adcPix2_2;
0001f22c                  var_2a0 = rcx_13;
0001f22c                  
0001f232                  if (numEdges != rcx_13 * 2)
0001f241                      var_a8[(uint64_t)rcx_13] = (uint16_t)var_2ac;
0001f232                  else
0001f234                      (uint16_t)var_2ac = adcPix2;
0001f234                  
0001f24d                  uint32_t rcx_15;
0001f24d                  uint128_t zmm2;
0001f24d                  
0001f24d                  if (adcPix2 != (uint16_t)startAperture_1)
0001f24d                  {
0001f28a                      zmm0 = Edge_Interpolate(*(uint16_t*)r14_3, 
0001f28a                          *(uint16_t*)((char*)r14_3 - 2), *(uint16_t*)r8, 
0001f28a                          *(uint16_t*)(rax_7 + r14_3 - 2), adcPix2);
0001f28f                      startAperture_1 = (uint64_t)startAperture;
0001f295                      rdx_2 = var_278_1;
0001f29d                      rcx_15 = (uint32_t)startAperture_1;
0001f2a0                      *(uint32_t*)rdx_2 = zmm0[0];
0001f2a8                      zmm1 = _mm_cvtepi32_ps((uint128_t)rcx_15);
0001f2a8                      
0001f2ae                      if ((uint32_t)zmm1 <= zmm0[0])
0001f2b5                          zmm2 = zmm0;
0001f2ae                      else
0001f2b0                          zmm2 = zmm1;
0001f2b0                      
0001f2c0                      uint128_t zmm3 = _mm_cvtepi32_ps((uint128_t)(uint16_t)r13);
0001f2c0                      
0001f2c6                      if ((uint32_t)zmm3 <= (uint32_t)zmm2)
0001f2d2                          zmm1 = zmm3;
0001f2c6                      else if (!((uint32_t)zmm1 > zmm0[0]))
0001f2cd                          zmm1 = zmm0;
0001f2cd                      
0001f2d5                      r8 = var_268;
0001f2dd                      r9 = var_2b6;
0001f2e3                      r11_1 = var_288_1;
0001f2eb                      (uint32_t)zmm1 = (uint32_t)zmm1 * 2f;
0001f2ef                      (uint32_t)zmm1 = (uint32_t)zmm1 - 512f;
0001f2f3                      *(uint32_t*)rdx_2 = (uint32_t)zmm1;
0001f24d                  }
0001f24d                  else
0001f24d                  {
0001f24f                      rcx_15 = (uint32_t)(uint16_t)startAperture_1;
0001f261                      *(uint32_t*)rdx_2 =
0001f261                          _mm_cvtepi32_ps((uint128_t)(rcx_15 * 2 - 0x200))[0];
0001f24d                  }
0001f24d                  
0001f2fb                  float (* rcx_17)[0x20];
0001f2fb                  
0001f2fb                  if (0 != *(uint16_t*)r8)
0001f2fb                  {
0001f31a                      zmm1 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)r8);
0001f31d                      uint32_t rax_29;
0001f31d                      
0001f31d                      if (adcPix2_2 >= rcx_15 + 3)
0001f330                          rax_29 = (uint32_t)*(uint16_t*)((char*)r14_3 - 6);
0001f31d                      else
0001f329                          rax_29 = (uint32_t)*(uint16_t*)((char*)r14_3 + ((
0001f329                              (uint64_t)(uint16_t)startAperture_1 - (uint64_t)adcPix2) << 1));
0001f329                      
0001f346                      (uint32_t)zmm2 = _mm_cvtepi32_ps((uint128_t)rax_29) / (uint32_t)zmm1;
0001f34a                      uint32_t rax_33;
0001f34a                      
0001f34a                      if (adcPix2_2 <= (uint32_t)(uint16_t)r13 - 3)
0001f35d                          rax_33 = (uint32_t)*(uint16_t*)((char*)r14_3 + 6);
0001f34a                      else
0001f356                          rax_33 = (uint32_t)*(uint16_t*)((char*)r14_3
0001f356                              + (((uint64_t)(uint16_t)r13 - (uint64_t)adcPix2) << 1));
0001f356                      
0001f362                      rcx_17 = var_298_1;
0001f36e                      zmm0 = _mm_cvtepi32_ps((uint128_t)rax_33);
0001f371                      zmm0[0] = zmm0[0] / (uint32_t)zmm1;
0001f375                      zmm0[0] = zmm0[0] - (uint32_t)zmm2;
0001f37f                      zmm0 = _mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0]), 
0001f37f                          0x7fffffffffffffff);
0001f384                      zmm0[0] = (float)zmm0[0];
0001f388                      *(uint8_t*)rcx_17 = zmm0[0];
0001f388                      *(uint16_t*)((char*)rcx_17 + 2) = *(uint16_t*)((char*)zmm0[0])[2];
0001f2fb                  }
0001f2fb                  else
0001f2fb                  {
0001f2fd                      rcx_17 = var_298_1;
0001f305                      *(uint32_t*)rcx_17 = 0;
0001f2fb                  }
0001f2fb                  
0001f38c                  r11_1 = &(*(uint992_t*)r11_1)[1];
0001f38f                  rdx_2 = &(*(uint1024_t*)rdx_2)[1];
0001f395                  numEdges += 1;
0001f397                  var_288_1 = r11_1;
0001f39f                  var_278_1 = rdx_2;
0001f3a7                  var_298_1 = &(*(uint1024_t*)rcx_17)[1];
0001f3a7                  
0001f3b2                  if (numEdges == 0x1e)
0001f3b2                  {
0001f3b4                      r11_1 -= 8;
0001f3b8                      rdx_2 -= 8;
0001f3c0                      var_298_1 = (char*)rcx_17 - 4;
0001f3c8                      numEdges = 0x1c;
0001f3cd                      var_288_1 = r11_1;
0001f3d5                      var_278_1 = rdx_2;
0001f3b2                  }
0001f3b2                  
0001f3dd                  r9 = -(r9);
0001f3e1                  var_2b6 = r9;
0001f218              }
0001f218              
0001f3e7              int32_t rcx_24 = var_2ac;
0001f3fb              r12 = var_230;
0001f3fb              
0001f407              if (*(uint16_t*)r14_3 < pWav[(uint64_t)(uint16_t)rcx_24])
0001f407                  (uint16_t)rcx_24 = adcPix2;
0001f407              
0001f40b              r8 += 2;
0001f40f              adcPix2 += 1;
0001f412              r14_3 += 2;
0001f416              var_2ac = rcx_24;
0001f41a              var_268 = r8;
0001f426          } while (adcPix2 <= (uint16_t)r13);
0001f426          
0001f42c          pEdges_1 = pEdges_2;
0001f442          pTrig_2 = pTrig_1;
0001f442          
0001f44a          if (r9 != 0xffff)
0001f44a          {
0001f44c              uint64_t numEdges_1 = (uint64_t)numEdges;
0001f44e              uint32_t rax_36 = (uint32_t)(uint16_t)r13;
0001f452              numEdges += 1;
0001f454              rawEdges[numEdges_1] = rax_36;
0001f462              relSlopes_1[numEdges_1] = 0;
0001f470              interpolatedEdges[numEdges_1] =
0001f470                  _mm_cvtepi32_ps((uint128_t)(rax_36 * 2 - 0x200))[0];
0001f44a          }
0001f010      }
0001f010      
0001f488      if (cam_1 == 1 || cam_1 == 3)
0001f488      {
0001f48a          int16_t rcx_28 = 0;
0001f48a          
0001f48f          if (numEdges > 0)
0001f48f          {
0001f4a8              do
0001f4a8              {
0001f496                  uint64_t rax_38 = (uint64_t)rcx_28;
0001f499                  rcx_28 += 1;
0001f49c                  rawEdges[rax_38] -= 1;
0001f4a8              } while ((uint32_t)rcx_28 < numEdges);
0001f4a8              
0001f4aa              pEdges_1 = pEdges_2;
0001f48f          }
0001f488      }
0001f488      
0001f4c3      float TriggerLevel = _divide(trigPercentage[0], 0x42c80000);
0001f4c8      (uint8_t)r12 = 0;
0001f4cb      int32_t r13_2 = 0;
0001f4ce      int32_t r14_4 = 0;
0001f4ce      
0001f4d3      if (numEdges > 0)
0001f4d3      {
0001f4d5          r13_2 = rawEdges[0];
0001f4e0          r14_4 = rawEdges[(uint64_t)(numEdges - 1)];
0001f4d3      }
0001f4d3      
0001f53c      uint32_t rax_42 = HandleNearfield(pContext, cam, pWav, pTrig_2, TriggerLevel, 
0001f53c          (uint16_t)startAperture_1, (uint16_t)var_2a4, &rawEdges, &interpolatedEdges, 
0001f53c          &relSlopes_1, numEdges);
0001f541      uint32_t r11_2 = rax_42;
0001f541      
0001f546      if (numEdges != rax_42)
0001f54d          (uint8_t)r12 = 1;
0001f546      else if (rax_42 > 0
0001f546              && (rawEdges[0] != r13_2 || rawEdges[(uint64_t)(rax_42 - 1)] != r14_4))
0001f54d          (uint8_t)r12 = 1;
0001f54d      
0001f57b      pContext->nearfieldData.nearfieldEdgesAltered = (uint8_t)r12;
0001f57b      
0001f585      if (r11_2 == 4)
0001f585      {
0001f5af          float relSlopes;
0001f5af          relSlopes = &relSlopes_1;
0001f5b9          r11_2 = RemoveDoubleImagingEdges((uint32_t)pWav, pTrig_1, &rawEdges, 
0001f5b9              &interpolatedEdges, relSlopes);
0001f585      }
0001f585      
0001f5bf      if (r11_2 > 0)
0001f5bf      {
0001f5cc          if (r11_2 < 4)
0001f5cc              r15 = (uint8_t)r11_2;
0001f5cc          
0001f5d0          pEdges_1->Num_Edges = r15;
0001f5d0          
0001f5d6          if (!cam_1)
0001f5d6          {
0001f677          label_1f677:
0001f677              int16_t rdx_9 = 0;
0001f67a              int16_t i = 0;
0001f67a              
0001f681              if (r15 > 0)
0001f681              {
0001f6a8                  do
0001f6a8                  {
0001f683                      uint64_t i_3 = (uint64_t)i;
0001f687                      i += 1;
0001f692                      pEdges_1->Raw_Edges[i_3] = rawEdges[i_3];
0001f69c                      pEdges_1->Interpolated_Edges[i_3] = interpolatedEdges[i_3];
0001f6a8                  } while (i < (uint16_t)pEdges_1->Num_Edges);
0001f681              }
0001f681              
0001f6af              int16_t rcx_33 = 0;
0001f6af              
0001f6b8              if (var_2a0 + 1 > 0)
0001f6b8              {
0001f6e8                  do
0001f6e8                  {
0001f6bd                      uint32_t r8_7 = (uint32_t)var_a8[(uint64_t)rcx_33];
0001f6c6                      uint64_t rax_61 = (uint64_t)rdx_9;
0001f6c6                      
0001f6d4                      if (r8_7 >= pEdges_1->Raw_Edges[rax_61]
0001f6d4                          && r8_7 <= pEdges_1->Raw_Edges[1 + rax_61])
0001f6d4                      {
0001f6d6                          rbx += 1;
0001f6dc                          rdx_9 = rbx * 2;
0001f6d4                      }
0001f6d4                      
0001f6df                      rcx_33 += 1;
0001f6e8                  } while ((uint32_t)rcx_33 < var_2a0 + 1);
0001f6b8              }
0001f5d6          }
0001f5d6          else if (cam_1 == 1)
0001f5de          {
0001f5f0          label_1f5f0:
0001f5f0              int16_t rdx_8 = 0;
0001f5f3              int16_t i_1 = 0;
0001f5f3              
0001f5fa              if (r15 > 0)
0001f5fa              {
0001f62f                  do
0001f62f                  {
0001f600                      uint64_t i_2 = (uint64_t)i_1;
0001f604                      i_1 += 1;
0001f612                      pEdges_1->Raw_Edges[i_2] = *(uint32_t*)(
0001f612                          &*(uint64_t*)((char*)var_230)[4]
0001f612                          + (((uint64_t)pEdges_1->Num_Edges - i_2) << 2));
0001f623                      void var_1ac;
0001f623                      pEdges_1->Interpolated_Edges[i_2] = *(uint32_t*)(
0001f623                          &var_1ac + (((uint64_t)pEdges_1->Num_Edges - i_2) << 2));
0001f62f                  } while (i_1 < (uint16_t)pEdges_1->Num_Edges);
0001f5fa              }
0001f5fa              
0001f636              int16_t rcx_32 = 0;
0001f636              
0001f63f              if (var_2a0 + 1 > 0)
0001f63f              {
0001f673                  do
0001f673                  {
0001f648                      uint32_t r8_6 = (uint32_t)var_a8[(uint64_t)rcx_32];
0001f651                      uint64_t rax_55 = (uint64_t)rdx_8;
0001f651                      
0001f65f                      if (r8_6 >= pEdges_1->Raw_Edges[1 + rax_55]
0001f65f                          && r8_6 <= pEdges_1->Raw_Edges[rax_55])
0001f65f                      {
0001f661                          rbx += 1;
0001f667                          rdx_8 = rbx * 2;
0001f65f                      }
0001f65f                      
0001f66a                      rcx_32 += 1;
0001f673                  } while ((uint32_t)rcx_32 < var_2a0 + 1);
0001f63f              }
0001f5de          }
0001f5de          else
0001f5de          {
0001f5e2              if (cam_1 == 2)
0001f5e2                  goto label_1f677;
0001f5e2              
0001f5ea              if (cam_1 == 3)
0001f5ea                  goto label_1f5f0;
0001f5de          }
0001f5bf      }
0001f5bf      
0001f6f5      __security_check_cookie(rax_1 ^ &var_318);
0001eed0  }

0001f721     cc cc cc cc cc cc cc                                                                           .......

0001f728    uint32_t RemoveDoubleImagingEdges(uint32_t pCam, uint16_t* pTrig, uint16_t* rawEdges, int32_t* interpolatedEdges, float* relSlopes, float* lowestPixels)

0001f728  {
0001f732      int64_t pCam_1 = pCam;
0001f746      int64_t rbx = 0;
0001f74d      uint16_t* rawEdges_1 = rawEdges;
0001f753      int32_t rbp = 0x3e7;
0001f758      int64_t rdi;
0001f758      (uint8_t)rdi = 1;
0001f75f      uint8_t r10 = 0;
0001f762      (uint8_t)pCam = 0;
0001f762      
0001f795      for (uint8_t i = 0; i < 4; )
0001f795      {
0001f76e          int32_t temp0_1;
0001f76e          int32_t temp1_1;
0001f76e          temp0_1 =
0001f76e              HIGHD((int64_t)(*(uint32_t*)((char*)rawEdges + 4) - *(uint32_t*)rawEdges));
0001f76e          temp1_1 =
0001f76e              LOWD((int64_t)(*(uint32_t*)((char*)rawEdges + 4) - *(uint32_t*)rawEdges));
0001f771          int32_t rax_5 = (temp1_1 ^ temp0_1) - temp0_1;
0001f771          
0001f775          if (rax_5 <= 4)
0001f775          {
0001f779              (uint8_t)pCam = 1;
0001f779              
0001f77b              if (rbp > rax_5)
0001f77b              {
0001f780                  rbp = rax_5;
0001f782                  r10 = i >> 1;
0001f785                  (uint8_t)rdi = r10;
0001f788                  (uint8_t)rdi ^= 1;
0001f77b              }
0001f775          }
0001f775          
0001f78b          i += 2;
0001f78f          rawEdges = &rawEdges[4];
0001f795      }
0001f795      
0001f79a      if ((uint8_t)pCam == 1)
0001f79a      {
0001f7a8          int32_t temp2_1;
0001f7a8          int32_t temp3_1;
0001f7a8          temp2_1 = HIGHD((int64_t)(*(uint32_t*)((char*)rawEdges_1 + 8)
0001f7a8              - *(uint32_t*)((char*)rawEdges_1 + 4)));
0001f7a8          temp3_1 = LOWD((int64_t)(*(uint32_t*)((char*)rawEdges_1 + 8)
0001f7a8              - *(uint32_t*)((char*)rawEdges_1 + 4)));
0001f7a8          
0001f7b0          if ((temp3_1 ^ temp2_1) - temp2_1 <= 0x14)
0001f7b0          {
0001f7bd              uint16_t* rawEdges_2 = rawEdges_1;
0001f7c0              int64_t i_2 = 2;
0001f7c4              int64_t var_48 = 0;
0001f834              uint128_t zmm1;
0001f834              int64_t i_1;
0001f834              
0001f834              do
0001f834              {
0001f7c9                  int64_t rdx_2 = (int64_t)*(uint32_t*)rawEdges_2;
0001f7c9                  
0001f7d0                  if ((uint32_t)rdx_2 <= *(uint32_t*)((char*)rawEdges_2 + 4))
0001f7d0                  {
0001f7d8                      void* rbp_1 = &pTrig[rdx_2];
0001f7dc                      uint64_t r11_1 = rbx >> 1;
0001f7e2                      int32_t zmm4 = *(uint32_t*)(&var_48 + (r11_1 << 2));
0001f7e2                      
0001f81a                      do
0001f81a                      {
0001f7e9                          uint32_t rcx = (uint32_t)*(uint16_t*)rbp_1;
0001f7f9                          uint128_t zmm0 = (uint128_t)(rcx
0001f7f9                              - (uint32_t)*(uint16_t*)(pCam_1 - pTrig + rbp_1));
0001f7fd                          zmm1 = _mm_cvtepi32_ps((uint128_t)rcx);
0001f803                          zmm0 = _divide(_mm_cvtepi32_ps(zmm0), (uint32_t)zmm1);
0001f803                          
0001f80b                          if (!((uint32_t)zmm0 <= zmm4))
0001f80d                              zmm4 = (uint32_t)zmm0;
0001f80d                          
0001f810                          rdx_2 = (uint64_t)((uint32_t)rdx_2 + 1);
0001f812                          rbp_1 += 2;
0001f81a                      } while ((uint32_t)rdx_2 <= *(uint32_t*)((char*)rawEdges_2 + 4));
0001f81a                      
0001f81c                      *(uint32_t*)(&var_48 + (r11_1 << 2)) = zmm4;
0001f7d0                  }
0001f7d0                  
0001f829                  rbx += 2;
0001f82d                  rawEdges_2 = &rawEdges_2[4];
0001f830                  i_1 = i_2;
0001f830                  i_2 -= 1;
0001f834              } while (i_1 != 1);
0001f84a              zmm1 = *(uint32_t*)(&var_48 + ((uint64_t)r10 << 2));
0001f84a              
0001f853              if (!(0.119999997f <= (uint32_t)zmm1))
0001f853              {
0001f859                  (uint32_t)zmm1 = (uint32_t)zmm1 * 4f;
0001f859                  
0001f86e                  if (!((*(uint32_t*)(&var_48 + ((uint64_t)(uint8_t)rdi << 2)))
0001f86e                      <= (uint32_t)zmm1))
0001f86e                  {
0001f877                      if ((uint8_t)rdi <= r10)
0001f877                      {
0001f8eb                          int64_t rcx_5 = (int64_t)((uint32_t)r10 * 2);
0001f8f2                          *(uint32_t*)((char*)rawEdges_1 + (rcx_5 << 2)) = 0;
0001f8f6                          *(uint32_t*)((char*)rawEdges_1 + (rcx_5 << 2) + 4) = 0;
0001f8fb                          interpolatedEdges[rcx_5] = 0;
0001f8ff                          interpolatedEdges[rcx_5 + 1] = 0;
0001f90c                          relSlopes[rcx_5] = 0;
0001f90f                          relSlopes[rcx_5 + 1] = 0;
0001f877                      }
0001f877                      else
0001f877                      {
0001f882                          int64_t rdi_1 = (int64_t)((uint32_t)(uint8_t)rdi * 2);
0001f88b                          void* rbp_2 = &rawEdges_1[rdi_1 * 2];
0001f88f                          int64_t rbx_1 = (int64_t)((uint32_t)r10 * 2);
0001f899                          memmove(&rawEdges_1[rbx_1 * 2], rbp_2, 8);
0001f89e                          void* rsi_1 = &interpolatedEdges[rdi_1];
0001f8ac                          memmove(&interpolatedEdges[rbx_1], rsi_1, 8);
0001f8bc                          void* rdi_2 = &relSlopes[rdi_1];
0001f8c7                          memmove(&relSlopes[rbx_1], rdi_2, 8);
0001f8d1                          *(uint32_t*)rbp_2 = 0;
0001f8d5                          *(uint32_t*)((char*)rbp_2 + 4) = 0;
0001f8d9                          *(uint32_t*)rsi_1 = 0;
0001f8db                          *(uint32_t*)((char*)rsi_1 + 4) = 0;
0001f8de                          *(uint32_t*)rdi_2 = 0;
0001f8e0                          *(uint32_t*)((char*)rdi_2 + 4) = 0;
0001f877                      }
0001f877                      
0001f913                      return 2;
0001f86e                  }
0001f853              }
0001f7b0          }
0001f79a      }
0001f79a      
0001f92e      return 4;
0001f728  }

0001f92f                                               cc cc cc cc cc cc cc cc cc                                         .........

0001f938    uint32_t RemoveFakeSpikeTouch(uint32_t numEdges, uint32_t fakeTouchIndex, float* interpolatedEdges, int32_t* rawEdges, float* relSlopes)

0001f938  {
0001f95a      if (numEdges != 4)
0001f95a      {
0001f9eb          uint32_t rdx = fakeTouchIndex * 2;
0001f9eb          
0001f9f0          if (rdx < 0x1e)
0001f9f0          {
0001f9f2              uint64_t rcx_1 = (uint64_t)(rdx + 2);
0001f9f5              uint64_t rbx_1 = (uint64_t)rdx;
0001f9fc              uint64_t rdi_1 = (uint64_t)(uint32_t)rcx_1;
0001fa08              uint64_t rsi_4 = (uint64_t)(numEdges - rdx - 1) << 2;
0001fa0f              memmove(&rawEdges[rbx_1], &rawEdges[rcx_1], rsi_4);
0001fa21              memmove(&interpolatedEdges[rbx_1], &interpolatedEdges[rdi_1], rsi_4);
0001fa36              memmove(&relSlopes[rbx_1], &relSlopes[rdi_1], rsi_4);
0001f9f0          }
0001f9f0          
0001fa3b          return numEdges - 2;
0001f95a      }
0001f95a      
0001f960      uint128_t zmm2 = 0x7fffffffffffffff;
0001f968      float zmm0[0x4] = interpolatedEdges[3];
0001f973      zmm0[0] = zmm0[0] - interpolatedEdges[2];
0001f97c      uint64_t zmm1[0x2] = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]);
0001f97f      zmm0 = interpolatedEdges[1];
0001f985      zmm0[0] = zmm0[0] - *(uint32_t*)interpolatedEdges;
0001f98e      float zmm3 = (float)_mm_and_pd(zmm1, zmm2)[0];
0001f992      float temp0_4[0x4] = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
0001f99c      temp0_4[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_4[0]), zmm2)[0];
0001f9a3      int32_t rax_3;
0001f9a3      
0001f9a3      if (temp0_4[0] <= zmm3)
0001f9a3      {
0001f9be          *(uint32_t*)rawEdges = rawEdges[1];
0001f9c5          rawEdges[1] = rawEdges[3];
0001f9cd          *(uint32_t*)interpolatedEdges = interpolatedEdges[1];
0001f9d4          interpolatedEdges[1] = interpolatedEdges[3];
0001f9db          *(uint32_t*)relSlopes = relSlopes[1];
0001f9dd          rax_3 = relSlopes[3];
0001f9a3      }
0001f9a3      else
0001f9a3      {
0001f9a9          rawEdges[1] = rawEdges[2];
0001f9b1          interpolatedEdges[1] = interpolatedEdges[2];
0001f9b5          rax_3 = relSlopes[2];
0001f9a3      }
0001f9a3      
0001f9e0      relSlopes[1] = rax_3;
0001f9e3      return 2;
0001f938  }

0001fa5d                                                                                         cc cc cc                               ...
0001fa60  cc cc cc cc                                                                                      ....

0001fa64    void SeachForInnerNearfieldExtraOutsideEdges(uint16_t* pCam, uint16_t* pTrig, uint32_t Start, uint32_t End, uint32_t numEdges, float TriggerLevel, int32_t* rawEdges, float* interpolatedEdges)

0001fa64  {
0001fa89      uint64_t r8 = (uint64_t)(Start + 0x14);
0001fa8d      char r10 = 0;
0001fa99      void* rcx = &pCam[r8];
0001fa9d      uint128_t zmm0;
0001fa9d      uint128_t zmm1;
0001fa9d      
0001fa9d      while ((uint32_t)r8 < *(uint32_t*)rawEdges)
0001fa9d      {
0001faad          zmm0 = (uint128_t)*(uint16_t*)((char*)pTrig - pCam + rcx);
0001fab4          (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)rcx) * TriggerLevel;
0001fabd          (uint32_t)zmm0 = _mm_cvtepi32_ps(zmm0) * 0.75f;
0001fabd          
0001fac4          if ((uint32_t)zmm0 <= (uint32_t)zmm1)
0001fb72              r10 = 0;
0001fac4          else
0001fac4          {
0001faca              r10 += 1;
0001faca              
0001fad1              if (r10 == 3)
0001fad1              {
0001fad7                  int32_t rax_3 = (int32_t)(r8 - 1);
0001fadb                  *(uint32_t*)rawEdges = rax_3;
0001faec                  *(uint32_t*)interpolatedEdges =
0001faec                      _mm_cvtepi32_ps((uint128_t)(rax_3 * 2 - 0x200));
0001faec                  break;
0001fad1              }
0001fac4          }
0001fac4          
0001fb75          r8 = (uint64_t)((uint32_t)r8 + 1);
0001fb78          rcx += 2;
0001fa9d      }
0001fa9d      
0001faf0      int64_t numEdges_1 = (int64_t)numEdges;
0001faf9      int32_t i = End - 0xa;
0001fafd      void* r10_1 = &pCam[(uint64_t)(End - 0xa)];
0001fb01      uint64_t rax_6 = (uint64_t)(uint32_t)(numEdges_1 - 1);
0001fb04      (uint8_t)r8 = 0;
0001fb0b      uint64_t r9 = (uint64_t)(uint32_t)rax_6;
0001fb0b      
0001fb0e      if (i <= rawEdges[rax_6])
0001fb0e          return;
0001fb0e      
0001fb98      do
0001fb98      {
0001fb20          zmm0 = (uint128_t)*(uint16_t*)((char*)r10_1 + (char*)pTrig - pCam);
0001fb27          (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)r10_1) * TriggerLevel;
0001fb30          (uint32_t)zmm0 = _mm_cvtepi32_ps(zmm0) * 0.75f;
0001fb30          
0001fb37          if ((uint32_t)zmm0 <= (uint32_t)zmm1)
0001fb8a              (uint8_t)r8 = 0;
0001fb37          else
0001fb37          {
0001fb39              (uint8_t)r8 += 1;
0001fb39              
0001fb40              if ((uint8_t)r8 == 3)
0001fb40              {
0001fb45                  rawEdges[r9] = i - 1;
0001fb57                  interpolatedEdges[r9] = _mm_cvtepi32_ps((uint128_t)((i - 1) * 2 - 0x200));
0001fb57                  break;
0001fb40              }
0001fb37          }
0001fb37          
0001fb8d          i -= 1;
0001fb8f          r10_1 -= 2;
0001fb98      } while (i > rawEdges[numEdges_1 - 1]);
0001fa64  }

0001fb9f                                                                                               cc                                 .
0001fba0  cc cc cc cc cc cc cc cc                                                                          ........

0001fba8    uint32_t ExtendInnerNearfieldEdges(struct _ctl_context_t* pContext, uint32_t numEdges, uint8_t Cam, uint8_t prevCam, int32_t* rawEdges, float* interpolatedEdges, uint16_t* pCam, uint32_t Start, uint32_t End, struct fpoint_t camPos1, struct fpoint_t camPos2)

0001fba8  {
0001fbc4      int32_t* rawEdges_1 = rawEdges;
0001fbcc      float zmm6[0x4];
0001fbcc      float var_38[0x4] = zmm6;
0001fbd0      double zmm7[0x2];
0001fbd0      double var_48[0x2] = zmm7;
0001fbd4      uint32_t result = numEdges;
0001fbda      uint128_t zmm8;
0001fbda      uint128_t var_58 = zmm8;
0001fbdf      uint64_t rax = (uint64_t)(numEdges - 1);
0001fbe5      int32_t rdi = rawEdges_1[rax];
0001fbeb      int32_t r14_1 = rdi - *(uint32_t*)rawEdges_1;
0001fbeb      
0001fbf5      if (r14_1 < 0x96)
0001fbf5      {
0001fbfb          uint64_t prevCam_1 = (uint64_t)prevCam;
0001fbfb          
0001fc0f          if (pContext->edges[prevCam_1].Num_Edges == 2)
0001fc0f          {
0001fc25              (uint8_t)numEdges = Cam;
0001fc37              int128_t zmm0_1 = FE_Linearize(pContext, (uint8_t)numEdges, 
0001fc37                  (interpolatedEdges[rax] + *(uint32_t*)interpolatedEdges) * 0.5f);
0001fc3c              zmm7 = pContext->edges[prevCam_1].Lin_Edges[1];
0001fc46              zmm7[0] = zmm7[0] + pContext->edges[prevCam_1].Lin_Edges[0];
0001fc50              zmm7[0] = zmm7[0] * 0.5f;
0001fc5d              double zmm0_2[0x2];
0001fc5d              uint128_t zmm5_1;
0001fc5d              
0001fc5d              if (!Cam || Cam == 2)
0001fc5d              {
0001fc89                  zmm5_1 = _mm_cvtepi32_ps((uint128_t)pContext->settings.focalLength);
0001fc8f                  zmm0_2 = _divide((uint32_t)zmm0_1, (uint32_t)zmm5_1);
0001fc94                  zmm7 ^= __mask@@NegFloat@;
0001fc5d              }
0001fc5d              else
0001fc5d              {
0001fc66                  zmm0_1 ^= __mask@@NegFloat@;
0001fc71                  zmm5_1 = _mm_cvtepi32_ps((uint128_t)pContext->settings.focalLength);
0001fc77                  zmm0_2 = _divide((uint32_t)zmm0_1, (uint32_t)zmm5_1);
0001fc5d              }
0001fc5d              
0001fcab              (uint32_t)zmm8 = (uint32_t)zmm0_2 + 0.785398185f;
0001fcba              (uint32_t)zmm8 = (uint32_t)zmm8
0001fcba                  + pContext->settings.sensorInfo[(uint64_t)Cam].rotation_offset;
0001fcda              uint128_t zmm0_4;
0001fcda              int512_t zmm6_1;
0001fcda              zmm0_4 = _safeTan(_divide(zmm7[0], (uint32_t)zmm5_1) + 0.785398185f
0001fcda                  + pContext->settings.sensorInfo[prevCam_1].rotation_offset);
0001fcdf              (uint128_t)zmm6_1 = zmm0_4;
0001fce6              float slope0;
0001fce6              float zmm5_2[0x4];
0001fce6              uint128_t zmm6_2;
0001fce6              slope0 = _safeTan((uint32_t)zmm8);
0001fceb              struct fpoint_t p1;
0001fceb              p1.x = camPos2.x;
0001fceb              p1.y = camPos2.y;
0001fcf3              struct fpoint_t p0;
0001fcf3              p0.x = camPos1.x;
0001fcf3              p0.y = camPos1.y;
0001fd01              struct fpoint_t rax_5;
0001fd01              float zmm2_1[0x4];
0001fd01              rax_5 = PointSlopeTriangulate(p0, slope0, p1, (uint32_t)zmm6_2);
0001fd06              (uint32_t)rawEdges = rax_5.x;
0001fd06              *(uint32_t*)((char*)rawEdges)[4] = rax_5.y;
0001fd0e              zmm5_2[0] = camPos1.x;
0001fd0e              zmm5_2[1] = camPos1.x;
0001fd17              float zmm1_4[0x4];
0001fd17              zmm1_4[0] = camPos1.y;
0001fd17              zmm1_4[1] = camPos1.y;
0001fd17              zmm1_4[2] = camPos1.y;
0001fd17              zmm1_4[3] = camPos1.y;
0001fd20              zmm6_2 = 0x7fffffffffffffff;
0001fd2d              zmm5_2[0] = zmm5_2[0] - (uint32_t)rawEdges;
0001fd36              zmm1_4[0] = zmm1_4[0] - *(uint32_t*)((char*)rawEdges)[4];
0001fd3f              zmm8 = _mm_cvtepi32_ps((uint128_t)r14_1);
0001fd43              float temp0_4[0x4] = _mm_unpacklo_ps(zmm5_2, *(uint64_t*)&zmm5_2[0]);
0001fd46              float temp0_5[0x4] = _mm_unpacklo_ps(zmm1_4, *(uint64_t*)&zmm1_4[0]);
0001fd50              float zmm3_2 =
0001fd50                  (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_4[0]), zmm6_2)[0];
0001fd5b              zmm2_1[0] =
0001fd5b                  (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_5[0]), zmm6_2)[0];
0001fd63              zmm2_1[0] = zmm2_1[0] * zmm2_1[0];
0001fd67              zmm2_1[0] = zmm2_1[0] + zmm3_2 * zmm3_2;
0001fd71              float zmm0_6[0x4];
0001fd71              float zmm3_3[0x4];
0001fd71              uint64_t zmm6_3[0x2];
0001fd71              zmm0_6 =
0001fd71                  sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm2_1, *(uint64_t*)&zmm2_1[0])[0])[0]);
0001fd76              uint64_t rax_6 = (uint64_t)pContext->edges[prevCam_1].Raw_Edges[1];
0001fd7e              zmm7[0] = (float)*(uint64_t*)&zmm0_6[0];
0001fd82              zmm0_6[0] = camPos2.x;
0001fd82              zmm0_6[1] = camPos2.x;
0001fd8b              zmm2_1 = {0};
0001fd8f              zmm7[0] = zmm7[0] * (uint32_t)zmm8;
0001fd94              zmm0_6[0] = zmm0_6[0] - (uint32_t)rawEdges;
0001fd9d              zmm2_1[0] = (float)rax_6;
0001fda2              uint64_t rax_7 = (uint64_t)pContext->edges[prevCam_1].Raw_Edges[0];
0001fdaa              float temp0_12[0x4] = _mm_unpacklo_ps(zmm0_6, *(uint64_t*)&zmm0_6[0]);
0001fdad              double temp0_13[0x2] = _mm_cvtps_pd(*(uint64_t*)&temp0_12[0]);
0001fdb0              temp0_12[0] = camPos2.y;
0001fdb0              temp0_12[1] = camPos2.y;
0001fdb0              temp0_12[2] = camPos2.y;
0001fdb0              temp0_12[3] = camPos2.y;
0001fdb9              temp0_12[0] = temp0_12[0] - *(uint32_t*)((char*)rawEdges)[4];
0001fdc6              float zmm4_1 = (float)_mm_and_pd(temp0_13, zmm6_3)[0];
0001fdd1              double temp0_16[0x2] =
0001fdd1                  _mm_cvtps_pd(_mm_unpacklo_ps(temp0_12, *(uint64_t*)&temp0_12[0])[0]);
0001fdd4              zmm0_6 = {0};
0001fdd8              zmm0_6[0] = (float)rax_7;
0001fde1              zmm3_3[0] = (float)_mm_and_pd(temp0_16, zmm6_3)[0];
0001fde5              zmm2_1[0] = zmm2_1[0] - zmm0_6[0];
0001fde9              float temp0_18[0x4] = _mm_unpacklo_ps(zmm2_1, *(uint64_t*)&zmm2_1[0]);
0001fdec              zmm3_3[0] = zmm3_3[0] * zmm3_3[0];
0001fdf0              zmm3_3[0] = zmm3_3[0] + zmm4_1 * zmm4_1;
0001fdf7              double zmm1_5[0x2] =
0001fdf7                  _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_18[0]), zmm6_3);
0001fdfb              float temp0_21[0x4] = _mm_unpacklo_ps(zmm3_3, *(uint64_t*)&zmm3_3[0]);
0001fdfe              zmm6_3[0] = (float)zmm1_5[0];
0001fe05              double zmm0_7[0x2];
0001fe05              double zmm1_6[0x2];
0001fe05              zmm0_7 = sqrt(_mm_cvtps_pd(*(uint64_t*)&temp0_21[0])[0]);
0001fe0a              zmm2_1 = {0};
0001fe0d              bool cond:0_1 = zmm7[0] <= 0f;
0001fe10              zmm1_6[0] = (float)zmm0_7[0];
0001fe14              zmm6[0] = zmm6[0] * zmm1_6[0];
0001fe14              
0001fe18              if (!cond:0_1)
0001fe18              {
0001fe21                  zmm7[0] = zmm7[0] * 4f;
0001fe21                  
0001fe2c                  if (!(zmm6[0] <= zmm7[0]))
0001fe2c                  {
0001fe32                      uint64_t Start_1 = (uint64_t)Start;
0001fe3a                      zmm6[0] = zmm6[0] / zmm7[0];
0001fe3e                      zmm6[0] = zmm6[0] * (uint32_t)zmm8;
0001fe43                      float temp0_23[0x4] = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
0001fe46                      double temp0_24[0x2] = _mm_cvtps_pd(*(uint64_t*)&temp0_23[0]);
0001fe49                      zmm6 = _mm_unpacklo_ps(temp0_23, *(uint64_t*)&temp0_23[0]);
0001fe4c                      temp0_24[0] = temp0_24[0] * 0.10000000000000001;
0001fe54                      double temp0_26[0x2] = _mm_cvtps_pd(*(uint64_t*)&zmm6[0]);
0001fe57                      temp0_26[0] = temp0_26[0] * 0.40000000000000002;
0001fe68                      int32_t rdx = (int32_t)(int16_t)(int32_t)temp0_26[0];
0001fe73                      int32_t rax_15;
0001fe73                      
0001fe73                      if (*(uint32_t*)rawEdges_1 >= (int32_t)(uint16_t)Start_1 + rdx)
0001fe73                      {
0001fe8a                          uint64_t End_1 = (uint64_t)End;
0001fe92                          int32_t r12_3 = rdx + rdi;
0001fe92                          
0001fe9d                          if (r12_3 <= (int32_t)(uint16_t)End_1)
0001fe9d                          {
0001fee4                              int32_t r14_2 = (int32_t)(int16_t)(int32_t)temp0_24[0];
0001fef0                              zmm1_6 = {0};
0001fef3                              int32_t rcx_2 = *(uint32_t*)rawEdges_1 - rdx;
0001fef7                              int32_t r10_1 = (int32_t)(End_1 - 2);
0001fef7                              
0001fefe                              if ((uint32_t)Start_1 > rcx_2)
0001fefe                                  rcx_2 = (uint32_t)Start_1;
0001fefe                              
0001ff05                              int32_t rdx_3 = *(uint32_t*)rawEdges_1 - r14_2 - 2;
0001ff0e                              void* rsi_1 = &pCam[(int64_t)rcx_2];
0001ff0e                              
0001ff12                              if (r10_1 < rdx_3)
0001ff12                                  rdx_3 = r10_1;
0001ff12                              
0001ff18                              if (rcx_2 < rdx_3)
0001ff18                              {
0001ff1c                                  uint64_t i_3 = (uint64_t)(rdx_3 - rcx_2);
0001ff48                                  uint64_t i;
0001ff48                                  
0001ff48                                  do
0001ff48                                  {
0001ff29                                      uint32_t rax_18 =
0001ff29                                          (uint32_t)*(uint16_t*)((char*)rsi_1 + 4)
0001ff29                                          - (uint32_t)*(uint16_t*)((char*)rsi_1 + 2) * 2;
0001ff2b                                      uint32_t rcx_5 = (uint32_t)*(uint16_t*)rsi_1;
0001ff2e                                      rsi_1 += 2;
0001ff34                                      int32_t temp0_29;
0001ff34                                      int32_t temp1_1;
0001ff34                                      temp0_29 = HIGHD((int64_t)(rax_18 + rcx_5));
0001ff34                                      temp1_1 = LOWD((int64_t)(rax_18 + rcx_5));
0001ff39                                      i = i_3;
0001ff39                                      i_3 -= 1;
0001ff41                                      zmm0_7 = _mm_cvtepi32_ps((uint128_t)((temp1_1
0001ff41                                          ^ temp0_29) - temp0_29));
0001ff44                                      zmm1_6[0] = zmm1_6[0] + zmm0_7[0];
0001ff48                                  } while (i != 1);
0001ff18                              }
0001ff18                              
0001ff4a                              int32_t rdx_6 = r14_2 + rdi;
0001ff4e                              int32_t rcx_6 = r12_3 - 2;
0001ff4e                              
0001ff56                              if ((uint32_t)Start_1 > rdx_6)
0001ff56                                  rdx_6 = (uint32_t)Start_1;
0001ff56                              
0001ff5d                              if (r10_1 < rcx_6)
0001ff5d                                  rcx_6 = r10_1;
0001ff5d                              
0001ff66                              void* r10_2 = &pCam[(int64_t)rdx_6];
0001ff66                              
0001ff6a                              if (rdx_6 < rcx_6)
0001ff6a                              {
0001ff6e                                  uint64_t i_2 = (uint64_t)(rcx_6 - rdx_6);
0001ff9c                                  uint64_t i_1;
0001ff9c                                  
0001ff9c                                  do
0001ff9c                                  {
0001ff7c                                      uint32_t rax_25 =
0001ff7c                                          (uint32_t)*(uint16_t*)((char*)r10_2 + 4)
0001ff7c                                          - (uint32_t)*(uint16_t*)((char*)r10_2 + 2) * 2;
0001ff7e                                      uint32_t rcx_10 = (uint32_t)*(uint16_t*)r10_2;
0001ff82                                      r10_2 += 2;
0001ff88                                      int32_t temp3_1;
0001ff88                                      int32_t temp4_1;
0001ff88                                      temp3_1 = HIGHD((int64_t)(rax_25 + rcx_10));
0001ff88                                      temp4_1 = LOWD((int64_t)(rax_25 + rcx_10));
0001ff8d                                      i_1 = i_2;
0001ff8d                                      i_2 -= 1;
0001ff95                                      zmm0_7 = _mm_cvtepi32_ps((uint128_t)((temp4_1
0001ff95                                          ^ temp3_1) - temp3_1));
0001ff98                                      zmm2_1[0] = zmm2_1[0] + zmm0_7[0];
0001ff9c                                  } while (i_1 != 1);
0001ff6a                              }
0001ff6a                              
0001ff9e                              bool cond:3_1 = zmm2_1[0] > zmm1_6[0];
0001ffa1                              zmm1_6 = {0};
0001ffa1                              
0001ffa5                              if (cond:3_1)
0001ffa5                                  goto label_1fea7;
0001ffa5                              
0001ffab                              zmm1_6[0] = (float)End_1;
0001ffab                              goto label_1ffb4;
0001fe9d                          }
0001fe9d                          
0001fe9f                          zmm1_6 = {0};
0001fea7                      label_1fea7:
0001fea7                          zmm1_6[0] = (float)Start_1;
0001feac                          zmm0_7 = _mm_cvtepi32_ps((uint128_t)rdi);
0001feaf                          zmm0_7[0] = zmm0_7[0] - zmm6[0];
0001feaf                          
0001feb6                          if (!(zmm1_6[0] <= zmm0_7[0]))
0001feb8                              zmm0_7 = zmm1_6;
0001feb8                          
0001febb                          int32_t rax_13 = (int32_t)zmm0_7[0];
0001febb                          
0001fec1                          if (*(uint32_t*)rawEdges_1 < rax_13)
0001fec1                              rax_13 = *(uint32_t*)rawEdges_1;
0001fec1                          
0001fec4                          *(uint32_t*)rawEdges_1 = rax_13;
0001fed4                          *(uint32_t*)interpolatedEdges =
0001fed4                              _mm_cvtepi32_ps((uint128_t)(rax_13 * 2 - 0x200))[0];
0001fed9                          rax_15 = rawEdges_1[(uint64_t)(uint32_t)rax];
0001fe73                      }
0001fe73                      else
0001fe73                      {
0001fe7c                          zmm1_6 = {0};
0001fe80                          zmm1_6[0] = (float)(uint64_t)End;
0001ffb4                      label_1ffb4:
0001ffb4                          zmm0_7 = _mm_cvtepi32_ps((uint128_t)*(uint32_t*)rawEdges_1);
0001ffb7                          zmm6[0] = zmm6[0] + zmm0_7[0];
0001ffb7                          
0001ffbe                          if (!(zmm6[0] <= zmm1_6[0]))
0001ffc0                              zmm6 = zmm1_6;
0001ffc0                          
0001ffc3                          rax_15 = (int32_t)zmm6[0];
0001ffc3                          
0001ffc9                          if (rdi > rax_15)
0001ffc9                              rax_15 = rdi;
0001fe73                      }
0001fe73                      
0001ffcc                      rawEdges_1[1] = rax_15;
0001ffd6                      result = 2;
0001ffe3                      interpolatedEdges[1] =
0001ffe3                          _mm_cvtepi32_ps((uint128_t)(rax_15 * 2 - 0x200))[0];
0001fe2c                  }
0001fe18              }
0001fc0f          }
0001fbf5      }
0001fbf5      
00020017      return result;
0001fba8  }

00020018                                                                          cc cc cc cc cc cc cc cc                          ........

00020020    uint32_t ChangeEdgesForSaturatedWaveformsInInnerNearfield(uint8_t Cam, uint8_t prevCam, uint32_t numEdges, int32_t* rawEdges, float* interpolatedEdges, uint8_t* bTchInCorner, float* relSlopes, uint32_t satStart, uint32_t satStop, uint32_t End)

00020020  {
00020026      if (numEdges)
00020026      {
000200b3          uint32_t rdx_1 = satStop;
000200ba          int32_t rax_7;
000200ba          uint64_t r10_2;
000200ba          
000200ba          if (satStart >= *(uint32_t*)rawEdges)
000200ba          {
000200bc              uint64_t rax_6 = (uint64_t)(numEdges - 1);
000200c0              r10_2 = (uint64_t)(uint32_t)rax_6;
000200c3              rax_7 = rawEdges[rax_6];
000200ba          }
000200ba          
000200c9          if (satStart < *(uint32_t*)rawEdges || rdx_1 > rax_7)
000200c9          {
000200f1              int32_t* interpolatedEdges_1 = interpolatedEdges;
000200f1              
000200f9              if (satStart < *(uint32_t*)rawEdges)
000200f9              {
000200fb                  *(uint32_t*)rawEdges = satStart;
00020109                  uint64_t rax_11 = (uint64_t)(numEdges - 1);
0002010d                  uint64_t rcx_3 = (uint64_t)(uint32_t)rax_11;
00020112                  *(uint32_t*)interpolatedEdges_1 =
00020112                      _mm_cvtepi32_ps((uint128_t)(satStart * 2 - 0x200));
0002011b                  rawEdges[1] = rawEdges[rax_11];
00020123                  interpolatedEdges_1[1] = interpolatedEdges_1[rcx_3];
0002012b                  relSlopes[1] = relSlopes[rcx_3];
000200f9              }
000200f9              
0002012f              uint64_t rax_15 = (uint64_t)(numEdges - 1);
00020133              uint64_t rcx_4 = (uint64_t)(uint32_t)rax_15;
00020133              
00020139              if (rdx_1 > rawEdges[rax_15])
00020139              {
0002014a                  if (rdx_1 > 0x15e && rawEdges[rcx_4] < rdx_1 - 0x32)
0002014a                      rdx_1 = End;
0002014a                  
0002014f                  rawEdges[1] = rdx_1;
00020161                  interpolatedEdges_1[1] = _mm_cvtepi32_ps((uint128_t)(rdx_1 * 2 - 0x200));
0002016b                  relSlopes[1] = relSlopes[rcx_4];
00020139              }
000200c9          }
000200c9          else
000200c9          {
000200d0              rawEdges[1] = rax_7;
000200d8              interpolatedEdges[1] = interpolatedEdges[r10_2];
000200e4              relSlopes[1] = relSlopes[r10_2];
000200c9          }
00020026      }
00020026      else
00020026      {
00020038          if (bTchInCorner[(uint64_t)prevCam])
00020178              return numEdges;
00020178          
0002004a          uint32_t rdx = satStop;
00020056          *(uint32_t*)rawEdges = satStart;
00020056          
00020068          if (rdx > 0x15e)
00020068              rdx = End;
00020068          
0002006d          uint128_t zmm0 = _mm_cvtepi32_ps((uint128_t)satStart);
00020070          rawEdges[1] = rdx;
00020074          (uint32_t)zmm0 = (uint32_t)zmm0 * 2f;
00020078          (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
0002007c          *(uint32_t*)interpolatedEdges = (uint32_t)zmm0;
00020089          (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)rawEdges[1]) * 2f;
0002008d          (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
00020091          interpolatedEdges[1] = (uint32_t)zmm0;
0002009b          *(uint32_t*)relSlopes = 0f;
0002009e          relSlopes[1] = 0;
000200a5          bTchInCorner[(uint64_t)Cam] = 1;
00020026      }
00020026      
0002016f      return 2;
00020020  }

00020179                                                                             cc cc cc cc cc cc cc                           .......

00020180    uint8_t PerformNearfieldInnerEdgesDiameterTest(struct _ctl_context_t* pContext, uint32_t* numEdges, float* interpolatedEdges, int32_t* rawEdges, float* relSlopes, uint8_t Cam, uint8_t prevCam, struct fpoint_t camPos1, struct fpoint_t camPos2, uint8_t bSmallStylusTest, uint8_t bInnerNearfield, uint32_t* iEdgeSelected)

00020180  {
000201a2      int128_t zmm6;
000201a2      int128_t var_38 = zmm6;
000201a6      uint128_t zmm7;
000201a6      uint128_t var_48 = zmm7;
000201ad      uint64_t prevCam_1 = (uint64_t)prevCam;
000201b6      int64_t rsi;
000201b6      (uint8_t)rsi = 0;
000201be      int128_t zmm9;
000201be      int128_t var_68 = zmm9;
000201c3      int128_t zmm10;
000201c3      int128_t var_78 = zmm10;
000201ce      uint32_t* numEdges_1 = numEdges;
000201e1      int128_t zmm11;
000201e1      int128_t var_88 = zmm11;
000201e7      int128_t zmm12;
000201e7      int128_t var_98 = zmm12;
000201ed      char Num_Edges = pContext->edges[prevCam_1].Num_Edges;
000201ed      
00020211      if (Num_Edges == 4 && (relSlopes[1] > 0.5f || relSlopes[2] > 0.5f))
00020505          (uint8_t)rsi = 1;
00020211      else if (Num_Edges == 2)
00020219      {
00020225          (uint8_t)numEdges = Cam;
00020238          int128_t zmm0_1 = FE_Linearize(pContext, (uint8_t)numEdges, 
00020238              (*(uint32_t*)interpolatedEdges + interpolatedEdges[3]) * 0.5f);
00020246          int128_t zmm0_2 =
00020246              FE_Linearize(pContext, (uint8_t)numEdges, *(uint32_t*)interpolatedEdges);
0002024b          zmm10 = pContext->edges[prevCam_1].Lin_Edges[1];
0002025d          (uint32_t)zmm9 = (uint32_t)zmm10 + pContext->edges[prevCam_1].Lin_Edges[0];
00020267          (uint32_t)zmm9 = (uint32_t)zmm9 * 0.5f;
00020278          int32_t rotation_offset;
00020278          int32_t rotation_offset_1;
00020278          
00020278          if (!(uint8_t)numEdges || (uint8_t)numEdges == 2)
00020278          {
00020345              rotation_offset = pContext->settings.sensorInfo[(uint64_t)(uint8_t)numEdges].
00020345                  rotation_offset;
0002034f              zmm7 = _mm_cvtepi32_ps((uint128_t)pContext->settings.focalLength);
0002036d              (uint32_t)zmm11 = _divide((uint32_t)zmm0_1, (uint32_t)zmm7) + 0.785398185f;
00020372              (uint32_t)zmm11 = (uint32_t)zmm11 + rotation_offset;
00020377              int128_t zmm0_8 = _divide((uint32_t)zmm0_2, (uint32_t)zmm7);
00020383              rotation_offset_1 = pContext->settings.sensorInfo[prevCam_1].rotation_offset;
00020391              (uint32_t)zmm12 = (uint32_t)zmm0_8 + 0.785398185f;
00020396              (uint32_t)zmm12 = (uint32_t)zmm12 + rotation_offset;
000203bf              (uint32_t)zmm9 = _divide((zmm9 ^ 0x80000000), (uint32_t)zmm7) + 0.785398185f;
000203c4              (uint32_t)zmm9 = (uint32_t)zmm9 + rotation_offset_1;
000203d2              (uint32_t)zmm10 =
000203d2                  _divide((zmm10 ^ 0x80000000), (uint32_t)zmm7) + 0.785398185f;
000203d7              (uint32_t)zmm10 = (uint32_t)zmm10 + rotation_offset_1;
00020278          }
00020278          else
00020278          {
0002029f              rotation_offset_1 = pContext->settings.sensorInfo[(uint64_t)(uint8_t)numEdges]
0002029f                  .rotation_offset;
000202a9              zmm7 = _mm_cvtepi32_ps((uint128_t)pContext->settings.focalLength);
000202cb              (uint32_t)zmm11 =
000202cb                  _divide((zmm0_1 ^ 0x80000000), (uint32_t)zmm7) + 0.785398185f;
000202d0              (uint32_t)zmm11 = (uint32_t)zmm11 + rotation_offset_1;
000202d5              int128_t zmm0_4 = _divide((zmm0_2 ^ 0x80000000), (uint32_t)zmm7);
000202e1              rotation_offset = pContext->settings.sensorInfo[prevCam_1].rotation_offset;
000202ef              (uint32_t)zmm12 = (uint32_t)zmm0_4 + 0.785398185f;
000202f8              (uint32_t)zmm12 = (uint32_t)zmm12 + rotation_offset_1;
0002030d              (uint32_t)zmm9 = _divide((uint32_t)zmm9, (uint32_t)zmm7) + 0.785398185f;
00020312              (uint32_t)zmm9 = (uint32_t)zmm9 + rotation_offset;
00020320              (uint32_t)zmm10 = _divide((uint32_t)zmm10, (uint32_t)zmm7) + 0.785398185f;
00020325              (uint32_t)zmm10 = (uint32_t)zmm10 + rotation_offset;
00020278          }
000203e0          int128_t zmm0_10;
000203e0          int512_t zmm6_1;
000203e0          zmm0_10 = _safeTan((uint32_t)zmm9);
000203e5          (uint128_t)zmm6_1 = zmm0_10;
000203ec          float slope0;
000203ec          float slope1;
000203ec          slope0 = _safeTan((uint32_t)zmm11);
000203f1          struct fpoint_t rdi;
000203f1          rdi.x = camPos2.x;
000203f1          rdi.y = camPos2.y;
000203f9          struct fpoint_t p0;
000203f9          p0.x = camPos1.x;
000203f9          p0.y = camPos1.y;
00020407          struct fpoint_t p1;
00020407          p1.x = rdi.x;
00020407          p1.y = rdi.y;
0002040a          struct fpoint_t rax_6 = PointSlopeTriangulate(p0, slope0, p1, slope1);
0002040f          struct fpoint_t arg_8;
0002040f          arg_8.x = p0.x;
0002040f          arg_8.y = p0.y;
0002041b          struct fpoint_t rbx;
0002041b          rbx.x = rax_6.x;
0002041b          rbx.y = rax_6.y;
0002041e          _safeTan((uint32_t)zmm12);
00020423          struct fpoint_t var_a8;
00020423          var_a8.x = rbx.x;
00020423          var_a8.y = rbx.y;
00020442          arg_8.x = rdi.x;
00020442          arg_8.y = rdi.y;
0002047a          float zmm0_13;
0002047a          zmm0_13 = _safeTan((uint32_t)zmm10);
00020491          struct fpoint_t var_a8_1;
00020491          var_a8_1.x = rbx.x;
00020491          var_a8_1.y = rbx.y;
000204ae          uint128_t zmm3_2;
000204ae          (uint32_t)zmm3_2 = arg_8.y - arg_8.x * zmm0_13;
000204b6          (uint32_t)zmm3_2 = (uint32_t)zmm3_2 + var_a8_1.x * zmm0_13 - var_a8_1.y;
000204ba          (uint32_t)zmm3_2 = (uint32_t)zmm3_2 * (uint32_t)zmm3_2;
000204be          (uint32_t)zmm3_2 = (uint32_t)zmm3_2 / (zmm0_13 * zmm0_13 + (uint32_t)zmm6);
000204be          
000204c5          if (!((uint32_t)zmm7 > (uint32_t)zmm3_2))
000204c7              zmm7 = zmm3_2;
000204c7          
000204ca          (uint32_t)zmm7 = (uint32_t)zmm7 * 4f;
000204ca          
000204da          if (!bSmallStylusTest)
000204da          {
000204e4              if (bInnerNearfield)
000204e4                  goto label_2051c;
000204e4              
00020503              if (!((uint32_t)zmm7 <= 400f)
00020503                      && (relSlopes[1] > 0.5f || !(relSlopes[2] <= 0.5f)))
00020505                  (uint8_t)rsi = 1;
000204da          }
000204da          else if (bInnerNearfield)
00020512          {
0002051c          label_2051c:
0002051c              
0002051f              if (400f > (uint32_t)zmm7 || !(300f <= (uint32_t)zmm7))
0002051f                  goto label_20536;
00020512          }
00020512          else if (!(300f <= (uint32_t)zmm7))
0002052c          {
00020536          label_20536:
00020536              *(uint32_t*)numEdges_1 = 2;
00020541              rawEdges[1] = rawEdges[3];
0002054a              interpolatedEdges[1] = interpolatedEdges[3];
00020552              relSlopes[1] = relSlopes[3];
00020558              iEdgeSelected[1] = iEdgeSelected[3];
0002052c          }
00020219      }
00020219      
0002059c      return (uint8_t)rsi;
00020180  }

0002059d                                                                                         cc cc cc                               ...
000205a0  cc cc cc cc                                                                                      ....

000205a4    uint8_t ReduceNumOfEdges(uint32_t* numEdges, float* relSlopes, int32_t* rawEdges, float* interpolatedEdges, uint32_t* iEdgeSelected, uint8_t bNearfield, uint8_t bInnerNearfield, uint8_t bDone)

000205a4  {
000205c5      int32_t i_5 = 0;
000205c8      int32_t* rawEdges_1 = rawEdges;
000205d1      uint32_t i = *(uint32_t*)numEdges;
000205d3      float* interpolatedEdges_1 = interpolatedEdges;
000205d6      int32_t* rdi;
000205d6      (uint8_t)rdi = 0;
000205d9      bDone = 0;
000205ec      uint64_t rax;
000205ec      
000205ec      if (i <= 4)
000205ec      {
000206c5          rax = 0;
000206c5          
000206cb          if (i > 0)
000206cb          {
000206cd              uint32_t* iEdgeSelected_1 = iEdgeSelected;
000206cd              
000206dc              do
000206dc              {
000206d0                  *(uint32_t*)iEdgeSelected_1 = (uint32_t)rax;
000206d3                  rax = (uint64_t)((uint32_t)rax + 1);
000206d6                  iEdgeSelected_1 = &iEdgeSelected_1[1];
000206dc              } while ((uint32_t)rax < i);
000206cb          }
000205ec      }
000205ec      else
000205ec      {
000205f2          float zmm1 = -1f;
00020601          *(uint32_t*)iEdgeSelected = 0;
00020604          rdi = 1;
00020608          iEdgeSelected[3] = i - 1;
00020608          
0002060f          if (i - 2 > 1)
0002060f          {
00020614              rax = (uint64_t)(i - 2);
00020617              uint32_t i_1 = 1;
00020617              
00020668              do
00020668              {
0002061e                  int32_t j = i_1 + 1;
0002061e                  
00020628                  if (j < i - 1)
00020628                  {
00020631                      void* rbp_2 = &relSlopes[(int64_t)j];
00020631                      
0002065a                      do
0002065a                      {
0002063b                          float zmm0 =
0002063b                              relSlopes[(uint64_t)(uint16_t)rdi] + *(uint32_t*)rbp_2;
0002063b                          
00020643                          if (!(zmm0 <= zmm1))
00020643                          {
00020645                              zmm1 = zmm0;
00020648                              iEdgeSelected[1] = i_1;
0002064c                              iEdgeSelected[2] = j;
00020643                          }
00020643                          
00020650                          j += 2;
00020653                          rbp_2 += 8;
0002065a                      } while (j < i - 1);
0002065a                      
0002065c                      rax = (uint64_t)(i - 2);
00020628                  }
00020628                  
00020660                  (uint16_t)rdi += 2;
00020663                  i_1 = (uint32_t)(uint16_t)rdi;
00020668              } while (i_1 < (uint32_t)rax);
0002060f          }
0002060f          
00020676          (uint8_t)rdi = 0;
000205ec      }
000205ec      
0002067e      if (bNearfield)
0002067e      {
000206e3          if (i >= 4)
000206e3          {
00020709              if (relSlopes[(uint64_t)iEdgeSelected[1]] > 0.25f
00020709                      || relSlopes[(uint64_t)iEdgeSelected[2]] > 0.25f)
00020719                  *(uint32_t*)numEdges = 4;
00020709              else
00020709              {
0002070e                  *(uint32_t*)iEdgeSelected = 0;
00020711                  *(uint32_t*)numEdges = 2;
00020713                  iEdgeSelected[1] = i - 1;
00020709              }
000206e3          }
000206e3          
00020752          if (!bInnerNearfield && *(uint32_t*)numEdges == 4
00020752              && !(relSlopes[(uint64_t)iEdgeSelected[1]] <= 0.5f)
00020752              && !(relSlopes[(uint64_t)iEdgeSelected[2]] <= 0.5f))
00020752          {
00020754              (uint8_t)rdi = 1;
00020757              bDone = 1;
00020752          }
0002067e      }
0002067e      else if (i > 4)
00020683      {
000206ad          if (!(relSlopes[(uint64_t)iEdgeSelected[1]] > 0.25f)
000206ad              && !(relSlopes[(uint64_t)iEdgeSelected[2]] > 0.25f))
000206ad          {
000206b2              iEdgeSelected[1] = 1;
000206b6              iEdgeSelected[2] = i - 2;
000206ad          }
000206ad          
000206ba          *(uint32_t*)numEdges = 4;
00020683      }
00020683      
00020762      void var_48;
00020762      void var_38;
00020762      
00020762      if (*(uint32_t*)numEdges > 0)
00020762      {
00020764          uint64_t i_6 = (uint64_t)*(uint32_t*)numEdges;
00020772          uint32_t* iEdgeSelected_2 = iEdgeSelected;
00020791          uint64_t i_2;
00020791          
00020791          do
00020791          {
00020778              uint64_t rcx = (uint64_t)*(uint32_t*)iEdgeSelected_2;
0002077e              *(uint32_t*)(&var_38 - iEdgeSelected + iEdgeSelected_2) = rawEdges_1[rcx];
00020786              *(uint32_t*)(&var_48 - iEdgeSelected + iEdgeSelected_2) = relSlopes[rcx];
0002078a              iEdgeSelected_2 = &iEdgeSelected_2[1];
0002078e              i_2 = i_6;
0002078e              i_6 -= 1;
00020791          } while (i_2 != 1);
00020793          (uint8_t)rdi = bDone;
00020762      }
00020762      
0002079b      int32_t i_3 = 0;
0002079b      
000207a1      if (*(uint32_t*)numEdges > 0)
000207a1      {
000207ac          int32_t* r9 = &var_38 - rawEdges_1;
000207af          void* rbx_2 = &var_48 - rawEdges_1;
000207b2          int32_t* r8_1 = (char*)relSlopes - rawEdges_1;
000207b2          
000207cb          do
000207cb          {
000207b9              i_3 += 1;
000207bc              *(uint32_t*)rawEdges_1 = *(uint32_t*)((char*)r9 + rawEdges_1);
000207c1              *(uint32_t*)((char*)r8_1 + rawEdges_1) =
000207c1                  *(uint32_t*)((char*)rbx_2 + rawEdges_1);
000207c5              rawEdges_1 = &rawEdges_1[1];
000207cb          } while (i_3 < *(uint32_t*)numEdges);
000207cb          
000207d0          if (*(uint32_t*)numEdges > 0)
000207d0          {
000207d2              uint64_t i_7 = (uint64_t)*(uint32_t*)numEdges;
000207d9              void* r8_2 = &var_48;
000207f2              uint64_t i_4;
000207f2              
000207f2              do
000207f2              {
000207e8                  *(uint32_t*)r8_2 = interpolatedEdges_1[(uint64_t)
000207e8                      *(uint32_t*)((char*)iEdgeSelected - &var_48 + r8_2)];
000207eb                  r8_2 += 4;
000207ef                  i_4 = i_7;
000207ef                  i_7 -= 1;
000207f2              } while (i_4 != 1);
000207f2              
000207f7              if (*(uint32_t*)numEdges > 0)
000207f7              {
000207fd                  float* r8_3 = &var_48 - interpolatedEdges_1;
000207fd                  
00020812                  do
00020812                  {
00020804                      i_5 += 1;
00020807                      *(uint32_t*)interpolatedEdges_1 =
00020807                          *(uint32_t*)((char*)r8_3 + interpolatedEdges_1);
0002080b                      interpolatedEdges_1 = &interpolatedEdges_1[1];
00020812                  } while (i_5 < *(uint32_t*)numEdges);
000207f7              }
000207d0          }
000207a1      }
000207a1      
00020823      (uint8_t)rax = (uint8_t)rdi;
00020833      return (uint8_t)rax;
000205a4  }

00020834                                                              cc cc cc cc cc cc cc cc                                  ........

0002083c    uint32_t HandleNearfield(struct _ctl_context_t* PTransLibUserModeContext, uint8_t Cam, uint16_t* pCam, uint16_t* pTrig, float TriggerLevel, uint16_t startPix, uint16_t stopPix, int32_t* rawEdges, float* interpolatedEdges, float* relSlopes, uint32_t numEdges)

0002083c  {
0002083f      uint16_t* pTrig_1 = pTrig;
00020861      uint128_t zmm6;
00020861      uint128_t var_58 = zmm6;
00020865      uint128_t focalLength;
00020865      uint128_t focalLength_3 = focalLength;
00020869      uint128_t focalLength_1;
00020869      uint128_t focalLength_2 = focalLength_1;
00020876      uint128_t zmm10;
00020876      uint128_t var_98 = zmm10;
000208ab      struct _ctl_context_t* pContext = PTransLibUserModeContext;
000208ae      uint32_t satStart = 0;
000208b4      uint32_t satStop = 0;
000208ba      char var_1ac = 0;
000208bf      uint8_t bInnerNearfield = 0;
000208c4      uint16_t nSatPix = 0;
000208c9      uint8_t bSmallStylusTest = 1;
000208cd      uint8_t numSensors = PTransLibUserModeContext->settings.numSensors;
000208da      char var_1b0;
000208da      char var_1a0;
000208da      
000208da      if (numSensors != 3 || Cam)
000208da      {
000208eb          uint32_t numSensors_1 = (uint32_t)numSensors;
000208f7          char temp1_1 = (char)((int64_t)((uint32_t)Cam + numSensors_1 - 1) % numSensors_1);
000208f9          var_1a0 = temp1_1;
00020900          var_1b0 = temp1_1;
000208da      }
000208da      else
000208da      {
000208dc          var_1a0 = 1;
000208e4          var_1b0 = 2;
000208da      }
000208da      
00020904      uint64_t Cam_1 = (uint64_t)Cam;
0002091c      uint32_t startAperture = (uint32_t)pContext->settings.sensor[Cam_1].startAperture;
00020924      uint32_t stopAperture = (uint32_t)pContext->settings.sensor[Cam_1].stopAperture;
00020924      
00020935      if (stopAperture > 0x1ff)
00020935          stopAperture = 0x1ff;
00020935      
00020945      if (startAperture >= 0x20c)
00020953          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_waveform.c", 
00020953              0x788);
00020953      
00020958      uint32_t numEdges_1 = numEdges;
00020960      int32_t r11 = pContext->satEnd[Cam_1];
00020968      int32_t rbx = pContext->satStart[Cam_1];
00020970      int128_t zmm11 = 0x41200000;
0002097e      uint32_t numEdges_3 = numEdges_1;
00020981      (uint8_t)pTrig = 0;
00020981      
00020987      if (numEdges_1 > 0x1e)
00020987          numEdges_3 = 0x1e;
00020987      
0002098c      uint32_t i_3 = numEdges_3 >> 1;
000209a6      uint32_t iEdgeSelected[0x20];
000209a6      float zmm0[0x4];
000209a6      uint64_t zmm1[0x2];
000209a6      float edge;
000209a6      
000209a6      if (i_3 < 2 || (numEdges_3 == 4 && pContext->prevCamNumEdges == numEdges_3))
00020993          (uint8_t)pTrig = 0;
000209a6      else if (rbx != 0xffff8001 && r11 != 0xffff8001)
000209b8      {
000209be          void* interpolatedEdges_3 = interpolatedEdges;
000209be          
000209c8          if (i_3 > 0)
000209c8          {
000209ca              float* r8 = &iEdgeSelected;
000209d2              void* interpolatedEdges_5 = interpolatedEdges_3;
000209d5              uint64_t i_2 = (uint64_t)i_3;
00020a0a              uint64_t i;
00020a0a              
00020a0a              do
00020a0a              {
000209d8                  zmm0 = *(uint32_t*)interpolatedEdges_5;
000209dc                  zmm1 = *(uint32_t*)((char*)interpolatedEdges_5 + 4);
000209dc                  
000209e4                  if (zmm0[0] <= zmm1[0])
000209eb                      edge = zmm1[0];
000209e4                  else
000209e6                      edge = zmm0[0];
000209e6                  
000209f1                  if (!(zmm1[0] > zmm0[0]))
000209f3                      zmm0 = zmm1;
000209f3                  
000209fa                  interpolatedEdges_5 += 8;
000209fe                  *(uint32_t*)r8 = edge - zmm0[0];
00020a03                  r8 = &r8[1];
00020a07                  i = i_2;
00020a07                  i_2 -= 1;
00020a0a              } while (i != 1);
000209c8          }
000209c8          
00020a10          uint32_t i_1 = 0;
00020a10          
00020a15          if (i_3 - 1 > 0)
00020a15          {
00020a1b              uint32_t (* r8_1)[0x20] = &iEdgeSelected;
00020a23              char* rcx = (char*)interpolatedEdges_3 + 8;
00020a23              
00020ab4              do
00020ab4              {
00020a27                  zmm1 = *(uint32_t*)r8_1;
00020a27                  
00020a3c                  if (!(10f <= zmm1[0]) && (*(uint1024_t*)r8_1)[1][0] > 10f)
00020a3c                  {
00020a4b                  label_20a4b:
00020a4b                      edge = *(uint32_t*)(rcx - 8);
00020a57                      zmm1 = _mm_cvtepi32_ps((uint128_t)(rbx - 0xa));
00020a57                      
00020a5d                      if (!(edge <= zmm1[0]))
00020a67                          zmm0 = _mm_cvtepi32_ps((uint128_t)(r11 + 0xa));
00020a67                      
00020a6d                      if (!(edge <= zmm1[0]) && zmm0[0] > edge)
00020a6d                      {
00020a89                      label_20a89:
00020a89                          (uint8_t)edge = *(uint8_t*)rcx;
00020a89                          *(uint16_t*)((char*)edge)[2] = *(uint16_t*)(rcx + 2);
00020a89                          *(uint16_t*)((char*)edge)[4] = *(uint16_t*)(rcx + 4);
00020a89                          *(uint16_t*)((char*)edge)[6] = *(uint16_t*)(rcx + 6);
00020a89                          *(uint16_t*)((char*)edge)[8] = *(uint16_t*)(rcx + 8);
00020a89                          *(uint16_t*)((char*)edge)[0xa] = *(uint16_t*)(rcx + 0xa);
00020a89                          *(uint16_t*)((char*)edge)[0xc] = *(uint16_t*)(rcx + 0xc);
00020a89                          *(uint16_t*)((char*)edge)[0xe] = *(uint16_t*)(rcx + 0xe);
00020a89                          
00020a95                          if (!(edge <= zmm1[0]) && zmm0[0] > edge)
00020a95                          {
00020abb                          label_20abb:
00020abb                              uint64_t r8_2 = (uint64_t)(i_1 + 1);
00020abb                              
00020ad3                              if (iEdgeSelected[r8_2][0] <= iEdgeSelected[(uint64_t)i_1])
00020add                                  pContext->fakeTouchIndex = (uint32_t)r8_2;
00020ad3                              else
00020ad5                                  pContext->fakeTouchIndex = i_1;
00020ad5                              
00020ae4                              (uint8_t)pTrig = 1;
00020ae4                              break;
00020a95                          }
00020a95                          
00020a97                          edge = *(uint32_t*)(rcx + 4);
00020a97                          
00020aa4                          if (!(edge <= zmm1[0]) && zmm0[0] > edge)
00020aa4                              goto label_20abb;
00020a6d                      }
00020a6d                      else
00020a6d                      {
00020a6f                          edge = *(uint32_t*)(rcx - 4);
00020a6f                          
00020a77                          if (!(edge <= zmm1[0]))
00020a77                          {
00020a81                              zmm0 = _mm_cvtepi32_ps((uint128_t)(r11 + 0xa));
00020a81                              
00020a87                              if (!(zmm0[0] <= edge))
00020a87                                  goto label_20a89;
00020a77                          }
00020a6d                      }
00020a3c                  }
00020a3c                  else if (!(zmm1[0] <= 10f) && !(10f <= (*(uint1024_t*)r8_1)[1]))
00020a49                      goto label_20a4b;
00020a49                  
00020aa6                  i_1 += 1;
00020aa9                  r8_1 = &(*(uint1024_t*)r8_1)[1];
00020aad                  rcx = &rcx[8];
00020ab4              } while (i_1 < i_3 - 1);
00020a15          }
000209b8      }
000209b8      
00020ae7      float* interpolatedEdges_1 = interpolatedEdges;
00020aef      pContext->spikeTouchFound = (uint8_t)pTrig;
00020aef      
00020af9      if ((uint8_t)pTrig == 1)
00020af9      {
00020b1c          uint32_t numEdges_2;
00020b1c          numEdges_2 = RemoveFakeSpikeTouch(numEdges_1, pContext->fakeTouchIndex, 
00020b1c              interpolatedEdges_1, rawEdges, relSlopes);
00020b21          numEdges_1 = numEdges_2;
00020af9      }
00020af9      
00020b24      uint128_t zmm12 = 0x7fffffffffffffff;
00020b2d      uint32_t Cam_2 = 0;
00020b2d      
00020b33      if (numEdges_1 > 0)
00020b33      {
00020b51          float* interpolatedEdges_2 = interpolatedEdges_1;
00020b54          float* interpolatedEdges_4 = interpolatedEdges_2;
00020b54          
00020be5          do
00020be5          {
00020b5c              zmm0 = interpolatedEdges_2[1];
00020b61              zmm0[0] = zmm0[0] - *(uint32_t*)interpolatedEdges_2;
00020b61              
00020b74              if (!(0x3ff0000000000000 < _mm_and_pd(
00020b74                  _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]), zmm12)[0]))
00020b74              {
00020b76                  uint64_t rax_11 = (uint64_t)(Cam_2 + 2);
00020b7d                  uint64_t Cam_3 = (uint64_t)Cam_2;
00020b90                  uint64_t rdi_1 = (uint64_t)(uint32_t)rax_11;
00020b92                  uint64_t rsi_3 = (uint64_t)(numEdges_1 - Cam_2 - 1) << 2;
00020b99                  memmove(&rawEdges[Cam_3], &rawEdges[rax_11], rsi_3);
00020ba9                  memmove(&interpolatedEdges[Cam_3], &interpolatedEdges[rdi_1], rsi_3);
00020bc1                  memmove(&relSlopes[Cam_3], &relSlopes[rdi_1], rsi_3);
00020bc6                  interpolatedEdges_2 = interpolatedEdges_4;
00020bce                  numEdges_1 -= 2;
00020b74              }
00020b74              
00020bd2              interpolatedEdges_2 = &interpolatedEdges_2[2];
00020bd6              Cam_2 += 2;
00020bda              interpolatedEdges_4 = interpolatedEdges_2;
00020be5          } while (Cam_2 < numEdges_1);
00020be5          
00020beb          pContext = PTransLibUserModeContext;
00020bfb          interpolatedEdges_1 = interpolatedEdges;
00020b33      }
00020b33      
00020c05      float zmm9[0x4];
00020c05      zmm9[0] = pContext->settings.sensorInfo[1].position.x;
00020c05      zmm9[1] = pContext->settings.sensorInfo[1].position.x;
00020c05      zmm9[2] = pContext->settings.sensorInfo[1].position.x;
00020c05      zmm9[3] = pContext->settings.sensorInfo[1].position.x;
00020c15      int128_t TriggerLevel_1 = TriggerLevel;
00020c1f      uint64_t rdx_6 = (uint64_t)var_1a0;
00020c2a      void* r10_2 = Cam_1 + pContext;
00020c2e      zmm9[0] = zmm9[0] - pContext->settings.sensorInfo[0].position.x;
00020c3a      numEdges = numEdges_1;
00020c4a      int128_t zmm13 = *(uint32_t*)((char*)pContext + ((Cam_1 * 3 + 0x1530) << 2));
00020c51      zmm9[0] = zmm9[0] / 537f;
00020c5a      struct _ctl_context_t* p0_2;
00020c5a      (uint32_t)p0_2 = (uint32_t)zmm13;
00020c64      uint64_t rax_14 = Cam_1 * 3;
00020c70      int128_t zmm14 = (&pContext->settings.sensorInfo[0].position.y)[rax_14];
00020c82      *(uint32_t*)((char*)p0_2)[4] = (uint32_t)zmm14;
00020c8c      struct _ctl_context_t* p0_1 = p0_2;
00020c9a      uint64_t rax_16 = rdx_6 * 3;
00020c9e      float var_178 = (*(uint32_t*)((char*)pContext + ((rdx_6 * 3 + 0x1530) << 2)))[0];
00020caf      zmm0 = (&pContext->settings.sensorInfo[0].position.y)[rax_16];
00020cb8      *(uint8_t*)((char*)r10_2 + 0x32e0) = 0;
00020cc2      float var_174 = zmm0[0];
00020ccb      struct fpoint_t rdi_2;
00020ccb      rdi_2.x = var_178;
00020ccb      rdi_2.y = var_178;
00020cd7      (uint8_t)pTrig = pContext->edges[rdx_6].Num_Edges;
00020cea      float* var_208;
00020cea      char var_1e0;
00020cea      float* relSlopes_1;
00020cea      struct fpoint_t p1;
00020cea      int32_t* rawEdges_1;
00020cea      
00020cea      if (!(uint8_t)pTrig)
00020cea      {
00020cf3          if (numEdges_1)
00020cf3          {
00020e76              uint32_t rax_28 = (uint32_t)var_1ac;
00020e76              
00020e79              if (numEdges_1 > 4)
00020e79                  rax_28 = 1;
00020e79              
00020e7d              var_1ac = rax_28;
00020cf3          }
00020cf3          else if (!pContext->edges[(uint64_t)var_1b0].Num_Edges)
00020d0a          {
00020d10              uint64_t startPix_1 = (uint64_t)startPix;
00020d18              uint32_t stopPix_1 = (uint32_t)stopPix;
00020d2f              int32_t r10_3 = 0;
00020d32              int32_t rdx_7 = (uint32_t)startPix_1;
00020d32              
00020d44              if ((uint32_t)startPix_1 <= stopPix_1)
00020d44              {
00020d46                  void* r8_7 = &pCam[startPix_1];
00020d46                  
00020d69                  do
00020d69                  {
00020d52                      r10_3 += (uint32_t)
00020d52                          *(uint16_t*)(&pContext->waveforms[Cam_1].ambient - pCam + r8_7);
00020d52                      
00020d5e                      if (*(uint16_t*)r8_7 > 0x400)
00020d5e                      {
00020d6d                          pContext->nearfieldData.b12_Bit = 1;
00020d6d                          break;
00020d5e                      }
00020d5e                      
00020d60                      rdx_7 += 1;
00020d63                      r8_7 += 2;
00020d69                  } while (rdx_7 <= stopPix_1);
00020d44              }
00020d44              
00020d7e              int16_t rax_22;
00020d7e              
00020d7e              if (!pContext->nearfieldData.b12_Bit)
00020d7e              {
00020d90                  zmm1 = 0x4479c000;
00020db5                  zmm1[0] = 999f - (float)(uint64_t)r10_3 /
00020db5                      _mm_cvtepi32_ps((uint128_t)(stopPix_1 - (uint32_t)startPix_1 + 1))[0];
00020db9                  rax_22 = (int16_t)(int64_t)zmm1[0];
00020d7e              }
00020d7e              else
00020d7e              {
00020d80                  zmm11 = 0x41a00000;
00020d89                  rax_22 = 0xaf0;
00020d7e              }
00020d7e              
00020dc6              (uint32_t)zmm11 = (uint32_t)zmm11 * 1.20000005f;
00020e05              zmm0 = _mm_cvtepi32_ps((uint128_t)rax_22);
00020e0d              uint8_t bCamSaturated = *(uint8_t*)((char*)r10_2 + 0x32dc);
00020e13              zmm0[0] = zmm0[0] * 0.980000019f;
00020e45              (uint32_t)var_208 = (uint32_t)zmm11;
00020e4c              FindSaturation_FirstLast(pCam, pTrig_1, (uint32_t)TriggerLevel_1, 
00020e4c                  (int16_t)(int64_t)zmm0[0], (uint32_t)var_208, (uint16_t)startPix_1, 
00020e4c                  (uint16_t)stopPix_1, rawEdges, 0, 0, bCamSaturated, &nSatPix, &satStart, 
00020e4c                  &satStop);
00020e5a              *(uint8_t*)((char*)r10_2 + 0x32dc) = nSatPix > 0;
00020e60              pContext->prevCamNumEdges = 0;
00020e67              return 0;
00020d0a          }
00020d0a          
00020e81          rawEdges_1 = rawEdges;
00020eda          var_1e0 = 1;
00020efb          (uint32_t)var_208 = 0x41200000;
00020f02          relSlopes_1 = FindSaturation_FirstLast(pCam, pTrig_1, (uint32_t)TriggerLevel_1, 
00020f02              0x384, 10f, startPix, stopPix, rawEdges_1, numEdges_1, 1, 
00020f02              *(uint8_t*)((char*)r10_2 + 0x32dc), &nSatPix, &satStart, &satStop);
00020f07          (uint8_t)Cam_2 = Cam;
00020f07          
00020f18          if (nSatPix <= 0)
00020f18              goto label_2142b;
00020f18          
00020f1e          var_1ac = 1;
00021244      label_21244:
00021244          (uint8_t)relSlopes_1 = 1;
00021247          bInnerNearfield = 1;
0002124b          goto label_21437;
00020cea      }
00020cea      
00020f28      Cam_2 = (uint32_t)Cam;
00020f35      p1 = (uint64_t)((uint32_t)var_1a0 + Cam_2);
00020f48      uint8_t arg_10;
00020f48      
00020f48      if (p1.x == 1 || p1.x == 5)
00020f48      {
00021259          if (!(uint8_t)Cam_2 || (uint8_t)Cam_2 == 2)
00021259          {
00021268              (uint8_t)relSlopes_1 = (uint8_t)pTrig;
0002126b              (uint8_t)relSlopes_1 -= 1;
0002126e              arg_10 = 0xffffffff;
00021259          }
00021259          else
00021259          {
0002125b              (uint8_t)relSlopes_1 = 0;
0002125e              arg_10 = 1;
00021259          }
00021259          
0002127e          rawEdges_1 = rawEdges;
00021290          zmm6 =
00021290              pContext->edges[0].Lin_Edges[rdx_6 * 0x1a + (uint64_t)(uint8_t)relSlopes_1];
00021290          
0002129c          if (!(-362.853973f <= (uint32_t)zmm6))
0002129c          {
000212f3              var_1e0 = 1;
00021314              (uint32_t)var_208 = 0x41200000;
0002131b              FindSaturation_FirstLast(pCam, pTrig_1, (uint32_t)TriggerLevel_1, 0x384, 10f, 
0002131b                  startPix, stopPix, rawEdges_1, numEdges_1, 1, 
0002131b                  *(uint8_t*)((char*)r10_2 + 0x32dc), &nSatPix, &satStart, &satStop);
0002129c          }
0002129c          
00021329          if (-362.853973f <= (uint32_t)zmm6 || nSatPix <= 0)
00021329          {
00021360              if (!numEdges_1)
00021360              {
00021362                  pContext->prevCamNumEdges = 0;
00020e67                  return 0;
00021360              }
00021360              
00021373              edge = interpolatedEdges_1[(uint64_t)(numEdges_1 - 1)];
00021329          }
00021329          else
00021329          {
00021343              edge = (float)(uint64_t)satStop * 2f - 512f;
00021343              
0002134e              if (numEdges_1)
0002134e              {
00021350                  uint64_t rax_47 = (uint64_t)(numEdges_1 - 1);
00021350                  
00021359                  if (!(edge > interpolatedEdges_1[rax_47]))
00021373                      edge = interpolatedEdges_1[rax_47];
0002134e              }
00021329          }
00021329          
00021378          int64_t rdx_14;
00021378          (uint8_t)rdx_14 = (uint8_t)Cam_2;
0002138a          zmm10 = FE_Linearize(pContext, (uint8_t)rdx_14, edge);
00021397          focalLength_1 = (uint128_t)pContext->settings.focalLength;
0002139c          uint128_t zmm0_6 = _mm_cvtepi32_ps((uint128_t)arg_10);
0002139f          focalLength_1 = _mm_cvtepi32_ps(focalLength_1);
000213a3          (uint32_t)zmm0_6 = (uint32_t)zmm0_6 * (uint32_t)zmm6;
000213cd          uint128_t zmm0_8;
000213cd          float zmm6_2;
000213cd          int512_t zmm7;
000213cd          zmm0_8 = _safeTan(_divide((uint32_t)zmm0_6, (uint32_t)focalLength_1)
000213cd              + 0.785398185f
000213cd              + (&pContext->settings.sensorInfo[0].rotation_offset)[rax_16]);
000213df          (uint128_t)zmm7 = zmm0_8;
000213e9          (uint32_t)zmm0_8 = _mm_cvtepi32_ps((uint128_t)-(arg_10)) * (uint32_t)zmm10;
00021408          float slope0_1;
00021408          slope0_1 = _safeTan(_divide((uint32_t)zmm0_8, (uint32_t)focalLength_1) + zmm6_2
00021408              + (&pContext->settings.sensorInfo[0].rotation_offset)[rax_14]);
00021410          p1.x = rdi_2.x;
00021410          p1.y = rdi_2.y;
00021413          struct fpoint_t p0;
00021413          p0.x = (uint32_t)p0_1;
00021413          p0.y = *(uint32_t*)((char*)p0_1)[4];
00021419          relSlopes_1 = PointSlopeTriangulate(p0, slope0_1, p1, (uint32_t)focalLength);
0002116a      label_2116a:
0002116a          p0_2 = relSlopes_1;
00021172          float zmm1_4[0x4] = *(uint32_t*)((char*)p0_2)[4];
0002117b          float zmm5_1[0x4] = (uint32_t)p0_2;
00021184          zmm1_4[0] = zmm1_4[0] - (uint32_t)zmm14;
00021189          zmm5_1[0] = zmm5_1[0] - (uint32_t)zmm13;
0002118e          zmm1_4 = _mm_unpacklo_ps(zmm1_4, *(uint64_t*)&zmm1_4[0]);
0002119c          float zmm3_2 = (float)_mm_and_pd(
0002119c              _mm_cvtps_pd(_mm_unpacklo_ps(zmm5_1, *(uint64_t*)&zmm5_1[0])[0]), zmm12)[0];
000211a0          uint64_t zmm0_5[0x2] = _mm_cvtps_pd(*(uint64_t*)&zmm1_4[0]);
000211a7          zmm9[0] = zmm9[0] * 120f;
000211b7          edge = (float)_mm_and_pd(zmm0_5, zmm12)[0];
000211b7          
000211bb          if (!(zmm9[0] <= zmm3_2))
000211bb          {
000211bd              zmm0_5 = zmm9;
000211c1              zmm0_5[0] = zmm0_5[0] * 85f;
000211c1              
000211cc              if (!(zmm0_5[0] <= edge))
000211ce                  var_1ac = 1;
000211bb          }
000211bb          
000211d3          zmm9[0] = zmm9[0] * 40f;
000211d3          
000211ea          if (zmm9[0] <= zmm3_2 || zmm9[0] <= edge)
000211ea          {
00021430              (uint8_t)relSlopes_1 = 0;
00021434              goto label_21437;
000211ea          }
000211ea          
000211f4          if (numEdges_1 != 4)
000211f4              goto label_21244;
000211f4          
000211f6          relSlopes_1 = relSlopes;
000211f6          
0002120e          if (relSlopes_1[1][0] > 0.5f)
0002120e          {
00021235              if (pContext->edges[rdx_6].Num_Edges != 4 || nSatPix)
0002122d                  goto label_21244;
0002120e          }
0002120e          else if (relSlopes_1[2][0] <= 0.5f || pContext->edges[rdx_6].Num_Edges != 4
0002120e                  || nSatPix)
00021218              goto label_21244;
00021218          
00021237          bInnerNearfield = 0;
0002123c          goto label_21563;
00020f48      }
00020f48      
00020f52      if (p1.x == 3)
00020f52      {
00020f58          zmm1 = 0x3fcccccd;
00020f58          
00020f69          if (!(uint8_t)Cam_2 || (uint8_t)Cam_2 == 2)
00020f69          {
00020f7b              arg_10 = 0xffffffff;
00020f83              (uint8_t)relSlopes_1 = 0;
00020f69          }
00020f69          else
00020f69          {
00020f6b              (uint8_t)relSlopes_1 = (uint8_t)pTrig;
00020f6e              arg_10 = 1;
00020f76              (uint8_t)relSlopes_1 -= 1;
00020f69          }
00020f69          
00020f86          zmm0[0] = pContext->settings.panelSize.y;
00020f86          zmm0[1] = pContext->settings.triggers.thresholdUp;
00020f86          *(uint16_t*)((char*)zmm0[1])[2] = pContext->settings.triggers.thresholdDown;
00020f86          zmm0[2] = pContext->settings.triggers.thresholdFloor;
00020f86          *(uint16_t*)((char*)zmm0[2])[2] =
00020f86              *(uint16_t*)((char*)pContext->settings.triggers + 6);
00020f86          zmm0[3] = pContext->settings.panelSize.y;
00020f8e          zmm0[0] - 0f;
00020f8e          
00020f97          if (FCMP_UO(zmm0[0], 0f) || !(zmm0[0] == 0f))
00020f97          {
00020f99              zmm1[0] = pContext->settings.panelSize.x;
00020f99              *(uint32_t*)((char*)zmm1[0])[4] = pContext->settings.panelSize.x;
00020f99              zmm1[1] = pContext->settings.triggers.thresholdUp;
00020f99              *(uint16_t*)((char*)zmm1[1])[2] = pContext->settings.triggers.thresholdDown;
00020f99              *(uint16_t*)((char*)zmm1[1])[4] = pContext->settings.triggers.thresholdFloor;
00020f99              *(uint16_t*)((char*)zmm1[1])[6] =
00020f99                  *(uint16_t*)((char*)pContext->settings.triggers + 6);
00020fa1              zmm1[0] = zmm1[0] / zmm0[0];
00020f97          }
00020f97          
00020fbe          rawEdges_1 = rawEdges;
00020fd0          zmm1[0] = zmm1[0] * 2f;
00020fd4          zmm1[0] = zmm1[0] * 25f;
00020fdc          zmm12 =
00020fdc              pContext->edges[0].Lin_Edges[rdx_6 * 0x1a + (uint64_t)(uint8_t)relSlopes_1];
00020fe6          zmm1[0] = zmm1[0] - 512f;
00020ff5          zmm1[0] = zmm1[0] * 0.785398185f;
00020ffd          int64_t rdx_11;
00020ffd          
00020ffd          if (!(zmm1[0] <= (zmm12 ^ __mask@@NegFloat@)[0]))
00020ffd          {
00021054              var_1e0 = 1;
00021075              (uint32_t)var_208 = 0x41200000;
0002107c              rdx_11 = FindSaturation_FirstLast(pCam, pTrig_1, (uint32_t)TriggerLevel_1, 
0002107c                  0x384, 10f, startPix, stopPix, rawEdges_1, numEdges_1, 1, 
0002107c                  *(uint8_t*)((char*)r10_2 + 0x32dc), &nSatPix, &satStart, &satStop);
00020ffd          }
00020ffd          
0002108a          if (zmm1[0] <= (zmm12 ^ __mask@@NegFloat@)[0] || nSatPix <= 0)
0002108a          {
000210ba              if (!numEdges_1)
000210ba              {
00021362                  pContext->prevCamNumEdges = 0;
00020e67                  return 0;
000210ba              }
000210ba              
000210c0              edge = *(uint32_t*)interpolatedEdges_1;
0002108a          }
0002108a          else
0002108a          {
000210a0              edge = (float)(uint64_t)satStart * 2f - (uint32_t)focalLength;
000210a0              
000210a7              if (numEdges_1)
000210a7              {
000210a9                  float edge_1 = *(uint32_t*)interpolatedEdges_1;
000210a9                  
000210b0                  if (!(edge_1 > edge))
000210b2                      edge = edge_1;
000210a7              }
0002108a          }
0002108a          
000210c4          (uint8_t)rdx_11 = (uint8_t)Cam_2;
000210d6          focalLength_1 = FE_Linearize(pContext, (uint8_t)rdx_11, edge);
000210e3          focalLength = (uint128_t)pContext->settings.focalLength;
000210ed          uint128_t zmm0_1;
000210ed          (uint32_t)zmm0_1 = _mm_cvtepi32_ps((uint128_t)arg_10) * (uint32_t)zmm12;
00021110          uint128_t zmm0_3;
00021110          int512_t zmm6_1;
00021110          float b;
00021110          zmm0_3 = _safeTan(_divide((uint32_t)zmm0_1, _mm_cvtepi32_ps(focalLength))
00021110              + 0.785398185f
00021110              + (&pContext->settings.sensorInfo[0].rotation_offset)[rax_16]);
00021121          (uint128_t)zmm6_1 = zmm0_3;
0002112b          (uint32_t)zmm0_3 =
0002112b              _mm_cvtepi32_ps((uint128_t)-(arg_10)) * (uint32_t)focalLength_1;
0002114b          float slope0;
0002114b          slope0 = _safeTan(_divide((uint32_t)zmm0_3, b) + 0.785398185f
0002114b              + (&pContext->settings.sensorInfo[0].rotation_offset)[rax_14]);
00021153          p1.x = rdi_2.x;
00021153          p1.y = rdi_2.y;
0002115c          relSlopes_1 = PointSlopeTriangulate(p0_1, slope0, p1, (uint32_t)zmm6);
00021161          zmm12 = 0x7fffffffffffffff;
00021161          goto label_2116a;
00020f52      }
00020f52      
00021423      rawEdges_1 = rawEdges;
0002142b  label_2142b:
0002142b      (uint8_t)relSlopes_1 = 0;
00021437  label_21437:
00021437      
0002143a      if (numEdges_1 <= 0)
0002143a          goto label_21487;
0002143a      
0002143f      uint32_t result;
0002143f      uint16_t var_200;
0002143f      uint16_t var_1f8;
0002143f      float* var_1f0;
0002143f      
0002143f      if (!(uint8_t)relSlopes_1)
0002143f      {
000214ed      label_214ed:
000214ed          
000214f0          if (!numEdges_1)
000214f0          {
00021362              pContext->prevCamNumEdges = 0;
00020e67              return 0;
000214f0          }
000214f0          
000214f9          if ((uint8_t)relSlopes_1)
000214f9          {
00021502              (uint8_t)pTrig = var_1a0;
0002150a              uint8_t camPos2;
0002150a              camPos2 = rdi_2.x;
0002150a              *(uint32_t*)((char*)camPos2)[4] = rdi_2.y;
0002150f              var_1e0 = p0_1;
0002151f              (uint32_t)var_1f0 = startAperture;
0002152b              p1.x = (uint8_t)Cam_2;
0002152e              var_1f8 = pCam;
00021539              var_200 = interpolatedEdges_1;
00021543              relSlopes_1 = ExtendInnerNearfieldEdges(pContext, numEdges_1, p1.x, 
00021543                  (uint8_t)pTrig, rawEdges_1, var_200, var_1f8, (uint32_t)var_1f0, 
00021543                  stopAperture, var_1e0, camPos2);
00021548              numEdges_1 = (uint32_t)relSlopes_1;
0002154b              numEdges = (uint32_t)relSlopes_1;
000214f9          }
000214f9          
00021559          char r12_1;
00021559          
00021559          if (numEdges_1 > 2)
00021559          {
0002155b              relSlopes_1 = relSlopes;
00021563          label_21563:
00021563              r12_1 = var_1ac;
00021563              
0002156b              if (r12_1)
0002156b              {
00021584                  var_1f8 = relSlopes_1;
00021591                  var_200 = interpolatedEdges_1;
0002159b                  MinMaxPixelFilter(pCam, startAperture, stopAperture, &numEdges, 
0002159b                      rawEdges_1, var_200, var_1f8);
0002156b              }
0002156b              
0002156b              goto label_215a7;
00021559          }
00021559          
000215a2          r12_1 = var_1ac;
000215a7      label_215a7:
000215a7          (uint8_t)relSlopes_1 = bInnerNearfield;
000215b8          (uint8_t)var_1f8 = (uint8_t)relSlopes_1;
000215bc          (uint8_t)var_200 = r12_1;
000215e4          uint8_t r11_2 = ReduceNumOfEdges(&numEdges, relSlopes, rawEdges_1, 
000215e4              interpolatedEdges_1, &iEdgeSelected, (uint8_t)var_200, (uint8_t)var_1f8, 0);
000215e7          result = numEdges;
000215e7          
000215fc          if (var_1ac == 1 && result == 4)
000215fc          {
00021612              if (pContext->edges[rdx_6].Num_Edges == 2)
00021612              {
00021614                  float zmm0_10[0x4] = pContext->edges[rdx_6].Lin_Edges[1];
0002161d                  zmm0_10[0] = zmm0_10[0] - pContext->edges[rdx_6].Lin_Edges[0];
00021631                  edge = (float)_mm_and_pd(
00021631                      _mm_cvtps_pd(_mm_unpacklo_ps(zmm0_10, *(uint64_t*)&zmm0_10[0])[0]), 
00021631                      zmm12)[0];
00021612              }
00021612              
00021639              if (pContext->edges[rdx_6].Num_Edges != 2 || !(10f > edge))
0002163b                  bSmallStylusTest = 0;
0002163b              
00021646              if (!r11_2 || bSmallStylusTest)
00021646              {
00021677                  uint32_t x = rdi_2.x;
0002167c                  struct fpoint_t camPos1;
0002167c                  camPos1.x = (uint32_t)p0_1;
0002167c                  camPos1.y = *(uint32_t*)((char*)p0_1)[4];
00021681                  (uint8_t)var_1f8 = var_1a0;
00021688                  (uint8_t)var_200 = (uint8_t)Cam_2;
00021697                  r11_2 = PerformNearfieldInnerEdgesDiameterTest(pContext, &numEdges, 
00021697                      interpolatedEdges_1, rawEdges_1, relSlopes, (uint8_t)var_200, 
00021697                      (uint8_t)var_1f8, camPos1, rdi_2.y, bSmallStylusTest, 
00021697                      bInnerNearfield, &iEdgeSelected);
0002169a                  result = numEdges;
0002169a                  
000216a4                  if (result == 4)
000216a4                      goto label_216a6;
00021646              }
00021646              else
00021646              {
000216a6              label_216a6:
000216a6                  
000216a9                  if (!r11_2)
000216a9                  {
000216c3                      var_1f8 = &numEdges;
000216d3                      var_200 = &iEdgeSelected;
000216e0                      NearfieldInnerEdgesCorrelationTest(pCam, pTrig_1, relSlopes, 
000216e0                          rawEdges_1, interpolatedEdges_1, var_200, var_1f8);
000216e5                      result = numEdges;
000216a9                  }
00021646              }
000215fc          }
0002143f      }
0002143f      else
0002143f      {
0002146a          var_1f8 = rawEdges_1;
0002146f          var_200 = (uint32_t)TriggerLevel_1;
00021476          (uint32_t)var_208 = numEdges_1;
0002147b          relSlopes_1 = SeachForInnerNearfieldExtraOutsideEdges(pCam, pTrig_1, 
0002147b              startAperture, stopAperture, (uint32_t)var_208, var_200, var_1f8, 
0002147b              interpolatedEdges_1);
00021480          (uint8_t)relSlopes_1 = bInnerNearfield;
00021487      label_21487:
00021487          
00021492          if (!(uint8_t)relSlopes_1 || nSatPix <= 0)
0002148a              goto label_214ed;
0002148a          
0002149b          (uint8_t)rdx_6 = var_1a0;
000214a9          var_1e0 = stopAperture;
000214c5          (uint32_t)var_1f0 = satStart;
000214d1          var_1f8 = relSlopes;
000214d6          var_200 = &pContext->nearfieldData.bTouchInCorner;
000214db          uint8_t (* rcx_19)[0x4];
000214db          (uint8_t)rcx_19 = (uint8_t)Cam_2;
000214e3          result = ChangeEdgesForSaturatedWaveformsInInnerNearfield((uint8_t)rcx_19, 
000214e3              (uint8_t)rdx_6, numEdges_1, rawEdges_1, interpolatedEdges_1, var_200, 
000214e3              var_1f8, (uint32_t)var_1f0, satStop, var_1e0);
0002143f      }
000216ec      pContext->prevCamNumEdges = result;
00021744      return result;
0002083c  }

00021745                 cc cc cc cc cc cc cc                                                                   .......

0002174c    void MinMaxPixelFilter(uint16_t* pCam, uint32_t Start, uint32_t End, uint32_t* numEdges, int32_t* rawEdges, float* interpolatedEdges, float* relSlopes)

0002174c  {
0002176f      void var_78;
0002176f      int64_t rax_1 = __security_cookie ^ &var_78;
00021777      uint32_t r12 = *(uint32_t*)numEdges;
00021782      float* interpolatedEdges_1 = interpolatedEdges;
0002179a      uint32_t Start_1 = Start;
000217a9      void var_50;
000217a9      
000217a9      if (r12)
000217a9      {
000217b2          (uint8_t)Start = 1;
000217b5          memset(&var_50, Start, (uint64_t)r12);
000217ba          Start = Start_1;
000217a9      }
000217a9      
000217c3      int32_t r10 = 1;
000217c6      int64_t rcx_1 = 1;
000217c6      
000217cb      if (r12 - 2 > 1)
000217cb      {
000217d9          void* r9 = &rawEdges[2];
000217d9          
000217e1          while (true)
000217e1          {
000217e1              int32_t rax_3 = rawEdges[rcx_1];
000217e1              
000217e6              if (rax_3 != Start)
000217e6              {
000217ec                  int32_t rdx = *(uint32_t*)r9;
000217ec                  
000217f2                  if (rdx == End)
00021896                      Start = Start_1;
000217f2                  else if (rax_3 <= 0xc8)
000217fd                  {
0002180f                      if (rdx - rax_3 < 0x14)
0002180f                          goto label_21815;
0002180f                      
00021896                      Start = Start_1;
000217fd                  }
000217fd                  else if (rax_3 < 0x12c || rdx - rax_3 >= 0x14)
00021896                      Start = Start_1;
0002180f                  else
0002180f                  {
00021815                  label_21815:
00021815                      int64_t r11_1 = (int64_t)rawEdges[rcx_1];
0002181e                      int16_t rdx_2 = pCam[r11_1];
00021823                      int16_t r8_1 = pCam[(int64_t)*(uint16_t*)r9];
00021828                      uint32_t rbp_1 = (uint32_t)rdx_2;
00021828                      
0002182f                      if (rdx_2 >= r8_1)
00021831                          rbp_1 = (uint32_t)r8_1;
00021831                      
00021835                      uint32_t r8_2;
00021835                      
00021835                      r8_2 =
00021835                          rdx_2 < r8_1 || rdx_2 <= r8_1 ? (uint32_t)r8_1 : (uint32_t)rdx_2;
00021835                      
00021841                      *(uint8_t*)(&var_50 + rcx_1) = 0;
00021846                      char var_4f[0x1f];
00021846                      var_4f[rcx_1] = 0;
00021846                      
0002185f                      while (true)
0002185f                      {
0002185f                          (uint16_t)r11_1 += 1;
0002185f                          
00021867                          if ((uint16_t)r11_1 >= *(uint16_t*)r9)
00021867                              break;
00021867                          
00021851                          uint32_t rdx_3 = (uint32_t)pCam[(int64_t)(uint16_t)r11_1];
00021851                          
0002185d                          if (rdx_3 >= rbp_1 && rdx_3 <= r8_2)
0002185d                              continue;
0002185d                          
0002188a                          *(uint8_t*)(&var_50 + rcx_1) = 1;
0002188f                          var_4f[rcx_1] = 1;
00021894                          break;
0002185f                      }
0002185f                      
00021873                      Start = Start_1;
00021873                      
00021877                      if (!*(uint8_t*)(&var_50 + rcx_1))
00021877                      {
00021879                          r10 += 1;
0002187c                          rcx_1 += 1;
0002187f                          r9 += 4;
00021877                      }
0002180f                  }
000217e6              }
000217e6              
0002189a              r10 += 1;
0002189d              rcx_1 += 1;
000218a0              r9 += 4;
000218a0              
000218a7              if (r10 >= r12 - 2)
000218a7                  break;
000217e1          }
000217e1          
000218ad          r12 = *(uint32_t*)numEdges;
000217cb      }
000217cb      
000218b0      uint32_t rdx_4 = 0;
000218b2      int32_t i = 0;
000218b2      
000218b8      if (r12)
000218b8      {
000218ba          int32_t* rsi_1 = (char*)rawEdges - interpolatedEdges_1;
000218bd          void* r9_1 = &var_50;
000218c2          float* interpolatedEdges_2 = interpolatedEdges_1;
000218c5          int32_t* r13_1 = (char*)relSlopes - interpolatedEdges_1;
000218c5          
000218f5          do
000218f5          {
000218cc              if (*(uint8_t*)r9_1)
000218cc              {
000218d1                  rdx_4 += 1;
000218d3                  *(uint32_t*)((char*)rsi_1 + interpolatedEdges_1) =
000218d3                      *(uint32_t*)((char*)rsi_1 + interpolatedEdges_2);
000218d8                  *(uint32_t*)interpolatedEdges_1 = *(uint32_t*)interpolatedEdges_2;
000218df                  *(uint32_t*)((char*)r13_1 + interpolatedEdges_1) =
000218df                      *(uint32_t*)((char*)r13_1 + interpolatedEdges_2);
000218e4                  interpolatedEdges_1 = &interpolatedEdges_1[1];
000218cc              }
000218cc              
000218e8              i += 1;
000218eb              r9_1 += 1;
000218ee              interpolatedEdges_2 = &interpolatedEdges_2[1];
000218f5          } while (i < *(uint32_t*)numEdges);
000218b8      }
000218b8      
000218f7      *(uint32_t*)numEdges = rdx_4;
00021901      __security_check_cookie(rax_1 ^ &var_78);
0002174c  }

00021924              cc cc cc cc cc cc cc cc                                                                  ........

0002192c    void NearfieldInnerEdgesCorrelationTest(uint16_t* pCam, uint16_t* pTrig, float* relSlopes, int32_t* rawEdges, float* interpolatedEdges, uint32_t* iEdgeSelected, uint32_t* numEdgesRet)

0002192c  {
00021948      int32_t r11 = rawEdges[2];
0002194c      int128_t zmm6;
0002194c      int128_t var_38 = zmm6;
00021950      int128_t zmm7;
00021950      int128_t var_48 = zmm7;
00021957      int32_t rcx = rawEdges[1];
0002195e      uint128_t zmm8;
0002195e      uint128_t var_58 = zmm8;
00021963      uint128_t zmm9;
00021963      uint128_t var_68 = zmm9;
00021968      int32_t r10_1 = r11 - rcx;
00021975      int32_t rdx;
00021975      int16_t r8;
00021975      
00021975      if (r10_1 >= 8)
00021975      {
0002198b          r8 = 4;
0002199e          (uint8_t)rdx = (r10_1 / 0xa) + 1;
00021975      }
00021975      else
00021975      {
0002197a          int32_t temp2_1;
0002197a          int32_t temp3_1;
0002197a          temp2_1 = HIGHD((int64_t)r10_1);
0002197a          temp3_1 = LOWD((int64_t)r10_1);
0002197d          (uint8_t)rdx = 0x64;
00021981          r8 = (int16_t)((temp3_1 - temp2_1) >> 1);
00021975      }
00021975      
000219a3      int32_t r10_2 = (int32_t)r8;
000219aa      int32_t r8_1 = r10_2 + rcx;
000219b1      int32_t rcx_1 = 0;
000219b4      int64_t rax_6 = (int64_t)r8_1;
000219b7      int32_t zmm4 = (int32_t){0};
000219be      void* rbx_1 = &pTrig[rax_6];
000219be      
000219c5      if (r8_1 > r11 - r10_2)
00021ada          zmm4 = (int32_t){0};
000219c5      else
000219c5      {
000219d7          int32_t r12_2 = rawEdges[2] - r10_2;
000219dd          void* r13_1 = &pCam[rax_6] - rbx_1;
000219dd          
00021abe          do
00021abe          {
000219e0              void* rdi_1 = (char*)rbx_1 - 6;
000219e4              int16_t rdx_3 = 0;
000219e8              int16_t r10_3 = 0;
000219ec              void* rax_7 = rdi_1;
000219ef              int64_t i_3 = 7;
00021a07              int64_t i;
00021a07              
00021a07              do
00021a07              {
000219f5                  rdx_3 += *(uint16_t*)((char*)r13_1 + rax_7);
000219fb                  r10_3 += *(uint16_t*)rax_7;
000219ff                  rax_7 += 2;
00021a03                  i = i_3;
00021a03                  i_3 -= 1;
00021a07              } while (i != 1);
00021a0c              float zmm3 = (int32_t){0};
00021a0f              zmm7 = {0};
00021a12              uint64_t i_2 = (uint64_t)(uint32_t)(i_3 + 7);
00021a1f              zmm6 = {0};
00021a2b              (uint32_t)zmm8 = _mm_cvtepi32_ps((uint128_t)rdx_3) * 0.142857149f;
00021a38              (uint32_t)zmm9 = _mm_cvtepi32_ps((uint128_t)r10_3) * 0.142857149f;
00021a85              uint64_t i_1;
00021a85              
00021a85              do
00021a85              {
00021a47                  uint128_t zmm2 = (uint128_t)*(uint16_t*)((char*)r13_1 + rdi_1);
00021a4b                  uint32_t rax_11 = (uint32_t)*(uint16_t*)rdi_1;
00021a4e                  rdi_1 += 2;
00021a52                  i_1 = i_2;
00021a52                  i_2 -= 1;
00021a5d                  (uint32_t)zmm2 = _mm_cvtepi32_ps(zmm2) - (uint32_t)zmm8;
00021a65                  uint128_t zmm1;
00021a65                  (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)rax_11) - (uint32_t)zmm9;
00021a6a                  float zmm0 = (uint32_t)zmm1;
00021a6d                  (uint32_t)zmm1 = (uint32_t)zmm1 * (uint32_t)zmm1;
00021a71                  zmm0 = zmm0 * (uint32_t)zmm2;
00021a75                  (uint32_t)zmm2 = (uint32_t)zmm2 * (uint32_t)zmm2;
00021a79                  (uint32_t)zmm6 = (uint32_t)zmm6 + (uint32_t)zmm1;
00021a7d                  (uint32_t)zmm7 = (uint32_t)zmm7 + (uint32_t)zmm2;
00021a81                  zmm3 = zmm3 + zmm0;
00021a85              } while (i_1 != 1);
00021a85              
00021a8f              if (!((uint32_t)zmm7 <= 0f) && !((uint32_t)zmm6 <= 0f))
00021a8f              {
00021a91                  bool cond:1_1 = zmm3 <= 0f;
00021a98                  (uint32_t)zmm6 = (uint32_t)zmm6 * (uint32_t)zmm7;
00021a9c                  zmm3 = zmm3 * zmm3 / (uint32_t)zmm6;
00021a9c                  
00021aa0                  zmm4 = cond:1_1 ? zmm4 + 0f - zmm3 : zmm4 + zmm3;
00021a8f              }
00021a8f              
00021ab3              r8_1 += (int32_t)(uint8_t)rdx;
00021ab6              rcx_1 += 1;
00021ab8              rbx_1 += (int64_t)(uint8_t)rdx * 2;
00021abe          } while (r8_1 <= r12_2);
00021abe          
00021ac7          zmm4 = rcx_1 <= 0 ? (int32_t){0} : zmm4 / (float)(uint64_t)rcx_1;
000219c5      }
000219c5      
00021ae8      if (0.5f <= zmm4)
00021ae8          return;
00021ae8      
00021afa      *(uint32_t*)numEdgesRet = 2;
00021b04      rawEdges[1] = rawEdges[3];
00021b0b      interpolatedEdges[1] = interpolatedEdges[3];
00021b19      relSlopes[1] = relSlopes[3];
00021b1f      iEdgeSelected[1] = iEdgeSelected[3];
0002192c  }

00021b54                                                              cc cc cc cc cc cc cc cc                                  ........

00021b5c    struct fpoint_t PointSlopeTriangulate(struct fpoint_t p0, float slope0, struct fpoint_t p1, float slope1)

00021b5c  {
00021b5c      int64_t arg_18;
00021b5c      (uint32_t)arg_18 = p1.x;
00021b5c      *(uint32_t*)((char*)arg_18)[4] = p1.y;
00021b61      int64_t arg_8;
00021b61      (uint32_t)arg_8 = p0.x;
00021b61      *(uint32_t*)((char*)arg_8)[4] = p0.y;
00021b6a      double zmm2 = 1000000.0;
00021b72      float zmm4[0x4] = slope0;
00021b75      slope0 = nanf;
00021b7d      float temp0 = _mm_unpacklo_ps(slope1, slope1);
00021b80      float temp0_1[0x4] = _mm_unpacklo_ps(zmm4, *(uint64_t*)&zmm4[0]);
00021b8a      bool cond:0 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_1[0]), slope0)[0] <= zmm2;
00021b91      float zmm0[0x4] = _mm_and_pd(_mm_cvtps_pd(temp0), slope0);
00021b95      float var_18;
00021b95      float var_14;
00021b95      
00021b95      if (cond:0)
00021b95      {
00021bc9          zmm2 = 1000000f;
00021bc9          
00021bd8          if ((float)*(uint64_t*)&zmm0[0] <= 1000000f)
00021bd8          {
00021bfd              temp0_1[0] - temp0;
00021bfd              
00021c02              if (FCMP_UO(temp0_1[0], temp0) || temp0_1[0] != temp0)
00021c02              {
00021c0b                  zmm0 = (uint32_t)arg_8;
00021c1d                  zmm0[0] = zmm0[0] * temp0_1[0];
00021c25                  (uint32_t)zmm2 =
00021c25                      *(uint32_t*)((char*)arg_18)[4] - *(uint32_t*)((char*)arg_8)[4];
00021c2b                  (uint32_t)zmm2 = (uint32_t)zmm2 + zmm0[0];
00021c32                  (uint32_t)zmm2 = (uint32_t)zmm2 - (uint32_t)arg_18 * temp0;
00021c36                  temp0_1[0] = temp0_1[0] - temp0;
00021c3a                  (uint32_t)zmm2 = (uint32_t)zmm2 / temp0_1[0];
00021c3e                  var_18 = (uint32_t)zmm2;
00021c43                  (uint32_t)zmm2 = (uint32_t)zmm2 - (uint32_t)arg_8;
00021c49                  (uint32_t)zmm2 = (uint32_t)zmm2 * temp0_1[0];
00021c4d                  (uint32_t)zmm2 = (uint32_t)zmm2 + *(uint32_t*)((char*)arg_8)[4];
00021c02              }
00021c02              else
00021c04                  var_18 = 1000000f;
00021c04              
00021c53              int32_t var_14_1 = (uint32_t)zmm2;
00021bd8          }
00021bd8          else
00021bd8          {
00021bda              zmm0 = (uint32_t)arg_18;
00021be0              var_18 = zmm0[0];
00021be5              zmm0[0] = zmm0[0] - (uint32_t)arg_8;
00021beb              zmm0[0] = zmm0[0] * temp0_1[0];
00021bef              zmm0[0] = zmm0[0] + *(uint32_t*)((char*)arg_8)[4];
00021bf5              var_14 = zmm0[0];
00021bd8          }
00021b95      }
00021b95      else
00021b95      {
00021b9b          if (*(uint64_t*)&zmm0[0] <= zmm2)
00021b9b          {
00021bac              zmm0 = (uint32_t)arg_8;
00021bb2              var_18 = zmm0[0];
00021bb7              zmm0[0] = zmm0[0] - (uint32_t)arg_18;
00021bbd              zmm0[0] = zmm0[0] * temp0;
00021bc1              zmm0[0] = zmm0[0] + *(uint32_t*)((char*)arg_18)[4];
00021b9b          }
00021b9b          else
00021b9b          {
00021b9d              zmm0 = 0x49742400;
00021ba5              var_18 = 1000000f;
00021b9b          }
00021b9b          
00021bf5          var_14 = zmm0[0];
00021b95      }
00021c61      return var_18;
00021b5c  }

00021c62        cc cc cc cc cc cc                                                                            ......

00021c68    void FindSaturation_FirstLast(uint16_t* pCam1, uint16_t* pTrig1, float TriggerLevel, uint16_t satThreshold, float d2SatThreshold, uint16_t startPix, uint16_t stopPix, int32_t* rawEdges, uint32_t numEdges, uint8_t bTouch, uint8_t bCamSaturated, uint16_t* nSatPix, uint32_t* satStart, uint32_t* satStop)

00021c68  {
00021c9b      int128_t zmm7 = TriggerLevel;
00021c9e      float zmm3 = TriggerLevel * 0.699999988f;
00021cab      uint16_t satThreshold_1 = satThreshold;
00021cb2      *(uint16_t*)nSatPix = 0;
00021cb5      int16_t r13 = 0;
00021cb9      uint16_t stopPix_2 = 0;
00021cbd      int64_t rdi;
00021cbd      (uint16_t)rdi = 0;
00021cc0      int64_t rbp;
00021cc0      (uint16_t)rbp = 0;
00021cc3      uint64_t rcx = 0;
00021cc6      int16_t arg_20 = 0;
00021cc6      
00021cce      if (numEdges > 0)
00021cd0          stopPix_2 = *(uint16_t*)rawEdges;
00021cd0      
00021cdf      uint128_t zmm0;
00021cdf      (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)satThreshold_1) * 0.300000012f;
00021ce7      int16_t rax_2 = (int16_t)(int64_t)(uint32_t)zmm0;
00021cfd      int64_t r12;
00021cfd      
00021cfd      if (bTouch)
00021cfd      {
00021d0c          if (bCamSaturated)
00021d0e              satThreshold_1 = 0x2710;
00021d0e          
00021d14          r12 = 5;
00021cfd      }
00021cfd      else
00021cff          (uint16_t)r12 = 4;
00021cff      
00021d1a      uint64_t startPix_1 = (uint64_t)startPix;
00021d29      uint32_t rdx = (uint32_t)(uint16_t)startPix_1;
00021d30      int16_t* r8_1 = &pCam1[startPix_1];
00021d33      void* rbx_1 = &pTrig1[startPix_1];
00021d39      TriggerLevel = d2SatThreshold * 2f;
00021d39      
00021d47      if ((uint16_t)startPix_1 > stopPix)
00021d47          return;
00021d47      
00021ea5      do
00021ea5      {
00021d5c          int16_t rax_5 = *(uint16_t*)r8_1 * 2 - r8_1[-1];
00021d66          int32_t rax_6 = (int32_t)(rax_5 - r8_1[1]);
00021d67          uint128_t zmm1;
00021d67          
00021d67          if (rax_5 - r8_1[1] >= 0)
00021d67          {
00021d89              (uint32_t)zmm0 = TriggerLevel * 0.949999988f;
00021d90              (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)rax_6) * 0.0500000007f;
00021d9b              TriggerLevel = (uint32_t)zmm1 + (uint32_t)zmm0;
00021d67          }
00021d67          else
00021d67          {
00021d74              (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)rax_6) * 0.0500000007f;
00021d7c              TriggerLevel = TriggerLevel * 0.949999988f - (uint32_t)zmm0;
00021d67          }
00021d67          
00021da2          if (d2SatThreshold <= TriggerLevel)
00021e53              rbp = 0;
00021da2          else if (*(uint16_t*)r8_1 > satThreshold_1)
00021dac          {
00021ddb          label_21ddb:
00021ddb              (uint16_t)rbp += 1;
00021ddb              
00021de2              if ((uint16_t)rbp > (uint16_t)r12)
00021de2              {
00021de9                  if (!(uint16_t)rdi)
00021de9                  {
00021def                      if ((uint16_t)rdx >= 0x1e)
00021def                      {
00021df1                          rcx = (uint64_t)(rdx - 0x1e);
00021df4                          arg_20 = (uint16_t)rcx;
00021def                      }
00021def                      
00021dfd                      if (*(uint16_t*)r8_1 <= satThreshold_1)
00021e02                          zmm3 = (uint32_t)zmm7 * 0.829999983f;
00021de9                  }
00021de9                  
00021e12                  (uint16_t)rdi += 1;
00021e12                  
00021e18                  if ((uint16_t)rdi > *(uint16_t*)nSatPix)
00021e18                  {
00021e20                      *(uint16_t*)nSatPix = (uint16_t)rdi;
00021e23                      uint32_t rcx_1 = (uint32_t)(uint16_t)rcx;
00021e23                      
00021e2a                      if ((uint16_t)startPix_1 > arg_20)
00021e2a                          rcx_1 = (uint32_t)(uint16_t)startPix_1;
00021e2a                      
00021e35                      *(uint32_t*)satStart = rcx_1;
00021e37                      uint32_t stopPix_1 = (uint32_t)stopPix;
00021e3f                      uint32_t stopPix_3 = (uint32_t)(uint16_t)rdx + 0x14;
00021e3f                      
00021e44                      if (stopPix_1 < stopPix_3)
00021e44                          stopPix_3 = stopPix_1;
00021e44                      
00021e4f                      *(uint32_t*)satStop = stopPix_3;
00021e18                  }
00021de2              }
00021dac          }
00021dac          else if (*(uint16_t*)r8_1 <= rax_2)
00021e53              rbp = 0;
00021db7          else
00021db7          {
00021dc8              zmm0 = (uint128_t)*(uint16_t*)rbx_1;
00021dcf              (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)r8_1) * zmm3;
00021dcf              
00021dd9              if (!((uint32_t)zmm1 <= _mm_cvtepi32_ps(zmm0)))
00021dd9                  goto label_21ddb;
00021dd9              
00021e53              rbp = 0;
00021db7          }
00021db7          
00021e68          if (numEdges > 0 && (uint32_t)(uint16_t)rdx > (uint32_t)stopPix_2 + 0xa)
00021e68          {
00021e70              rdi = 0;
00021e70              
00021e78              if ((uint32_t)r13 >= numEdges - 1)
00021e89                  stopPix_2 = stopPix;
00021e78              else
00021e78              {
00021e7a                  r13 += 1;
00021e82                  stopPix_2 = rawEdges[(uint64_t)r13];
00021e78              }
00021e68          }
00021e68          
00021e8f          (uint16_t)rcx = arg_20;
00021e94          (uint16_t)rdx += 2;
00021e98          r8_1 = &r8_1[2];
00021e9c          rbx_1 += 4;
00021ea5      } while ((uint16_t)rdx <= stopPix);
00021c68  }

00021ec7                       cc cc cc cc cc cc cc cc cc                                                         .........

00021ed0    void Find_Saturation(uint16_t* pWaveform, uint16_t startPix, uint16_t stopPix, int32_t* satStart, int32_t* satEnd)

00021ed0  {
00021ef7      *(uint32_t*)satStart = 0xffff8001;
00021efa      *(uint32_t*)satEnd = 0xffff8001;
00021efd      uint32_t r8 = (uint32_t)pWaveform[0xc9];
00021f1f      int16_t temp0;
00021f1f      int16_t temp1;
00021f1f      temp0 = HIGHD((int64_t)(r8 - (uint32_t)pWaveform[0xc8]));
00021f1f      temp1 = LOWD((int64_t)(r8 - (uint32_t)pWaveform[0xc8]));
00021f36      int16_t i = 0xcb;
00021f3a      int16_t r11_2 = (temp1 ^ temp0) - temp0;
00021f3d      int16_t temp2;
00021f3d      int16_t temp3;
00021f3d      temp2 = HIGHD((int64_t)((uint32_t)pWaveform[0xca] - r8));
00021f3d      temp3 = LOWD((int64_t)((uint32_t)pWaveform[0xca] - r8));
00021f44      int16_t r9_2 = (temp3 ^ temp2) - temp2;
00021f44      
00021f88      do
00021f88      {
00021f47          uint64_t i_2 = (uint64_t)i;
00021f55          int16_t temp4_1;
00021f55          int16_t temp5_1;
00021f55          temp4_1 = HIGHD((int64_t)(pWaveform[i_2] - pWaveform[i_2 - 1]));
00021f55          temp5_1 = LOWD((int64_t)(pWaveform[i_2] - pWaveform[i_2 - 1]));
00021f58          int16_t rax_10 = (temp5_1 ^ temp4_1) - temp4_1;
00021f58          
00021f76          if (*(uint32_t*)satStart == 0xffff8001 && rax_10 < 0x64
00021f76              && (r9_2 > 0x12c || r11_2 > 0x12c) && pWaveform[i_2] > 0x320)
00021f76          {
00021f93              *(uint32_t*)satStart = (uint32_t)i - 1;
00021f93              break;
00021f76          }
00021f76          
00021f78          i += 1;
00021f7c          r11_2 = r9_2;
00021f80          r9_2 = rax_10;
00021f88      } while (i <= 0x12c);
00021f88      
00021f95      uint32_t r8_1 = (uint32_t)pWaveform[0x12b];
00021fb1      int16_t temp6;
00021fb1      int16_t temp7;
00021fb1      temp6 = HIGHD((int64_t)((uint32_t)pWaveform[0x12a] - r8_1));
00021fb1      temp7 = LOWD((int64_t)((uint32_t)pWaveform[0x12a] - r8_1));
00021fb8      int16_t i_1 = 0x129;
00021fc1      int16_t r11_5 = (temp7 ^ temp6) - temp6;
00021fc4      int16_t temp8;
00021fc4      int16_t temp9;
00021fc4      temp8 = HIGHD((int64_t)(r8_1 - (uint32_t)pWaveform[0x12c]));
00021fc4      temp9 = LOWD((int64_t)(r8_1 - (uint32_t)pWaveform[0x12c]));
00021fcb      int16_t r9_5 = (temp9 ^ temp8) - temp8;
00021fcb      
0002201b      do
0002201b      {
00021fce          uint64_t i_3 = (uint64_t)i_1;
00021fd2          int16_t rdi_1 = pWaveform[i_3];
00021fdf          int16_t temp10_1;
00021fdf          int16_t temp11_1;
00021fdf          temp10_1 = HIGHD((int64_t)(rdi_1 - pWaveform[i_3 + 1]));
00021fdf          temp11_1 = LOWD((int64_t)(rdi_1 - pWaveform[i_3 + 1]));
00021fe2          int16_t rax_22 = (temp11_1 ^ temp10_1) - temp10_1;
00021fe2          
00021fff          if (*(uint32_t*)satEnd == 0xffff8001 && (r11_5 > 0x12c || r9_5 > 0x12c)
00021fff              && rax_22 < 0x64 && rdi_1 > 0x320)
00021fff          {
00022026              *(uint32_t*)satEnd = (uint32_t)i_1 + 1;
00022026              break;
00021fff          }
00021fff          
00022001          r11_5 = r9_5;
00022005          r9_5 = rax_22;
0002200e          i_1 -= 1;
0002201b      } while (i_1 >= 0xc8);
0002201b      
00022029      int32_t rax_25 = *(uint32_t*)satStart;
00022029      
00022033      if (rax_25 != 0xffff8001 && *(uint32_t*)satEnd != 0xffff8001)
00022033      {
0002203c          *(uint32_t*)satStart = rax_25 * 2 - 0x200;
00022048          *(uint32_t*)satEnd = *(uint32_t*)satEnd * 2 - 0x200;
00022033      }
00021ed0  }

00022066                    cc cc cc cc cc cc                                                                    ......

0002206c    void FindPenEdges(struct _ctl_context_t* pContext, uint8_t sensor, struct edgeStruct_t* pEdges, uint16_t* pWaveform, uint16_t* retPeakSignal)

0002206c  {
0002208e      uint16_t thresholdFloor = pContext->settings.penSt.thresholdFloor;
0002209f      uint32_t rdi = 0;
000220a3      int16_t r12 = 1;
000220a7      int16_t arg_10 = 0;
000220b1      uint16_t startAperture = pContext->settings.sensor[(uint64_t)sensor].startAperture;
000220b9      int16_t stopAperture = pContext->settings.sensor[(uint64_t)sensor].stopAperture;
000220c2      uint32_t sensor_1 = (uint32_t)sensor;
000220c5      pEdges->Num_Edges = 0;
000220cc      uint128_t zmm0;
000220cc      float zmm2;
000220cc      uint128_t zmm3;
000220cc      uint32_t rcx_8;
000220cc      
000220cc      if (!sensor_1)
000220cc      {
0002221f      label_2221f:
0002221f          int16_t* r14_2 = &pWaveform[(uint64_t)startAperture];
00022223          int16_t* rcx_9 = r14_2;
00022223          
0002222a          if (startAperture <= stopAperture)
0002222a          {
00022237              uint64_t i_3 = (uint64_t)(stopAperture - startAperture + 1);
00022248              uint64_t i;
00022248              
00022248              do
00022248              {
0002223d                  if ((uint16_t)rdi < *(uint16_t*)rcx_9)
0002223d                      (uint16_t)rdi = *(uint16_t*)rcx_9;
0002223d                  
00022241                  rcx_9 = &rcx_9[1];
00022245                  i = i_3;
00022245                  i_3 -= 1;
00022248              } while (i != 1);
0002224a              arg_10 = (uint16_t)rdi;
0002222a          }
0002222a          
0002225e          *(uint16_t*)retPeakSignal = (uint16_t)rdi;
00022264          (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)(uint16_t)rdi) * 0.75f;
0002226c          uint16_t r15_2 = (int16_t)(int64_t)(uint32_t)zmm0;
0002226c          
00022275          if ((uint16_t)rdi > thresholdFloor)
00022275          {
0002227b              uint16_t adcPix2_1 = startAperture;
0002227b              
00022282              if (startAperture <= stopAperture)
00022282              {
00022288                  zmm2 = 2f;
00022290                  zmm3 = 0x44000000;
00022290                  
0002232c                  do
0002232c                  {
000222ac                      if (((uint32_t)*(uint16_t*)r14_2 - (uint32_t)r15_2) * (int32_t)r12
000222ac                          > 0)
000222ac                      {
000222b2                          uint32_t adcPix2_2 = (uint32_t)adcPix2_1;
000222b5                          pEdges->Raw_Edges[(uint64_t)pEdges->Num_Edges] = adcPix2_2;
000222b5                          
000222bb                          if (adcPix2_1 != startAperture)
000222bb                          {
00022301                              (uint32_t)zmm0 = Edge_Interpolate(*(uint16_t*)r14_2, 
00022301                                  r14_2[-1], r15_2, r15_2, adcPix2_1) * 2f;
00022305                              (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
00022309                              pEdges->Interpolated_Edges[(uint64_t)pEdges->Num_Edges] =
00022309                                  (uint32_t)zmm0;
0002230f                              pEdges->Num_Edges += 1;
000222bb                          }
000222bb                          else
000222bb                          {
000222bd                              uint64_t Num_Edges_2 = (uint64_t)pEdges->Num_Edges;
000222c8                              (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)adcPix2_2) * 2f;
000222cc                              (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
000222d0                              pEdges->Interpolated_Edges[Num_Edges_2] = (uint32_t)zmm0;
000222d6                              pEdges->Num_Edges += 1;
000222bb                          }
000222bb                          
00022316                          r12 = -(r12);
000222ac                      }
000222ac                      
0002231a                      r14_2 = &r14_2[1];
0002231a                      
00022322                      if (pEdges->Num_Edges >= 4)
00022322                          break;
00022322                      
00022324                      adcPix2_1 += 1;
0002232c                  } while (adcPix2_1 <= stopAperture);
0002232c                  
00022332                  (uint16_t)rdi = arg_10;
00022332                  
0002233b                  if (r12 != 1)
0002233b                  {
0002233d                      rcx_8 = (uint32_t)stopAperture;
00022349                  label_22349:
00022349                      pEdges->Raw_Edges[(uint64_t)pEdges->Num_Edges] = rcx_8;
0002234c                      uint64_t Num_Edges_3 = (uint64_t)pEdges->Num_Edges;
00022353                      (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)rcx_8) * zmm2;
00022357                      (uint32_t)zmm0 = (uint32_t)zmm0 - (uint32_t)zmm3;
0002235b                      pEdges->Interpolated_Edges[Num_Edges_3] = (uint32_t)zmm0;
00022361                      pEdges->Num_Edges += 1;
0002233b                  }
00022282              }
00022275          }
000220cc      }
000220cc      else if (sensor_1 == 1)
000220d5      {
000220ed      label_220ed:
000220ed          uint16_t adcPix2 = 1 + stopAperture;
000220f1          void* r14_1 = &pWaveform[(uint64_t)stopAperture];
000220f5          void* rcx_2 = r14_1;
000220f5          
000220fb          if (adcPix2 > startAperture)
000220fb          {
00022103              uint64_t i_2 = (uint64_t)(adcPix2 - startAperture);
00022114              uint64_t i_1;
00022114              
00022114              do
00022114              {
00022109                  if ((uint16_t)rdi < *(uint16_t*)rcx_2)
00022109                      (uint16_t)rdi = *(uint16_t*)rcx_2;
00022109                  
0002210d                  rcx_2 -= 2;
00022111                  i_1 = i_2;
00022111                  i_2 -= 1;
00022114              } while (i_1 != 1);
00022116              arg_10 = (uint16_t)rdi;
000220fb          }
000220fb          
0002212a          *(uint16_t*)retPeakSignal = (uint16_t)rdi;
00022130          (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)(uint16_t)rdi) * 0.75f;
00022138          int16_t r15_1 = (int16_t)(int64_t)(uint32_t)zmm0;
00022138          
0002214a          if ((uint16_t)rdi > thresholdFloor && adcPix2 > startAperture)
0002214a          {
00022150              zmm2 = 2f;
00022158              zmm3 = 0x44000000;
00022158              
000221ff              do
000221ff              {
00022174                  if (((uint32_t)*(uint16_t*)r14_1 - (uint32_t)r15_1) * (int32_t)r12 > 0)
00022174                  {
00022176                      uint64_t Num_Edges = (uint64_t)pEdges->Num_Edges;
00022176                      
0002217e                      if (adcPix2 <= stopAperture)
0002217e                      {
000221b1                          pEdges->Raw_Edges[Num_Edges] = (uint32_t)adcPix2;
000221cb                          (uint32_t)zmm0 = Edge_Interpolate(*(uint16_t*)((char*)r14_1 + 2), 
000221cb                              *(uint16_t*)r14_1, r15_1, r15_1, adcPix2) * 2f;
000221d5                          (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
000221d9                          pEdges->Interpolated_Edges[(uint64_t)pEdges->Num_Edges] =
000221d9                              (uint32_t)zmm0;
000221df                          pEdges->Num_Edges += 1;
0002217e                      }
0002217e                      else
0002217e                      {
00022180                          uint32_t stopAperture_1 = (uint32_t)stopAperture;
00022184                          pEdges->Raw_Edges[Num_Edges] = stopAperture_1;
00022187                          uint64_t Num_Edges_1 = (uint64_t)pEdges->Num_Edges;
00022192                          (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)stopAperture_1) * 2f;
00022196                          (uint32_t)zmm0 = (uint32_t)zmm0 - 512f;
0002219a                          pEdges->Interpolated_Edges[Num_Edges_1] = (uint32_t)zmm0;
000221a0                          pEdges->Num_Edges += 1;
0002217e                      }
0002217e                      
000221e6                      r12 = -(r12);
00022174                  }
00022174                  
000221ea                  r14_1 -= 2;
000221ea                  
000221f2                  if (pEdges->Num_Edges >= 4)
000221f2                      break;
000221f2                  
000221f9                  adcPix2 -= 1;
000221ff              } while (adcPix2 > startAperture);
000221ff              
00022205              (uint16_t)rdi = arg_10;
00022205              
0002220e              if (r12 != 1)
0002220e              {
00022214                  rcx_8 = (uint32_t)startAperture;
00022217                  goto label_22349;
0002220e              }
0002214a          }
000220d5      }
000220d5      else
000220d5      {
000220da          if (sensor_1 == 2)
000220da              goto label_2221f;
000220da          
000220e3          if (sensor_1 == 3)
000220e3              goto label_220ed;
000220d5      }
00022365      uint8_t Num_Edges_4 = pEdges->Num_Edges;
00022365      bool cond:1 = Num_Edges_4 != 2;
00022369      zmm3 = 0x7fffffffffffffff;
00022369      
00022371      if (Num_Edges_4 > 2)
00022371      {
00022373          (uint32_t)zmm0 = pEdges->Interpolated_Edges[1];
00022373          *(uint32_t*)((char*)zmm0)[4] = pEdges->Interpolated_Edges[1];
00022373          *(uint32_t*)((char*)zmm0)[8] = pEdges->Interpolated_Edges[1];
00022373          *(uint32_t*)((char*)zmm0)[0xc] = pEdges->Interpolated_Edges[1];
00022378          uint128_t zmm4;
00022378          (uint32_t)zmm4 = pEdges->Interpolated_Edges[3];
00022378          *(uint32_t*)((char*)zmm4)[4] = pEdges->Interpolated_Edges[3];
00022378          *(uint32_t*)((char*)zmm4)[8] = pEdges->Interpolated_Edges[3];
00022378          *(uint32_t*)((char*)zmm4)[0xc] = pEdges->Interpolated_Edges[3];
0002237d          float zmm5 = pEdges->Interpolated_Edges[2];
00022382          (uint32_t)zmm0 = (uint32_t)zmm0 - pEdges->Interpolated_Edges[0];
0002238a          uint64_t zmm1[0x2] = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0));
00022390          (uint32_t)zmm0 = (uint32_t)zmm4 - zmm5;
00022398          zmm2 = (float)_mm_and_pd(zmm1, zmm3)[0];
000223a6          (uint32_t)zmm0 = (float)_mm_and_pd(
000223a6              _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0)), zmm3)[0];
000223a6          
000223ad          if (!((uint32_t)zmm0 <= zmm2))
000223ad          {
000223af              pEdges->Interpolated_Edges[0] = zmm5;
000223b4              pEdges->Interpolated_Edges[1] = (uint32_t)zmm4;
000223ad          }
000223ad          
000223b9          pEdges->Num_Edges = 2;
000223bd          cond:1 = pEdges->Num_Edges != 2;
00022371      }
00022371      
000223c1      if (cond:1)
000223c1          return;
000223c1      
000223c3      (uint32_t)zmm0 = pEdges->Interpolated_Edges[1];
000223c3      *(uint32_t*)((char*)zmm0)[4] = pEdges->Interpolated_Edges[1];
000223c3      *(uint32_t*)((char*)zmm0)[8] = pEdges->Interpolated_Edges[1];
000223c3      *(uint32_t*)((char*)zmm0)[0xc] = pEdges->Interpolated_Edges[1];
000223c8      (uint32_t)zmm0 = (uint32_t)zmm0 - pEdges->Interpolated_Edges[0];
000223d7      (uint32_t)zmm0 =
000223d7          (float)_mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0)), zmm3)[0];
000223d7      
000223ec      if (!((uint32_t)zmm0 <= 14f) && (uint16_t)rdi < 0x3e8)
000223ee          pEdges->Num_Edges = 0;
0002206c  }

0002240f                                               cc cc cc cc cc cc cc cc cc                                         .........

00022418    float FastestTouchSpeed(struct sub_sampler_working_t* pSS_Struct)

00022418  {
00022434      uint128_t zmm2 = {0};
00022437      void* rax_1 = (uint64_t)pSS_Struct->thisSensor * 0x70;
00022449      void* r9_2 = (uint64_t)pSS_Struct->newest * 0x1cc + pSS_Struct;
0002244c      void* r8_2 = (uint64_t)pSS_Struct->oldest * 0x1cc + pSS_Struct;
0002244f      char r10 = 0xff;
00022452      void* rbx = (char*)rax_1 + r9_2;
00022456      void* r11 = (char*)rax_1 + r8_2;
0002245a      char i = *(uint8_t*)((char*)rbx + 0x18);
0002246a      int32_t rax_4;
0002246a      uint128_t zmm0;
0002246a      uint128_t zmm1;
0002246a      
0002246a      if (i == *(uint8_t*)((char*)r11 + 0x18) && i >= 1)
0002246a      {
00022470          uint128_t zmm3 = 0x7fffffffffffffff;
00022478          (uint8_t)pSS_Struct = 0;
00022478          
0002247c          if (i > 0)
0002247c          {
000224be              do
000224be              {
0002247e                  uint64_t rax_2 = (uint64_t)(uint8_t)pSS_Struct;
00022486                  (uint32_t)zmm0 = (*(uint32_t*)((char*)rbx + (rax_2 << 3)))
00022486                      - *(uint32_t*)((char*)r11 + (rax_2 << 3));
0002248c                  (uint32_t)zmm0 =
0002248c                      (uint32_t)zmm0 + *(uint32_t*)((char*)rbx + (rax_2 << 3) + 4);
00022492                  (uint32_t)zmm0 =
00022492                      (uint32_t)zmm0 - *(uint32_t*)((char*)r11 + (rax_2 << 3) + 4);
00022499                  (uint32_t)zmm0 = (uint32_t)zmm0 * 0.5f;
000224ab                  (uint32_t)zmm1 = (float)_mm_and_pd(
000224ab                      _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0)), zmm3);
000224ab                  
000224b2                  if (!((uint32_t)zmm1 <= (uint32_t)zmm2))
000224b2                  {
000224b4                      zmm2 = zmm1;
000224b7                      r10 = (uint8_t)pSS_Struct;
000224b2                  }
000224b2                  
000224ba                  (uint8_t)pSS_Struct += 1;
000224be              } while ((uint8_t)pSS_Struct < i);
0002247c          }
0002247c          
000224c0          int64_t rax_3 = (int64_t)r10;
000224c9          (uint32_t)zmm0 = (*(uint32_t*)((char*)rbx + (rax_3 << 3)))
000224c9              - *(uint32_t*)((char*)r11 + (rax_3 << 3));
000224d2          zmm1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0));
000224db          (uint32_t)zmm0 = (*(uint32_t*)((char*)rbx + (rax_3 << 3) + 4))
000224db              - *(uint32_t*)((char*)r11 + (rax_3 << 3) + 4);
000224e6          (uint32_t)zmm2 = (float)_mm_and_pd(zmm1, zmm3);
000224f4          (uint32_t)zmm3 =
000224f4              (float)_mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0)), zmm3);
000224f4          
000224fb          if (!((uint32_t)zmm3 > (uint32_t)zmm2))
000224fd              zmm2 = zmm3;
000224fd          
00022500          rax_4 = *(uint32_t*)((char*)r9_2 + 0x1c0);
0002246a      }
0002246a      
00022514      if (i != *(uint8_t*)((char*)r11 + 0x18) || i < 1
00022514              || rax_4 == *(uint32_t*)((char*)r8_2 + 0x1c0) || r10 == 0xff)
00022528          zmm0 = 0xbf800000;
00022514      else
00022514      {
0002251a          (uint32_t)zmm1 = (float)(uint64_t)(rax_4 - *(uint32_t*)((char*)r8_2 + 0x1c0));
0002251f          (uint32_t)zmm2 = (uint32_t)zmm2 / (uint32_t)zmm1;
00022523          zmm0 = zmm2;
00022514      }
00022514      
00022535      return (uint32_t)zmm0;
00022418  }

00022536                                                                    cc cc cc cc cc cc                                    ......

0002253c    void Populate_Waveform_Buffers(uint8_t illuminated, uint8_t ambientSubtract, struct sensor_waveform_t* waveforms, struct waveform_t* wf, uint16_t startAperture, uint16_t stopAperture)

0002253c  {
00022555      int64_t rbp;
00022555      (uint8_t)rbp = ambientSubtract;
0002255d      int64_t rbx;
0002255d      (uint8_t)rbx = illuminated;
0002255d      
00022575      if (!CheckApertureSanity(startAperture, stopAperture))
00022575          return;
00022575      
0002257b      uint16_t pixelCount = wf->pixelCount;
0002257b      
00022588      if (pixelCount < 1)
00022588      {
0002259e          onError__("wf->pixelCount < 1", 
0002259e              "c:\development_work\csf_release_hp\driver\foureyes\ctl_waveform.c", 0x111);
0002259e          return;
00022588      }
00022588      
000225a8      uint16_t pixelStart = wf->pixelStart;
000225a8      
000225b4      if (pixelStart > 0x200)
000225b4      {
0002259e          onError__("wf->pixelStart > FOCAL_LENGTH", 
0002259e              "c:\development_work\csf_release_hp\driver\foureyes\ctl_waveform.c", 0x116);
0002259e          return;
000225b4      }
000225b4      
000225c5      uint64_t pixelCount_1 = (uint64_t)pixelCount;
000225c9      uint64_t pixelStart_1 = (uint64_t)pixelStart;
000225c9      
000225d6      if ((int32_t)(pixelStart_1 + pixelCount_1) > 0x20c)
000225d6      {
0002259e          onError__("wf->pixelStart + wf->pixelCount > MAX_PIXELS", 
0002259e              "c:\development_work\csf_release_hp\driver\foureyes\ctl_waveform.c", 0x11b);
0002259e          return;
000225d6      }
000225d6      
000225ea      uint64_t cam = (uint64_t)wf->info.cam;
000225ee      void* rbx_2;
000225ee      
000225ee      if (!(uint8_t)rbx)
000225ee      {
00022697          memmove(&waveforms->ambient[cam * 0x625 + (uint64_t)pixelStart], wf->pWaveform, 
00022697              (uint64_t)pixelCount * 2);
000226a3          rbx_2 = &waveforms[cam].ambient;
000225ee      }
000225ee      else
000225ee      {
000225f7          if (!(uint8_t)rbp)
00022664              memmove(&waveforms->sensor[cam * 0x625 + (uint64_t)pixelStart], 
00022664                  wf->pWaveform, (uint64_t)pixelCount * 2);
000225f7          else if ((uint32_t)pixelCount_1 > 0)
00022610          {
00022612              uint16_t* pWaveform = wf->pWaveform;
00022615              void* rax_2 = cam * 0xc4a + waveforms + (pixelStart_1 << 1);
0002261c              uint64_t i_1 = pixelCount_1;
00022642              uint64_t i;
00022642              
00022642              do
00022642              {
0002261f                  uint16_t rcx_2 = *(uint16_t*)pWaveform;
0002261f                  
00022627                  if (rcx_2 <= *(uint16_t*)(0x418 + rax_2))
00022633                      *(uint16_t*)rax_2 = 0;
00022627                  else
0002262e                      *(uint16_t*)rax_2 = rcx_2 - *(uint16_t*)(0x418 + rax_2);
0002262e                  
00022637                  pWaveform = &pWaveform[1];
0002263b                  rax_2 += 2;
0002263f                  i = i_1;
0002263f                  i_1 -= 1;
00022642              } while (i != 1);
00022610          }
00022610          
00022670          rbx_2 = cam * 0xc4a + waveforms;
000225ee      }
000225ee      
000226b9      memset(rbx_2, 0, (uint64_t)startAperture * 2);
000226be      uint32_t stopAperture_1 = (uint32_t)stopAperture;
000226db      memset((char*)rbx_2 + ((int64_t)(stopAperture_1 + 1) << 1), 0, 
000226db          (int64_t)(0x20b - stopAperture_1) * 2);
0002253c  }

000226fb                                                                                   cc cc cc cc cc                             .....
00022700  cc cc cc cc                                                                                      ....

00022704    void Handle_Triggers(uint8_t illuminated, uint8_t penMode, struct _ctl_context_t* pContext)

00022704  {
0002271b      if (!illuminated || penMode)
0002271b          return;
0002271b      
00022721      pContext->edgeBits u>>= 1;
00022721      
00022736      if (pContext->ssInput.edgeCount > penMode)
0002273c          pContext->edgeBits |= 0x80000000;
0002273c      
00022755      char var_28;
00022755      memmove(&var_28, &pContext->settings.triggers, 0x18);
00022761      uint32_t edgeBits = pContext->edgeBits;
00022767      pContext->elapsedSinceTrigger += (uint32_t)pContext->deltaTimeStamp;
00022777      int32_t var_20;
00022777      
00022777      if (pContext->elapsedSinceTrigger <= var_20)
00022777          return;
00022777      
0002277d      pContext->elapsedSinceTrigger = 0;
0002277d      
00022786      if (!edgeBits)
00022786          goto label_227c2;
00022786      
0002279d      int32_t var_18;
0002279d      
0002279d      if (var_18 <= FastestTouchSpeed(&pContext->subSamplerStruct))
0002279d          return;
0002279d      
000227a3      pContext->noMoveCount += 1;
000227b5      int16_t var_1c;
000227b5      
000227b5      if ((uint16_t)pContext->noMoveCount <= var_1c)
000227b5          return;
000227b5      
000227bb      pContext->noMoveCount = 0;
000227c2  label_227c2:
000227c2      pContext->triggerCam += 1;
000227c8      uint32_t rax_4;
000227c8      (uint8_t)rax_4 = pContext->triggerCam;
000227c8      
000227d4      if ((uint8_t)rax_4 >= pContext->settings.numSensors)
000227d6          pContext->triggerCam = 0;
000227d6      
000227dd      uint64_t triggerCam_1 = (uint64_t)pContext->triggerCam;
00022838      Update_TrigWaveform(&pContext->settings.triggers, 
00022838          pContext->waveforms[triggerCam_1].trigInit, 
00022838          pContext->settings.sensor[triggerCam_1].startAperture, 
00022838          pContext->settings.sensor[triggerCam_1].stopAperture, 
00022838          (char)(int64_t)(long double)pContext->settings.triggers.trigPercentage, 
00022838          &pContext->waveforms[triggerCam_1], &pContext->waveforms[triggerCam_1].trigger);
00022838      
00022844      if (pContext->settings.numSensors == 2)
00022844      {
00022846          uint64_t triggerCam = (uint64_t)pContext->triggerCam;
0002284d          int32_t rdx_2 = (int32_t)(triggerCam + 2);
0002284d          
00022853          if (rdx_2 < 4)
00022853          {
00022880              void* rdx_3;
00022880              (uint8_t)rdx_3 = pContext->waveforms[triggerCam].trigInit;
000228ad              Update_TrigWaveform(&pContext->settings.triggers, (uint8_t)rdx_3, 
000228ad                  pContext->settings.sensor[triggerCam].startAperture, 
000228ad                  pContext->settings.sensor[triggerCam].stopAperture, 0x32, 
000228ad                  &pContext->waveforms[triggerCam], 
000228ad                  &pContext->waveforms[(int64_t)rdx_2].trigger);
00022853          }
00022844      }
00022844      
000228c3      *(uint8_t*)(((uint64_t)pContext->triggerCam + 1) * 0xc4a + pContext) = 0;
00022704  }

000228d2                                                        cc cc cc cc cc cc                                            ......

000228d8    void CTL_Init_Triggers(struct _ctl_context_t* pContext)

000228d8  {
000228fd      ST_AcquireLock(&pContext->waveformLock, 0);
00022902      int64_t rdi;
00022902      (uint8_t)rdi = 0;
00022902      
0002290c      if (pContext->settings.numSensors > 0)
0002290c      {
000229c7          do
000229c7          {
0002291b              uint64_t rbp_1 = (uint64_t)(uint8_t)rdi;
00022963              Update_TrigWaveform(&pContext->settings.triggers, 1, 
00022963                  pContext->settings.sensor[rbp_1].startAperture, 
00022963                  pContext->settings.sensor[rbp_1].stopAperture, 
00022963                  (char)(int64_t)(long double)pContext->settings.triggers.trigPercentage, 
00022963                  &pContext->waveforms[rbp_1], &pContext->waveforms[rbp_1].trigger);
00022963              
0002297b              if (pContext->settings.numSensors == 2 && (uint32_t)(uint8_t)rdi + 2 < 4)
000229b8                  Update_TrigWaveform(&pContext->settings.triggers, 1, 
000229b8                      pContext->settings.sensor[rbp_1].startAperture, 
000229b8                      pContext->settings.sensor[rbp_1].stopAperture, 0x32, 
000229b8                      &pContext->waveforms[rbp_1], 
000229b8                      &pContext->waveforms[(int64_t)((uint32_t)(uint8_t)rdi + 2)].trigger);
000229b8              
000229bd              (uint8_t)rdi += 1;
000229c7          } while ((uint8_t)rdi < pContext->settings.numSensors);
0002290c      }
0002290c      
000229f0      /* tailcall */
000229f0      return KeReleaseMutex(&pContext->waveformLock.mutex, 0);
000228d8  }

000229f7                                                                       cc cc cc cc cc cc cc cc cc                         .........

00022a00    void Update_TrigWaveform(struct triggers_t* pTrigSettings, uint8_t trigInit, uint16_t startAperture, uint16_t stopAperture, uint8_t trigPercent, uint16_t* sensorWaveform, uint16_t* trigWaveform)

00022a00  {
00022a18      int64_t rbp;
00022a18      (uint8_t)rbp = trigInit;
00022a18      
00022a35      if (!CheckApertureSanity(startAperture, stopAperture))
00022a35          return;
00022a35      
00022a3b      int64_t rsi;
00022a3b      (uint8_t)rsi = trigPercent;
00022a3b      
00022a43      if (!(uint8_t)rsi)
00022a43          return;
00022a43      
00022a52      if ((uint8_t)rbp == 1)
00022a52      {
00022a64          memset(trigWaveform, 0, 0x418);
00022a64          
00022a6c          if (startAperture <= stopAperture)
00022a6c          {
00022a88              uint64_t i_2 = (uint64_t)(stopAperture - startAperture + 1);
00022a8c              void* r8 = &trigWaveform[(uint64_t)startAperture];
00022aaf              uint64_t i;
00022aaf              
00022aaf              do
00022aaf              {
00022a9f                  int32_t temp2_1;
00022a9f                  int32_t temp3_1;
00022a9f                  temp2_1 = HIGHD(0x51eb851f * (uint32_t)
00022a9f                      *(uint16_t*)((char*)sensorWaveform - trigWaveform + r8)
00022a9f                      * (uint32_t)(uint8_t)rsi);
00022a9f                  temp3_1 = LOWD(0x51eb851f * (uint32_t)
00022a9f                      *(uint16_t*)((char*)sensorWaveform - trigWaveform + r8)
00022a9f                      * (uint32_t)(uint8_t)rsi);
00022aa4                  *(uint16_t*)r8 = (int16_t)(temp2_1 >> 5);
00022aa8                  r8 += 2;
00022aac                  i = i_2;
00022aac                  i_2 -= 1;
00022aaf              } while (i != 1);
00022a6c          }
00022a52      }
00022a52      else if (startAperture <= stopAperture)
00022ab9      {
00022ada          int16_t* r8_1 = &trigWaveform[(uint64_t)startAperture];
00022ade          uint64_t i_3 = (uint64_t)(stopAperture - startAperture + 1);
00022b40          uint64_t i_1;
00022b40          
00022b40          do
00022b40          {
00022ae7              int16_t r9 = *(uint16_t*)r8_1;
00022af3              int32_t temp0_1;
00022af3              int32_t temp1_1;
00022af3              temp0_1 = HIGHD(0x51eb851f * (uint32_t)
00022af3                  *(uint16_t*)((char*)r8_1 + (char*)sensorWaveform - trigWaveform)
00022af3                  * (uint32_t)(uint8_t)rsi);
00022af3              temp1_1 = LOWD(0x51eb851f * (uint32_t)
00022af3                  *(uint16_t*)((char*)r8_1 + (char*)sensorWaveform - trigWaveform)
00022af3                  * (uint32_t)(uint8_t)rsi);
00022af5              uint16_t rdx_4 = (int16_t)(temp0_1 >> 5);
00022af5              
00022afc              if (rdx_4 <= r9)
00022afc              {
00022b17                  uint32_t thresholdDown = (uint32_t)pTrigSettings->thresholdDown;
00022b17                  
00022b29                  if (thresholdDown >= (uint32_t)r9 - (uint32_t)rdx_4)
00022b35                      *(uint16_t*)r8_1 = rdx_4;
00022b29                  else
00022b2f                      *(uint16_t*)r8_1 = r9 - (uint16_t)thresholdDown;
00022afc              }
00022afc              else
00022afc              {
00022afe                  uint32_t thresholdUp = (uint32_t)pTrigSettings->thresholdUp;
00022afe                  
00022b0f                  if (thresholdUp >= (uint32_t)rdx_4 - (uint32_t)r9)
00022b35                      *(uint16_t*)r8_1 = rdx_4;
00022b0f                  else
00022b2f                      *(uint16_t*)r8_1 = r9 + (uint16_t)thresholdUp;
00022afc              }
00022afc              
00022b39              r8_1 = &r8_1[1];
00022b3d              i_1 = i_3;
00022b3d              i_3 -= 1;
00022b40          } while (i_1 != 1);
00022ab9      }
00022a00  }

00022b5b                                                                                   cc cc cc cc cc                             .....
00022b60  cc cc cc cc                                                                                      ....

00022b64    uint8_t FE_ProcessWaveform(struct _ctl_context_t* pContext, struct waveform_t* wf, uint8_t processNearfield, uint8_t processEdgesInbetween)

00022b64  {
00022b80      uint8_t rsi = 0;
00022b85      bool cond:0 = wf->info.led;
00022b89      pContext->currentSensor = wf->info.cam;
00022b8e      pContext->temperature = wf->info.temperature;
00022b94      float rax_1;
00022b94      (uint8_t)rax_1 = pContext->settings.numSensors;
00022b9a      int64_t rbp;
00022b9a      (uint8_t)rbp = cond:0;
00022b9a      
00022bb6      if ((uint8_t)rax_1 >= 2 && wf->info.led != 2 && wf->info.cam < (uint8_t)rax_1)
00022bb6      {
00022bc7          if (!(pContext->settings.penSt.enabled & 1))
00022bdd              pContext->pen.penInUse = 0;
00022bc7          else
00022bd5              pContext->pen.penInUse = (wf->info.penPressure & 0x8000) > 0;
00022bd5          
00022bf0          wf->info.penPressure &= 0x7fff;
00022bf6          ST_AcquireLock(&pContext->waveformLock, 0);
00022bfb          wf->info
00022c30          Populate_Waveform_Buffers((uint8_t)rbp, pContext->settings.AmbientSubON, 
00022c30              &pContext->waveforms, wf, 
00022c30              pContext->settings.sensor[(uint64_t)
00022c30                  *(uint8_t*)((char*)(*(int96_t*)((char*)wf + 0x10)))[3]].startAperture, 
00022c30              pContext->settings.sensor[(uint64_t)
00022c30              *(uint8_t*)((char*)(*(int96_t*)((char*)wf + 0x10)))[3]].stopAperture);
00022c41          Handle_Triggers((uint8_t)rbp, pContext->pen.penInUse, pContext);
00022c4f          KeReleaseMutex(&pContext->waveformLock.mutex, 0);
00022bb6      }
00022bb6      
00022c58      if ((uint8_t)rax_1 < 2 || wf->info.led == 2 || wf->info.cam >= (uint8_t)rax_1
00022c58              || !(uint8_t)rbp)
00022ef2          (uint8_t)rax_1 = 0;
00022c58      else
00022c58      {
00022c5e          uint16_t fwtimeStamp = wf->info.fwtimeStamp;
00022c69          pContext->prevDeltaTimeStamp = pContext->deltaTimeStamp;
00022c70          uint16_t prevFwTimeStamp = pContext->prevFwTimeStamp;
00022c7a          uint16_t rax_6 = fwtimeStamp - prevFwTimeStamp;
00022c7a          
00022c80          if (fwtimeStamp < prevFwTimeStamp)
00022c82              rax_6 -= 1;
00022c82          
00022c86          pContext->deltaTimeStamp = rax_6;
00022c90          pContext->timestamp += (uint32_t)rax_6;
00022c96          pContext->prevFwTimeStamp = fwtimeStamp;
00022ca4          uint16_t var_28_1;
00022ca4          
00022ca4          if (!pContext->pen.penInUse)
00022ca4          {
00022d8e              uint32_t rax_7;
00022d8e              (uint8_t)rax_7 = pContext->settings.numSensors;
00022d96              uint16_t trigPercentage;
00022d96              
00022d96              if ((uint8_t)rax_7 == 4)
00022d96              {
00022d98                  uint64_t cam_3 = (uint64_t)wf->info.cam;
00022daf                  trigPercentage = pContext->settings.triggers.trigPercentage;
00022dd5                  var_28_1 = &pContext->edges[cam_3];
00022ddd                  FindEdges(pContext, (uint8_t)cam_3, &pContext->waveforms[cam_3], 
00022ddd                      &pContext->waveforms[cam_3].trigger, var_28_1, trigPercentage, 1);
00022d96              }
00022d96              else if ((uint8_t)rax_7 == 2)
00022de9              {
00022def                  uint64_t cam_4 = (uint64_t)wf->info.cam;
00022e06                  trigPercentage = pContext->settings.triggers.trigPercentage;
00022e2c                  var_28_1 = &pContext->edges[cam_4];
00022e34                  FindEdges(pContext, (uint8_t)cam_4, &pContext->waveforms[cam_4], 
00022e34                      &pContext->waveforms[cam_4].trigger, var_28_1, trigPercentage, 1);
00022e34                  
00022e48                  if (!(650f <= pContext->settings.panelSize.x))
00022e50                      FindExtra2CamEdges(pContext, 1);
00022e50                  
00022e55                  uint64_t cam = (uint64_t)wf->info.cam;
00022e84                  FindTouchIntegrals(&pContext->waveforms[cam], 
00022e84                      &pContext->waveforms[cam].trigger, &pContext->edges[cam], 
00022e84                      &pContext->touchIntegralData[cam]);
00022de9              }
00022de9              
00022e99              if (!pContext->edges[(uint64_t)wf->info.cam].Num_Edges)
00022e99              {
00022e9b                  uint64_t cam_1 = (uint64_t)wf->info.cam;
00022ec4                  var_28_1 = &pContext->satEnd[cam_1];
00022ec9                  Find_Saturation(&pContext->waveforms[cam_1], 0xc8, 0x12c, 
00022ec9                      &pContext->satStart[cam_1], var_28_1);
00022e99              }
00022ca4          }
00022ca4          else
00022ca4          {
00022cae              if (wf->info.penPressure)
00022cae              {
00022cb0                  float thresholdPressure = pContext->penStatics.thresholdPressure;
00022cb0                  
00022ccc                  if ((uint32_t)wf->info.penPressure
00022ccc                          <= (uint32_t)(uint16_t)(int64_t)thresholdPressure
00022ccc                          + pContext->settings.penSt.threshold)
00022cd8                      thresholdPressure =
00022cd8                          thresholdPressure - pContext->settings.penSt.thresholdDown;
00022ccc                  else
00022cce                      thresholdPressure =
00022cce                          thresholdPressure + pContext->settings.penSt.thresholdUp;
00022cce                  
00022ce0                  pContext->penStatics.thresholdPressure = thresholdPressure;
00022cae              }
00022cae              
00022cf5              pContext->pen.eraser = 0;
00022cfc              int16_t rax_10;
00022cfc              (uint8_t)rax_10 = wf->info.penPressure
00022cfc                  < (uint16_t)(int64_t)(long double)pContext->penStatics.thresholdPressure;
00022cff              pContext->pen.pentip = (uint8_t)rax_10;
00022d05              uint64_t cam_2 = (uint64_t)wf->info.cam;
00022d14              var_28_1 = &pContext->penStatics.peakSignal[cam_2];
00022d37              FindPenEdges(pContext, (uint8_t)cam_2, &pContext->edges[cam_2], 
00022d37                  &pContext->waveforms[cam_2], var_28_1);
00022d3c              enum autoCorrectState_t autoCorrectState =
00022d3c                  pContext->autoCorrectData.autoCorrectState;
00022d3c              
00022d45              if (autoCorrectState == AC_ACCUMULATING)
00022d84                  AutoCorrect_UpdatingInit(pContext);
00022d45              else if (autoCorrectState == 2)
00022d77                  AutoCorrect_UpdatingGrad(pContext);
00022d4a              else if (autoCorrectState == 3)
00022d6a                  AutoCorrect_UpdatingStep(pContext);
00022d4f              else if (autoCorrectState == 4)
00022d5d                  AutoCorrect_UpdatingLine(pContext);
00022ca4          }
00022ee0          uint8_t rcx_23 = FindEdgesInbetween(pContext, wf);
00022ee3          (uint8_t)rax_1 = 1;
00022ee3          
00022ee6          if (pContext->settings.numSensors == 4)
00022ee6              rsi = rcx_23;
00022ee6          
00022ee9          pContext->ssInput.edgesBetweenFound = rsi;
00022c58      }
00022c58      
00022f0e      return (uint8_t)rax_1;
00022b64  }

00022f0f                                               cc cc cc cc cc cc cc cc cc                                         .........

00022f18    void FE_ProcessEdgesImplicit(struct _ctl_context_t* pContext, struct wfinfo_t* info)

00022f18  {
00022f37      struct wfinfo_t* info_1 = info;
00022f4a      uint64_t i_3;
00022f4a      
00022f4a      if (pContext->pen.penInUse)
00022f4a      {
00022f4c          uint64_t cam = (uint64_t)info->cam;
00022f53          i_3 = cam * 0x68;
00022f5b          int32_t EdgeCorrectionAlpha = pContext->settings.sensor[cam].EdgeCorrectionAlpha;
00022f64          float EdgeCorrectionBeta = pContext->settings.sensor[cam].EdgeCorrectionBeta;
00022f6d          void* rax_2 = &pContext->edges[0].Interpolated_Edges + i_3;
00022f79          *(uint128_t*)(&pContext->edges[0].Unscaled_Interp_Edges + i_3) =
00022f79              *(uint128_t*)rax_2;
00022f83          int64_t i_2 = 4;
00022fa2          int64_t i;
00022fa2          
00022fa2          do
00022fa2          {
00022f8b              int128_t zmm0;
00022f8b              (uint32_t)zmm0 = (*(uint32_t*)rax_2) * EdgeCorrectionAlpha;
00022f8f              (uint32_t)zmm0 = (uint32_t)zmm0 + EdgeCorrectionBeta;
00022f93              (uint32_t)zmm0 = (uint32_t)zmm0 + *(uint32_t*)rax_2;
00022f97              *(uint32_t*)rax_2 = (uint32_t)zmm0;
00022f9b              rax_2 += 4;
00022f9f              i = i_2;
00022f9f              i_2 -= 1;
00022fa2          } while (i != 1);
00022f4a      }
00022f4a      
00022fa4      uint64_t cam_4 = (uint64_t)info->cam;
00022fa9      char i_1 = 0;
00022fa9      
00022fbf      if (pContext->edges[cam_4].Num_Edges > 0)
00022fbf      {
00022fe5          do
00022fe5          {
00022fc1              i_3 = (uint64_t)i_1;
00022fc5              (uint8_t)info = (uint8_t)cam_4;
00022fd7              i_1 += 1;
00022fda              pContext->edges[cam_4].Lin_Edges[i_3] = FE_Linearize(pContext, (uint8_t)info, 
00022fda                  pContext->edges[cam_4].Interpolated_Edges[i_3]);
00022fe5          } while (i_1 < pContext->edges[cam_4].Num_Edges);
00022fbf      }
00022fbf      
00022fe7      uint64_t cam_2 = (uint64_t)info_1->cam;
00022ff2      (uint8_t)i_3 = pContext->edges[cam_2].Num_Edges;
0002300a      ConvertToRad((uint8_t)cam_2, &pContext->edges[cam_2].Lin_Edges, (uint8_t)i_3, 
0002300a          &pContext->edges[cam_2].Angles);
00023021      int32_t temp0;
00023021      int32_t temp1;
00023021      temp0 =
00023021          HIGHD((int64_t)((uint32_t)info_1->packetID - (uint32_t)pContext->prevPacketID));
00023021      temp1 =
00023021          LOWD((int64_t)((uint32_t)info_1->packetID - (uint32_t)pContext->prevPacketID));
00023024      int32_t rax_11 = (temp1 - temp0) >> 1;
00023024      
00023029      if (rax_11 < 1)
00023029          rax_11 = 1;
00023029      
0002302d      pContext->ssInput.id.id += (uint16_t)rax_11;
0002303b      pContext->ssInput.id.deltaTimeStamp = pContext->deltaTimeStamp;
00023048      pContext->ssInput.timestamp = pContext->timestamp;
0002304e      uint32_t rax_13;
0002304e      (uint8_t)rax_13 = info_1->packetID;
00023051      pContext->prevPacketID = (uint8_t)rax_13;
00023051      
0002305e      if (pContext->pen.penInUse)
0002305e      {
00023064          uint64_t cam_3 = (uint64_t)info_1->cam;
00023069          struct frame_id_t rax_14;
00023069          rax_14.id = pContext->ssInput.id.id;
00023069          rax_14.deltaTimeStamp = pContext->ssInput.id.deltaTimeStamp;
0002306f          pContext->ssOutput.id.id = rax_14.id;
0002306f          pContext->ssOutput.id.deltaTimeStamp = rax_14.deltaTimeStamp;
00023075          pContext->trueEdges.id.id = rax_14.id;
00023075          pContext->trueEdges.id.deltaTimeStamp = rax_14.deltaTimeStamp;
0002307b          pContext->touches.id.id = rax_14.id;
0002307b          pContext->touches.id.deltaTimeStamp = rax_14.deltaTimeStamp;
00023083          uint64_t rdx_2 = cam_3 * 9;
00023091          pContext->ssOutput.sensor[cam_3].edgeSet[0].touchCount = 0;
00023099          *(uint32_t*)(&pContext->trueEdges + (rdx_2 << 2)) = 0;
000230a0          pContext->trueEdges.edgeSet[0].edgePair[0].edge[1 + rdx_2] = 0;
000230a7          pContext->trueEdges.edgeSet[0].edgePair[1].edge[rdx_2] = 0;
000230ae          pContext->trueEdges.edgeSet[0].edgePair[1].edge[1 + rdx_2] = 0;
000230ae          
000230c4          if (pContext->edges[(uint64_t)pContext->currentSensor].Num_Edges == 2)
000230c4          {
000230ca              pContext->ssOutput.sensor[cam_3].edgeSet[0].touchCount = 1;
000230d2              pContext->trueEdges.trueSensor = (uint8_t)cam_3;
000230e4              *(uint32_t*)(&pContext->trueEdges + (rdx_2 << 2)) =
000230e4                  pContext->edges[cam_3].Angles[0];
000230f2              pContext->trueEdges.edgeSet[0].edgePair[0].edge[1 + rdx_2] =
000230f2                  pContext->edges[cam_3].Angles[1];
000230c4          }
000230c4          
000230c4          goto label_23171;
0002305e      }
0002305e      
000230fb      uint64_t cam_1 = (uint64_t)info_1->cam;
00023110      pContext->ssInput.sensor = (uint8_t)cam_1;
0002311a      int96_t Angles = (int96_t)pContext->edges[cam_1].Angles;
00023123      pContext->ssInput.edges[0] = (uint16_t)Angles;
00023123      *(uint8_t*)((char*)pContext->ssInput.edges[0])[2] = *(uint8_t*)((char*)Angles)[2];
00023123      *(uint8_t*)((char*)pContext->ssInput.edges[0])[3] = *(uint8_t*)((char*)Angles)[3];
00023123      pContext->ssInput.edges[1] = *(uint8_t*)((char*)Angles)[4];
00023123      *(uint16_t*)((char*)pContext->ssInput.edges[1])[2] = *(uint16_t*)((char*)Angles)[6];
00023123      pContext->ssInput.edges[2] = *(uint32_t*)((char*)Angles)[8];
00023127      (uint8_t)cam_1 = pContext->edges[cam_1].Num_Edges;
0002312e      pContext->ssInput.edgeCount = (uint8_t)cam_1;
00023134      uint16_t touchIntegral[0x2] = pContext->edges[cam_1].touchIntegral;
0002313b      pContext->ssInput.touchIntegral[0] = touchIntegral[0];
0002313b      pContext->ssInput.touchIntegral[1] = touchIntegral[1];
00023141      uint16_t rawTouchWidth[0x2] = pContext->edges[cam_1].rawTouchWidth;
0002314f      pContext->ssInput.touchWidth[0] = rawTouchWidth[0];
0002314f      pContext->ssInput.touchWidth[1] = rawTouchWidth[1];
0002314f      
0002315d      if (!SS_SubSample(&pContext->subSamplerStruct, &pContext->ssInput, 
0002315d              &pContext->ssOutput))
0002315d          return;
0002315d      
00023171  label_23171:
00023171      Calculate_Center_Angles(&pContext->ssOutput, &pContext->edges);
00023176      void (* edgesCallback)(void*, uint32_t, uint8_t, struct edgeStruct_t*) =
00023176          pContext->edgesCallback;
0002317d      enum touch_state_t rdi_1 = TS_TOUCH_UP;
00023185      uint8_t rax_20;
00023185      
00023185      if (edgesCallback)
00023185      {
00023187          rax_20 = pContext->currentSensor;
0002318a          uint8_t rcx_8 = 3;
0002318a          
0002318f          if (rax_20 < 3)
0002318f              rcx_8 = rax_20;
0002318f          
00023192          uint64_t r12_1 = (uint64_t)rcx_8;
00023192          
000231af          if (pContext->edges[r12_1].Num_Edges > 0 || pContext->hadEdgesInLastFrame[r12_1])
000231c8              edgesCallback(pContext->edgesParam, (uint64_t)pContext->timestamp, rcx_8, 
000231c8                  &pContext->edges);
000231c8          
000231db          pContext->hadEdgesInLastFrame[r12_1] = pContext->edges[r12_1].Num_Edges > 0;
00023185      }
00023185      
000231ea      uint8_t rax_23;
000231ea      
000231ea      if (pContext->pen.penInUse)
000231ea      {
000231f3          uint32_t numSensors = (uint32_t)pContext->settings.numSensors;
000231fa          pContext->penStatics.elapsedSinceShutterAdjust +=
000231fa              (uint32_t)pContext->deltaTimeStamp;
000231fa          
0002320b          if ((uint32_t)info_1->cam >= numSensors - 1)
0002320b          {
00023214              struct pen_t pen;
00023214              pen.penInUse = pContext->pen.penInUse;
00023214              pen.prevPenMode = pContext->pen.prevPenMode;
00023214              pen.pentip = pContext->pen.pentip;
00023214              pen.eraser = pContext->pen.eraser;
00023224              rax_23 =
00023224                  ActivePenPath(pContext, pen, (uint8_t)numSensors, &pContext->triangError);
00023229              goto label_23250;
0002320b          }
0002320b          
00023380      label_23380:
00023380          
000233b2          if (!pContext->pen.penInUse && pContext->settings.numSensors == 2
000233b2              && pContext->trackStateData.lastStateWasSingleTouch
000233b2              && (uint32_t)pContext->edges[1].Num_Edges
000233b2              + (uint32_t)pContext->edges[0].Num_Edges <= 4)
000233b2          {
000233b4              struct frame_id_t rax_28;
000233b4              rax_28.id = pContext->ssOutput.id.id;
000233b4              rax_28.deltaTimeStamp = pContext->ssOutput.id.deltaTimeStamp;
000233ce              pContext->touches.id.id = rax_28.id;
000233ce              pContext->touches.id.deltaTimeStamp = rax_28.deltaTimeStamp;
000233d4              PerformTouchTracking(pContext, &pContext->touches, &pContext->outputTouches, 
000233d4                  0);
000233e7              UpdateTrackingCircles(&pContext->filterData, &pContext->outputTouches);
000233ec              void (* triangulatedTouchesCallback_1)(void*, struct touches_t*) =
000233ec                  pContext->triangulatedTouchesCallback;
000233ec              
000233ff              if (triangulatedTouchesCallback_1 && pContext->outputTouches.touchCount > 0)
0002340f                  triangulatedTouchesCallback_1(pContext->triangulatedTouchesParam, 
0002340f                      &pContext->outputTouches);
000233b2          }
000233b2          
000233b2          return;
000231ea      }
000231ea      
0002322b      rax_20 = pContext->settings.numSensors;
0002322b      
00023234      if (rax_20 == 2)
0002324b          rax_23 = TwoSensorPath(pContext);
00023234      else
00023234      {
00023238          if (rax_20 != 4)
00023238              goto label_23380;
00023238          
00023241          rax_23 = FourSensorPath(pContext);
00023234      }
00023234      
00023250  label_23250:
00023250      
00023253      if (!rax_23)
00023253          goto label_23380;
00023253      
00023260      int64_t* rsi;
00023260      
00023260      if (!pContext->pen.penInUse)
00023260      {
00023305          if (pContext->pen.prevPenMode)
00023305          {
00023316              memset(&pContext->trackStateData, 0, 0x120);
0002331e              CTL_Init_Triggers(pContext);
00023305          }
00023305          
00023323          rsi = &pContext->outputTouches;
0002333a          PerformTouchTracking(pContext, &pContext->touches, rsi, 1);
00023349          UpdateTrackingCircles(&pContext->filterData, rsi);
00023260      }
00023260      else
00023260      {
0002326c          enum touch_state_t touchState = pContext->touches.touches[0].touchState;
00023272          rsi = &pContext->outputTouches;
00023287          int64_t rax_24;
00023287          enum touch_state_t rcx_15;
00023287          
00023287          if (pContext->penStatics.currentState != TS_TOUCH_DOWN && rcx_15 != 2)
00023287          {
0002328e              if (touchState == TS_TOUCH)
0002329c                  rdi_1 = TS_TOUCH_DOWN;
0002328e              else
0002328e              {
00023290                  rdi_1 = TS_HOVER;
00023290                  
00023296                  if (touchState != TS_HOVER)
00023296                      rdi_1 = TS_NO_TOUCH;
0002328e              }
0002328e              
000232b0              (uint32_t)rax_24 = pContext->touches.touches[0].position.x;
000232b0              *(uint32_t*)((char*)rax_24)[4] = pContext->touches.touches[0].position.y;
00023287          }
00023287          else if (touchState == TS_TOUCH)
000232a3          {
000232ae              rdi_1 = TS_TOUCH;
000232b0              (uint32_t)rax_24 = pContext->touches.touches[0].position.x;
000232b0              *(uint32_t*)((char*)rax_24)[4] = pContext->touches.touches[0].position.y;
000232a3          }
000232a3          else
000232a3          {
000232a5              (uint32_t)rax_24 = pContext->penStatics.prevTouchPos.x;
000232a5              *(uint32_t*)((char*)rax_24)[4] = pContext->penStatics.prevTouchPos.y;
000232a3          }
000232a3          
000232b7          *(uint64_t*)rsi = rax_24;
000232ba          int32_t rax_25;
000232ba          (uint16_t)rax_25 = pContext->touches.id.id;
000232ba          *(uint16_t*)((char*)rax_25)[2] = pContext->touches.id.deltaTimeStamp;
000232c0          *(uint32_t*)((char*)rsi + 0x2a) = rax_25;
000232c3          pContext->penStatics.currentState = rdi_1;
000232c9          struct fpoint_t rax_26;
000232c9          rax_26.x = pContext->touches.touches[0].position.x;
000232c9          rax_26.y = pContext->touches.touches[0].position.y;
000232d0          pContext->penStatics.prevTouchPos.x = rax_26.x;
000232d0          pContext->penStatics.prevTouchPos.y = rax_26.y;
000232d0          
000232e3          if (rdi_1 == TS_HOVER && !(pContext->settings.penSt.enabled & 4))
000232e3          {
000232e5              rdi_1 = TS_NO_TOUCH;
000232e8              rsi[5] = 0;
000232e3          }
000232e3          
000232ec          rsi[5] = 0;
000232ec          
000232f3          if (rdi_1)
000232f5              rsi[5] = 1;
000232f5          
000232f9          rsi[1] = rdi_1;
00023260      }
00023260      
0002334e      void (* triangulatedTouchesCallback)(void*, struct touches_t*) =
0002334e          pContext->triangulatedTouchesCallback;
0002334e      
00023361      if (triangulatedTouchesCallback && pContext->outputTouches.touchCount > 0)
0002336d          triangulatedTouchesCallback(pContext->triangulatedTouchesParam, rsi);
0002336d      
0002336f      (uint8_t)triangulatedTouchesCallback = pContext->pen.penInUse;
00023375      pContext->pen.prevPenMode = (uint8_t)triangulatedTouchesCallback;
00022f18  }

0002342f                                               cc cc cc cc cc cc cc cc cc                                         .........

00023438    void Calculate_Center_Angles(struct sensor_set_t* sensor, struct edgeStruct_t* edges)

00023438  {
00023455      int64_t rsi = 0;
00023457      struct edgeStruct_t* edges_1 = edges;
0002345d      int64_t rbp = 0;
0002345f      float* rdi = &edges->CentreAngles[1];
00023463      uint8_t* rbx = &sensor->edgeSet[0].touchCount;
00023467      int64_t i_1 = 4;
000234e2      int64_t i;
000234e2      
000234e2      do
000234e2      {
0002346b          (uint8_t)edges = 0;
0002346b          
0002346f          if (ADJ(rbx)->edgeSet[0].touchCount > 0)
0002346f          {
0002349c              do
0002349c              {
00023471                  uint64_t rcx = (uint64_t)(uint8_t)edges;
00023474                  (uint8_t)edges += 1;
00023476                  int64_t rax_1 = rcx + rbp;
00023493                  edges_1->CentreAngles[rsi + rcx] = (
00023493                      sensor->edgeSet[0].edgePair[rax_1].edge[1]
00023493                      + *(uint32_t*)((char*)sensor + (rax_1 << 3))) * 0.5f;
0002349c              } while ((uint8_t)edges < ADJ(rbx)->edgeSet[0].touchCount);
0002346f          }
0002346f          
000234a1          if (ADJ(rbx)->edgeSet[0].touchCount < 2)
000234bf              memset(
000234bf                  &edges_1->CentreAngles[(uint64_t)ADJ(rbx)->edgeSet[0].touchCount + rsi], 
000234bf                  0, (uint64_t)(2 - ADJ(rbx)->edgeSet[0].touchCount) << 2);
000234bf          
000234c7          if (ADJ(rbx)->edgeSet[0].touchCount == 1)
000234cc              ADJ(rdi)->CentreAngles[1] = ADJ(rdi)->CentreAngles[0];
000234cc          
000234ce          rbp += 0xe;
000234d2          rsi += 0x1a;
000234d6          rbx = &rbx[0x70];
000234da          rdi = &rdi[0x1a];
000234de          i = i_1;
000234de          i_1 -= 1;
000234e2      } while (i != 1);
00023438  }

00023503           cc cc cc cc cc cc cc cc cc                                                                 .........

0002350c    void FindExtra2CamEdges(struct _ctl_context_t* pContext, uint8_t processNearfield)

0002350c  {
0002351c      void var_c8;
0002351c      int64_t rax_1 = __security_cookie ^ &var_c8;
0002352a      uint64_t currentSensor = (uint64_t)pContext->currentSensor;
0002352d      struct edgeStruct_t edges;
0002352d      edges.Num_Edges = 0;
0002352d      
00023544      if (pContext->edges[currentSensor].Num_Edges)
00023544      {
0002354a          int32_t rax_4 = (int32_t)(currentSensor + 2);
0002354a          
00023550          if (rax_4 < 4)
00023550          {
00023598              FindEdges(pContext, (uint8_t)currentSensor, 
00023598                  &pContext->waveforms[currentSensor], 
00023598                  &pContext->waveforms[(int64_t)rax_4].trigger, &edges, 50f, 1);
00023598              
000235a5              if (edges.Num_Edges)
000235a5              {
0002363c                  pContext->currentSensor
00023656                  edges.touchIntegral[0] =
00023656                      pContext->edges[(uint64_t)*(char*)pContext].touchIntegral[0];
0002366e                  edges.touchIntegral[1] =
0002366e                      pContext->edges[(uint64_t)*(char*)pContext].touchIntegral[1];
00023676                  memmove(&pContext->edges[(uint64_t)*(char*)pContext], &edges, 0x68);
00023687                  *(uint8_t*)(((uint64_t)pContext->currentSensor + 0x7a) * 0x68
00023687                      + pContext) = 0x32;
000235a5              }
000235a5              else
000235a5              {
000235ab                  uint64_t currentSensor_1 = (uint64_t)pContext->currentSensor;
000235b1                  int64_t rcx_2 = currentSensor_1 ^ 1;
000235b1                  
000235d2                  if (!pContext->edges[rcx_2].Num_Edges
000235d2                      || *(uint8_t*)((rcx_2 + 0x7a) * 0x68 + pContext) != 0x32)
000235d2                  {
000235f4                      int32_t rax_18;
000235f4                      
000235f4                      if (pContext->edges[currentSensor_1].Num_Edges == 2)
00023605                          rax_18 = (uint32_t)pContext->settings.sensor[currentSensor_1].
00023605                              stopAperture - 0x14;
00023605                      
00023618                      if (pContext->edges[currentSensor_1].Num_Edges != 2
00023618                              || pContext->edges[currentSensor_1].Raw_Edges[0] <= rax_18
00023618                              || pContext->edges[currentSensor_1].Raw_Edges[1] <= rax_18)
00023635                          memset(&pContext->edges, 0, 0x68);
00023618                      else
00023622                          *(uint8_t*)((currentSensor_1 + 0x7a) * 0x68 + pContext) = 0x32;
000235d2                  }
000235d2                  else
000235dc                      *(uint8_t*)((currentSensor_1 + 0x7a) * 0x68 + pContext) = 0x4b;
000235a5              }
00023550          }
00023544      }
00023544      
00023697      __security_check_cookie(rax_1 ^ &var_c8);
0002350c  }

000236a5                 cc cc cc cc cc cc cc                                                                   .......

000236ac    void PerformTouchTracking(struct _ctl_context_t* pContext, struct touches_t* ptouchesIn, struct touches_t* ptouchesOut, uint8_t stable)

000236ac  {
000236c7      pContext->trackStateData.timeStamp = pContext->timestamp;
000236d3      pContext->trackStateData.stabilityOfPreTouch =
000236d3          pContext->pretouchData.touchStabilities;
000236ec      pContext->trackStateData.timeSinceLastNoEdges =
000236ec          pContext->ssOutput.timestamp - pContext->pretouchData.timeOfLastNoEdges;
000236f2      uint32_t rax_3;
000236f2      (uint8_t)rax_3 = pContext->settings.numSensors == 2;
00023700      TTS_TrackTouches(&pContext->trackStateData, ptouchesIn, ptouchesOut, stable, 
00023700          (uint8_t)rax_3);
0002370f      SmoothOutputTouchJitter(&pContext->trackStateData, ptouchesOut);
0002370f      
0002371b      if (pContext->settings.numSensors == 4)
0002371b      {
00023732          uint128_t zmm1_1;
00023732          (uint32_t)zmm1_1 =
00023732              _mm_cvtepi32_ps((uint128_t)ptouchesOut->id.deltaTimeStamp) / 1000f;
0002373a          FC_StraightLineFilter(&pContext->straightLineFilter, (uint32_t)zmm1_1, 
0002373a              ptouchesOut);
0002371b      }
000236ac  }

0002374f                                               cc cc cc cc cc cc cc cc cc                                         .........

00023758    uint8_t ActivePenPath(struct _ctl_context_t* pContext, struct pen_t pen, uint8_t numSensors, float* retTriangError)

00023758  {
0002375b      struct pen_t arg_10;
0002375b      arg_10.penInUse = pen.penInUse;
0002375b      arg_10.prevPenMode = pen.prevPenMode;
0002375b      arg_10.pentip = pen.pentip;
0002375b      arg_10.eraser = pen.eraser;
00023771      *(uint32_t*)retTriangError = 0f;
00023775      retTriangError[1] = 0;
0002377a      int128_t zmm6;
0002377a      int128_t var_58 = zmm6;
0002377e      int128_t zmm7;
0002377e      int128_t var_68 = zmm7;
00023782      int32_t rax;
00023782      (uint16_t)rax = pContext->ssInput.id.id;
00023782      *(uint16_t*)((char*)rax)[2] = pContext->ssInput.id.deltaTimeStamp;
00023788      struct _ctl_context_t* pContext_1 = pContext;
0002378b      pContext->touches.id.id = (uint16_t)rax;
0002378b      pContext->touches.id.deltaTimeStamp = *(uint16_t*)((char*)rax)[2];
00023791      (uint8_t)rax = 0;
00023793      struct edgeStruct_t (* edges_1)[0x4] = &pContext->edges;
0002379a      (uint8_t)pContext = 0;
0002379c      int64_t r15;
0002379c      (uint8_t)r15 = 0;
0002379f      float* dist2 = retTriangError;
000237a2      char arg_18 = 0;
000237a9      int64_t r12;
000237a9      (uint8_t)r12 = numSensors;
000237ac      struct pen_t rbx;
000237ac      rbx.penInUse = pen.penInUse;
000237ac      rbx.prevPenMode = pen.prevPenMode;
000237ac      rbx.pentip = pen.pentip;
000237ac      rbx.eraser = pen.eraser;
000237ae      uint8_t arg_8 = 0;
000237bd      struct line_def_t lines[0x4];
000237bd      struct line_def_t (* arg_20)[0x4];
000237bd      struct line_def_t (* rdx)[0x4];
000237bd      
000237bd      if (numSensors)
000237bd      {
000237c3          zmm6 = 0x3f000000;
000237d3          rdx = &lines;
000237db          float (* r14_1)[0x4] = (char*)edges_1 + 0x40;
000237df          float* r13 = &pContext_1->settings.sensorInfo[0].position.y;
000237e6          arg_20 = &lines;
000237e6          
00023894          do
00023894          {
000237f3              if (*((char*)ADJ(r14_1) + 0x3191) == 2)
000237f3              {
0002380a                  float zmm0;
0002380a                  zmm0 = _safeTan((ADJ(r14_1)->edges[0].Angles[1]
0002380a                      + ADJ(r14_1)->edges[0].Angles[0]) * (uint32_t)zmm6
0002380a                      + ADJ(r13)->settings.sensorInfo[0].rotation_offset);
0002380f                  (uint8_t)rdx = (uint8_t)arg_20;
0002380f                  *(uint8_t*)((char*)rdx)[1] = *(uint8_t*)((char*)arg_20)[1];
0002380f                  *(uint8_t*)((char*)rdx)[2] = *(uint8_t*)((char*)arg_20)[2];
0002380f                  *(uint8_t*)((char*)rdx)[3] = *(uint8_t*)((char*)arg_20)[3];
00023817                  float y = ADJ(r13)->settings.sensorInfo[0].position.y;
00023822                  float var_d4_1 = (uint32_t)zmm7;
00023828                  float var_dc = zmm0;
00023834                  y = y - zmm0 * ADJ(r13)->settings.sensorInfo[0].position.x;
00023840                  *(uint32_t*)rdx = var_dc;
00023845                  *(uint32_t*)((char*)rdx + 4) = y;
0002384b                  (uint8_t)pContext = arg_18;
00023852                  *(uint32_t*)((char*)rdx + 8) = var_d4_1;
00023857                  (uint8_t)rax = 1 << (uint8_t)pContext;
00023859                  (uint8_t)pContext = arg_8;
00023860                  (uint8_t)pContext |= (uint8_t)rax;
00023862                  (uint8_t)rax = arg_18;
00023869                  (uint8_t)r15 += 1;
0002386c                  arg_8 = (uint8_t)pContext;
000237f3              }
000237f3              
00023873              (uint8_t)rax += 1;
00023876              rdx = &(*(uint384_t*)rdx)[1];
0002387a              r14_1 = &(*(uint128_t*)r14_1)[0x1a];
0002387e              r13 = &r13[3];
00023882              arg_18 = (uint8_t)rax;
00023889              (uint8_t)arg_20 = (uint8_t)rdx;
00023889              *(uint8_t*)((char*)arg_20)[1] = *(uint8_t*)((char*)rdx)[1];
00023889              *(uint8_t*)((char*)arg_20)[2] = *(uint8_t*)((char*)rdx)[2];
00023889              *(uint8_t*)((char*)arg_20)[3] = *(uint8_t*)((char*)rdx)[3];
00023894          } while ((uint8_t)rax < (uint8_t)r12);
00023894          
0002389a          edges_1 = &pContext_1->edges;
000237bd      }
000237bd      
000238a4      if (!numSensors || (uint8_t)r15 <= 1)
000238a4      {
000239d7          pContext_1->touches.touches[0].touchState = TS_NO_TOUCH;
000239de          pContext_1->touches.touchCount = 0;
000238a4      }
000238a4      else
000238a4      {
000238aa          (uint8_t)rdx = (uint8_t)pContext;
000238b4          (uint8_t)retTriangError = (uint8_t)r12;
000238ba          struct fpoint_t rax_4 =
000238ba              MinDistTriangQbyCam(&lines, (uint8_t)rdx, dist2, (uint8_t)retTriangError);
000238bf          pContext_1->touches.touches[0].position.x = rax_4.x;
000238bf          pContext_1->touches.touches[0].position.y = rax_4.y;
000238bf          
000238cc          if (pContext_1->autoCorrectData.autoCorrectState == AC_ACCUMULATING)
000238cc          {
000238d3              struct fpoint_t touchPos;
000238d3              touchPos.x = rax_4.x;
000238d3              touchPos.y = rax_4.y;
000238dc              AutoCorrect_Accumulate(pContext_1, (uint8_t)r12, touchPos, *(uint32_t*)dist2);
000238cc          }
000238cc          
000238f3          void var_e8;
000238f3          memmove(&var_e8, &pContext_1->settings.penSt, 0x28);
00023904          char var_110;
00023904          var_110 = &var_e8;
0002391d          int32_t var_118;
0002391d          var_118 = &pContext_1->penStatics;
00023922          zmm6 = PopulateDerivatives((uint8_t)r12, &pContext_1->settings.sensorInfo, 
00023922              &pContext_1->touches.touches, edges_1, pContext_1, 1);
00023922          
00023932          if (SparkleFilter(pContext_1) == 1)
00023934              return 0;
00023934          
00023941          int64_t rdx_4;
00023941          (uint8_t)rdx_4 = (&pContext_1->penStatics);
00023941          *(uint8_t*)((char*)rdx_4)[1] = *(uint8_t*)((char*)(&pContext_1->penStatics))[1];
00023941          *(uint8_t*)((char*)rdx_4)[2] = *(uint8_t*)((char*)(&pContext_1->penStatics))[2];
00023941          *(uint8_t*)((char*)rdx_4)[3] = *(uint8_t*)((char*)(&pContext_1->penStatics))[3];
0002394a          int32_t rcx_6;
0002394a          uint8_t rdx_5;
0002394a          rcx_6 = memmove(&var_e8, rdx_4, 0x48);
0002394f          struct line_def_t (* r11)[0x4];
0002394f          (uint32_t)r11 = pContext_1->settings.panelSize.x;
0002394f          *(uint32_t*)((char*)r11)[4] = pContext_1->settings.panelSize.y;
0002395b          bool cond:0_1 = *(uint32_t*)dist2 <= (uint32_t)zmm6;
0002395e          arg_20 = r11;
0002395e          
00023966          if (!cond:0_1)
00023966          {
0002399e              var_110 = &lines;
000239a3              (uint8_t)rcx_6 = (uint8_t)r12;
000239a6              var_118 = edges_1;
000239ab              int64_t rdx_6;
000239ab              rcx_6 = ReflectionFilter((uint8_t)rcx_6, (uint8_t)r15, arg_8, 
000239ab                  &pContext_1->touches, var_118, var_110, dist2, &var_e8, &arg_20);
00023966          }
00023966          
000239b7          rbx.penInUse = arg_10.penInUse;
000239b7          rbx.prevPenMode = arg_10.prevPenMode;
000239b7          rbx.pentip = arg_10.pentip;
000239b7          rbx.eraser = arg_10.eraser;
000239be          pContext_1->touches.touchCount = 1;
000239cf          pContext_1->touches.touches[0].touchState = ((rcx_6 - rcx_6) & 0xfffffffd) + 5;
000238a4      }
000238a4      
000239f3      struct edgeStruct_t* edges;
000239f3      (uint8_t)edges = (uint8_t)edges_1;
000239f3      *(uint8_t*)((char*)edges)[1] = *(uint8_t*)((char*)edges_1)[1];
000239f3      *(uint8_t*)((char*)edges)[2] = *(uint8_t*)((char*)edges_1)[2];
000239f3      *(uint8_t*)((char*)edges)[3] = *(uint8_t*)((char*)edges_1)[3];
000239fe      struct pen_t pen_1;
000239fe      pen_1.penInUse = rbx.penInUse;
000239fe      pen_1.prevPenMode = rbx.prevPenMode;
000239fe      pen_1.pentip = rbx.pentip;
000239fe      pen_1.eraser = rbx.eraser;
00023a02      AutoShutter(pContext_1, edges, &pContext_1->penStatics, 
00023a02          pContext_1->settings.penSt.shutterRate, pen_1, (uint8_t)r15);
00023a2b      return 1;
00023758  }

00023a2c                                      cc cc cc cc cc cc cc cc                                                  ........

00023a34    uint8_t SparkleFilter(struct _ctl_context_t* pContext)

00023a34  {
00023a5a      uint64_t i_1;
00023a5a      uint64_t var_38 = __security_cookie ^ &i_1;
00023a5f      int64_t r11;
00023a5f      (uint8_t)r11 = pContext->settings.numSensors;
00023a66      char rdx = 0;
00023a6b      struct edgeStruct_t (* rbx)[0x4] = &pContext->edges;
00023a7a      void var_50;
00023a7a      int16_t var_40[0x4];
00023a7a      uint64_t rax_1;
00023a7a      void* r8;
00023a7a      
00023a7a      if ((uint8_t)r11 > 0)
00023a7a      {
00023a84          int64_t r15_1 = 0;
00023a87          int16_t (* rcx)[0x4] = &var_40;
00023a8c          r8 = &var_50;
00023a91          struct edgeStruct_t (* rbp_1)[0x4] = rbx;
00023a94          uint16_t* r12_1 = &pContext->settings.sensor[0].stopAperture;
00023a9b          i_1 = (uint64_t)(uint8_t)r11;
00023a9f          uint8_t* r14_1 = &pContext->edges[0].Num_Edges;
00023aa6          r11 = 0;
00023ba4          uint64_t i;
00023ba4          
00023ba4          do
00023ba4          {
00023aaf              uint32_t rax_3;
00023aaf              uint64_t j_2;
00023aaf              
00023aaf              if (ADJ(rbp_1)->edges[0].Raw_Edges[0] >= ADJ(rbp_1)->edges[0].Raw_Edges[1])
00023aaf              {
00023ab9                  (uint8_t)j_2 = 1;
00023abc                  (uint8_t)rax_3 = 0;
00023aaf              }
00023aaf              else
00023aaf              {
00023ab1                  (uint8_t)j_2 = 0;
00023ab4                  (uint8_t)rax_3 = 1;
00023aaf              }
00023aaf              
00023ac1              *(uint32_t*)r8 = 0;
00023ac4              *(uint16_t*)rcx = 1;
00023aca              int32_t r13_1 =
00023aca                  *(uint32_t*)((char*)rbx + (((uint64_t)(uint8_t)rax_3 + r15_1) << 2));
00023ad5              int32_t rsi_1 =
00023ad5                  *(uint32_t*)((char*)rbx + (((uint64_t)(uint8_t)j_2 + r15_1) << 2));
00023ad5              
00023aea              if (r13_1 - rsi_1 < 8 && *((char*)ADJ(r14_1) + 0x3191) == 2)
00023aea              {
00023af0                  uint64_t startAperture =
00023af0                      (uint64_t)ADJ(r12_1)->settings.sensor[0].startAperture;
00023af0                  
00023aff                  if ((uint32_t)startAperture < rsi_1 - 2)
00023aff                  {
00023b04                      int32_t j_5 = rsi_1 - 2 - (uint32_t)startAperture;
00023b07                      int32_t rbx_1 = 0;
00023b0e                      uint64_t j_3 = (uint64_t)j_5;
00023b11                      void* rdi_1 = &pContext->waveforms + ((startAperture + r11) << 1);
00023b24                      uint64_t j;
00023b24                      
00023b24                      do
00023b24                      {
00023b18                          uint32_t rax_11 = (uint32_t)*(uint16_t*)rdi_1;
00023b1b                          rdi_1 += 2;
00023b1f                          rbx_1 += rax_11;
00023b21                          j = j_3;
00023b21                          j_3 -= 1;
00023b24                      } while (j != 1);
00023b26                      rdx = 0;
00023b28                      *(uint32_t*)r8 = rbx_1;
00023b2b                      *(uint16_t*)rcx = (uint16_t)j_5 + 1;
00023aff                  }
00023aff                  
00023b31                  uint32_t stopAperture =
00023b31                      (uint32_t)ADJ(r12_1)->settings.sensor[0].stopAperture;
00023b36                  j_2 = (uint64_t)(r13_1 + 2);
00023b36                  
00023b40                  if ((uint32_t)j_2 < stopAperture)
00023b40                  {
00023b46                      int32_t rdi_2 = *(uint32_t*)r8;
00023b4c                      int32_t j_4 = stopAperture - (uint32_t)j_2;
00023b4f                      void* rsi_4 =
00023b4f                          &pContext->waveforms + (((int64_t)(uint32_t)j_2 + r11) << 1);
00023b59                      int16_t r13_2 = *(uint16_t*)rcx + (uint16_t)j_4;
00023b5d                      j_2 = (uint64_t)j_4;
00023b6c                      uint64_t j_1;
00023b6c                      
00023b6c                      do
00023b6c                      {
00023b60                          rax_1 = (uint64_t)*(uint16_t*)rsi_4;
00023b63                          rsi_4 += 2;
00023b67                          rdi_2 += (uint32_t)rax_1;
00023b69                          j_1 = j_2;
00023b69                          j_2 -= 1;
00023b6c                      } while (j_1 != 1);
00023b6e                      rdx = 0;
00023b70                      *(uint32_t*)r8 = rdi_2;
00023b73                      *(uint16_t*)rcx = r13_2;
00023b40                  }
00023b40                  
00023b7a                  rbx = &pContext->edges;
00023aea              }
00023aea              
00023b81              rbp_1 = &(*(uint3328_t*)rbp_1)[1];
00023b85              r14_1 = &r14_1[0x68];
00023b89              r15_1 += 0x1a;
00023b8d              r12_1 = &r12_1[0x1a];
00023b91              r8 += 4;
00023b95              rcx = &(*(uint64_t*)rcx)[1];
00023b99              r11 += 0x625;
00023ba0              i = i_1;
00023ba0              i_1 -= 1;
00023ba4          } while (i != 1);
00023baa          (uint8_t)r11 = pContext->settings.numSensors;
00023a7a      }
00023a7a      
00023bb1      (uint8_t)r8 = 1;
00023bb1      
00023bb7      if ((uint8_t)r11 > 1)
00023bb7      {
00023bb9          void var_4c;
00023bb9          int32_t* r9 = &var_4c;
00023bb9          
00023bdc          do
00023bdc          {
00023bcf              if (*(uint32_t*)r9 > *(uint32_t*)(&var_50 + ((uint64_t)rdx << 2)))
00023bcf                  rdx = (uint8_t)r8;
00023bcf              
00023bd2              (uint8_t)r8 += 1;
00023bd5              r9 = &r9[1];
00023bdc          } while ((uint8_t)r8 < (uint8_t)r11);
00023bb7      }
00023bb7      
00023bde      uint64_t r8_1 = (uint64_t)rdx;
00023bde      
00023c08      if ((float)(uint64_t)*(uint32_t*)(&var_50 + (r8_1 << 2))
00023c08              / _mm_cvtepi32_ps((uint128_t)var_40[r8_1]) <= 12f)
00023c1d          (uint8_t)rax_1 = 0;
00023c08      else
00023c08      {
00023c0f          (uint8_t)rax_1 = 1;
00023c12          pContext->penStatics.peakSignal[r8_1] = 0xe10;
00023c08      }
00023c08      
00023c27      __security_check_cookie(var_38 ^ &i_1);
00023c48      return (uint8_t)rax_1;
00023a34  }

00023c49                             cc cc cc cc cc cc cc                                                           .......

00023c50    void __convention("sysv") PopulateDerivatives(uint8_t numSensors @ rcx, struct sensor_info_t* sensorInfo @ rdx, struct fpoint_t const* touchPos @ r8, struct edgeStruct_t* edges @ r9, struct penStatics_t* retPenStatics, struct pen_settings_t* penSt)

00023c50  {
00023c52      if (!numSensors)
00023c52          return;
00023c52      
00023c89      uint128_t zmm8 = 0x7fffffffffffffff;
00023c95      struct sensor_info_t* B = sensorInfo;
00023c98      float (* rbx_1)[0x2] = &edges->CentreAngles;
00023c9c      uint64_t rbp_1 = (uint64_t)numSensors;
00023c9f      float (* rdi_1)[0x4] = &retPenStatics->estimateSignal;
00023da8      uint64_t i;
00023da8      
00023da8      do
00023da8      {
00023cab          if (ADJ(rbx_1)->Num_Edges != 2)
00023cab          {
00023d8e              ADJ(rbx_1)->CentreAngles[0] = 0;
00023d91              ADJ(rdi_1)->distance[0] = 0f;
00023d95              ADJ(rdi_1)->estimateSignal[0] = 0;
00023cab          }
00023cab          else
00023cab          {
00023cb1              float zmm0[0x4];
00023cb1              zmm0[0] = ADJ(rbx_1)->Angles[0];
00023cb1              zmm0[1] = ADJ(rbx_1)->Angles[0];
00023cb1              zmm0[2] = ADJ(rbx_1)->Angles[0];
00023cb1              zmm0[3] = ADJ(rbx_1)->Angles[0];
00023cbc              zmm0[0] = zmm0[0] + ADJ(rbx_1)->Angles[1];
00023cc1              zmm0[0] = zmm0[0] * 0.5f;
00023cc9              zmm0[0] = zmm0[0] * 57.295826f;
00023cd1              ADJ(rbx_1)->CentreAngles[0] = zmm0[0];
00023cd5              uint128_t zmm0_1;
00023cd5              double zmm4_1;
00023cd5              uint64_t zmm5_1[0x2];
00023cd5              zmm0_1 = DistanceSquare(touchPos, B);
00023ce1              double zmm1_1[0x2];
00023ce1              double entry_zmm3;
00023ce1              uint64_t zmm6[0x2];
00023ce1              
00023ce1              if ((uint32_t)zmm0_1 <= 0f)
00023cf4                  zmm1_1 = {0};
00023ce1              else
00023ce1              {
00023ce9                  zmm0_1 = sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_1, (uint64_t)zmm0_1)));
00023cee                  zmm1_1[0] = (float)(uint64_t)zmm0_1;
00023ce1              }
00023ce1              
00023d0a              ADJ(rdi_1)->distance[0] = zmm1_1[0];
00023d0f              char var_a8[0x14];
00023d0f              memmove(&var_a8, penSt, 0x28);
00023d22              char var_78[0x10];
00023d22              memmove(&var_78, retPenStatics, 0x48);
00023d3a              int32_t var_94;
00023d3a              void var_68;
00023d3a              uint64_t zmm1_2[0x2];
00023d3a              uint64_t entry_zmm2[0x2];
00023d3a              uint64_t zmm9[0x2];
00023d3a              zmm0 = pow(
00023d3a                  _mm_cvtps_pd((uint64_t)*(uint32_t*)(&var_68 - retPenStatics + rdi_1)), 
00023d3a                  _mm_cvtps_pd(((uint128_t)var_94)[0]), entry_zmm2, entry_zmm3, zmm4_1, 
00023d3a                  zmm5_1, zmm6, zmm8, zmm9);
00023d47              zmm1_2[0] = (float)*(uint64_t*)&zmm0[0];
00023d4b              zmm0[0] = ADJ(rbx_1)->CentreAngles[0];
00023d4b              zmm0[1] = ADJ(rbx_1)->CentreAngles[0];
00023d4b              zmm0[2] = ADJ(rbx_1)->touchIntegral[0];
00023d4b              *(uint16_t*)((char*)zmm0[2])[2] = ADJ(rbx_1)->touchIntegral[1];
00023d4b              zmm0[3] = ADJ(rbx_1)->rawTouchWidth[0];
00023d4b              *(uint16_t*)((char*)zmm0[3])[2] = ADJ(rbx_1)->rawTouchWidth[1];
00023d4f              zmm0[0] = zmm0[0] - 45f;
00023d57              (uint32_t)entry_zmm3 = 1f / zmm1_2[0];
00023d5e              zmm1_2 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]);
00023d61              zmm0 = 0x3f800000;
00023d6e              entry_zmm2[0] = (float)_mm_and_pd(zmm1_2, zmm8)[0];
00023d72              entry_zmm2[0] = entry_zmm2[0] / 47.5f;
00023d7a              zmm0[0] = 1f - entry_zmm2[0];
00023d7e              (uint32_t)entry_zmm3 = (uint32_t)entry_zmm3 * zmm0[0];
00023d82              int32_t var_90;
00023d82              (uint32_t)entry_zmm3 = (uint32_t)entry_zmm3 * var_90;
00023d88              ADJ(rdi_1)->estimateSignal[0] = (uint32_t)entry_zmm3;
00023cab          }
00023cab          
00023d98          B = &B[1];
00023d9c          rdi_1 = &(*(uint128_t*)rdi_1)[1];
00023da0          rbx_1 = &rbx_1[0xd];
00023da4          i = rbp_1;
00023da4          rbp_1 -= 1;
00023da8      } while (i != 1);
00023c50  }

00023dd5                                                                 cc cc cc cc cc cc cc                                   .......

00023ddc    void ReflectionFilter(uint8_t arg1, uint8_t arg2, uint8_t arg3, struct fpoint_t* arg4, struct edgeStruct_t* arg5, struct line_def_t* arg6, float* arg7, struct penStatics_t* arg8, struct fpoint_t arg9)

00023ddc  {
00023e07      int64_t r12;
00023e07      (uint8_t)r12 = arg1;
00023e0a      uint32_t rcx = (uint32_t)arg2;
00023e0d      int64_t rsi;
00023e0d      (uint8_t)rsi = arg3;
00023e1e      void penStatics;
00023e1e      
00023e1e      if (rcx == 3)
00023e1e      {
00023ee9          memmove(&penStatics, arg8, 0x48);
00023f13          struct edgeStruct_t* rbx;
00023f13          (uint8_t)rbx = 0;
00023f13          
00023f17          if (!EliminateBadCameraByBrighness34((uint8_t)r12, (uint8_t)rsi, arg4, arg5, 
00023f17              arg6, arg7, &penStatics))
00023f17          {
00023f24              int64_t* rax_4;
00023f24              (uint32_t)rax_4 = arg9.x;
00023f24              *(uint32_t*)((char*)rax_4)[4] = arg9.y;
00023f34              int64_t rcx_7 = *(uint64_t*)rax_4;
00023f37              int64_t rax_5;
00023f37              (uint32_t)rax_5 = arg4->x;
00023f37              *(uint32_t*)((char*)rax_5)[4] = arg4->y;
00023f3b              int64_t var_88_1 = rax_5;
00023f45              (uint8_t)rax_5 = 0;
00023f45              
00023f5a              if (!((uint32_t)var_88_1 <= (uint32_t)rcx_7 * 0.5f))
00023f5c                  (uint8_t)rax_5 = 1;
00023f5c              
00023f71              if (!(*(uint32_t*)((char*)var_88_1)[4]
00023f71                      <= *(uint32_t*)((char*)rcx_7)[4] * 0.5f))
00023f73                  (uint8_t)rax_5 |= 2;
00023f73              
00023f77              if ((uint8_t)rax_5 > 1)
00023f77              {
00023f97                  if (!((uint8_t)rsi & 1) || !((uint8_t)rsi & 2))
00023f97                  {
00023f99                      (uint8_t)rbx = (uint8_t)rsi;
00023f9c                      (uint8_t)rbx &= 3;
00023f97                  }
00023f77              }
00023f77              else if (!((uint8_t)rsi & 4) || !((uint8_t)rsi & 8))
00023f83              {
00023f85                  (uint8_t)rbx = (uint8_t)rsi;
00023f88                  (uint8_t)rbx &= 0xc;
00023f83              }
00023f83              
00023f9f              (uint8_t)rbx = ~(uint8_t)rbx;
00023fa8              (uint8_t)rbx &= (uint8_t)rsi;
00023fb0              struct fpoint_t rax_6 =
00023fb0                  MinDistTriangQbyCam(arg6, (uint8_t)rbx, &arg7[1], (uint8_t)r12);
00023fb5              arg4->x = rax_6.x;
00023fb5              arg4->y = rax_6.y;
00023fb9              *(uint32_t*)arg7 = 7f;
00023f17          }
00023f17          else
00023f19              *(uint32_t*)arg7 = 6f;
00023e1e      }
00023e1e      else if (rcx == 4)
00023e27      {
00023e42          memmove(&penStatics, arg8, 0x48);
00023e42          
00023e70          if (!EliminateBadCameraByBrighness34((uint8_t)r12, (uint8_t)rsi, arg4, arg5, 
00023e70              arg6, arg7, &penStatics))
00023e70          {
00023ec3              if (!EliminateBadCameraByError4((uint8_t)r12, (uint8_t)rsi, arg4, arg6, arg7))
00023ed0                  *(uint32_t*)arg7 = 9f;
00023ec3              else
00023ec5                  *(uint32_t*)arg7 = 4f;
00023e70          }
00023e70          else
00023e70          {
00023e72              int32_t zmm0_1 = arg7[1];
00023e77              *(uint32_t*)arg7 = 5f;
00023e77              
00023e84              if (!(zmm0_1 <= 1f))
00023e84              {
00023e9b                  EliminateBadCameraByError4((uint8_t)r12, (uint8_t)rsi, arg4, arg6, arg7);
00023ea0                  *(uint32_t*)arg7 = 3f;
00023e84              }
00023e70          }
00023e27      }
00023e27      else
00023e29          *(uint32_t*)arg7 = 8f;
00023ddc  }

00023fd6                                                                    cc cc cc cc cc cc                                    ......

00023fdc    uint8_t EliminateBadCameraByError4(uint8_t numSensors, uint8_t camBits, struct fpoint_t* touchPos, struct line_def_t* trigLines, float* retTriangError)

00023fdc  {
00024001      int64_t rbx;
00024001      (uint8_t)rbx = 0;
00024003      struct line_def_t* lines = trigLines;
00024009      int64_t r12;
00024009      (uint8_t)r12 = camBits;
0002400c      (uint8_t)trigLines = numSensors;
0002400f      int64_t rdi;
0002400f      (uint8_t)rdi = 0;
00024012      int32_t var_28 = 0x49742400;
00024017      int32_t var_24 = 0x49742400;
0002401c      int32_t var_20 = 0x49742400;
00024021      int32_t var_1c = 0x49742400;
00024021      
00024028      if (numSensors > 0)
00024028      {
0002402d          int32_t* dist2 = &var_28;
0002402d          
0002405b          do
0002405b          {
00024031              numSensors = (uint8_t)rdi;
00024031              
00024038              if (TEST_BITD((uint32_t)camBits, numSensors))
0002404c                  MinDistTriangQbyCam(lines, ~(1 << numSensors) & (uint8_t)r12, dist2, 
0002404c                      (uint8_t)trigLines);
0002404c              
00024051              (uint8_t)rdi += 1;
00024054              dist2 = &dist2[1];
0002405b          } while ((uint8_t)rdi < (uint8_t)trigLines);
00024028      }
00024028      
0002405d      numSensors = 0;
0002405d      
00024062      if ((uint8_t)trigLines > 0)
00024062      {
00024064          int32_t* rdx_1 = &var_28;
00024064          
00024082          do
00024082          {
00024075              if (!((&var_28)[(uint64_t)(uint8_t)rbx] <= *(uint32_t*)rdx_1))
00024077                  (uint8_t)rbx = numSensors;
00024077              
00024079              numSensors += 1;
0002407b              rdx_1 = &rdx_1[1];
00024082          } while (numSensors < (uint8_t)trigLines);
00024062      }
00024062      
00024084      int32_t* retTriangError_1 = retTriangError;
0002408c      *(uint32_t*)retTriangError_1;
00024096      struct fpoint_t rax_2;
00024096      
00024096      if (*(uint32_t*)retTriangError_1 <= (&var_28)[(uint64_t)(uint8_t)rbx])
000240b9          rax_2.x = 0;
00024096      else
00024096      {
000240ad          rax_2 = MinDistTriangQbyCam(lines, ~(1 << (uint8_t)rbx) & (uint8_t)r12, 
000240ad              &retTriangError_1[1], (uint8_t)trigLines);
000240b2          touchPos->x = rax_2.x;
000240b2          touchPos->y = rax_2.y;
000240b5          rax_2.x = 1;
00024096      }
00024096      
000240d9      return rax_2.x;
00023fdc  }

000240da                                                                                cc cc cc cc cc cc                            ......

000240e0    uint8_t EliminateBadCameraByBrighness34(uint8_t numSensors, uint8_t camBits, struct fpoint_t* touchPos, struct edgeStruct_t* edges, struct line_def_t* trigLines, float* retTriangError, struct penStatics_t* penStatics)

000240e0  {
00024102      void var_98;
00024102      int64_t rax_1 = __security_cookie ^ &var_98;
0002411a      int64_t rsi;
0002411a      (uint8_t)rsi = camBits;
00024125      int64_t rdi;
00024125      (uint8_t)rdi = numSensors;
00024138      char var_68[0x20];
00024138      struct fpoint_t rax_2;
00024138      int64_t rcx_1;
00024138      rax_2 = memmove(&var_68, penStatics, 0x48);
0002413d      uint8_t r9 = 0;
00024140      int32_t zmm1 = 0x49742400;
00024148      int32_t var_78 = 0x49742400;
0002414e      int32_t var_74 = 0x49742400;
00024154      int32_t var_70 = 0x49742400;
0002415a      int32_t var_6c = 0x49742400;
0002415a      
00024163      if ((uint8_t)rdi > 0)
00024163      {
0002416d          void var_48;
0002416d          void* r8 = &var_48;
00024172          uint8_t* rdx_1 = &edges->Num_Edges;
00024176          rcx_1 = 0;
00024179          uint64_t i_1 = (uint64_t)(uint8_t)rdi;
000241ca          uint64_t i;
000241ca          
000241ca          do
000241ca          {
00024180              if (ADJ(rdx_1)->Num_Edges == 2)
00024180              {
0002418b                  void var_40;
0002418b                  
0002418b                  if (!((*(uint32_t*)(&var_40 + rcx_1)) <= 2700f))
0002418d                      *(uint32_t*)(&var_40 + rcx_1) = 0x4528c000;
0002418d                  
0002419d                  uint128_t zmm0 = _mm_cvtepi32_ps((uint128_t)*(uint16_t*)r8);
0002419d                  
000241a3                  if (!(2700f <= (uint32_t)zmm0))
000241a3                  {
000241a5                      int32_t zmm2 = *(uint32_t*)(&var_40 + rcx_1);
000241a5                      
000241ae                      if (!(zmm2 <= (uint32_t)zmm0))
000241ae                      {
000241b0                          (uint32_t)zmm0 = (uint32_t)zmm0 / zmm2;
000241b4                          *(uint32_t*)(&var_78 + rcx_1) = (uint32_t)zmm0;
000241ae                      }
000241a3                  }
00024180              }
00024180              
000241ba              rdx_1 = &rdx_1[0x68];
000241be              r8 += 2;
000241c2              rcx_1 += 4;
000241c6              i = i_1;
000241c6              i_1 -= 1;
000241ca          } while (i != 1);
00024163      }
00024163      
000241cc      rax_2.x = 0;
000241cc      
000241d2      if ((uint8_t)rdi > 0)
000241d2      {
000241d4          int32_t* rdx_2 = &var_78;
000241d4          
000241ee          do
000241ee          {
000241dc              if (!(zmm1 <= *(uint32_t*)rdx_2))
000241dc              {
000241de                  zmm1 = *(uint32_t*)rdx_2;
000241e2                  r9 = rax_2.x;
000241dc              }
000241dc              
000241e5              rax_2.x += 1;
000241e7              rdx_2 = &rdx_2[1];
000241ee          } while (rax_2.x < (uint8_t)rdi);
000241d2      }
000241d2      
000241fb      if ((uint8_t)rdi <= 0 || 0.400000006f <= zmm1)
00024223          rax_2.x = 0;
000241fb      else
000241fb      {
000241fd          (uint8_t)rcx_1 = r9;
00024216          rax_2 = MinDistTriangQbyCam(trigLines, ~(1 << (uint8_t)rcx_1) & (uint8_t)rsi, 
00024216              &retTriangError[1], (uint8_t)rdi);
0002421b          touchPos->x = rax_2.x;
0002421b          touchPos->y = rax_2.y;
0002421f          rax_2.x = 1;
000241fb      }
000241fb      
0002422d      __security_check_cookie(rax_1 ^ &var_98);
0002424e      return rax_2.x;
000240e0  }

0002424f                                               cc cc cc cc cc cc cc cc cc                                         .........

00024258    void AutoShutter(struct _ctl_context_t* pContext, struct edgeStruct_t* edges, struct penStatics_t* penStatics, uint32_t shutterRate, struct pen_t pen, uint8_t usableSensors)

00024258  {
0002426e      if (penStatics->elapsedSinceShutterAdjust < shutterRate)
0002426e          return;
0002426e      
00024274      penStatics->elapsedSinceShutterAdjust = 0;
00024279      uint64_t dynamicCamNum = (uint64_t)penStatics->dynamicCamNum;
0002427e      struct pen_t rax;
0002427e      rax.penInUse = pen.penInUse;
0002427e      rax.prevPenMode = pen.prevPenMode;
0002427e      rax.pentip = pen.pentip;
0002427e      rax.eraser = pen.eraser;
00024281      int32_t var_20[0x6];
00024281      var_20[dynamicCamNum] = 0;
00024281      
0002429d      if ((char)(rax >> 0x10) && usableSensors >= 3 && edges[dynamicCamNum].Num_Edges == 2
0002429d          && !(edges[dynamicCamNum].Angles[0] <= 0.17453292f)
0002429d          && !(1.39646709f <= edges[dynamicCamNum].Angles[1])
0002429d          && pContext->penshutter_callback)
0002429d      {
000242de          uint64_t rcx_2 = (uint64_t)(uint8_t)dynamicCamNum;
000242ef          uint16_t rax_4;
000242ef          
000242ef          if (penStatics->peakSignal[rcx_2]
000242ef              <= (uint16_t)(int64_t)(long double)penStatics->estimateSignal[rcx_2])
000242ef          {
0002431c              penStatics->dynamicShutters[rcx_2] += pContext->settings.penSt.shutterUp;
00024322              rax_4 = pContext->settings.penSt.shutterMax;
00024322              
0002432f              if (penStatics->dynamicShutters[rcx_2] > rax_4)
00024331                  penStatics->dynamicShutters[rcx_2] = rax_4;
000242ef          }
000242ef          else
000242ef          {
000242fe              penStatics->dynamicShutters[rcx_2] -= pContext->settings.penSt.shutterDown;
00024304              rax_4 = pContext->settings.penSt.shutterMin;
00024304              
00024311              if (penStatics->dynamicShutters[rcx_2] < rax_4)
00024331                  penStatics->dynamicShutters[rcx_2] = rax_4;
000242ef          }
00024344          (uint8_t)edges = (uint8_t)dynamicCamNum;
00024347          pContext->penshutter_callback(pContext->shutterParam, edges, 
00024347              (uint64_t)penStatics->dynamicShutters[rcx_2]);
0002429d      }
0002429d      
0002434d      penStatics->dynamicCamNum += 1;
0002434d      
00024359      if (penStatics->dynamicCamNum >= pContext->settings.numSensors)
0002435b          penStatics->dynamicCamNum = 0;
00024258  }

0002436d                                         cc cc cc cc cc cc cc                                                   .......

00024374    void AutoCorrect_Init_Data(struct _ctl_context_t* pContext)

00024374  {
000243b2      int128_t zmm11;
000243b2      (uint32_t)zmm11 = pContext->settings.sensorInfo[2].position.y;
000243b2      *(uint32_t*)((char*)zmm11)[4] = pContext->settings.sensorInfo[2].position.y;
000243b2      *(uint32_t*)((char*)zmm11)[8] = pContext->settings.sensorInfo[2].position.y;
000243b2      *(uint32_t*)((char*)zmm11)[0xc] = pContext->settings.sensorInfo[2].position.y;
000243bb      int128_t zmm10;
000243bb      (uint32_t)zmm10 = pContext->settings.sensorInfo[2].position.x;
000243bb      *(uint32_t*)((char*)zmm10)[4] = pContext->settings.sensorInfo[2].position.x;
000243bb      *(uint32_t*)((char*)zmm10)[8] = pContext->settings.sensorInfo[2].position.x;
000243bb      *(uint32_t*)((char*)zmm10)[0xc] = pContext->settings.sensorInfo[2].position.x;
000243c4      int128_t zmm12;
000243c4      (uint32_t)zmm12 = pContext->settings.sensorInfo[0].position.x;
000243c4      *(uint32_t*)((char*)zmm12)[4] = pContext->settings.sensorInfo[0].position.x;
000243c4      *(uint32_t*)((char*)zmm12)[8] = pContext->settings.sensorInfo[0].position.x;
000243c4      *(uint32_t*)((char*)zmm12)[0xc] = pContext->settings.sensorInfo[0].position.x;
000243d2      int128_t zmm13;
000243d2      (uint32_t)zmm13 = pContext->settings.sensorInfo[0].position.y;
000243d2      *(uint32_t*)((char*)zmm13)[4] = pContext->settings.sensorInfo[0].position.y;
000243d2      *(uint32_t*)((char*)zmm13)[8] = pContext->settings.sensorInfo[0].position.y;
000243d2      *(uint32_t*)((char*)zmm13)[0xc] = pContext->settings.sensorInfo[0].position.y;
000243df      int128_t zmm9;
000243df      (uint32_t)zmm9 = (uint32_t)zmm11 - (uint32_t)zmm13;
000243ec      int128_t zmm8;
000243ec      (uint32_t)zmm8 = (uint32_t)zmm10 - (uint32_t)zmm12;
000243f1      int128_t zmm6;
000243f1      (uint32_t)zmm6 = (uint32_t)zmm9 * (uint32_t)zmm9;
000243ff      (uint32_t)zmm6 = (uint32_t)zmm6 + (uint32_t)zmm8 * (uint32_t)zmm8;
00024403      memset(&pContext->autoCorrectData, 0, 0xa58);
0002440f      float maxEdgeCorrection;
0002440f      
0002440f      if ((uint32_t)zmm6 <= 0f)
00024424          maxEdgeCorrection = 1f;
0002440f      else
0002441d          maxEdgeCorrection = sqrtf(384625f / (uint32_t)zmm6);
0002441d      
0002442c      pContext->autoCorrectData.rmsScaling = maxEdgeCorrection;
00024434      maxEdgeCorrection = pContext->settings.autoCorrect.maxEdgeCorrection;
00024434      
00024443      if (!(maxEdgeCorrection > 1f))
00024445          maxEdgeCorrection = 1f;
00024445      
00024464      pContext->autoCorrectData.rmsError = -1f;
0002446e      maxEdgeCorrection = maxEdgeCorrection * 0.00048828125f * 3.14159274f;
0002447e      pContext->autoCorrectData.maxSampleError =
0002447e          maxEdgeCorrection * maxEdgeCorrection * (uint32_t)zmm6;
0002448e      (uint32_t)zmm8 = (uint32_t)zmm8 * 0.00999999978f;
00024493      (uint32_t)zmm9 = (uint32_t)zmm9 * 0.00999999978f;
0002449c      (uint32_t)zmm10 = (uint32_t)zmm10 - (uint32_t)zmm8;
000244a5      float zmm1 = (uint32_t)zmm8 + (uint32_t)zmm12;
000244aa      float zmm2 = (uint32_t)zmm9 + (uint32_t)zmm13;
000244af      (uint32_t)zmm11 = (uint32_t)zmm11 - (uint32_t)zmm9;
000244b4      pContext->autoCorrectData.grid.xLowerCut = zmm1;
000244bc      pContext->autoCorrectData.grid.xUpperCut = (uint32_t)zmm10;
000244c5      (uint32_t)zmm10 = (uint32_t)zmm10 - zmm1;
000244d2      pContext->autoCorrectData.grid.yUpperCut = (uint32_t)zmm11;
000244db      (uint32_t)zmm11 = (uint32_t)zmm11 - zmm2;
000244e8      pContext->autoCorrectData.grid.yLowerCut = zmm2;
000244f5      pContext->autoCorrectData.grid.yScale = 4f / (uint32_t)zmm11;
000244fd      pContext->autoCorrectData.grid.xScale = 4f / (uint32_t)zmm10;
00024505      memset(&pContext->autoCorrectData.grid.cells, 0, 0x840);
0002450d      pContext->autoCorrectData.totalCount = 0;
00024515      pContext->autoCorrectData.numGoodCells = 0;
0002451c      pContext->autoCorrectData.elapsedFrames = 0;
00024525      pContext->autoCorrectData.borderCounts[0] = 0;
00024525      pContext->autoCorrectData.borderCounts[1] = 0;
00024525      pContext->autoCorrectData.borderCounts[2] = 0;
00024525      pContext->autoCorrectData.borderCounts[3] = 0;
0002452b      pContext->autoCorrectData.accError = 0.0;
0002453a      pContext->autoCorrectData.autoCorrectState = AC_ACCUMULATING;
00024374  }

00024570                                                  cc cc cc cc cc cc cc cc                                          ........

00024578    uint8_t AutoCorrect_AttemptToBinSample(struct fpoint_t touchPos, struct edgeStruct_t* edges, struct autoCorrectGrid_t* grid, uint16_t* totalCount, uint8_t* numGoodCells, struct fpoint_t* lastStoredPt, uint8_t* borderCounts)

00024578  {
00024587      uint64_t arg_8;
00024587      (uint32_t)arg_8 = touchPos.x;
00024587      *(uint32_t*)((char*)arg_8)[4] = touchPos.y;
0002459b      char r10 = 0;
000245b5      char rbx = (char)(int64_t)(((uint32_t)arg_8 - grid->xLowerCut) * grid->xScale);
000245ba      char r11 =
000245ba          (char)(int64_t)((*(uint32_t*)((char*)arg_8)[4] - grid->yLowerCut) * grid->yScale);
000245da      uint64_t borderCounts_1;
000245da      
000245da      if (grid->cells[0][(uint64_t)r11 + ((uint64_t)rbx << 2)].count < 8)
000245da      {
000245e0          uint64_t count =
000245e0              (uint64_t)grid->cells[0][(uint64_t)r11 + ((uint64_t)rbx << 2)].count;
000245e4          int64_t i_1 = 4;
000245f5          float (* rax_1)[0x4] = &edges->Unscaled_Interp_Edges;
00024619          int64_t i;
00024619          
00024619          do
00024619          {
000245fe              float zmm0 = ADJ(rax_1)->Unscaled_Interp_Edges[1]
000245fe                  + ADJ(rax_1)->Unscaled_Interp_Edges[0];
00024602              rax_1 = &(*(uint128_t*)rax_1)[0x1a];
0002460e              grid->cells[0][(uint64_t)r11 + ((uint64_t)rbx << 2)].cent[count][0] =
0002460e                  zmm0 * 0.5f;
00024616              i = i_1;
00024616              i_1 -= 1;
00024619          } while (i != 1);
0002461b          grid->cells[0][(uint64_t)r11 + ((uint64_t)rbx << 2)].count += 1;
0002461e          uint64_t* rcx_2;
0002461e          (uint32_t)rcx_2 = (uint32_t)lastStoredPt;
0002461e          *(uint32_t*)((char*)rcx_2)[4] = *(uint32_t*)((char*)lastStoredPt)[4];
00024628          *(uint64_t*)rcx_2 = arg_8;
0002462b          *(uint16_t*)totalCount += 1;
0002462b          
00024633          if (grid->cells[0][(uint64_t)r11 + ((uint64_t)rbx << 2)].count == 5)
00024633          {
0002463a              *(uint8_t*)numGoodCells += 1;
0002463d              borderCounts_1 = borderCounts;
0002463d              
00024645              if (!rbx)
00024647                  *(uint8_t*)borderCounts_1 += 1;
00024647              
0002464d              if (rbx == 3)
0002464f                  *(uint8_t*)(borderCounts_1 + 1) += 1;
0002464f              
00024656              if (!r11)
00024658                  *(uint8_t*)(borderCounts_1 + 2) += 1;
00024658              
00024660              if (r11 == 3)
00024662                  *(uint8_t*)(borderCounts_1 + 3) += 1;
00024633          }
00024633          
00024666          r10 = 1;
000245da      }
000245da      
00024678      (uint8_t)borderCounts_1 = r10;
0002467b      return (uint8_t)borderCounts_1;
00024578  }

0002467c                                                                                      cc cc cc cc                              ....
00024680  cc cc cc cc                                                                                      ....

00024684    void AutoCorrect_Accumulate(struct _ctl_context_t* pContext, uint8_t const numSensors, struct fpoint_t const touchPos, float const origTriangError)

00024684  {
00024687      if (numSensors != 4)
00024687          return;
00024687      
0002468d      int64_t arg_18;
0002468d      (uint32_t)arg_18 = touchPos.x;
0002468d      *(uint32_t*)((char*)arg_18)[4] = touchPos.y;
000246a3      struct fpoint_t rax;
000246a3      rax.x = touchPos.x;
000246a3      rax.y = touchPos.y;
000246a6      float zmm5[0x4] = origTriangError;
000246a6      
000246ef      if (pContext->edges[0].Num_Edges != 2 || pContext->edges[1].Num_Edges != 2
000246ef              || pContext->edges[2].Num_Edges != 2 || pContext->edges[3].Num_Edges != 2
000246ef              || pContext->autoCorrectData.maxSampleError <= zmm5[0])
000246ef          return;
000246ef      
000246f5      float zmm4 = (uint32_t)arg_18;
000246fb      origTriangError = *(uint32_t*)((char*)arg_18)[4];
00024708      float zmm2 = zmm4 - pContext->autoCorrectData.lastStoredPt.x;
0002470f      float zmm1 = origTriangError - pContext->autoCorrectData.lastStoredPt.y;
0002470f      
00024735      if (zmm4 <= pContext->autoCorrectData.grid.xLowerCut
00024735              || pContext->autoCorrectData.grid.xUpperCut <= zmm4
00024735              || origTriangError <= pContext->autoCorrectData.grid.yLowerCut
00024735              || pContext->autoCorrectData.grid.yUpperCut <= origTriangError
00024735              || zmm1 * zmm1 + zmm2 * zmm2 <= 25f)
0002474a          return;
0002474a      
0002476d      struct fpoint_t touchPos_1;
0002476d      touchPos_1.x = rax.x;
0002476d      touchPos_1.y = rax.y;
0002476d      
00024781      if (AutoCorrect_AttemptToBinSample(touchPos_1, &pContext->edges, 
00024781          &pContext->autoCorrectData.grid, &pContext->autoCorrectData.totalCount, 
00024781          &pContext->autoCorrectData.numGoodCells, &pContext->autoCorrectData.lastStoredPt, 
00024781          &pContext->autoCorrectData.borderCounts))
00024781      {
00024783          pContext->autoCorrectData.elapsedFrames = 0;
00024798          pContext->autoCorrectData.accError =
00024798              _mm_cvtps_pd(_mm_unpacklo_ps(zmm5, *(uint64_t*)&zmm5[0])[0])
00024798              + pContext->autoCorrectData.accError;
00024781      }
00024684  }

000247a6                    cc cc cc cc cc cc                                                                    ......

000247ac    float AutoCorrect_CostFcn(float const* pars, float const maxCorr, float* costGrad)

000247ac  {
000247b8      int128_t zmm5 = {0};
000247c8      int128_t zmm4 = maxCorr;
000247cb      int32_t* r8 = (char*)costGrad - pars;
000247ce      int64_t i_1 = 8;
000247db      int128_t zmm0;
000247db      (uint32_t)zmm0 = maxCorr * 2f;
000247df      (uint32_t)zmm0 = (uint32_t)zmm0 * 0.100000001f;
000247e7      int128_t zmm6;
000247e7      (uint32_t)zmm6 = 1f / (uint32_t)zmm0;
000247ef      int128_t zmm8;
000247ef      (uint32_t)zmm8 = (uint32_t)zmm6 * 2f;
00024840      int64_t i;
00024840      
00024840      do
00024840      {
000247f4          float const zmm3 = *(uint32_t*)pars;
000247f4          
000247fb          if (!(zmm3 <= (uint32_t)zmm4))
00024816              zmm3 = (zmm3 - (uint32_t)zmm4) * (uint32_t)zmm6;
000247fb          else if ((zmm4 ^ __mask@@NegFloat@) <= zmm3)
0002481c              zmm3 = (int32_t){0};
00024810          else
00024816              zmm3 = (zmm3 + (uint32_t)zmm4) * (uint32_t)zmm6;
00024816          
0002482e          *(uint32_t*)((char*)r8 + pars) = (uint32_t)zmm8 * zmm3;
00024834          pars = &pars[1];
00024838          i = i_1;
00024838          i_1 -= 1;
0002483c          (uint32_t)zmm5 = (uint32_t)zmm5 + zmm3 * zmm3;
00024840      } while (i != 1);
00024853      return (uint32_t)zmm5;
000247ac  }

00024854                                                              cc cc cc cc cc cc cc cc                                  ........

0002485c    float AutoCorrect_CalculateErrorAndGradient(struct _ctl_context_t* pContext, float const* pars, float const* centroid, float* gradient)

0002485c  {
0002485f      float* dist2 = gradient;
00024867      float const* pars_1 = pars;
00024886      float zmm6;
00024886      float var_58 = zmm6;
0002488e      int128_t zmm7;
0002488e      (uint32_t)zmm7 = pContext->settings.autoCorrect.maxEdgeCorrection;
0002488e      *(uint8_t*)((char*)zmm7)[4] = pContext->settings.autoCorrect.mode;
0002488e      *(uint32_t*)((char*)zmm7)[8] = pContext->settings.autoCorrect.maxEdgeCorrection;
0002488e      *(uint32_t*)((char*)zmm7)[0xc] = pContext->settings.autoCorrect.maxEdgeCorrection;
00024896      bool cond:0 = gradient;
0002489f      int128_t entry_zmm8;
0002489f      int128_t var_78 = entry_zmm8;
000248a4      int128_t entry_zmm10;
000248a4      int128_t var_88 = entry_zmm10;
000248ac      int128_t zmm12;
000248ac      int128_t var_98 = zmm12;
000248ce      float const* centroid_1 = centroid;
000248de      int64_t rdi;
000248de      (uint8_t)rdi = 0;
000248e1      float* r13 = &pContext->settings.sensorInfo[0].position.y;
000248e8      void var_11c;
000248e8      int32_t* pertDist2 = &var_11c - pars;
000248f2      float const* pars_2 = pars;
000248f5      float costGrad;
000248f5      int32_t* rax_2 = &costGrad - pars;
000248f8      int64_t r12 = 0;
000248fb      int64_t i_2 = 8;
00024ad4      struct line_def_t var_100;
00024ad4      struct line_def_t pertLines;
00024ad4      
00024ad4      do
00024ad4      {
00024913          (uint8_t)pars = (uint8_t)rdi;
00024919          (uint32_t)entry_zmm8 = (*(uint32_t*)centroid_1) * 0.0009765625f;
00024922          (uint32_t)entry_zmm10 = 0.5f - (uint32_t)entry_zmm8;
00024927          (uint32_t)entry_zmm8 = (uint32_t)entry_zmm8 + 0.5f;
0002493d          int128_t zmm0;
0002493d          (uint32_t)zmm0 = (uint32_t)entry_zmm8 * pars_2[1];
0002495d          (uint8_t)centroid = 1;
00024960          struct _ctl_context_t* rcx;
00024960          (uint8_t)rcx = (uint8_t)rdi;
00024963          float edges = FE_Linearize(pContext, (uint8_t)pars, 
00024963              (uint32_t)entry_zmm10 * *(uint32_t*)pars_2 + *(uint32_t*)centroid_1
00024963                  + (uint32_t)zmm0);
00024969          float angles;
00024969          ConvertToRad((uint8_t)rcx, &edges, (uint8_t)centroid, &angles);
0002497a          zmm0 = _safeTan(angles + ADJ(r13)->settings.sensorInfo[0].rotation_offset);
0002497f          var_f8;
0002497f          *(uint32_t*)(&var_f8 + r12) = 0x3f800000;
00024988          float zmm1_1 = (uint32_t)zmm0;
0002498b          zmm12 = zmm0;
0002498f          (uint32_t)zmm0 = ADJ(r13)->settings.sensorInfo[0].position.y;
0002498f          *(uint32_t*)((char*)zmm0)[4] = ADJ(r13)->settings.sensorInfo[0].position.y;
0002498f          *(uint32_t*)((char*)zmm0)[8] = ADJ(r13)->settings.sensorInfo[0].position.y;
0002498f          *(uint32_t*)((char*)zmm0)[0xc] = ADJ(r13)->settings.sensorInfo[0].position.y;
00024995          *(uint32_t*)(&var_100 + r12) = (uint32_t)zmm12;
000249a2          (uint32_t)zmm0 =
000249a2              (uint32_t)zmm0 - zmm1_1 * ADJ(r13)->settings.sensorInfo[0].position.x;
000249a6          var_fc;
000249a6          *(uint32_t*)(&var_fc + r12) = (uint32_t)zmm0;
000249a6          
000249b0          if (cond:0)
000249b0          {
000249b6              (uint32_t)entry_zmm10 = (uint32_t)entry_zmm10 * 9.99999975e-05f;
000249bf              (uint8_t)pars = (uint8_t)rdi;
000249c5              (uint32_t)entry_zmm10 = (uint32_t)entry_zmm10 + zmm6;
000249dd              (uint8_t)centroid = 1;
000249e0              struct _ctl_context_t* rcx_1;
000249e0              (uint8_t)rcx_1 = (uint8_t)rdi;
000249e3              edges = FE_Linearize(pContext, (uint8_t)pars, (uint32_t)entry_zmm10);
000249e9              float angles_1;
000249e9              ConvertToRad((uint8_t)rcx_1, &edges, (uint8_t)centroid, &angles_1);
000249f3              float* rdx_1;
000249f3              (uint8_t)rdx_1 = (uint8_t)rdi;
000249fc              (uint32_t)entry_zmm8 = (uint32_t)entry_zmm8 * 9.99999975e-05f;
00024a0e              (uint32_t)entry_zmm8 = (uint32_t)entry_zmm8 + zmm6;
00024a1f              *(uint32_t*)((char*)rax_2 + pars_2) = (angles_1 - angles) * 10000f;
00024a34              struct _ctl_context_t* rcx_2;
00024a34              (uint8_t)rcx_2 = (uint8_t)rdi;
00024a37              edges = FE_Linearize(pContext, (uint8_t)rdx_1, (uint32_t)entry_zmm8);
00024a3d              float angles_2;
00024a3d              ConvertToRad((uint8_t)rcx_2, &edges, (uint8_t)centroid, &angles_2);
00024a59              float zmm1_2 = (uint32_t)zmm12 * 9.99999975e-05f;
00024a67              (uint32_t)zmm12 = (uint32_t)zmm12 + 9.99999975e-05f;
00024a80              *(uint32_t*)((char*)pertDist2 + pars_2) = (angles_2 - angles) * 10000f;
00024a89              zmm0 = _divide((uint32_t)zmm12, 1f - zmm1_2);
00024a8e              float y = ADJ(r13)->settings.sensorInfo[0].position.y;
00024a94              var_c8;
00024a94              *(uint32_t*)(&var_c8 + r12) = 0x3f800000;
00024aa0              *(uint32_t*)(&pertLines + r12) = (uint32_t)zmm0;
00024aaa              (uint32_t)zmm0 = (uint32_t)zmm0 * ADJ(r13)->settings.sensorInfo[0].position.x;
00024ab4              var_cc;
00024ab4              *(uint32_t*)(&var_cc + r12) = y - (uint32_t)zmm0;
000249b0          }
000249b0          
00024abe          (uint8_t)rdi += 1;
00024ac1          pars_2 = &pars_2[2];
00024ac4          centroid_1 = &centroid_1[1];
00024ac8          r12 += 0xc;
00024acc          r13 = &r13[3];
00024ad4      } while ((uint8_t)rdi < 4);
00024ad4      
00024ada      float* dist2_1 = dist2;
00024ae2      struct line_def_t* lines = &var_100;
00024aea      float maxCorr;
00024aea      int512_t zmm10;
00024aea      
00024aea      if (!cond:0)
00024aea      {
00024b55          (uint8_t)pars = 4;
00024b57          int512_t zmm6_2;
00024b57          zmm6_2 = MinDistTriangQ(lines, (uint8_t)pars, &dist2);
00024b5c          (uint128_t)zmm6_2 = (uint32_t)dist2;
00024aea      }
00024aea      else
00024aea      {
00024af9          float zmm0_6;
00024af9          zmm0_6 = MinDistTriangQPertLines(lines, &pertLines, &pertDist2);
00024afe          char rcx_3 = 0;
00024b00          int64_t* rdx_3 = &pertDist2;
00024b05          int64_t i_3 = 4;
00024b49          int64_t i;
00024b49          
00024b49          do
00024b49          {
00024b12              uint64_t rax_5 = (uint64_t)rcx_3;
00024b17              float zmm2_3 = *(uint32_t*)rdx_3 - zmm0_6;
00024b1b              rdx_3 += 4;
00024b1f              zmm2_3 = zmm2_3 * 10000f;
00024b30              dist2_1[rax_5] = zmm2_3 * (&costGrad)[rax_5];
00024b35              uint64_t rax_6 = (uint64_t)(rcx_3 + 1);
00024b38              rcx_3 += 2;
00024b3a              i = i_3;
00024b3a              i_3 -= 1;
00024b44              dist2_1[rax_6] = zmm2_3 * (&costGrad)[rax_6];
00024b49          } while (i != 1);
00024aea      }
00024aea      
00024b75      float zmm0_7;
00024b75      float zmm6_3;
00024b75      int512_t zmm8;
00024b75      zmm0_7 = AutoCorrect_CostFcn(pars_1, maxCorr, &costGrad);
00024b75      
00024b87      if (cond:0)
00024b87      {
00024b8e          float* rax_8 = &costGrad - dist2_1;
00024ba6          int64_t i_1;
00024ba6          
00024ba6          do
00024ba6          {
00024b9a              *(uint32_t*)dist2_1 =
00024b9a                  *(uint32_t*)((char*)rax_8 + dist2_1) + *(uint32_t*)dist2_1;
00024b9e              dist2_1 = &dist2_1[1];
00024ba2              i_1 = i_2;
00024ba2              i_2 -= 1;
00024ba6          } while (i_1 != 1);
00024b87      }
00024b87      
00024bbd      (uint128_t)zmm8 = var_78;
00024bc2      (uint128_t)zmm10 = var_88;
00024bdb      return zmm6_3 + zmm0_7;
0002485c  }

00024bdc                                                                                      cc cc cc cc                              ....
00024be0  cc cc cc cc                                                                                      ....

00024be4    uint8_t AutoCorrect_Evaluate(struct _ctl_context_t* pContext, float const* pars, uint8_t const gradientRequired, struct autoCorrectOpt_t* optData)

00024be4  {
00024c00      float const* pars_1 = pars;
00024c10      uint128_t zmm6;
00024c10      uint128_t var_48 = zmm6;
00024c1b      void var_68;
00024c1b      float* gradient = ((char*)pars - pars) & &var_68;
00024c2b      int16_t rcx = 0;
00024c2f      int64_t entry_r13;
00024c2f      (uint16_t)entry_r13 = (uint16_t)entry_r13 - (uint16_t)entry_r13;
00024c33      float* gradient_1 = gradient;
00024c3b      int16_t arg_18 = 0;
00024c43      (uint16_t)entry_r13 &= 4;
00024c47      (uint16_t)entry_r13 += 1;
00024c47      
00024c4f      if (!optData->looping)
00024c4f      {
00024c51          pContext->autoCorrectData.accError = 0.0;
00024c51          
00024c5c          if (gradientRequired)
00024c5c          {
00024c6c              memset(&pContext->autoCorrectData.accGradient, 0, 0x40);
00024c81              memset(&pContext->autoCorrectData.accHess, 0, 0x120);
00024c86              gradient = gradient_1;
00024c8e              rcx = 0;
00024c96              pars_1 = pars;
00024c5c          }
00024c5c          
00024ca9          optData->looping = 1;
00024cad          optData->iLast = 0;
00024cb1          optData->jLast = 0;
00024cb5          optData->kLast = 0;
00024c4f      }
00024c4f      
00024cb9      int64_t rsi;
00024cb9      (uint8_t)rsi = optData->iLast;
00024cbd      int64_t rdi;
00024cbd      (uint8_t)rdi = optData->jLast;
00024cc1      int64_t rbp;
00024cc1      (uint8_t)rbp = optData->kLast;
00024cc8      uint64_t rax_2;
00024cc8      
00024cc8      if ((uint8_t)rsi >= 4)
00024cc8      {
00024e71      label_24e71:
00024e71          optData->looping = 0;
00024e75          (uint8_t)rax_2 = 1;
00024cc8      }
00024cc8      else
00024cc8      {
00024cd9          while (true)
00024cd9          {
00024cd9              if ((uint8_t)rdi < 4)
00024cd9              {
00024e27                  while (true)
00024e27                  {
00024e27                      if ((uint8_t)rbp < pContext->autoCorrectData.grid.cells[0][
00024e27                          (uint64_t)(uint8_t)rdi + ((uint64_t)(uint8_t)rsi << 2)].count)
00024e27                      {
00024d06                          if (rcx >= 0x14)
00024d06                          {
00024e61                              optData->iLast = (uint8_t)rsi;
00024e65                              optData->jLast = (uint8_t)rdi;
00024e69                              optData->kLast = (uint8_t)rbp;
00024e6d                              (uint8_t)rax_2 = 0;
00024e6f                              break;
00024d06                          }
00024d06                          
00024d22                          float zmm0_1[0x4];
00024d22                          zmm0_1 = AutoCorrect_CalculateErrorAndGradient(pContext, pars_1, 
00024d22                              &pContext->autoCorrectData.grid.cells[0][
00024d22                                  (uint64_t)(uint8_t)rdi + ((uint64_t)(uint8_t)rsi << 2)].cent[(
00024d22                                  uint64_t)(uint8_t)rbp], 
00024d22                              gradient);
00024d27                          gradient = gradient_1;
00024d32                          double (* r10)[0x8] = &pContext->autoCorrectData.accGradient;
00024d3a                          char r11_1 = 0;
00024d3d                          zmm0_1 = _mm_unpacklo_ps(zmm0_1, *(uint64_t*)&zmm0_1[0]);
00024d40                          uint64_t zmm1_1[0x2] = _mm_cvtps_pd(*(uint64_t*)&zmm0_1[0]);
00024d43                          zmm1_1[0] = zmm1_1[0] + pContext->autoCorrectData.accError;
00024d4d                          pContext->autoCorrectData.accError = (int64_t)zmm1_1;
00024d4d                          
00024d5a                          if (gradient)
00024d5a                          {
00024d60                              zmm0_1 = _mm_unpacklo_ps(zmm0_1, *(uint64_t*)&zmm0_1[0]);
00024d60                              
00024d72                              if (!(
00024d72                                  _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm0_1[0]), zmm6)[0]
00024d72                                  <= 9.9999999747524271e-07))
00024d72                              {
00024d80                                  (uint8_t)rcx = 0;
00024d83                                  float zmm3_1 = 1f / zmm0_1[0];
00024d83                                  
00024df2                                  do
00024df2                                  {
00024d87                                      float zmm2_1[0x4] = *(uint32_t*)gradient;
00024d8b                                      zmm2_1 =
00024d8b                                          _mm_unpacklo_ps(zmm2_1, *(uint64_t*)&zmm2_1[0]);
00024d8e                                      zmm0_1 = _mm_cvtps_pd(*(uint64_t*)&zmm2_1[0]);
00024d91                                      zmm2_1[0] = zmm2_1[0] * zmm3_1;
00024d95                                      *(uint64_t*)&zmm0_1[0] = *(uint64_t*)&zmm0_1[0]
00024d95                                          + ADJ(r10)->autoCorrectData.accGradient[0];
00024d9a                                      ADJ(r10)->autoCorrectData.accGradient[0] =
00024d9a                                          (int64_t)zmm0_1;
00024d9a                                      
00024da2                                      if ((uint8_t)rcx < 8)
00024da2                                      {
00024da9                                          float* gradient_2 = gradient;
00024dae                                          uint64_t i_1 = (uint64_t)(8 - (uint8_t)rcx);
00024de3                                          uint64_t i;
00024de3                                          
00024de3                                          do
00024de3                                          {
00024db2                                              rax_2 = (uint64_t)r11_1;
00024db9                                              r11_1 += 1;
00024dbc                                              zmm2_1[0] =
00024dbc                                                  zmm2_1[0] * *(uint32_t*)gradient_2;
00024dc1                                              gradient_2 = &gradient_2[1];
00024dc5                                              i = i_1;
00024dc5                                              i_1 -= 1;
00024dcc                                              zmm1_1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm2_1, 
00024dcc                                                  *(uint64_t*)&zmm2_1[0])[0]);
00024dcf                                              zmm1_1[0] = zmm1_1[0] +
00024dcf                                                  pContext->autoCorrectData.accHess[rax_2];
00024dd9                                              pContext->autoCorrectData.accHess[rax_2] =
00024dd9                                                  (int64_t)zmm1_1;
00024de3                                          } while (i != 1);
00024da2                                      }
00024da2                                      
00024de5                                      (uint8_t)rcx += 1;
00024de7                                      r10 = &(*(uint512_t*)r10)[1];
00024deb                                      gradient = &gradient[1];
00024df2                                  } while ((uint8_t)rcx < 8);
00024df2                                  
00024df4                                  gradient = gradient_1;
00024d72                              }
00024d5a                          }
00024d5a                          
00024e07                          pars_1 = pars;
00024e15                          rcx = arg_18 + (uint16_t)entry_r13;
00024e19                          (uint8_t)rbp += 1;
00024e1c                          arg_18 = rcx;
00024e27                      }
00024e27                      else
00024e27                      {
00024e2d                          pars_1 = pars;
00024e35                          (uint8_t)rdi += 1;
00024e3d                          (uint8_t)rbp = 0;
00024e3d                          
00024e43                          if ((uint8_t)rdi >= 4)
00024e43                              goto label_24e49;
00024e27                      }
00024e27                  }
00024e27                  
00024e27                  break;
00024cd9              }
00024cd9              
00024e49          label_24e49:
00024e49              (uint8_t)rsi += 1;
00024e4c              (uint8_t)rdi = 0;
00024e4c              
00024e52              if ((uint8_t)rsi >= 4)
00024e52                  goto label_24e71;
00024e52              
00024e54              pars_1 = pars;
00024cd9          }
00024cc8      }
00024cc8      
00024e94      return (uint8_t)rax_2;
00024be4  }

00024e95                                                                 cc cc cc cc cc cc cc                                   .......

00024e9c    uint8_t AutoCorrect_LevMarUpdate(double* accHess, double const* accGrad, float* step, float const mu)

00024e9c  {
00024ebb      mu = mu * 4f;
00024ec3      int64_t rbp = 0;
00024ec5      float* step_1 = step;
00024ec8      int64_t i_2 = 8;
00024ecb      (uint8_t)step = 0;
00024ed1      char r9 = 1;
00024ed4      void var_228;
00024ed4      void* r11 = &var_228;
00024ed9      void a;
00024ed9      void* r10 = &a;
00024ede      int64_t i_3 = 8;
00024ee1      int64_t r12 = 0;
00024f70      int64_t i;
00024f70      
00024f70      do
00024f70      {
00024ee4          uint64_t rax_1 = (uint64_t)(uint8_t)step;
00024ee8          mu = _mm_unpacklo_ps(mu, mu);
00024eeb          (uint8_t)step += 1;
00024ef7          *(uint64_t*)r10 = _mm_cvtps_pd(mu) + accHess[rax_1];
00024eff          double zmm0;
00024eff          
00024eff          if (r9 < 8)
00024eff          {
00024f01              uint64_t rcx = (uint64_t)r9;
00024f09              void var_288;
00024f09              double* rsi_1 = &var_288 + ((r12 + rcx) << 3) + 0x20;
00024f1b              double* rcx_2 = &var_288 + ((rcx * 9 + rbp) << 3) + 0x20;
00024f20              uint64_t j_1 = (uint64_t)(8 - r9);
00024f44              uint64_t j;
00024f44              
00024f44              do
00024f44              {
00024f24                  uint64_t rax_5 = (uint64_t)(uint8_t)step;
00024f28                  (uint8_t)step += 1;
00024f2b                  zmm0 = accHess[rax_5];
00024f31                  *(uint64_t*)rcx_2 = zmm0;
00024f35                  *(uint64_t*)rsi_1 = zmm0;
00024f39                  rsi_1 = &rsi_1[1];
00024f3c                  rcx_2 = &rcx_2[9];
00024f40                  j = j_1;
00024f40                  j_1 -= 1;
00024f44              } while (j != 1);
00024eff          }
00024eff          
00024f46          zmm0 = *(uint64_t*)accGrad;
00024f4a          r9 += 1;
00024f4d          rbp += 1;
00024f50          r10 += 0x50;
00024f54          r12 += 9;
00024f58          accGrad = &accGrad[1];
00024f63          *(uint64_t*)r11 = zmm0 * 2.0;
00024f68          r11 += 0x48;
00024f6c          i = i_3;
00024f6c          i_3 -= 1;
00024f70      } while (i != 1);
00024f7d      uint8_t result = GaussElimDbl(&a, 8);
00024f7d      
00024f84      if (result)
00024f84      {
00024f86          void* rcx_4 = &var_228;
00024f9f          int64_t i_1;
00024f9f          
00024f9f          do
00024f9f          {
00024f8b              float zmm0_1 = (float)(long double)*(uint64_t*)rcx_4;
00024f8f              rcx_4 += 0x48;
00024f93              *(uint32_t*)step_1 = zmm0_1;
00024f97              step_1 = &step_1[1];
00024f9b              i_1 = i_2;
00024f9b              i_2 -= 1;
00024f9f          } while (i_1 != 1);
00024f84      }
00024f84      
00024fc1      return result;
00024e9c  }

00024fc2        cc cc cc cc cc cc                                                                            ......

00024fc8    void AutoCorrect_UpdatingInit(struct _ctl_context_t* pContext)

00024fc8  {
00024fd2      pContext->autoCorrectData.elapsedFrames += 1;
00024fda      struct _ctl_context_t* pContext_1 = pContext;
00024fda      
00025017      if (pContext->autoCorrectData.borderCounts[0] < 3
00025017              || pContext->autoCorrectData.borderCounts[1] < 3
00025017              || pContext->autoCorrectData.borderCounts[2] < 3
00025017              || pContext->autoCorrectData.borderCounts[3] < 3
00025017              || pContext->autoCorrectData.elapsedFrames <= 0x12c)
00025017          return;
00025017      
0002501f      float* rdx_1 = &pContext_1->settings.sensor[0].EdgeCorrectionBeta;
00025026      int64_t i_1 = 4;
0002502a      (uint8_t)pContext = 0;
0002506a      int64_t i;
0002506a      
0002506a      do
0002506a      {
00025036          uint64_t rax_1 = (uint64_t)(uint8_t)pContext;
00025039          (uint8_t)pContext += 1;
0002503b          float zmm1 = ADJ(rdx_1)->settings.sensor[0].EdgeCorrectionAlpha * 512f;
00025047          pContext_1->autoCorrectData.optData.bestPars[rax_1] =
00025047              ADJ(rdx_1)->settings.sensor[0].EdgeCorrectionBeta - zmm1;
00025050          zmm1 = zmm1 + ADJ(rdx_1)->settings.sensor[0].EdgeCorrectionBeta;
00025054          uint64_t rax_2 = (uint64_t)(uint8_t)pContext;
00025057          rdx_1 = &rdx_1[0xd];
0002505b          (uint8_t)pContext += 1;
0002505d          i = i_1;
0002505d          i_1 -= 1;
00025061          pContext_1->autoCorrectData.optData.bestPars[rax_2] = zmm1;
0002506a      } while (i != 1);
00025080      float costGrad[0x8];
00025080      float zmm0_1[0x4] = AutoCorrect_CostFcn(
00025080          &pContext_1->autoCorrectData.optData.bestPars, 
00025080          pContext_1->settings.autoCorrect.maxEdgeCorrection, &costGrad);
0002509b      float zmm2_1 = (float)(long double)pContext_1->autoCorrectData.accError
0002509b          / _mm_cvtepi32_ps((uint128_t)pContext_1->autoCorrectData.totalCount);
0002509f      uint128_t zmm1_1 = {0};
000250a2      zmm0_1[0] = zmm0_1[0] + zmm2_1;
000250a2      
000250a9      if (!(zmm0_1[0] <= 0f))
000250a9      {
000250b1          double zmm0_2;
000250b1          zmm0_2 =
000250b1              sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_1, *(uint64_t*)&zmm0_1[0])[0])[0]);
000250b6          (uint32_t)zmm1_1 = (float)zmm0_2;
000250a9      }
000250a9      
000250ba      (uint32_t)zmm1_1 = (uint32_t)zmm1_1 * pContext_1->autoCorrectData.rmsScaling;
000250c2      pContext_1->autoCorrectData.rmsError = (uint32_t)zmm1_1;
000250c2      
000250d1      if (pContext_1->settings.autoCorrect.mode > 0)
000250d1      {
000250d3          pContext_1->autoCorrectData.optData.curIter = 0;
000250da          pContext_1->autoCorrectData.autoCorrectState = AC_UPDATING_GRAD;
000250da          return;
000250d1      }
000250d1      
000250f5      memset(&pContext_1->autoCorrectData.grid.cells, 0, 0x840);
000250fc      pContext_1->autoCorrectData.totalCount = 0;
00025103      pContext_1->autoCorrectData.numGoodCells = 0;
0002510a      pContext_1->autoCorrectData.elapsedFrames = 0;
00025110      pContext_1->autoCorrectData.borderCounts[0] = 0;
00025110      pContext_1->autoCorrectData.borderCounts[1] = 0;
00025110      pContext_1->autoCorrectData.borderCounts[2] = 0;
00025110      pContext_1->autoCorrectData.borderCounts[3] = 0;
00025116      pContext_1->autoCorrectData.accError = 0.0;
0002511d      pContext_1->autoCorrectData.autoCorrectState = AC_ACCUMULATING;
00024fc8  }

00025132                                                        cc cc cc cc cc cc                                            ......

00025138    void AutoCorrect_UpdatingGrad(struct _ctl_context_t* pContext)

00025138  {
00025151      if (pContext->autoCorrectData.optData.curIter >= 0x14)
00025151      {
0002520b          memset(&pContext->autoCorrectData.grid.cells, 0, 0x840);
00025212      label_25212:
00025212          pContext->autoCorrectData.totalCount = 0;
00025219          pContext->autoCorrectData.numGoodCells = 0;
00025220          pContext->autoCorrectData.elapsedFrames = 0;
00025228          pContext->autoCorrectData.borderCounts[0] = 0;
00025228          pContext->autoCorrectData.borderCounts[1] = 0;
00025228          pContext->autoCorrectData.borderCounts[2] = 0;
00025228          pContext->autoCorrectData.borderCounts[3] = 0;
0002522e          pContext->autoCorrectData.autoCorrectState = AC_ACCUMULATING;
00025238          pContext->autoCorrectData.accError = 0.0;
00025238          return;
00025151      }
00025151      
00025168      uint8_t rax_1;
00025168      uint64_t zmm0_1[0x2];
00025168      rax_1 = AutoCorrect_Evaluate(pContext, &pContext->autoCorrectData.optData.bestPars, 
00025168          1, &pContext->autoCorrectData.optData);
00025168      
00025172      if (!rax_1)
00025172          return;
00025172      
00025178      zmm0_1[0] = (float)(long double)pContext->autoCorrectData.accError;
00025180      double (* rax_2)[0x8] = &pContext->autoCorrectData.accGradient;
00025187      int64_t i_1 = 8;
0002518a      pContext->autoCorrectData.optData.bestError = zmm0_1[0];
00025192      uint64_t temp0_1[0x2] = _mm_xor_pd(zmm0_1, zmm0_1);
000251aa      int64_t i;
000251aa      
000251aa      do
000251aa      {
00025196          double zmm1_1 = ADJ(rax_2)->autoCorrectData.accGradient[0];
0002519a          rax_2 = &(*(uint512_t*)rax_2)[1];
0002519e          i = i_1;
0002519e          i_1 -= 1;
000251a6          temp0_1[0] = temp0_1[0] + zmm1_1 * zmm1_1;
000251aa      } while (i != 1);
000251b1      float zmm1_2 = (float)sqrt(temp0_1[0]);
000251b1      
000251bc      if (!pContext->autoCorrectData.optData.curIter)
000251be          pContext->autoCorrectData.optData.mu = zmm1_2;
000251be      
000251d1      if (!(9.99999997e-07f <= zmm1_2))
000251d1      {
000251e2          memset(&pContext->autoCorrectData.grid.cells, 0, 0x840);
000251e7          goto label_25212;
000251d1      }
000251d1      
000251e9      pContext->autoCorrectData.autoCorrectState = AC_UPDATING_STEP;
000251f3      pContext->autoCorrectData.optData.curStep = 0;
00025138  }

0002524f                                               cc cc cc cc cc cc cc cc cc                                         .........

00025258    void AutoCorrect_UpdatingStep(struct _ctl_context_t* pContext)

00025258  {
0002526c      if (pContext->autoCorrectData.optData.curStep >= 5)
0002526c      {
0002530a          memset(&pContext->autoCorrectData.grid.cells, 0, 0x840);
00025313          pContext->autoCorrectData.totalCount = 0;
0002531a          pContext->autoCorrectData.numGoodCells = 0;
00025320          pContext->autoCorrectData.elapsedFrames = 0;
00025326          pContext->autoCorrectData.borderCounts[0] = 0;
00025326          pContext->autoCorrectData.borderCounts[1] = 0;
00025326          pContext->autoCorrectData.borderCounts[2] = 0;
00025326          pContext->autoCorrectData.borderCounts[3] = 0;
0002532c          pContext->autoCorrectData.accError = 0.0;
00025333          pContext->autoCorrectData.autoCorrectState = AC_ACCUMULATING;
0002526c      }
0002526c      else
0002526c      {
0002527a          float (* step)[0x8] = &pContext->autoCorrectData.optData.step;
0002527a          
0002529b          if (!AutoCorrect_LevMarUpdate(&pContext->autoCorrectData.accHess, 
0002529b              &pContext->autoCorrectData.accGradient, step, 
0002529b              pContext->autoCorrectData.optData.mu))
0002529b          {
000252d4              float zmm1_1 = pContext->autoCorrectData.optData.mu * 10f;
000252df              pContext->autoCorrectData.optData.mu = zmm1_1;
000252df              
000252e7              if (!(0.00100000005f <= zmm1_1))
000252e9                  pContext->autoCorrectData.optData.mu = 0x3a83126f;
000252e9              
000252f3              pContext->autoCorrectData.optData.curStep += 1;
0002529b          }
0002529b          else
0002529b          {
0002529d              int64_t i_1 = 8;
000252b6              int64_t i;
000252b6              
000252b6              do
000252b6              {
000252a5                  float zmm0_1 = ADJ(step)->autoCorrectData.optData.bestPars[0]
000252a5                      - ADJ(step)->autoCorrectData.optData.step[0];
000252a9                  step = &(*(uint256_t*)step)[1];
000252ad                  i = i_1;
000252ad                  i_1 -= 1;
000252b1                  ADJ(step)->autoCorrectData.optData.bestPars[7] = zmm0_1;
000252b6              } while (i != 1);
000252b8              pContext->autoCorrectData.autoCorrectState = AC_UPDATING_LINE;
0002529b          }
0002526c      }
00025258  }

00025348                          cc cc cc cc cc cc cc cc                                                          ........

00025350    void AutoCorrect_UpdatingLine(struct _ctl_context_t* pContext)

00025350  {
0002538b      uint8_t rax;
0002538b      uint128_t zmm0;
0002538b      float zmm6;
0002538b      uint128_t zmm7_1;
0002538b      rax = AutoCorrect_Evaluate(pContext, &pContext->autoCorrectData.optData.candPars, 0, 
0002538b          &pContext->autoCorrectData.optData);
0002538b      
00025392      if (!rax)
00025392          return;
00025392      
00025398      float zmm2_1 = (float)(long double)pContext->autoCorrectData.accError;
000253a0      int64_t i_2 = 8;
000253a5      double (* rax_1)[0x8] = &pContext->autoCorrectData.accGradient;
000253ac      float (* rcx)[0x8] = &pContext->autoCorrectData.optData.step;
000253b3      int64_t i_3 = 4;
000253b6      pContext->autoCorrectData.optData.candError = zmm2_1;
000253d5      int64_t i;
000253d5      
000253d5      do
000253d5      {
000253be          (uint32_t)zmm0 = (float)(long double)ADJ(rax_1)->autoCorrectData.accGradient[0];
000253c2          rax_1 = &(*(uint512_t*)rax_1)[1];
000253c6          (uint32_t)zmm0 = (uint32_t)zmm0 * ADJ(rcx)->autoCorrectData.optData.step[0];
000253ca          rcx = &(*(uint256_t*)rcx)[1];
000253cd          i = i_2;
000253cd          i_2 -= 1;
000253d1          (uint32_t)zmm7_1 = (uint32_t)zmm7_1 + (uint32_t)zmm0;
000253d5      } while (i != 1);
000253d7      float zmm1[0x4];
000253d7      zmm1[0] = pContext->autoCorrectData.optData.bestError;
000253d7      zmm1[1] = pContext->autoCorrectData.optData.bestError;
000253d7      zmm1[2] = pContext->autoCorrectData.optData.bestError;
000253d7      zmm1[3] = pContext->autoCorrectData.optData.bestError;
000253e2      zmm1[0] = zmm1[0] - zmm2_1;
000253ee      (uint32_t)zmm0 = (uint32_t)zmm7_1 * 0.100000001f;
000253ee      
000253f5      if (zmm1[0] <= (uint32_t)zmm0)
000253f5      {
0002552b          zmm1[0] = pContext->autoCorrectData.optData.mu;
0002552b          zmm1[1] = pContext->autoCorrectData.optData.curIter;
0002552b          *(uint8_t*)((char*)zmm1[1])[1] = pContext->autoCorrectData.optData.curStep;
0002552b          *(uint16_t*)((char*)zmm1[1])[2] =
0002552b              *(uint16_t*)((char*)pContext->autoCorrectData.optData + 6);
0002552b          zmm1[2] = pContext->autoCorrectData.optData.mu;
0002552b          zmm1[3] = pContext->autoCorrectData.optData.mu;
0002553b          zmm1[0] = zmm1[0] * 10f;
00025546          pContext->autoCorrectData.optData.mu = zmm1[0];
00025546          
0002554e          if (!(0.00100000005f <= zmm1[0]))
00025550              pContext->autoCorrectData.optData.mu = 0x3a83126f;
00025550          
0002555a          pContext->autoCorrectData.optData.curStep += 1;
00025560          pContext->autoCorrectData.autoCorrectState = AC_UPDATING_STEP;
00025560          return;
000253f5      }
000253f5      
000253fe      (uint32_t)zmm0 = (uint32_t)zmm7_1 * 0.25f;
000253fe      
00025409      if ((uint32_t)zmm0 <= zmm1[0])
00025409      {
0002543c          (uint32_t)zmm7_1 = (uint32_t)zmm7_1 * 0.75f;
0002543c          
00025447          if (!((uint32_t)zmm7_1 > zmm1[0]))
00025447          {
00025449              zmm1[0] = pContext->autoCorrectData.optData.mu;
00025449              zmm1[1] = pContext->autoCorrectData.optData.curIter;
00025449              *(uint8_t*)((char*)zmm1[1])[1] = pContext->autoCorrectData.optData.curStep;
00025449              *(uint16_t*)((char*)zmm1[1])[2] =
00025449                  *(uint16_t*)((char*)pContext->autoCorrectData.optData + 6);
00025449              zmm1[2] = pContext->autoCorrectData.optData.mu;
00025449              zmm1[3] = pContext->autoCorrectData.optData.mu;
00025459              zmm1[0] = zmm1[0] * 0.100000001f;
00025460              pContext->autoCorrectData.optData.mu = zmm1[0];
00025460              
00025468              if (!(0.00100000005f <= zmm1[0]))
0002546a                  pContext->autoCorrectData.optData.mu = 0;
00025447          }
00025409      }
00025409      else
00025409      {
0002540b          zmm1[0] = pContext->autoCorrectData.optData.mu;
0002540b          zmm1[1] = pContext->autoCorrectData.optData.curIter;
0002540b          *(uint8_t*)((char*)zmm1[1])[1] = pContext->autoCorrectData.optData.curStep;
0002540b          *(uint16_t*)((char*)zmm1[1])[2] =
0002540b              *(uint16_t*)((char*)pContext->autoCorrectData.optData + 6);
0002540b          zmm1[2] = pContext->autoCorrectData.optData.mu;
0002540b          zmm1[3] = pContext->autoCorrectData.optData.mu;
0002541b          zmm1[0] = zmm1[0] * 2f;
00025426          pContext->autoCorrectData.optData.mu = zmm1[0];
00025426          
0002542e          if (!(0.00100000005f <= zmm1[0]))
00025430              pContext->autoCorrectData.optData.mu = 0x3a83126f;
00025409      }
00025409      
00025471      float (* rsi_1)[0x8] = &pContext->autoCorrectData.optData.bestPars;
00025488      memmove(rsi_1, &pContext->autoCorrectData.optData.candPars, 0x20);
00025494      float* rax_2 = &pContext->settings.sensor[0].EdgeCorrectionBeta;
0002549b      pContext->autoCorrectData.optData.bestError =
0002549b          pContext->autoCorrectData.optData.candError;
000254d9      int64_t i_1;
000254d9      
000254d9      do
000254d9      {
000254a2          (uint32_t)zmm0 = ADJ(rsi_1)->autoCorrectData.optData.bestPars[1];
000254a2          *(uint32_t*)((char*)zmm0)[4] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[1];
000254a2          *(uint32_t*)((char*)zmm0)[8] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[1];
000254a2          *(uint32_t*)((char*)zmm0)[0xc] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[1];
000254a7          (uint32_t)zmm0 = (uint32_t)zmm0 - ADJ(rsi_1)->autoCorrectData.optData.bestPars[0];
000254ab          (uint32_t)zmm0 = (uint32_t)zmm0 * 0.0009765625f;
000254b3          ADJ(rax_2)->settings.sensor[0].EdgeCorrectionAlpha = (uint32_t)zmm0;
000254b8          zmm1[0] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[0];
000254b8          zmm1[1] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[0];
000254b8          zmm1[2] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[0];
000254b8          zmm1[3] = ADJ(rsi_1)->autoCorrectData.optData.bestPars[0];
000254bc          rsi_1 = &(*(uint256_t*)rsi_1)[2];
000254c0          zmm1[0] = zmm1[0] + ADJ(rsi_1)->autoCorrectData.optData.candError;
000254c5          zmm1[0] = zmm1[0] * 0.5f;
000254cd          ADJ(rax_2)->settings.sensor[0].EdgeCorrectionBeta = zmm1[0];
000254d1          rax_2 = &rax_2[0xd];
000254d5          i_1 = i_3;
000254d5          i_3 -= 1;
000254d9      } while (i_1 != 1);
000254db      uint32_t totalCount = (uint32_t)pContext->autoCorrectData.totalCount;
000254e2      zmm1[0] = pContext->autoCorrectData.optData.bestError;
000254e2      zmm1[1] = pContext->autoCorrectData.optData.bestError;
000254e2      zmm1[2] = pContext->autoCorrectData.optData.bestError;
000254e2      zmm1[3] = pContext->autoCorrectData.optData.bestError;
000254ee      zmm0 = _mm_cvtepi32_ps((uint128_t)totalCount);
000254f1      zmm1[0] = zmm1[0] / (uint32_t)zmm0;
000254f1      
000254f8      if (!(zmm1[0] <= zmm6))
00025505          zmm6 = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm1, *(uint64_t*)&zmm1[0])[0]));
00025505      
00025511      pContext->autoCorrectData.autoCorrectState = AC_UPDATING_GRAD;
0002551b      pContext->autoCorrectData.rmsError = zmm6 * pContext->autoCorrectData.rmsScaling;
00025523      pContext->autoCorrectData.optData.curIter += 1;
00025350  }

0002558f                                               cc cc cc cc cc cc cc cc cc                                         .........

00025598    uint8_t TwoSensorPath(struct _ctl_context_t* pContext)

00025598  {
000255b2      uint64_t currentSensor_2 = (uint64_t)pContext->currentSensor;
000255be      int64_t rbx;
000255be      (uint8_t)rbx = 0;
000255c8      uint8_t numTouchesTriangulated = 0;
000255cd      struct _ctl_context_t* pContext_1 = pContext;
000255d2      int64_t r15;
000255d2      (uint8_t)r15 = 0;
000255ef      uint8_t rax_4 = TouchesStable(pContext, 
000255ef          pContext->ssOutput.sensor[currentSensor_2].edgeSet[0].transitions, 
000255ef          pContext->ssOutput.sensor[(uint64_t)((uint32_t)currentSensor_2 - 1) & 1].edgeSet[
000255ef              0].transitions, 
000255ef          &pContext->pretouchData);
000255f4      uint64_t currentSensor = (uint64_t)pContext_1->currentSensor;
000255fe      int32_t rax_5 = (uint32_t)currentSensor;
00025600      enum occlusionState_t rax_10;
00025600      
00025600      if (!rax_4)
00025600      {
000256ad          enum occlusionState_t occlusionState_1 =
000256ad              pContext_1->twoSensorTriangulation.occlusionState;
000256c5          pContext_1->twoSensorTriangulation.triangulationType = NO_TRIANGULATION;
000256cb          pContext_1->twoSensorTriangulation.prevOcclusionState = occlusionState_1;
000256e3          pContext_1->twoSensorTriangulation.occlusionState = UpdateOcclusionState(
000256e3              &pContext_1->ssOutput.sensor[currentSensor], 
000256e3              &pContext_1->ssOutput.sensor[(uint64_t)(rax_5 - 1) & 1], occlusionState_1);
00025600      }
00025600      else
00025600      {
0002560c          pContext_1->twoSensorTriangulation.unStableFrameCnt = 0;
00025616          char touchCount =
00025616              pContext_1->ssOutput.sensor[currentSensor].edgeSet[0].touchCount;
00025621          char postulations =
00025621              pContext_1->ssOutput.sensor[(uint64_t)(rax_5 - 1) & 1].postulations;
00025629          int64_t rcx;
00025629          (uint8_t)rcx =
00025629              pContext_1->ssOutput.sensor[(uint64_t)(rax_5 - 1) & 1].edgeSet[0].touchCount;
00025633          enum triangulationType_t rax_9;
00025633          
00025633          if (postulations != 1)
00025633          {
00025662              if (postulations != 2)
0002567a                  (uint8_t)rax_9 = !touchCount;
00025662              else if (touchCount != 2)
00025667              {
00025656                  if (touchCount != 1 || ((uint8_t)rcx != 2 && (uint8_t)rcx != 1))
0002567a                      (uint8_t)rax_9 = !touchCount;
00025656                  else
00025658                      rax_9 = TWO_TOUCH_OCCLUSION_TRIANGULATION;
00025667              }
00025667              else if ((uint8_t)rcx == 2)
0002566e                  rax_9 = TWO_TOUCH_NO_OCCLUSION_TRIANGULATION;
0002566c              else if ((uint8_t)rcx != 1)
0002567a                  (uint8_t)rax_9 = !touchCount;
00025656              else
00025658                  rax_9 = TWO_TOUCH_OCCLUSION_TRIANGULATION;
00025633          }
00025633          else if (touchCount != 1)
00025638          {
00025656              if ((touchCount == 2 || touchCount == 1)
00025656                      && ((uint8_t)rcx == 2 || (uint8_t)rcx == 1))
00025658                  rax_9 = TWO_TOUCH_OCCLUSION_TRIANGULATION;
00025656              else
0002567a                  (uint8_t)rax_9 = !touchCount;
00025638          }
00025638          else if ((uint8_t)rcx == 1)
0002563f              rax_9 = SINGLE_TOUCH_TRIANGULATION;
0002563d          else if ((uint8_t)rcx == 2 || (uint8_t)rcx == 1)
00025658              rax_9 = TWO_TOUCH_OCCLUSION_TRIANGULATION;
00025656          else
0002567a              (uint8_t)rax_9 = !touchCount;
0002567a          
0002568f          pContext_1->twoSensorTriangulation.triangulationType = rax_9;
00025695          rax_10 = PerformTriangulation(pContext_1, &pContext_1->triangulated, 
00025695              &numTouchesTriangulated);
0002569a          pContext_1->twoSensorTriangulation.stableFrameCnt += 1;
000256a1          (uint8_t)rbx = numTouchesTriangulated;
000256a8          (uint8_t)r15 = (uint8_t)rax_10;
00025600      }
00025600      
000256ef      if (pContext_1->twoSensorTriangulation.triangulationType)
000256ef      {
000256f1          (uint8_t)rax_10 = pContext_1->twoSensorTriangulation.numTouchesFromEdges;
000256f7          uint64_t currentSensor_1 = (uint64_t)pContext_1->currentSensor;
000256fa          enum occlusionState_t occlusionState_2 =
000256fa              pContext_1->twoSensorTriangulation.occlusionState;
00025701          pContext_1->twoSensorTriangulation.prevNumTouchesFromEdges = (uint8_t)rax_10;
00025707          (uint8_t)rax_10 = pContext_1->twoSensorTriangulation.numTouchesCalculated;
0002570d          pContext_1->twoSensorTriangulation.numTouchesFromEdges = (uint8_t)rbx;
00025713          pContext_1->twoSensorTriangulation.prevNumTouchesCalculated = (uint8_t)rax_10;
0002571b          pContext_1->twoSensorTriangulation.numTouchesCalculated = (uint8_t)rbx;
0002572f          pContext_1->twoSensorTriangulation.prevOcclusionState = occlusionState_2;
00025751          pContext_1->twoSensorTriangulation.occlusionState = UpdateOcclusionState(
00025751              &pContext_1->ssOutput.sensor[currentSensor_1], 
00025751              &pContext_1->ssOutput.sensor[(uint64_t)((uint32_t)currentSensor_1 - 1) & 1], 
00025751              occlusionState_2);
00025757          KI_TwoSensorSortKite(&pContext_1->triangulated);
000256ef      }
000256ef      
0002575c      enum occlusionState_t occlusionState =
0002575c          pContext_1->twoSensorTriangulation.occlusionState;
0002576e      struct kite_t __return;
0002576e      enum orientation_t orientation;
0002576e      uint8_t* occludedSensor;
0002576e      float (* r14)[0x4];
0002576e      
0002576e      if (occlusionState == OCCLUSION_ENTRY || occlusionState == OCCLUSION
0002576e          || occlusionState == OCCLUSION_EXIT)
0002576e      {
000257b0          pContext_1->edges[(uint64_t)pContext_1->currentSensor].CentreAngles[0] = 0;
000257be          pContext_1->edges[(uint64_t)pContext_1->currentSensor].CentreAngles[1] = 0;
000257c5          enum occlusionState_t occlusionState_3 =
000257c5              pContext_1->twoSensorTriangulation.occlusionState;
000257c5          
000257d7          if (occlusionState_3 == OCCLUSION_ENTRY
000257d7                  || pContext_1->twoSensorTriangulation.prevOcclusionState
000257d7                  == OCCLUSION_ENTRY)
000257e0              pContext_1->widthHistories.deltaTime +=
000257e0                  (uint32_t)pContext_1->ssOutput.id.deltaTimeStamp;
000257e0          
0002580a          occludedSensor = &pContext_1->occludedSensor;
00025811          r14 = &pContext_1->centreAngles;
0002585c          memmove(&pContext_1->triangulated, 
0002585c              ReworkCenterAngles(&__return, &pContext_1->occPredictions, 
0002585c                  &pContext_1->widthHistories, occlusionState_3, 
0002585c                  &pContext_1->ssOutput.sensor, 
0002585c                  &pContext_1->filterData.generalTouchData.touchDownCircle, 
0002585c                  &pContext_1->triangulateStatics, r14, occludedSensor, 
0002585c                  pContext_1->twoSensorTriangulation.orientation, 0), 
0002585c              0xbc);
0002576e      }
0002576e      else
0002576e      {
00025772          r14 = &pContext_1->centreAngles;
00025780          memset(r14, 0, 0x10);
00025785          orientation = pContext_1->twoSensorTriangulation.orientation;
0002578b          occludedSensor = &pContext_1->occludedSensor;
00025792          *((char*)ADJ(occludedSensor) + 0x3aa4) = 4;
00025797          pContext_1->occPredictions.preFullyOccludedOrientation = orientation;
0002579d          pContext_1->occPredictions.isFullyOccluded = 0;
0002576e      }
0002576e      
00025861      (uint8_t)orientation = pContext_1->settings.numSensors;
00025875      float* rbp = &pContext_1->ssOutput;
0002588c      float* var_178;
0002588c      (uint8_t)var_178 = (uint8_t)orientation;
00025890      SaveTouchWidthsHistory(rbp, &pContext_1->twoSensorTriangulation, 
00025890          &pContext_1->triangulateStatics, &pContext_1->widthHistories, (uint8_t)var_178);
0002589c      pContext_1->touches.touchCount =
0002589c          pContext_1->twoSensorTriangulation.numTouchesCalculated;
000258a7      enum orientation_t rax_40;
000258a7      
000258a7      if ((uint8_t)r15 != 1)
000258a7      {
00025a87          memset(&pContext_1->touches.touches, 0, 0x30);
00025a8c          int64_t rax_41;
00025a8c          (uint32_t)rax_41 = pContext_1->settings.panelSize.x;
00025a8c          *(uint32_t*)((char*)rax_41)[4] = pContext_1->settings.panelSize.y;
00025aa1          enum orientation_t panelSize;
00025aa1          panelSize = rax_41;
00025aa6          (uint8_t)rax_41 = *((char*)ADJ(occludedSensor) + 0x3aa4);
00025ada          (uint8_t)var_178 = (uint8_t)rax_41;
00025ade          ProcessQuadraticTouchTrackingFilter(&pContext_1->filterData.quadraticTTFilter, 
00025ade              &pContext_1->triangulated, 
00025ade              pContext_1->filterData.predictionFilter.hasSwitchedDuringThisOcclusion, 
00025ade              pContext_1->settings.numSensors, (uint8_t)var_178, rbp, 
00025ade              &pContext_1->filterData.generalTouchData.diamondWidths, r14, 
00025ade              &pContext_1->twoSensorTriangulation, panelSize);
00025afb          UpdateUnstableFirstTouchFilter(&pContext_1->triangulateStatics, 
00025afb              &pContext_1->filterData.unstableFirstFilter, &pContext_1->ssInput, 
00025afb              pContext_1->twoSensorTriangulation.numTouchesFromEdges);
00025b00          enum orientation_t orientation_2 =
00025b00              pContext_1->filterData.quadraticTTFilter.orientation;
00025b07          enum orientation_t orientation_1 = pContext_1->twoSensorTriangulation.orientation;
00025b07          
00025b15          if (orientation_2 != orientation_1 && orientation_2)
00025b15          {
00025b17              pContext_1->twoSensorTriangulation.prevOrientation = orientation_1;
00025b1d              pContext_1->twoSensorTriangulation.orientation = orientation_2;
00025b15          }
00025b15          
00025b30          enum occlusionState_t occlusionState_5;
00025b30          
00025b30          if (pContext_1->twoSensorTriangulation.prevOrientation
00025b30              != pContext_1->twoSensorTriangulation.orientation)
00025b30          {
00025b40              SwapTouchWidthBufferHistories(&pContext_1->widthHistories, 
00025b40                  &pContext_1->occPredictions.centreAnglesHistory);
00025b45              occlusionState_5 = pContext_1->twoSensorTriangulation.occlusionState;
00025b45              
00025b5c              if (occlusionState_5 == OCCLUSION_ENTRY || occlusionState_5 == OCCLUSION
00025b5c                      || occlusionState_5 == OCCLUSION_EXIT)
00025bb4                  rax_40 = memmove(&pContext_1->triangulated, 
00025bb4                      ReworkCenterAngles(&__return, &pContext_1->occPredictions, 
00025bb4                          &pContext_1->widthHistories, occlusionState_5, rbp, 
00025bb4                          &pContext_1->filterData.generalTouchData.touchDownCircle, 
00025bb4                          &pContext_1->triangulateStatics, r14, occludedSensor, 
00025bb4                          pContext_1->twoSensorTriangulation.orientation, 1), 
00025bb4                      0xbc);
00025b30          }
00025b30          
00025bc0          if (pContext_1->twoSensorTriangulation.triangulationType
00025bc0              == NO_TOUCH_TRIANGULATION)
00025bc0          {
00025bc2              (uint8_t)occlusionState_5 =
00025bc2                  pContext_1->twoSensorTriangulation.numTouchesFromEdges;
00025bd6              UpdateSimTwoTouchFilter(pContext_1, 
00025bd6                  &pContext_1->filterData.simTwoTouchFilter, pContext_1->currentSensor, 
00025bd6                  (uint8_t)occlusionState_5);
00025bc0          }
000258a7      }
000258a7      else
000258a7      {
000258c0          struct triangulate_statics_t* var_168;
000258c0          (uint8_t)var_168 = pContext_1->twoSensorTriangulation.numTouchesFromEdges;
000258db          GenerateRequiredFilterData(&pContext_1->filterData, 
000258db              pContext_1->twoSensorTriangulation.occlusionState, r14, rbp, 
000258db              &pContext_1->triangulateStatics, &pContext_1->triangulated, (uint8_t)var_168);
000258e3          ExecuteOrientationFilters(pContext_1);
000258ff          pContext_1->twoSensorTriangulation.prevOrientation =
000258ff              pContext_1->twoSensorTriangulation.orientation;
00025905          enum orientation_t rax_28 =
00025905              FilterManager(&pContext_1->filterData, &pContext_1->twoSensorTriangulation);
0002590a          pContext_1->twoSensorTriangulation.orientation = rax_28;
00025916          enum occlusionState_t occlusionState_4;
00025916          
00025916          if (pContext_1->twoSensorTriangulation.prevOrientation != rax_28)
00025916          {
00025926              SwapTouchWidthBufferHistories(&pContext_1->widthHistories, 
00025926                  &pContext_1->occPredictions.centreAnglesHistory);
00025936              SwapDoubleOcclusionHistoryBuffers(
00025936                  &pContext_1->filterData.doubleOcclusionFilter, 
00025936                  *((char*)ADJ(occludedSensor) + 0x3aa4));
0002593b              occlusionState_4 = pContext_1->twoSensorTriangulation.occlusionState;
00025916          }
00025916          
00025952          struct kite_t (* kite)[0x6];
00025952          
00025952          if (pContext_1->twoSensorTriangulation.prevOrientation != rax_28 && (
00025952              occlusionState_4 == OCCLUSION_ENTRY || occlusionState_4 == OCCLUSION
00025952              || occlusionState_4 == OCCLUSION_EXIT))
00025952          {
0002599a              kite = &pContext_1->triangulated;
000259ad              memmove(kite, 
000259ad                  ReworkCenterAngles(&__return, &pContext_1->occPredictions, 
000259ad                      &pContext_1->widthHistories, occlusionState_4, rbp, 
000259ad                      &pContext_1->filterData.generalTouchData.touchDownCircle, 
000259ad                      &pContext_1->triangulateStatics, r14, occludedSensor, 
000259ad                      pContext_1->twoSensorTriangulation.orientation, 1), 
000259ad                  0xbc);
00025952          }
00025952          else
000259b4              kite = &pContext_1->triangulated;
000259b4          
000259cd          pContext_1->filterData.topWanderData.bottomX[0] =
000259cd              pContext_1->filterData.generalTouchData.boundaryPts[0].boundingPts[2].x;
000259dc          pContext_1->filterData.topWanderData.bottomX[1] =
000259dc              pContext_1->filterData.generalTouchData.boundaryPts[1].boundingPts[2].x;
000259e5          pContext_1->filterData.topWanderData.bottomX[2] =
000259e5              pContext_1->filterData.generalTouchData.boundaryPts[2].boundingPts[2].x;
000259ee          pContext_1->filterData.topWanderData.bottomX[3] =
000259ee              pContext_1->filterData.generalTouchData.boundaryPts[3].boundingPts[2].x;
000259f7          pContext_1->filterData.topWanderData.cam0CenterAngles[0] =
000259f7              pContext_1->edges[0].CentreAngles[0];
000259ff          pContext_1->filterData.topWanderData.cam0CenterAngles[1] =
000259ff              pContext_1->edges[0].CentreAngles[1];
00025a08          pContext_1->filterData.topWanderData.cam1CenterAngles[0] =
00025a08              pContext_1->edges[1].CentreAngles[0];
00025a11          pContext_1->filterData.topWanderData.cam1CenterAngles[1] =
00025a11              pContext_1->edges[1].CentreAngles[1];
00025a14          void topWanderData;
00025a14          memmove(&topWanderData, &pContext_1->filterData.topWanderData, 0x20);
00025a30          struct touchDownCircles_t* var_170_2;
00025a30          (uint32_t)var_170_2 = pContext_1->twoSensorTriangulation.orientation;
00025a49          PopulateTouchOutputPoints(&pContext_1->touches, 
00025a49              &pContext_1->twoSensorTriangulation, rbp, &pContext_1->filterData, kite, 
00025a49              (uint32_t)var_170_2, &topWanderData);
00025a59          (uint8_t)var_170_2 = *((char*)ADJ(occludedSensor) + 0x3aa4);
00025a70          AddTouchPointsToLinearRegressionBuffer(&pContext_1->filterData.generalTouchData, 
00025a70              &pContext_1->touches, pContext_1->filterData.decisionFilter, rbp, 
00025a70              &pContext_1->twoSensorTriangulation.unStableFrameCnt, (uint8_t)var_170_2);
000258a7      }
000258a7      
00025bdb      bool cond:2 = rbp[6] >= 2;
00025bdf      (uint8_t)rax_40 = *((char*)ADJ(occludedSensor) + 0x3aa4);
00025be3      int16_t rcx_31 = rbp[0x72];
00025bea      numTouchesTriangulated = (uint8_t)rax_40;
00025bf1      (uint8_t)rax_40 = pContext_1->settings.numSensors;
00025bff      char i = (uint8_t)rax_40;
00025bff      
00025c0f      if (!cond:2 && rbp[0x22] < 2)
00025c0f      {
00025c20          memset(&pContext_1->occPredictions.centreAnglesHistory, 0, 0x444);
00025c25          pContext_1->occPredictions.centreAnglesHistory.deltaTime = 0;
00025c0f      }
00025c0f      else if (!pContext_1->occPredictions.isFullyOccluded)
00025c37      {
00025c3d          pContext_1->occPredictions.centreAnglesHistory.deltaTime = 0;
00025c43          struct touches_t* rbx_1;
00025c43          (uint8_t)rbx_1 = 0;
00025c43          
00025c49          if ((uint8_t)rax_40 > 0)
00025c49          {
00025d23              do
00025d23              {
00025c5a                  float (* r15_3)[0x4] = r14;
00025c5d                  (uint16_t)r14 = rcx_31;
00025c66                  (uint8_t)occludedSensor = 0;
00025c6d                  void* ptBuffer = &pContext_1->occPredictions.centreAnglesHistory.
00025c6d                      widthHistory[0][(uint64_t)(uint8_t)rbx_1];
00025c75                  (uint8_t)pContext_1 = numTouchesTriangulated;
00025c75                  
00025d05                  do
00025d05                  {
00025c7d                      float centreAngle = (int32_t){0};
00025c7d                      
00025c83                      if ((uint8_t)pContext_1 == (uint8_t)rbx_1)
00025c85                          centreAngle = ADJ(r15_3)->centreAngles[0];
00025c83                      else if (!(uint8_t)rbx_1)
00025c8f                      {
00025c9a                          if (!(uint8_t)occludedSensor || (uint8_t)occludedSensor == 1)
00025cad                              centreAngle = rbp[1] + *(uint32_t*)rbp;
00025c9a                          else
00025ca1                              centreAngle = rbp[3] + rbp[2];
00025ca1                          
00025cda                          centreAngle = centreAngle * 0.5f;
00025c8f                      }
00025c8f                      else if ((uint8_t)rbx_1 == 1)
00025cb7                      {
00025cc2                          if (!(uint8_t)occludedSensor || (uint8_t)occludedSensor == 3)
00025cd5                              centreAngle = rbp[0x1f] + rbp[0x1e];
00025cc2                          else
00025cc9                              centreAngle = rbp[0x1d] + rbp[0x1c];
00025cc9                          
00025cda                          centreAngle = centreAngle * 0.5f;
00025cb7                      }
00025cb7                      
00025ce8                      (uint16_t)var_178 = (uint16_t)r14;
00025cee                      AddNewDataToBuffer(ptBuffer, (char*)ptBuffer + 0x40, 8, centreAngle, 
00025cee                          (uint16_t)var_178);
00025cf3                      (uint8_t)occludedSensor += 1;
00025cf6                      ptBuffer += 0x110;
00025cfd                      r15_3 = &(*(uint128_t*)r15_3)[1];
00025d05                  } while ((uint8_t)occludedSensor < 4);
00025d05                  
00025d0b                  pContext_1 = pContext;
00025d13                  (uint8_t)rbx_1 += 1;
00025d15                  r14 = &pContext_1->centreAngles;
00025d23              } while ((uint8_t)rbx_1 < i);
00025c49          }
00025c37      }
00025c37      
00025d37      (uint8_t)rax_40 = pContext_1->twoSensorTriangulation.triangulationType;
00025d4d      return (uint8_t)rax_40;
00025598  }

00025d4e                                            cc cc cc cc cc cc                                                    ......

00025d54    void PopulateTouchOutputPoints(struct touches_t* touches, struct twoSensorTriangulationMngr_t* twoSensorTriangulation, struct sub_sample_t* ssOut, struct filterManager_t* filterData, struct kite_t* kite, enum orientation_t orientation, struct topWanderData_t* topWanderData)

00025d54  {
00025d6d      int32_t rax;
00025d6d      (uint16_t)rax = ssOut->id.id;
00025d6d      *(uint16_t*)((char*)rax)[2] = ssOut->id.deltaTimeStamp;
00025d7c      touches->id.id = (uint16_t)rax;
00025d7c      touches->id.deltaTimeStamp = *(uint16_t*)((char*)rax)[2];
00025d7c      
00025d89      if (orientation == O_VERTICAL)
00025d89      {
00025d8b          kite->solvedIdx[0] = 0;
00025d92          kite->solvedIdx[1] = (uint8_t)orientation;
00025d89      }
00025d89      else if (orientation == O_HORIZONTAL)
00025d9d      {
00025d9f          kite->solvedIdx[0] = (uint8_t)orientation;
00025da5          kite->solvedIdx[1] = 3;
00025d9d      }
00025d9d      
00025dac      enum filterTypeFlag_t decisionFilter = filterData->decisionFilter;
00025db6      int64_t rax_2;
00025db6      
00025db6      if (decisionFilter == PIVOT_FILTER)
00025db6      {
00025db8          int64_t rax_1;
00025db8          (uint32_t)rax_1 = filterData->pivotFilter.adjustedPts[0].x;
00025db8          *(uint32_t*)((char*)rax_1)[4] = filterData->pivotFilter.adjustedPts[0].y;
00025dbf          touches->touches[0].position.x = (uint32_t)rax_1;
00025dbf          touches->touches[0].position.y = *(uint32_t*)((char*)rax_1)[4];
00025dc2          (uint32_t)rax_2 = filterData->pivotFilter.adjustedPts[1].x;
00025dc2          *(uint32_t*)((char*)rax_2)[4] = filterData->pivotFilter.adjustedPts[1].y;
00025ec5          touches->touches[1].position.x = (uint32_t)rax_2;
00025ec5          touches->touches[1].position.y = *(uint32_t*)((char*)rax_2)[4];
00025db6      }
00025db6      else if (decisionFilter != DOUBLE_OCCLUSION_FILTER)
00025dd1      {
00025df8          if (decisionFilter != STRAIGHT_LINE_FILTER)
00025df8          {
00025e14              if (touches->touchCount == 1)
00025e14              {
00025e16                  kite->solvedIdx[0] = 0;
00025e16                  
00025e25                  if (filterData->generalTouchData.touchDownCircle[0].
00025e25                      TouchLeftTouchDownCircle == 1)
00025e25                  {
00025e27                      float* topWanderData_1 = topWanderData;
00025e2c                      struct fpoint_t tchPt;
00025e2c                      tchPt.x = kite->kPt[0].pt.x;
00025e2c                      tchPt.y = kite->kPt[0].pt.y;
00025e3e                      struct fpoint_t rax_6 = PerformTopWanderFix(
00025e3e                          *(uint32_t*)topWanderData_1, topWanderData_1[3], 
00025e3e                          topWanderData_1[4], tchPt);
00025e43                      kite->kPt[0].pt.x = rax_6.x;
00025e43                      kite->kPt[0].pt.y = rax_6.y;
00025e25                  }
00025e14              }
00025e14              else if (orientation == O_VERTICAL)
00025e4c              {
00025e4e                  float* topWanderData_2 = topWanderData;
00025e5b                  struct fpoint_t* rbx_2 = (int64_t)kite->solvedIdx[0] * 0x2c;
00025e6d                  struct fpoint_t tchPt_1;
00025e6d                  tchPt_1.x = *(uint32_t*)((char*)rbx_2 + kite);
00025e6d                  tchPt_1.y = *(uint32_t*)(&rbx_2->y + kite);
00025e71                  struct fpoint_t rax_7 = PerformTopWanderFix(*(uint32_t*)topWanderData_2, 
00025e71                      topWanderData_2[3], topWanderData_2[4], tchPt_1);
00025e76                  float bottomX = topWanderData_2[6];
00025e7b                  float cam1Angle = topWanderData_2[2];
00025e80                  float cam0Angle = topWanderData_2[1];
00025e85                  *(uint32_t*)((char*)rbx_2 + kite) = rax_7.x;
00025e85                  *(uint32_t*)(&rbx_2->y + kite) = rax_7.y;
00025e91                  struct fpoint_t* rbx_4 = (int64_t)kite->solvedIdx[1] * 0x2c;
00025e95                  struct fpoint_t tchPt_2;
00025e95                  tchPt_2.x = *(uint32_t*)((char*)rbx_4 + kite);
00025e95                  tchPt_2.y = *(uint32_t*)(&rbx_4->y + kite);
00025e99                  struct fpoint_t rax_8 =
00025e99                      PerformTopWanderFix(cam0Angle, cam1Angle, bottomX, tchPt_2);
00025e9e                  *(uint32_t*)((char*)rbx_4 + kite) = rax_8.x;
00025e9e                  *(uint32_t*)(&rbx_4->y + kite) = rax_8.y;
00025e4c              }
00025e4c              
00025eae              int64_t rax_11 = *(uint64_t*)((int64_t)kite->solvedIdx[0] * 0x2c + kite);
00025eb2              touches->touches[0].position.x = (uint32_t)rax_11;
00025eb2              touches->touches[0].position.y = *(uint32_t*)((char*)rax_11)[4];
00025ec1              rax_2 = *(uint64_t*)((int64_t)kite->solvedIdx[1] * 0x2c + kite);
00025df8          }
00025df8          else
00025df8          {
00025dfa              int64_t rax_5;
00025dfa              (uint32_t)rax_5 = filterData->straightLineFilter.adjustedPts[0].x;
00025dfa              *(uint32_t*)((char*)rax_5)[4] =
00025dfa                  filterData->straightLineFilter.adjustedPts[0].y;
00025e01              touches->touches[0].position.x = (uint32_t)rax_5;
00025e01              touches->touches[0].position.y = *(uint32_t*)((char*)rax_5)[4];
00025e04              (uint32_t)rax_2 = filterData->straightLineFilter.adjustedPts[1].x;
00025e04              *(uint32_t*)((char*)rax_2)[4] =
00025e04                  filterData->straightLineFilter.adjustedPts[1].y;
00025df8          }
00025df8          
00025ec5          touches->touches[1].position.x = (uint32_t)rax_2;
00025ec5          touches->touches[1].position.y = *(uint32_t*)((char*)rax_2)[4];
00025dd1      }
00025dd1      else
00025dd1      {
00025dd3          int64_t rax_3;
00025dd3          (uint32_t)rax_3 = filterData->doubleOcclusionFilter.adjustedPts[0].x;
00025dd3          *(uint32_t*)((char*)rax_3)[4] =
00025dd3              filterData->doubleOcclusionFilter.adjustedPts[0].y;
00025dda          touches->touches[0].position.x = (uint32_t)rax_3;
00025dda          touches->touches[0].position.y = *(uint32_t*)((char*)rax_3)[4];
00025ddd          int64_t rax_4;
00025ddd          (uint32_t)rax_4 = filterData->doubleOcclusionFilter.adjustedPts[1].x;
00025ddd          *(uint32_t*)((char*)rax_4)[4] =
00025ddd              filterData->doubleOcclusionFilter.adjustedPts[1].y;
00025de4          touches->touches[1].position.x = (uint32_t)rax_4;
00025de4          touches->touches[1].position.y = *(uint32_t*)((char*)rax_4)[4];
00025de8          twoSensorTriangulation->numTouchesCalculated = 2;
00025dec          touches->touchCount = 2;
00025dd1      }
00025ec9      kite->solvedIdx[0];
00025efb      float zmm0 = (filterData->generalTouchData.tonyTangents[(int64_t)(
00025efb          *(int16_t*)((char*)kite + 0xb0))[0]].width[1] + filterData->generalTouchData.
00025efb          tonyTangents[(int64_t)(*(int16_t*)((char*)kite + 0xb0))[0]].width[0]) * 0.5f;
00025eff      touches->touches[0].width = zmm0;
00025f04      touches->touches[0].height = zmm0;
00025f09      kite->solvedIdx[1];
00025f2e      zmm0 = (filterData->generalTouchData.tonyTangents[(int64_t)(
00025f2e          *(int16_t*)((char*)kite + 0xb0))[1]].width[1] + filterData->generalTouchData.
00025f2e          tonyTangents[(int64_t)(*(int16_t*)((char*)kite + 0xb0))[1]].width[0]) * 0.5f;
00025f32      touches->touches[1].width = zmm0;
00025f37      touches->touches[1].height = zmm0;
00025d54  }

00025f48                          cc cc cc cc cc cc cc cc                                                          ........

00025f50    enum occlusionState_t UpdateOcclusionState(struct edge_set_t* edgeSet0, struct edge_set_t* edgeSet1, enum occlusionState_t prevOcclusionState)

00025f50  {
00025f5c      uint8_t r10 = edgeSet0->touchCount + edgeSet1->touchCount;
00025f5c      
00025f63      if (prevOcclusionState)
00025f63      {
00025f68          if (prevOcclusionState == OCCLUSION_ENTRY)
00025f68          {
00025fab              if (edgeSet0->specialCases & 2 || edgeSet1->specialCases & 2)
00025fba                  return OCCLUSION_EXIT;
00025fba              
00025fb4              if (r10 == 3)
00025fb4                  return OCCLUSION;
00025fb4              
00025fd8              return NO_OCCLUSION;
00025f68          }
00025f68          
00025f6d          if (prevOcclusionState == 2)
00025f6d          {
00025f7e          label_25f7e:
00025f7e              
00025f86              if (edgeSet0->specialCases & 2 || edgeSet1->specialCases & 2)
00025fba                  return OCCLUSION_EXIT;
00025fba              
00025f8b              if (r10 != 2)
00025fd8                  return prevOcclusionState;
00025fd8              
00025f8d              return NO_OCCLUSION;
00025f6d          }
00025f6d          
00025f72          if (prevOcclusionState != 3)
00025f72          {
00025f77              if (prevOcclusionState != 4)
00025fd8                  return prevOcclusionState;
00025fd8              
00025f77              goto label_25f7e;
00025f72          }
00025f72          
00025f9a          if (!(edgeSet0->specialCases & 1) && !(edgeSet1->specialCases & 1))
00025f8d              return NO_OCCLUSION;
00025f63      }
00025f63      else if (!(edgeSet0->specialCases & 1) && !(edgeSet1->specialCases & 1) && r10 != 3)
00025fd8          return prevOcclusionState;
00025fd8      
00025fd2      return OCCLUSION_ENTRY;
00025f50  }

00025fd9                                                                             cc cc cc cc cc cc cc                           .......

00025fe0    uint8_t PerformTriangulation(struct _ctl_context_t* pContext, struct kite_t* retKite, uint8_t* numTouchesTriangulated)

00025fe0  {
00025ff5      void var_d8;
00025ff5      uint64_t var_28 = __security_cookie ^ &var_d8;
00025ffd      enum triangulationType_t triangulationType =
00025ffd          pContext->twoSensorTriangulation.triangulationType;
00026004      uint8_t rdi = 0;
00026012      uint64_t touchCount;
00026012      
00026012      if (triangulationType < NO_TRIANGULATION)
00026012      {
000260fe      label_260fe:
000260fe          char var_a8[0x80];
000260fe          RtlStringCchPrintfA(&var_a8, 0x80, "Unknown triangulation type %d.", 
000260fe              triangulationType);
00026115          onBug__(&var_a8, "c:\development_work\csf_release_hp\driver\foureyes\ctl2path.c", 
00026115              0x30f);
0002611a          *(uint8_t*)numTouchesTriangulated = 0;
00026012      }
00026012      else if (triangulationType <= NO_TOUCH_TRIANGULATION)
000260e8          *(uint8_t*)numTouchesTriangulated = 0;
0002601c      else if (triangulationType <= TWO_TOUCH_OCCLUSION_TRIANGULATION)
00026026      {
00026044          uint64_t trueSensor_1 = (uint64_t)pContext->ssOutput.trueSensor;
0002606c          struct triangulate_statics_t* r9;
0002606c          (uint8_t)r9 = (char)(trueSensor_1 - 1) & 1;
0002608a          uint8_t rax_6 = TR_TriangulationHandler(&pContext->ssOutput.sensor[trueSensor_1], 
0002608a              &pContext->ssOutput.sensor[(uint64_t)(uint32_t)(trueSensor_1 - 1) & 1], 
0002608a              (uint8_t)trueSensor_1, (uint8_t)r9, &pContext->triangulateStatics, retKite);
0002608f          uint64_t trueSensor = (uint64_t)pContext->ssOutput.trueSensor;
00026099          rdi = rax_6;
000260a7          int64_t rcx_4;
000260a7          (uint8_t)rcx_4 = pContext->ssOutput.sensor[(uint64_t)(uint32_t)(trueSensor - 1)
000260a7              & 1].edgeSet[0].touchCount;
000260a7          
000260b5          if (pContext->ssOutput.sensor[trueSensor].edgeSet[0].touchCount <= (uint8_t)rcx_4)
000260dc              touchCount = (uint64_t)pContext->ssOutput.sensor[
000260dc                  (uint64_t)((uint32_t)pContext->ssOutput.trueSensor - 1) & 1].edgeSet[0].
000260dc                  touchCount;
000260b5          else
000260c2              touchCount = (uint64_t)pContext->ssOutput.sensor[(uint64_t)pContext->ssOutput.
000260c2                  trueSensor].edgeSet[0].touchCount;
000260c2          
000260e4          *(uint8_t*)numTouchesTriangulated = (uint8_t)touchCount;
00026026      }
00026026      else
00026026      {
0002602c          if (triangulationType != QUICK_TAP_TRIANGULATION)
0002602c              goto label_260fe;
0002602c          
00026115          onBug__(
00026115              "performTriangulation() called instead of performQuickTapTriangulation().", 
00026115              "c:\development_work\csf_release_hp\driver\foureyes\ctl2path.c", 0x306);
0002611a          *(uint8_t*)numTouchesTriangulated = 0;
00026026      }
00026026      
0002611d      (uint8_t)touchCount = rdi;
0002612b      __security_check_cookie(var_28 ^ &var_d8);
0002613a      return (uint8_t)touchCount;
00025fe0  }

0002613b                                                                                   cc cc cc cc cc                             .....
00026140  cc cc cc cc                                                                                      ....

00026144    struct kite_t* ReworkCenterAngles(struct kite_t* __return, struct occlusionPrediction_t* occPredictions, struct touchWidthsHistory_t* historyBuf, enum occlusionState_t occlusionState, struct sub_sample_t* ssOut, struct touchDownCircles_t* tchDownCircles, struct triangulate_statics_t* triangulateStatics, float* centreAngles, uint8_t* occludedSensor, enum orientation_t orientation, uint8_t orientationJustSwitched)

00026144  {
00026175      double zmm6[0x2];
00026175      double var_48[0x2] = zmm6;
00026179      float zmm7[0x4];
00026179      float var_58[0x4] = zmm7;
0002617d      double zmm8[0x2];
0002617d      double var_68[0x2] = zmm8;
00026182      uint64_t trueSensor = (uint64_t)ssOut->trueSensor;
0002619f      struct kite_t* result = __return;
000261a4      occPredictions->closestTchWidthSq = 0f;
000261af      (uint8_t)__return = ssOut->sensor[trueSensor].edgeSet[0].touchCount;
000261b3      char rdx = (char)(trueSensor - 1) & 1;
000261b3      
000261dc      if ((uint8_t)__return == 1 && ssOut->sensor[(uint64_t)rdx].edgeSet[0].touchCount == 2)
000261de          *(uint8_t*)occludedSensor = (uint8_t)trueSensor;
000261dc      else if ((uint8_t)__return != 2
000261dc          || ssOut->sensor[(uint64_t)rdx].edgeSet[0].touchCount != 1)
000261f4      {
000261fb          *(uint8_t*)occludedSensor = 4;
000261ff          occlusionState = NO_OCCLUSION;
000261f4      }
000261f4      else
000261f6          *(uint8_t*)occludedSensor = rdx;
000261f6      
00026205      if (occlusionState)
00026205      {
0002620b          int64_t rax_2;
0002620b          (uint8_t)rax_2 = *(uint8_t*)occludedSensor;
00026213          zmm8 = {0};
00026217          (uint8_t)rax_2 -= 1;
00026219          void var_88;
00026219          void* rbx_1 = &var_88;
00026221          float* r13_2 = &result->kPt[0].pt.y;
00026225          (uint8_t)rax_2 &= 1;
00026227          int32_t* r12_1 = nullptr;
0002622a          int32_t* var_1a0_1 = nullptr;
0002622f          uint64_t rax_5 = (uint64_t)(uint8_t)rax_2;
00026232          void* var_148_1 = &var_88;
0002623a          int64_t i_4 = 4;
00026246          uint64_t r8 = rax_5 * 3;
00026252          uint64_t var_190_1 = r8;
0002625e          int64_t rcx_1 = rax_5 * 0xe;
00026265          int64_t var_168_1 = rcx_1;
00026654          struct fpoint_t A;
00026654          float var_138[0x4];
00026654          int32_t ptsArr;
00026654          void var_d8;
00026654          int64_t i;
00026654          
00026654          do
00026654          {
0002626f              uint64_t rdx_1 = (uint64_t)*(uint8_t*)occludedSensor;
00026273              void* rax_7 = (char*)r12_1 + rdx_1;
00026277              uint64_t r9 = (uint64_t)centreAnglesCalcData[1 + rax_7 * 2][0];
0002627d              uint64_t r14_1 = (uint64_t)centreAnglesCalcData[rax_7 * 2][0];
00026282              int64_t rax_8 = rcx_1 + r14_1;
0002628e              struct fpoint_t B;
0002628e              B.x = (uint32_t)rax_8;
0002628e              B.y = *(uint32_t*)((char*)rax_8)[4];
00026298              zmm7 = ssOut->sensor[0].edgeSet[0].edgePair[rax_8].edge[1];
0002629e              zmm7[0] = zmm7[0] + *(uint32_t*)((char*)ssOut + (rax_8 << 3));
000262ac              zmm7[0] = zmm7[0] * 0.5f;
000262b7              struct sensor_info_t* snsInfo_1 = triangulateStatics->snsInfo;
000262d7              struct fpoint_t rax_11;
000262d7              rax_11 = CTL_Triangulate(zmm7[0], 
000262d7                  *(uint32_t*)((char*)ssOut + ((rdx_1 * 0x1c + r9) << 2)), 
000262d7                  (char*)snsInfo_1 + (r8 << 2), &snsInfo_1[rdx_1]);
000262dc              *(uint32_t*)rbx_1 = rax_11.x;
000262dc              *(uint32_t*)((char*)rbx_1 + 4) = rax_11.y;
000262f3              uint64_t r10_1;
000262f3              
000262f3              if ((*(uint8_t*)occludedSensor || (uint8_t)r14_1 != 1)
000262f3                      && (*(uint8_t*)occludedSensor != 1 || (uint8_t)r14_1))
00026301                  r10_1 = r9;
000262f3              else
000262f3              {
000262f5                  r10_1 = r9;
000262fa                  occPredictions->totalWidthTouchPts[r10_1].x = rax_11.x;
000262fa                  occPredictions->totalWidthTouchPts[r10_1].y = rax_11.y;
000262f3              }
000262f3              
00026306              uint64_t rdx_4 = (uint64_t)*(uint8_t*)occludedSensor;
00026316              void* rcx_3 = ((char*)r12_1 + rdx_4) * 0x44;
0002631a              void* r12_2 = (char*)rcx_3 + historyBuf;
0002631e              rax_11.x = *(uint8_t*)((char*)r12_2 + 0x40);
00026325              double zmm0[0x2];
00026325              
00026325              if (rax_11.x > 4)
00026325              {
00026339                  memset(&ptsArr, 0, 0x40);
0002633e                  uint64_t rbx_2 = (uint64_t)*(uint8_t*)((char*)r12_2 + 0x40);
00026356                  memmove(&ptsArr, r12_2, rbx_2 << 3);
0002635b                  ptsArr = zmm8[0];
0002635b                  
00026368                  if ((uint8_t)rbx_2 > 1)
00026368                  {
0002636a                      (uint8_t)rbx_2 -= 1;
0002636c                      void var_110;
0002636c                      void* rax_12 = &var_110;
00026374                      uint64_t j_3 = (uint64_t)(uint8_t)rbx_2;
00026394                      uint64_t j;
00026394                      
00026394                      do
00026394                      {
00026377                          zmm0 = *(uint32_t*)rax_12;
0002637b                          zmm0[0] = zmm0[0] * 9.99999997e-07f;
00026383                          zmm0[0] = zmm0[0] + *(uint32_t*)((char*)rax_12 - 8);
00026388                          *(uint32_t*)rax_12 = zmm0[0];
0002638c                          rax_12 += 8;
00026390                          j = j_3;
00026390                          j_3 -= 1;
00026394                      } while (j != 1);
00026368                  }
00026368                  
00026396                  uint64_t rbx_3 = (uint64_t)*(uint8_t*)((char*)r12_2 + 0x40);
000263b1                  CurveFit(&ptsArr, (uint8_t)rbx_3, 3, &var_138);
000263e8                  int32_t var_120[0x2];
000263e8                  zmm0 = CalcPolynomialY(
000263e8                      (float)(uint64_t)historyBuf->deltaTime * 9.99999997e-07f
000263e8                          + (&var_120)[rbx_3][0], 
000263e8                      3, &var_138);
000263ed                  rbx_1 = var_148_1;
00026325              }
00026325              else if (rax_11.x <= 0)
000263fd              {
0002641c                  int64_t r12_3;
0002641c                  (uint32_t)r12_3 = B.x;
0002641c                  *(uint32_t*)((char*)r12_3)[4] = B.y;
00026421                  struct sensor_info_t* snsInfo_2 = triangulateStatics->snsInfo;
0002644d                  struct fpoint_t rax_19 = CTL_Triangulate(
0002644d                      (*(uint32_t*)((char*)ssOut + (r12_3 << 3)))[0], 
0002644d                      *(uint32_t*)((char*)ssOut + ((rdx_4 * 0x1c + r10_1) << 2)), 
0002644d                      (char*)snsInfo_2 + (var_190_1 << 2), &snsInfo_2[rdx_4]);
00026452                  uint64_t rdx_10 = (uint64_t)*(uint8_t*)occludedSensor;
0002645d                  A.x = rax_19.x;
0002645d                  A.y = rax_19.y;
0002646a                  struct sensor_info_t* snsInfo_3 = triangulateStatics->snsInfo;
00026491                  struct fpoint_t rax_23;
00026491                  rax_23 = CTL_Triangulate(
00026491                      ssOut->sensor[0].edgeSet[0].edgePair[r12_3].edge[1], 
00026491                      *(uint32_t*)((char*)ssOut + ((rdx_10 * 0x1c + r9) << 2)), 
00026491                      (char*)snsInfo_3 + (var_190_1 << 2), &snsInfo_3[rdx_10]);
000264a0                  B.x = rax_23.x;
000264a0                  B.y = rax_23.y;
000264a5                  zmm0 = DistanceSquare(&A, &B);
000264a5                  
000264ae                  if (zmm0[0] <= zmm8[0])
000264c1                      zmm0 = zmm8;
000264ae                  else
000264ae                  {
000264b6                      zmm0 = sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0])[0]);
000264bb                      zmm0[0] = (float)zmm0[0];
000264ae                  }
000263fd              }
000263fd              else
000263fd              {
000263ff                  rax_11.x -= 1;
00026408                  zmm0 = *(uint32_t*)(&historyBuf->widthHistory[0][0].tchWidths[0].y
00026408                      + (char*)rcx_3 + ((uint64_t)rax_11.x << 3));
000263fd              }
000263fd              
000264c5              int32_t* r12_4 = var_1a0_1;
000264d7              zmm0[0] = zmm0[0] * 0.5f;
000264e2              bool cond:0_1 = zmm0[0] <= zmm8[0];
000264e6              *(uint32_t*)(&var_d8 - centreAngles + (char*)centreAngles + r12_4) = zmm0[0];
000264e6              
000264eb              if (!cond:0_1)
000264eb              {
000264f1                  zmm0[0] = zmm0[0] * zmm0[0];
000264f1                  
000264fe                  if (!*(uint8_t*)occludedSensor && (uint8_t)r14_1 == 1)
000264fe                  {
0002650b                  label_2650b:
0002650b                      
0002650f                      if (!(zmm0[0] <= occPredictions->closestTchWidthSq))
00026511                          occPredictions->closestTchWidthSq = zmm0[0];
000264fe                  }
000264fe                  else if (*(uint8_t*)occludedSensor == 1 && !(uint8_t)r14_1)
00026509                      goto label_2650b;
00026509                  
00026516                  int64_t rax_25;
00026516                  (uint8_t)rax_25 = (uint8_t)r9;
0002651a                  bool cond:3_1 = (uint8_t)rax_25 != *(uint8_t*)occludedSensor;
00026525                  struct sensor_info_t* snsInfo_5 = triangulateStatics->snsInfo;
00026531                  zmm7[0] = zmm7[0] + (&snsInfo_5->rotation_offset)[var_190_1];
0002653b                  double temp0_4[0x2] =
0002653b                      _mm_cvtps_pd(_mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0])[0]);
0002653e                  double zmm0_4;
0002653e                  
0002653e                  if (cond:3_1)
0002653e                  {
00026583                      double zmm0_5;
00026583                      float zmm6_3[0x4];
00026583                      float zmm7_2[0x4];
00026583                      zmm0_5 = cos(temp0_4[0]);
00026588                      float zmm2_1 = *(uint32_t*)rbx_1;
00026599                      (uint32_t)zmm0_5 = (float)(zmm0_5 *
00026599                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm6_3, *(uint64_t*)&zmm6_3[0])[0]));
000265a1                      double x =
000265a1                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm7_2, *(uint64_t*)&zmm7_2[0])[0]);
000265a4                      ADJ(r13_2)->kPt[0].pt.x = zmm2_1 - (uint32_t)zmm0_5;
000265aa                      float zmm6_4[0x4];
000265aa                      zmm0_4 = sin(x);
000265af                      float zmm2_2 = *(uint32_t*)((char*)rbx_1 + 4);
000265be                      (uint32_t)zmm0_4 = (float)(zmm0_4 *
000265be                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm6_4, *(uint64_t*)&zmm6_4[0])[0]));
000265c6                      ADJ(r13_2)->kPt[0].pt.y = zmm2_2 - (uint32_t)zmm0_4;
0002653e                  }
0002653e                  else
0002653e                  {
00026540                      double zmm0_3;
00026540                      float zmm6_1[0x4];
00026540                      float zmm7_1[0x4];
00026540                      zmm0_3 = cos(temp0_4[0]);
00026545                      float temp0_5[0x4] = _mm_unpacklo_ps(zmm6_1, *(uint64_t*)&zmm6_1[0]);
00026548                      float temp0_6[0x4] = _mm_unpacklo_ps(zmm7_1, *(uint64_t*)&zmm7_1[0]);
00026552                      (uint32_t)zmm0_3 =
00026552                          (float)(zmm0_3 * _mm_cvtps_pd(*(uint64_t*)&temp0_5[0]));
00026556                      (uint32_t)zmm0_3 = (uint32_t)zmm0_3 + *(uint32_t*)rbx_1;
0002655a                      ADJ(r13_2)->kPt[0].pt.x = (uint32_t)zmm0_3;
00026563                      float zmm6_2[0x4];
00026563                      zmm0_4 = sin(_mm_cvtps_pd(*(uint64_t*)&temp0_6[0]));
00026572                      (uint32_t)zmm0_4 = (float)(zmm0_4 *
00026572                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm6_2, *(uint64_t*)&zmm6_2[0])[0]));
00026576                      (uint32_t)zmm0_4 = (uint32_t)zmm0_4 + *(uint32_t*)((char*)rbx_1 + 4);
0002657b                      ADJ(r13_2)->kPt[0].pt.y = (uint32_t)zmm0_4;
0002653e                  }
0002653e                  
000265d0                  (uint32_t)zmm0_4 = ADJ(r13_2)->kPt[0].pt.y;
000265d0                  *(uint8_t*)((char*)zmm0_4)[4] = ADJ(r13_2)->kPt[0].sourceST[0];
000265d0                  *(uint8_t*)((char*)zmm0_4)[5] = ADJ(r13_2)->kPt[0].sourceST[1];
000265d6                  double zmm1_3;
000265d6                  (uint32_t)zmm1_3 = ADJ(r13_2)->kPt[0].pt.x;
000265d6                  *(uint32_t*)((char*)zmm1_3)[4] = ADJ(r13_2)->kPt[0].pt.x;
000265dc                  uint64_t rbx_4 = (uint64_t)*(uint8_t*)occludedSensor * 3;
000265e8                  struct sensor_info_t* snsInfo = triangulateStatics->snsInfo;
000265ef                  (uint32_t)zmm0_4 = (uint32_t)zmm0_4 - (&snsInfo->position.y)[rbx_4];
000265f5                  (uint32_t)zmm1_3 =
000265f5                      (uint32_t)zmm1_3 - *(uint32_t*)((char*)snsInfo + (rbx_4 << 2));
000265fa                  zmm0 = atan2f((uint32_t)zmm0_4, (uint32_t)zmm1_3);
00026604                  zmm0[0] = zmm0[0] - (&snsInfo_5->rotation_offset)[rbx_4];
0002660b                  r12_4 = var_1a0_1;
00026610                  rbx_1 = var_148_1;
00026618                  ADJ(r13_2)->kPt[0].centreAngle = zmm0[0];
0002661e                  *(uint32_t*)((char*)r12_4 + centreAngles) = zmm0[0];
000264eb              }
000264eb              
00026624              rcx_1 = var_168_1;
00026629              r8 = var_190_1;
0002662e              rbx_1 += 8;
00026632              r12_1 = &r12_4[1];
00026636              r13_2 = &r13_2[0xb];
0002663a              i = i_4;
0002663a              i_4 -= 1;
00026640              var_148_1 = rbx_1;
0002664f              var_1a0_1 = r12_1;
00026654          } while (i != 1);
00026662          float zmm0_6 = DistanceSquare(&occPredictions->totalWidthTouchPts, 
00026662              &occPredictions->totalWidthTouchPts[1]);
00026667          bool cond:2_1 = occPredictions->isFullyOccluded != 1;
0002666e          occPredictions->totalTchWidthSq = zmm0_6;
0002666e          
00026672          if (!cond:2_1)
00026672          {
00026681              uint8_t rax_31 = 1;
00026681              
00026689              if (!(occPredictions->closestTchWidthSq > zmm0_6 * 0.850000024f))
0002668b                  rax_31 = 0;
0002668b              
0002668d              occPredictions->isFullyOccluded = rax_31;
0002668d              
00026698              if (!orientationJustSwitched)
000266a1                  occPredictions->centreAnglesHistory.deltaTime +=
000266a1                      (uint32_t)ssOut->id.deltaTimeStamp;
000266a1              
000266ef          label_266ef:
000266ef              
000266f3              if (!occPredictions->isFullyOccluded)
000266fc                  occPredictions->preFullyOccludedOrientation = orientation;
00026672          }
00026672          else if (!occPredictions->isFullyOccluded)
000266ad          {
000266b7              uint32_t deltaTimeStamp;
000266b7              
000266b7              if (orientationJustSwitched != 1)
000266b7              {
000266d3                  uint8_t rax_33 = 1;
000266d3                  
000266db                  if (!(occPredictions->closestTchWidthSq > zmm0_6 * 0.899999976f))
000266dd                      rax_33 = 0;
000266dd                  
000266df                  occPredictions->isFullyOccluded = rax_33;
000266e2                  deltaTimeStamp = (uint32_t)ssOut->id.deltaTimeStamp;
000266b7              }
000266b7              else
000266b7              {
000266b9                  deltaTimeStamp = (uint32_t)ssOut->id.deltaTimeStamp;
000266c0                  occPredictions->isFullyOccluded = 1;
000266b7              }
000266b7              
000266e9              occPredictions->centreAnglesHistory.deltaTime = deltaTimeStamp;
000266e9              goto label_266ef;
000266ad          }
000266ad          
00026703          if (occPredictions->isFullyOccluded == 1)
00026703          {
00026710              int64_t r14_2 = 0;
00026713              struct kite_t* result_2 = result;
00026718              A.x = (&occPredictions->predictedCentreAngle);
00026718              A.y = *(uint32_t*)((char*)(&occPredictions->predictedCentreAngle))[4];
0002671d              float (* var_1a0_2)[0x4] = &occPredictions->predictedCentreAngle;
0002672a              int32_t* r12_5 = &ptsArr;
00026732              int64_t i_5 = 4;
000268bc              int64_t i_1;
000268bc              
000268bc              do
000268bc              {
0002673b                  uint64_t rcx_11 = (uint64_t)*(uint8_t*)occludedSensor;
0002674c                  struct fpoint_t rax_48;
0002674c                  
0002674c                  if (occPredictions->centreAnglesHistory.widthHistory[0][r14_2 + rcx_11].
0002674c                      numFrames < 4)
0002674c                  {
00026898                      struct fpoint_t tchPt;
00026898                      tchPt.x = result_2->kPt[0].pt.x;
00026898                      tchPt.y = result_2->kPt[0].pt.y;
0002689b                      rax_48 = NailTouchIfStillInTouchDownCircle(tchPt, tchDownCircles);
0002674c                  }
0002674c                  else
0002674c                  {
00026755                      int64_t rdx_15 = rcx_11 + r14_2;
00026760                      uint64_t rax_38 = (uint64_t)(uint8_t)(rcx_11 - 1) & 1;
0002677a                      int64_t rcx_14 =
0002677a                          rax_38 * 0xe + (uint64_t)centreAnglesCalcData[rdx_15 * 2][0];
00026791                      zmm6 = ssOut->sensor[0].edgeSet[0].edgePair[rcx_14].edge[1];
00026797                      zmm6[0] = zmm6[0] + *(uint32_t*)((char*)ssOut + (rcx_14 << 3));
000267a5                      zmm6[0] = zmm6[0] * 0.5f;
000267ad                      int32_t ptsArr_1;
000267ad                      memset(&ptsArr_1, 0, 0x40);
000267b2                      uint64_t numFrames = (uint64_t)occPredictions->centreAnglesHistory.
000267b2                          widthHistory[0][rdx_15].numFrames;
000267ca                      memmove(&ptsArr_1, 
000267ca                          &occPredictions->centreAnglesHistory.widthHistory[0][rdx_15], 
000267ca                          numFrames << 3);
000267cf                      ptsArr_1 = zmm8[0];
000267cf                      
000267dc                      if ((uint8_t)numFrames > 1)
000267dc                      {
000267de                          (uint8_t)numFrames -= 1;
000267e0                          void var_c0;
000267e0                          float* rax_40 = &var_c0;
000267e8                          uint64_t j_4 = (uint64_t)(uint8_t)numFrames;
00026808                          uint64_t j_1;
00026808                          
00026808                          do
00026808                          {
000267fc                              *(uint32_t*)rax_40 =
000267fc                                  *(uint32_t*)rax_40 * 9.99999997e-07f + rax_40[-2];
00026800                              rax_40 = &rax_40[2];
00026804                              j_1 = j_4;
00026804                              j_4 -= 1;
00026808                          } while (j_1 != 1);
000267dc                      }
000267dc                      
0002681f                      uint64_t numFrames_1 = (uint64_t)occPredictions->centreAnglesHistory.
0002681f                          widthHistory[0][rdx_15].numFrames;
00026828                      CurveFit(&ptsArr_1, (uint8_t)numFrames_1, 3, &var_138);
00026857                      int32_t var_d0[0x2];
00026857                      float sensorBAngle;
00026857                      float sensorAAngle;
00026857                      sensorBAngle = CalcPolynomialY(
00026857                          (float)(uint64_t)occPredictions->centreAnglesHistory.deltaTime
00026857                              * 9.99999997e-07f + (&var_d0)[numFrames_1][0], 
00026857                          3, &var_138);
0002685c                      struct sensor_info_t* snsInfo_4 = triangulateStatics->snsInfo;
0002686b                      ADJ(var_1a0_2)->predictedCentreAngle[0] = sensorBAngle;
0002688c                      rax_48 = CTL_Triangulate(sensorAAngle, sensorBAngle, 
0002688c                          &snsInfo_4[rax_38], &snsInfo_4[rcx_11]);
0002674c                  }
0002674c                  
000268a0                  var_1a0_2 = &(*(uint128_t*)var_1a0_2)[1];
000268a6                  *(uint32_t*)r12_5 = rax_48.x;
000268a6                  r12_5[1] = rax_48.y;
000268aa                  r14_2 += 4;
000268ae                  r12_5 = &r12_5[2];
000268b2                  result_2 = &result_2->kPt[1];
000268b6                  i_1 = i_5;
000268b6                  i_5 -= 1;
000268bc              } while (i_1 != 1);
000268c2              int32_t* r13_5;
000268c2              (uint32_t)r13_5 = A.x;
000268c2              *(uint32_t*)((char*)r13_5)[4] = A.y;
000268c7              int64_t rsi_1 = 0;
000268c9              float (* rbx_6)[0x4] = &var_138;
000268d1              int64_t i_7 = 4;
000268d5              int32_t* B_1 = &ptsArr;
00026926              int64_t j_5;
00026926              int64_t i_2;
00026926              
00026926              do
00026926              {
000268dd                  zmm6 = 0x60ad78ec;
000268e5                  *(uint32_t*)rbx_6 = 0x60ad78ec;
000268eb                  struct fpoint_t* A_1 = &var_88;
000268f3                  j_5 = 4;
00026914                  int64_t j_2;
00026914                  
00026914                  do
00026914                  {
000268ff                      double zmm0_8[0x2] = DistanceSquare(A_1, B_1);
000268ff                      
00026907                      if (!(zmm6[0] <= zmm0_8[0]))
00026909                          zmm6 = zmm0_8;
00026909                      
0002690c                      A_1 = &A_1[1];
00026910                      j_2 = j_5;
00026910                      j_5 -= 1;
00026914                  } while (j_2 != 1);
00026916                  *(uint32_t*)rbx_6 = zmm6[0];
0002691a                  B_1 = &B_1[2];
0002691e                  rbx_6 = &(*(uint128_t*)rbx_6)[1];
00026922                  i_2 = i_7;
00026922                  i_7 -= 1;
00026926              } while (i_2 != 1);
00026928              struct kite_t* result_1 = result;
0002692d              uint64_t i_6 = (uint64_t)(uint32_t)(j_5 + 4);
00026939              int32_t* rdi_1 = &ptsArr;
000269ac              uint64_t i_3;
000269ac              
000269ac              do
000269ac              {
00026945                  float zmm1_7 = *(uint32_t*)r13_5;
0002694b                  int32_t* rax_50 = (uint64_t)*(uint8_t*)occludedSensor * 0x70;
0002695e                  struct fpoint_t rax_51;
0002695e                  
0002695e                  if (zmm1_7 <= *(uint32_t*)((char*)rax_50 + ssOut) || (*(uint32_t*)(
0002695e                      &ssOut->sensor[0].edgeSet[0].edgePair[0].edge[1] + rax_50))[0] <= zmm1_7)
0002695e                  {
0002698d                  label_2698d:
0002698d                      struct fpoint_t tchPt_1;
0002698d                      tchPt_1.x = result_1->kPt[0].pt.x;
0002698d                      tchPt_1.y = result_1->kPt[0].pt.y;
00026990                      rax_51 = NailTouchIfStillInTouchDownCircle(tchPt_1, tchDownCircles);
0002695e                  }
0002695e                  else
0002695e                  {
00026960                      zmm1_7 = *(uint32_t*)(&var_d8 + rsi_1);
00026960                      
00026981                      if ((*(uint32_t*)(&var_138 + rsi_1))[0]
00026981                              <= zmm1_7 * zmm1_7 * 1.04999995f)
00026981                          goto label_2698d;
00026981                      
00026983                      rax_51.x = *(uint32_t*)rdi_1;
00026983                      rax_51.y = rdi_1[1];
0002695e                  }
0002695e                  
00026995                  result_1->kPt[0].pt.x = rax_51.x;
00026995                  result_1->kPt[0].pt.y = rax_51.y;
00026998                  r13_5 = &r13_5[1];
0002699c                  rsi_1 += 4;
000269a0                  result_1 = &result_1->kPt[1];
000269a4                  rdi_1 = &rdi_1[2];
000269a8                  i_3 = i_6;
000269a8                  i_6 -= 1;
000269ac              } while (i_3 != 1);
00026703          }
00026205      }
00026205      
000269dc      return result;
00026144  }

000269dd                                                                                         cc cc cc                               ...
000269e0  cc cc cc cc                                                                                      ....

000269e4    struct fpoint_t NailTouchIfStillInTouchDownCircle(struct fpoint_t tchPt, struct touchDownCircles_t* tchDownCircles)

000269e4  {
000269e9      struct fpoint_t B;
000269e9      B.x = tchPt.x;
000269e9      B.y = tchPt.y;
000269f6      int64_t result;
000269f6      (uint32_t)result = tchPt.x;
000269f6      *(uint32_t*)((char*)result)[4] = tchPt.y;
000269fc      int32_t rax;
000269fc      (uint8_t)rax = tchDownCircles->TouchAge <= *(int64_t*)((char*)tchDownCircles + 0x30);
00026a06      void* rdi_2 = &tchDownCircles[(uint64_t)(uint8_t)rax];
00026a06      
00026a13      if (*(uint32_t*)((char*)rdi_2 + 0x10) > 0 && !*(uint8_t*)((char*)rdi_2 + 0x1c))
00026a13      {
00026a1a          struct fpoint_t* A;
00026a1a          (uint32_t)A = (uint32_t)rdi_2;
00026a1a          *(uint32_t*)((char*)A)[4] = *(uint32_t*)((char*)rdi_2)[4];
00026a1a          
00026a2d          if (!(49f <= DistanceSquare(A, &B)))
00026a2f              return *(uint64_t*)rdi_2;
00026a13      }
00026a13      
00026a3f      return result;
000269e4  }

00026a40  cc cc cc cc cc cc cc cc                                                                          ........

00026a48    void SaveTouchWidthsHistory(struct sub_sample_t* ssOut, struct twoSensorTriangulationMngr_t* twoSensorTriangulation, struct triangulate_statics_t* triangulateStatics, struct touchWidthsHistory_t* historyBuf, uint8_t numSensors)

00026a48  {
00026a59      int64_t r14;
00026a59      int64_t var_28 = r14;
00026a62      int128_t zmm6;
00026a62      int128_t var_38 = zmm6;
00026a6d      void var_c8;
00026a6d      int64_t rax_1 = __security_cookie ^ &var_c8;
00026a78      uint16_t deltaTimeStamp = ssOut->id.deltaTimeStamp;
00026a85      struct touchWidthsHistory_t* historyBuf_1 = historyBuf;
00026a97      struct triangulate_statics_t* triangulateStatics_1 = triangulateStatics;
00026a9d      char var_68 = 0;
00026aa1      char var_67 = 1;
00026aa6      char var_66 = 1;
00026aab      char var_65 = 0;
00026aaf      char var_64 = 0;
00026ab3      char var_63 = 0;
00026ab7      char var_62 = 0;
00026abb      char var_61 = 0;
00026abf      char var_60 = 0;
00026ac3      char var_5f = 0;
00026ac7      char var_5e = 0;
00026acb      char var_5d = 0;
00026acf      char var_5c = 0;
00026ad3      char var_5b = 0;
00026ad7      char var_5a = 0;
00026adb      char var_59 = 0;
00026adf      char var_58 = 1;
00026ae4      char var_57 = 0;
00026ae8      char var_56 = 0;
00026aec      char var_55 = 1;
00026af1      char var_54 = 0;
00026af5      char var_53 = 0;
00026af9      char var_52 = 0;
00026afd      char var_51 = 0;
00026b01      char var_50 = 1;
00026b06      char var_4f = 1;
00026b0b      char var_4e = 1;
00026b10      char var_4d = 1;
00026b15      char var_4c = 0;
00026b19      char var_4b = 0;
00026b1d      char var_4a = 0;
00026b21      char var_49 = 0;
00026b21      
00026b2e      if (ssOut->sensor[0].edgeSet[0].touchCount < 2
00026b2e          && ssOut->sensor[1].edgeSet[0].touchCount < 2)
00026b2e      {
00026b45      label_26b45:
00026b45          memset(historyBuf_1, 0, 0x444);
00026b4a          triangulateStatics_1 = triangulateStatics;
00026b4f          historyBuf_1->deltaTime = 0;
00026b2e      }
00026b2e      else if (!twoSensorTriangulation->occlusionState
00026b2e              && twoSensorTriangulation->prevOcclusionState)
00026b38          goto label_26b45;
00026b38      
00026b67      if (ssOut->sensor[0].edgeSet[0].touchCount == 2
00026b67          && ssOut->sensor[1].edgeSet[0].touchCount == 2)
00026b67      {
00026b6d          void* r12;
00026b6d          (uint8_t)r12 = 0;
00026b70          char var_98_1 = 0;
00026b70          
00026cbb          do
00026cbb          {
00026b74              (uint8_t)r14 = 0;
00026b74              
00026b7e              if (numSensors > 0)
00026b7e              {
00026b84                  uint64_t rax_2 = (uint64_t)(uint8_t)r12;
00026b88                  int64_t r8 = 0;
00026b8b                  int64_t var_80_1 = 0;
00026b93                  r12 = &var_c8 + (rax_2 << 3) + 0x61;
00026b9f                  void* ptBuffer = rax_2 * 0x110 + historyBuf_1;
00026ba2                  void* r13 = nullptr;
00026ba2                  
00026c98                  do
00026c98                  {
00026bb1                      int64_t rdi_2 = (uint64_t)*(uint8_t*)((char*)r12 - 1) + r8;
00026bb4                      uint64_t rdx = (uint64_t)(uint8_t)(r14 - 1) & 1;
00026bbf                      uint64_t rbx_1 = rdx * 3;
00026bcd                      int64_t rcx_3 = rdx * 0xe + (uint64_t)*(uint8_t*)r12;
00026bd0                      struct sensor_info_t* snsInfo = triangulateStatics_1->snsInfo;
00026be6                      (uint32_t)zmm6 = ssOut->sensor[0].edgeSet[0].edgePair[rcx_3].edge[1]
00026be6                          + *(uint32_t*)((char*)ssOut + (rcx_3 << 3));
00026bec                      (uint32_t)zmm6 = (uint32_t)zmm6 * 0.5f;
00026bf7                      struct fpoint_t rax_5;
00026bf7                      float sensorBAngle;
00026bf7                      rax_5 = CTL_Triangulate(*(uint32_t*)((char*)ssOut + (rdi_2 << 3)), 
00026bf7                          (uint32_t)zmm6, (char*)r13 + snsInfo, 
00026bf7                          (char*)snsInfo + (rbx_1 << 2));
00026c05                      struct fpoint_t A;
00026c05                      A.x = rax_5.x;
00026c05                      A.y = rax_5.y;
00026c0f                      struct sensor_info_t* snsInfo_1 = triangulateStatics->snsInfo;
00026c1f                      struct fpoint_t rax_7 = CTL_Triangulate(
00026c1f                          ssOut->sensor[0].edgeSet[0].edgePair[rdi_2].edge[1], 
00026c1f                          sensorBAngle, (char*)r13 + snsInfo_1, 
00026c1f                          (char*)snsInfo_1 + (rbx_1 << 2));
00026c2e                      struct fpoint_t B;
00026c2e                      B.x = rax_7.x;
00026c2e                      B.y = rax_7.y;
00026c33                      float zmm0_2[0x4] = DistanceSquare(&A, &B);
00026c3f                      float centreAngle;
00026c3f                      
00026c3f                      if (zmm0_2[0] <= 0f)
00026c52                          centreAngle = (int32_t){0};
00026c3f                      else
00026c4c                          centreAngle = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_2, 
00026c4c                              *(uint64_t*)&zmm0_2[0])[0])[0]);
00026c4c                      
00026c69                      AddNewDataToBuffer(ptBuffer, (char*)ptBuffer + 0x40, 8, centreAngle, 
00026c69                          deltaTimeStamp);
00026c73                      triangulateStatics_1 = triangulateStatics;
00026c78                      r8 = var_80_1 + 0xe;
00026c7c                      (uint8_t)r14 += 1;
00026c7f                      r12 += 2;
00026c83                      ptBuffer += 0x44;
00026c87                      r13 += 0xc;
00026c8b                      var_80_1 = r8;
00026c98                  } while ((uint8_t)r14 < numSensors);
00026c98                  
00026c9e                  (uint8_t)r12 = var_98_1;
00026ca3                  historyBuf_1 = historyBuf;
00026b7e              }
00026b7e              
00026caa              triangulateStatics_1 = triangulateStatics;
00026caf              (uint8_t)r12 += 1;
00026cb2              var_98_1 = (uint8_t)r12;
00026cbb          } while ((uint8_t)r12 < 4);
00026b67      }
00026b67      
00026ccc      __security_check_cookie(rax_1 ^ &var_c8);
00026a48  }

00026cf2                                                        cc cc cc cc cc cc                                            ......

00026cf8    void SwapTouchWidthBufferHistories(struct touchWidthsHistory_t* historyBuf, struct touchWidthsHistory_t* centreAnglesHistory)

00026cf8  {
00026d12      int64_t rdi;
00026d12      (uint8_t)rdi = 0;
00026d12      
00026e2b      do
00026e2b      {
00026d22          if (historyBuf->widthHistory[0][(uint64_t)(uint8_t)rdi].numFrames > 0)
00026d22          {
00026d2b              if (!(uint8_t)rdi)
00026d2b              {
00026d42                  SwapBufferContents(historyBuf, &historyBuf->widthHistory[0][0].numFrames, 
00026d42                      &historyBuf->widthHistory[3], 
00026d42                      &historyBuf->widthHistory[3][0].numFrames);
00026d63                  SwapBufferContents(&historyBuf->widthHistory[2], 
00026d63                      &historyBuf->widthHistory[2][0].numFrames, 
00026d63                      &historyBuf->widthHistory[1], 
00026d63                      &historyBuf->widthHistory[1][0].numFrames);
00026d7d                  SwapBufferContents(centreAnglesHistory, 
00026d7d                      &centreAnglesHistory->widthHistory[0][0].numFrames, 
00026d7d                      &centreAnglesHistory->widthHistory[3], 
00026d7d                      &centreAnglesHistory->widthHistory[3][0].numFrames);
00026e1f                  SwapBufferContents(&centreAnglesHistory->widthHistory[2], 
00026e1f                      &centreAnglesHistory->widthHistory[2][0].numFrames, 
00026e1f                      &centreAnglesHistory->widthHistory[1], 
00026e1f                      &centreAnglesHistory->widthHistory[1][0].numFrames);
00026d2b              }
00026d2b              else if ((uint8_t)rdi == 1)
00026da4              {
00026dbf                  SwapBufferContents(&historyBuf->widthHistory[0][1], 
00026dbf                      &historyBuf->widthHistory[0][1].numFrames, 
00026dbf                      &historyBuf->widthHistory[1][1].tchWidths, 
00026dbf                      &historyBuf->widthHistory[1][1].numFrames);
00026de0                  SwapBufferContents(&historyBuf->widthHistory[2][1], 
00026de0                      &historyBuf->widthHistory[2][1].numFrames, 
00026de0                      &historyBuf->widthHistory[3][1].tchWidths, 
00026de0                      &historyBuf->widthHistory[3][1].numFrames);
00026dfe                  SwapBufferContents(&centreAnglesHistory->widthHistory[0][1].tchWidths, 
00026dfe                      &centreAnglesHistory->widthHistory[0][1].numFrames, 
00026dfe                      &centreAnglesHistory->widthHistory[1][1].tchWidths, 
00026dfe                      &centreAnglesHistory->widthHistory[1][1].numFrames);
00026e1f                  SwapBufferContents(&centreAnglesHistory->widthHistory[2][1], 
00026e1f                      &centreAnglesHistory->widthHistory[2][1].numFrames, 
00026e1f                      &centreAnglesHistory->widthHistory[3][1], 
00026e1f                      &centreAnglesHistory->widthHistory[3][1].numFrames);
00026da4              }
00026d22          }
00026d22          
00026e24          (uint8_t)rdi += 1;
00026e2b      } while ((uint8_t)rdi < 4);
00026cf8  }

00026e46                    cc cc cc cc cc cc                                                                    ......

00026e4c    struct fpoint_t PerformTopWanderFix(float cam0Angle, float cam1Angle, float bottomX, struct fpoint_t tchPt)

00026e4c  {
00026e4f      float x = tchPt.x;
00026e66      int64_t rbx;
00026e66      (uint32_t)rbx = tchPt.x;
00026e66      *(uint32_t*)((char*)rbx)[4] = tchPt.y;
00026e69      int64_t var_68 = rbx;
00026e8a      float zmm8[0x4] = cam0Angle;
00026e8e      int128_t zmm6;
00026e8e      (uint32_t)zmm6 = cam1Angle + 0f - 1.57079637f;
00026e96      int128_t zmm0;
00026e96      int128_t zmm6_1;
00026e96      zmm0 = _safeTan(cam0Angle);
00026ea2      double zmm0_1;
00026ea2      float zmm6_2[0x4];
00026ea2      float zmm7;
00026ea2      zmm0_1 = _safeTan((uint32_t)zmm6_1);
00026ea2      
00026eab      if (!((uint32_t)zmm0 <= zmm7))
00026eab      {
00026eb1          float zmm1[0x4] = 0x3f000000;
00026eb1          
00026ecb          if (!(0.5f <= (uint32_t)zmm0) && !(zmm7 <= (uint32_t)zmm0_1)
00026ecb              && !((uint32_t)zmm0_1 <= -0.5f))
00026ecb          {
00026ecd              zmm6_2 ^= __mask@@NegFloat@;
00026ecd              
00026ed8              if (zmm8[0] <= zmm6_2[0])
00026ee7                  zmm0_1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm6_2, *(uint64_t*)&zmm6_2[0])[0]);
00026ed8              else
00026ede                  zmm0_1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm8, *(uint64_t*)&zmm8[0])[0]);
00026ede              
00026ef2              zmm1[0] = (float)(zmm0_1 - 0.10000000000000001);
00026f04              float zmm2 = (float)(
00026f04                  _mm_cvtps_pd(_mm_unpacklo_ps(zmm1, *(uint64_t*)&zmm1[0])[0]) * 2.5);
00026f04              
00026f0b              if (!(zmm7 <= zmm2))
00026f0d                  zmm2 = zmm7;
00026f0d              
00026f10              zmm1 = 0x3f800000;
00026f21              zmm1[0] = 1f - zmm2;
00026f25              (uint32_t)zmm0_1 = tchPt.y * zmm2;
00026f29              zmm1[0] = zmm1[0] * bottomX;
00026f2e              zmm1[0] = zmm1[0] + (uint32_t)zmm0_1;
00026f32              (uint32_t)var_68 = zmm1[0];
00026f38              return var_68;
00026ecb          }
00026eab      }
00026eab      
00026f64      return rbx;
00026e4c  }

00026f65                 cc cc cc cc cc cc cc                                                                   .......

00026f6c    uint8_t SS_SubSample(struct sub_sampler_working_t* pSS_Struct, struct sub_sample_in_t const* input, struct sub_sample_t* output)

00026f6c  {
00026f84      uint64_t newest = (uint64_t)pSS_Struct->newest;
00026f92      struct sub_sample_t* output_1 = output;
00026f95      (uint8_t)output = input->sensor;
00026f9f      char rdi = 0;
00026fa8      (uint8_t)output -= pSS_Struct->sample[newest].trueSensor;
00026fb7      int64_t rbp;
00026fb7      (uint16_t)rbp = 0;
00026fbe      int64_t r8 = (int64_t)((uint32_t)newest + 1);
00026fcc      char temp1 =
00026fcc          (char)((int64_t)(uint32_t)(uint8_t)output % (uint32_t)pSS_Struct->numSensors);
00026fd7      uint64_t rdx_3 = r8 / 5;
00026fdf      uint8_t r8_1 = (uint8_t)r8 - ((uint8_t)rdx_3 + (char)(rdx_3 << 2));
00026fe9      int32_t rax_7 = (uint32_t)pSS_Struct->oldest + 1;
00026feb      pSS_Struct->newest = r8_1;
00026ff2      int64_t rcx_1 = (int64_t)rax_7;
00026ffb      uint64_t rdx_5 = rcx_1 / 5;
00027008      pSS_Struct->oldest = (uint8_t)rcx_1 - ((uint8_t)rdx_5 + (char)(rdx_5 << 2));
00027022      memset((uint64_t)r8_1 * 0x1cc + pSS_Struct, 0, 0x1cc);
0002703a      char* state = (uint64_t)pSS_Struct->state;
00027040      pSS_Struct->thisSensor = ((int64_t)((uint32_t)pSS_Struct->thisSensor + 1)
00027040          % (uint32_t)pSS_Struct->numSensors);
00027048      uint64_t rdx_7;
00027048      
00027048      if (!(uint32_t)state)
0002704a          rbp = 1;
00027048      else if ((uint32_t)state != 1)
00027055      {
00027075          if (temp1 != 1)
00027075          {
0002707d              state = SyncSubSampler(pSS_Struct, input);
00027082              char i = 0;
00027082              
0002708c              if (pSS_Struct->numSensors > 0)
0002708c              {
000270df                  do
000270df                  {
00027095                      uint32_t i_1 = (uint32_t)i;
00027099                      i += 1;
000270cf                      pSS_Struct->sample[(int64_t)((uint32_t)pSS_Struct->oldest + i_1)
000270cf                          % 0x1cc].floop = 1;
000270df                  } while (i < pSS_Struct->numSensors);
0002708c              }
0002708c              
000270e1              (uint8_t)state = input->sensor;
000270e4              pSS_Struct->thisSensor = (uint8_t)state;
00027075          }
00027075          
000270ee          if (input->edgeCount > 4)
000270ee          {
000270fe              rbp = 0x20;
00027111              ((uint64_t)pSS_Struct->thisSensor * 0x70 + pSS_Struct)[
00027111                  (uint64_t)pSS_Struct->newest * 0x1cc + 0x18] = 0;
000270ee          }
00027055      }
00027055      else
00027055      {
0002705d          state = SyncSubSampler(pSS_Struct, input);
00027062          pSS_Struct->state = SS_RUNNING;
00027055      }
00027055      
0002711a      if (!((uint8_t)rbp & 0x37))
0002711a      {
00027120          uint64_t thisSensor = (uint64_t)pSS_Struct->thisSensor;
00027143          void* rcx_15 = (uint64_t)pSS_Struct->newest * 0x1cc + pSS_Struct;
00027149          void* rbp_3 = (uint64_t)pSS_Struct->oldest * 0x1cc + pSS_Struct;
0002714c          *(uint8_t*)((char*)rcx_15 + 0x1c4) = (uint8_t)thisSensor;
00027152          int32_t rax_21;
00027152          (uint16_t)rax_21 = input->id.id;
00027152          *(uint16_t*)((char*)rax_21)[2] = input->id.deltaTimeStamp;
00027159          *(uint16_t*)((char*)rcx_15 + 0x1c6) = (uint16_t)rax_21;
00027159          *(uint16_t*)((char*)rcx_15 + 0x1c8) = *(uint16_t*)((char*)rax_21)[2];
00027162          void* r8_7 = thisSensor * 0x70 + rcx_15;
00027165          *(uint32_t*)((char*)rcx_15 + 0x1c0) = input->timestamp;
0002716b          *(uint8_t*)((char*)r8_7 + 0x6c) = 1;
00027170          uint32_t rax_22;
00027170          (uint8_t)rax_22 = input->edgeCount;
00027173          (uint8_t)rax_22 u>>= 1;
00027175          *(uint8_t*)((char*)r8_7 + 0x18) = (uint8_t)rax_22;
00027175          
0002717d          if (input->edgesBetweenFound == 1)
0002717f              *(uint32_t*)((char*)r8_7 + 0x1c) |= 0x40;
0002717f          
00027184          (uint8_t)rdx_7 = 0;
00027184          
0002718a          if ((uint8_t)rax_22 > 0)
0002718a          {
000271bb              do
000271bb              {
0002718c                  uint64_t rcx_16 = (uint64_t)(uint8_t)rdx_7;
0002718f                  (uint8_t)rdx_7 += 1;
00027194                  *(uint32_t*)((char*)r8_7 + (rcx_16 << 3)) = input->edges[rcx_16 * 2];
0002719c                  *(uint32_t*)((char*)r8_7 + (rcx_16 << 3) + 4) =
0002719c                      input->edges[1 + rcx_16 * 2];
000271a6                  *(uint16_t*)((char*)r8_7 + (rcx_16 << 1) + 0x10) =
000271a6                      input->touchIntegral[rcx_16];
000271b1                  *(uint16_t*)((char*)r8_7 + (rcx_16 << 1) + 0x14) =
000271b1                      input->touchWidth[rcx_16];
000271bb              } while ((uint8_t)rdx_7 < *(uint8_t*)((char*)r8_7 + 0x18));
0002718a          }
0002718a          
000271d0          if (CalcSubSamples(pSS_Struct) == 1 && !*(uint8_t*)((char*)rbp_3 + 0x1c5))
000271d0          {
000271de              memmove(output_1, rbp_3, 0x1cc);
000271e3              rdi = 1;
000271d0          }
0002711a      }
0002711a      
000271f5      (uint8_t)state = rdi;
00027201      return (uint8_t)state;
00026f6c  }

00027202        cc cc cc cc cc cc                                                                            ......

00027208    void SyncSubSampler(struct sub_sampler_working_t* pSS_Struct, struct sub_sample_in_t const* in)

00027208  {
00027220      uint64_t rbp;
00027220      (uint8_t)rbp = in->sensor;
00027236      uint16_t rdi = in->id.id - (uint16_t)pSS_Struct->numSensors;
00027239      pSS_Struct->thisSensor = (uint8_t)rbp;
00027243      memset(pSS_Struct, 0, 0x8fc);
00027243      
000272cd      for (int32_t i = 0; i < 5; )
000272cd      {
00027260          uint64_t rcx_1 = (uint64_t)((uint32_t)pSS_Struct->oldest + i);
00027263          i += 1;
0002727b          void* rcx_4 = rcx_1 % 5 * 0x1cc + pSS_Struct;
0002727e          *(uint16_t*)((char*)rcx_4 + 0x1c6) = rdi;
00027285          uint16_t deltaTimeStamp = in->id.deltaTimeStamp;
00027289          *(uint8_t*)((char*)rcx_4 + 0x1c4) = (uint8_t)rbp;
00027290          *(uint16_t*)((char*)rcx_4 + 0x1c8) = deltaTimeStamp;
0002729a          rdi += 1;
0002729e          *(uint32_t*)((char*)rcx_4 + 0x1c0) = in->timestamp;
000272a8          int64_t rax_5 = (uint64_t)(uint8_t)rbp * 0x70;
000272ac          *(uint8_t*)(rax_5 + rcx_4 + 0x6c) = 0;
000272b1          *(uint8_t*)(rax_5 + rcx_4 + 0x18) = 0;
000272c7          rbp = (uint64_t)((int64_t)((uint32_t)(uint8_t)rbp + 1)
000272c7              % (uint32_t)pSS_Struct->numSensors);
000272cd      }
00027208  }

000272e4              cc cc cc cc cc cc cc cc                                                                  ........

000272ec    uint8_t CalcSubSamples(struct sub_sampler_working_t* pSS_Struct)

000272ec  {
00027304      uint32_t numSensors = (uint32_t)pSS_Struct->numSensors;
0002730c      uint64_t oldest = (uint64_t)pSS_Struct->oldest;
00027330      void* r12_2 = (uint64_t)pSS_Struct->newest * 0x1cc + pSS_Struct;
00027339      struct sub_sampler_working_t* pSS_Struct_1 = pSS_Struct;
0002733c      void* i_14 = (uint64_t)pSS_Struct->thisSensor * 0x70;
00027340      void* rdi = (char*)i_14 + r12_2;
00027344      int64_t r15;
00027344      (uint8_t)r15 = 1;
00027356      void* rbp_2 = oldest * 0x1cc + pSS_Struct;
00027359      char i = 0;
0002735c      int32_t r9 = 1;
0002735f      struct edge_set_t* rsi = (char*)i_14 + rbp_2;
00027363      void* var_60 = rdi;
00027372      float* var_70 = rsi;
00027372      
0002737a      if (numSensors > 1)
0002737a      {
00027382          while (!i)
00027382          {
000273a4              void* rcx_3 = (uint64_t)(r9 + (uint32_t)oldest) % 5 * 0x1cc + pSS_Struct_1;
000273a4              
000273b7              if (!*(uint8_t*)((uint64_t)*(uint8_t*)((char*)rcx_3 + 0x1c4) * 0x70 + rcx_3
000273b7                      + 0x18))
000273b7                  i = 1;
000273b7              
000273bb              r9 += 1;
000273bb              
000273c1              if (r9 >= numSensors)
000273c1                  break;
00027382          }
00027382          
000273c3          rsi = var_70;
0002737a      }
0002737a      
000273d9      if (!*(uint8_t*)((char*)rbp_2 + 0x1c5))
000273d9      {
000273f7          uint32_t touchCount = (uint32_t)rsi->touchCount;
000273f7          
000273fe          if (!i)
000273fe          {
0002745a              uint32_t rcx_7;
0002745a              enum touch_trans_t transition;
0002745a              
0002745a              if (!touchCount)
0002745a              {
000274bc                  rcx_7 = (uint32_t)*(uint8_t*)((char*)rdi + 0x18);
000274bc                  
000274c3                  if (!rcx_7)
000274e4                      transition = NONE_TO_NONE;
000274c3                  else if (rcx_7 == 1)
000274df                      transition = NONE_TO_ONE;
000274c8                  else if (rcx_7 == 2)
000274d7                      transition = NONE_TO_TWO;
000274cd                  else
000274cf                      transition = INVALID_TRANS;
0002745a              }
0002745a              else if (touchCount == 1)
0002745f              {
00027491                  rcx_7 = (uint32_t)*(uint8_t*)((char*)rdi + 0x18);
00027491                  
00027498                  if (!rcx_7)
000274b4                      transition = ONE_TO_NONE;
00027498                  else if (rcx_7 == 1)
000274ac                      transition = ONE_TO_ONE;
0002749d                  else if (rcx_7 != 2)
000274cf                      transition = INVALID_TRANS;
000274a2                  else
000274a4                      transition = ONE_TO_TWO;
0002745f              }
0002745f              else if (touchCount != 2)
000274cf                  transition = INVALID_TRANS;
00027464              else
00027464              {
00027466                  rcx_7 = (uint32_t)*(uint8_t*)((char*)rdi + 0x18);
00027466                  
0002746d                  if (!rcx_7)
00027489                      transition = TWO_TO_NONE;
0002746d                  else if (rcx_7 == 1)
00027481                      transition = TWO_TO_ONE;
00027472                  else if (rcx_7 != 2)
000274cf                      transition = INVALID_TRANS;
00027477                  else
00027479                      transition = TWO_TO_TWO;
00027464              }
00027464              
000274ea              pSS_Struct_1->touchTrans = transition;
000274ea              
000274f1              if (transition < NONE_TO_NONE)
00028531                  (uint8_t)r15 = 0;
000274f1              else if (transition <= ONE_TO_NONE)
0002744d                  SetupOtherSensorFrames(pSS_Struct_1, 1, 0, transition);
000274fb              else
000274fb              {
00027505                  int64_t postulationRanking;
00027505                  float yi;
00027505                  int32_t arg_20;
00027505                  
00027505                  if (transition == ONE_TO_ONE)
00027505                  {
00028393                      int32_t rcx_37 = 1;
00028396                      arg_20 = 1;
00028396                      
000283a0                      if (numSensors > 1)
000283a0                      {
000283ac                          postulationRanking = (char*)rdi - rsi;
000283ac                          
00028529                          do
00028529                          {
000283c1                              int64_t postulationRanking_1 = postulationRanking;
000283e5                              void* r13_22 =
000283e5                                  (uint64_t)((uint32_t)pSS_Struct_1->oldest + rcx_37) % 5
000283e5                                  * 0x1cc + pSS_Struct_1;
000283e8                              int128_t* rbx_6 = rsi;
000283eb                              void* yi_8 =
000283eb                                  (uint64_t)pSS_Struct_1->thisSensor * 0x70 + r13_22;
000283f6                              void* yi_4 = yi_8;
000283f9                              *(uint8_t*)((char*)yi_8 + 0x6c) = 1;
000283fe                              *(uint8_t*)((char*)yi_8 + 0x18) = 1;
00028403                              int64_t i_18 = 2;
00028444                              int64_t i_1;
00028444                              
00028444                              do
00028444                              {
00028430                                  uint8_t rax_145 = SFP_Lerp(
00028430                                      *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00028430                                      (*(uint32_t*)rbx_6), 
00028430                                      *(uint32_t*)((char*)r12_2 + 0x1c0), 
00028430                                      (*(uint32_t*)((char*)rbx_6 + postulationRanking_1)), 
00028430                                      *(uint32_t*)((char*)r13_22 + 0x1c0), yi_4);
00028435                                  yi_4 += 4;
00028439                                  rbx_6 += 4;
0002843d                                  (uint8_t)r15 &= rax_145;
00028440                                  i_1 = i_18;
00028440                                  i_18 -= 1;
00028444                              } while (i_1 != 1);
0002844b                              rsi = var_70;
00028450                              uint32_t x2_19 = *(uint32_t*)((char*)r12_2 + 0x1c0);
0002845c                              uint32_t x1_18 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
0002846a                              uint128_t zmm1 = (uint128_t)rsi->touchIntegral[0];
0002847b                              uint32_t xi_3 = *(uint32_t*)((char*)r13_22 + 0x1c0);
00028482                              uint128_t zmm3 = _mm_cvtepi32_ps((uint128_t)
00028482                                  *(uint16_t*)((char*)var_60 + 0x10));
0002848c                              SFP_Lerp(x1_18, _mm_cvtepi32_ps(zmm1), x2_19, (uint32_t)zmm3, 
0002848c                                  xi_3, &yi);
000284a3                              *(uint16_t*)((char*)yi_8 + 0x10) =
000284a3                                  (int16_t)(int64_t)(long double)yi;
000284ac                              uint32_t x2_20 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000284b4                              uint32_t x1_19 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
000284be                              uint32_t rax_149 = (uint32_t)rsi->touchWidth[0];
000284c2                              zmm3 = _mm_cvtepi32_ps((uint128_t)
000284c2                                  *(uint16_t*)((char*)var_60 + 0x14));
000284e4                              SFP_Lerp(x1_19, _mm_cvtepi32_ps((uint128_t)rax_149), x2_20, 
000284e4                                  (uint32_t)zmm3, *(uint32_t*)((char*)r13_22 + 0x1c0), &yi);
000284f0                              pSS_Struct_1 = pSS_Struct;
000284f8                              int16_t r11_22 = (int16_t)(int64_t)(long double)yi;
00028502                              rcx_37 = arg_20 + 1;
00028504                              *(uint32_t*)((char*)yi_8 + 0x20) = 4;
00028516                              *(uint16_t*)((char*)yi_8 + 0x14) = r11_22;
0002851b                              arg_20 = rcx_37;
00028529                          } while (rcx_37 < numSensors);
000283a0                      }
00027505                  }
00027505                  else
00027505                  {
0002750f                      int32_t var_90;
0002750f                      
0002750f                      if (transition == ONE_TO_TWO)
0002750f                      {
00027ef0                          float singlePair_1[0x2];
00027ef0                          singlePair_1[0] = rsi->edgePair[0].edge[0];
00027ef0                          singlePair_1[1] = rsi->edgePair[0].edge[1];
00027f03                          *(uint8_t*)((char*)rdi + 0x19) =
00027f03                              FindMatchingEdgePair(rdi, singlePair_1);
00027f06                          struct edge_pair_t* rcx_23;
00027f06                          (uint8_t)rcx_23 = pSS_Struct_1->numSensors;
00027f0f                          FindBestMatches((uint8_t)rcx_23, rsi, rdi, &postulationRanking);
00027f14                          int32_t rdx_16 = 1;
00027f17                          arg_20 = 1;
00027f17                          
00027f21                          if (numSensors > 1)
00027f21                          {
00027f2b                              uint64_t r8_14 = (uint64_t)var_90 * 9;
00027f33                              uint64_t rcx_24 = (uint64_t)(uint32_t)postulationRanking * 9;
00027f3a                              uint64_t var_a8_3 = r8_14;
00027f3f                              int64_t rax_98 = (char*)rdi - rsi;
00027f53                              uint64_t rcx_25 =
00027f53                                  (uint64_t)*(uint32_t*)((char*)postulationRanking)[4] * 9;
00027f57                              void* rax_100 = (char*)rdi + 8;
00027f57                              
00028388                              do
00028388                              {
00027f9c                                  void* rcx_30 =
00027f9c                                      (uint64_t)((uint32_t)pSS_Struct_1->oldest + rdx_16)
00027f9c                                      % 5 * 0x1cc + pSS_Struct_1;
00027f9f                                  void* r13_14 =
00027f9f                                      (uint64_t)pSS_Struct_1->thisSensor * 0x70 + rcx_30;
00027fa7                                  *(uint8_t*)((char*)r13_14 + 0x6c) = 3;
00027fac                                  *(uint8_t*)((char*)r13_14 + (r8_14 << 2) + 0x18) = 1;
00028003                                  (uint8_t)r15 &= SFP_Lerp(
00028003                                      *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00028003                                      rsi->edgePair[0].edge[0], 
00028003                                      *(uint32_t*)((char*)r12_2 + 0x1c0), 
00028003                                      (*(uint32_t*)rdi), 
00028003                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), 
00028003                                      (char*)r13_14 + (r8_14 << 2));
0002801f                                  uint8_t rax_109 = SFP_Lerp(
0002801f                                      *(uint32_t*)((char*)rbp_2 + 0x1c0), 
0002801f                                      rsi->edgePair[0].edge[1], 
0002801f                                      *(uint32_t*)((char*)r12_2 + 0x1c0), 
0002801f                                      (*(uint32_t*)((char*)rdi + 0xc)), 
0002801f                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), 
0002801f                                      (char*)r13_14 + (var_a8_3 << 2) + 4);
00028024                                  (uint8_t)r15 &= rax_109;
0002802c                                  *(uint32_t*)((char*)r13_14 + (var_a8_3 << 2) + 0x1c) |= 2;
00028036                                  uint32_t x2_13 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00028042                                  uint32_t rax_112 = (uint32_t)rsi->touchIntegral[0];
00028046                                  uint32_t x1_13 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
0002804c                                  uint128_t zmm3_3 = _mm_cvtepi32_ps((uint128_t)
0002804c                                      *(uint16_t*)((char*)rdi + 0x10));
0002806d                                  SFP_Lerp(x1_13, _mm_cvtepi32_ps((uint128_t)rax_112), 
0002806d                                      x2_13, (uint32_t)zmm3_3, 
0002806d                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), &yi);
00028081                                  *(uint16_t*)((char*)r13_14 + (var_a8_3 << 2) + 0x10) =
00028081                                      (int16_t)(int64_t)(long double)yi;
0002808b                                  uint32_t x2_14 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00028093                                  uint32_t x1_14 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
0002809d                                  uint32_t rax_116 = (uint32_t)rsi->touchWidth[0];
000280a1                                  zmm3_3 = _mm_cvtepi32_ps((uint128_t)
000280a1                                      *(uint16_t*)((char*)rdi + 0x14));
000280c2                                  SFP_Lerp(x1_14, _mm_cvtepi32_ps((uint128_t)rax_116), 
000280c2                                      x2_14, (uint32_t)zmm3_3, 
000280c2                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), &yi);
000280cc                                  int128_t* rdi_6 = rsi;
000280d9                                  *(uint16_t*)((char*)r13_14 + (var_a8_3 << 2) + 0x14) =
000280d9                                      (int16_t)(int64_t)(long double)yi;
000280df                                  *(uint32_t*)((char*)r13_14 + (var_a8_3 << 2) + 0x20) = 5;
000280ed                                  *(uint8_t*)((char*)r13_14 + (rcx_24 << 2) + 0x18) = 1;
000280f3                                  void* yi_3 = (char*)r13_14 + (rcx_24 << 2);
000280f8                                  int64_t i_16 = 2;
00028140                                  int64_t i_2;
00028140                                  
00028140                                  do
00028140                                  {
0002812c                                      uint8_t rax_122 = SFP_Lerp(
0002812c                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
0002812c                                          (*(uint32_t*)rdi_6), 
0002812c                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
0002812c                                          (*(uint32_t*)((char*)rdi_6 + rax_98)), 
0002812c                                          *(uint32_t*)((char*)rcx_30 + 0x1c0), yi_3);
00028131                                      yi_3 += 4;
00028135                                      (uint8_t)r15 &= rax_122;
00028138                                      rdi_6 += 4;
0002813c                                      i_2 = i_16;
0002813c                                      i_16 -= 1;
00028140                                  } while (i_2 != 1);
00028151                                  *(uint32_t*)((char*)r13_14 + (rcx_24 << 2) + 0x1c) |= 4;
00028164                                  uint32_t rax_124 = (uint32_t)var_70[4];
0002816d                                  uint32_t x2_15 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00028175                                  zmm3_3 = _mm_cvtepi32_ps((uint128_t)
00028175                                      *(uint16_t*)((char*)var_60 + 0x10));
0002819d                                  SFP_Lerp(*(uint32_t*)((char*)rbp_2 + 0x1c0), 
0002819d                                      _mm_cvtepi32_ps((uint128_t)rax_124), x2_15, 
0002819d                                      (uint32_t)zmm3_3, 
0002819d                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), &yi);
000281ac                                  *(uint16_t*)((char*)r13_14 + (rcx_24 << 2) + 0x10) =
000281ac                                      (int16_t)(int64_t)(long double)yi;
000281b6                                  uint32_t x2_16 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000281be                                  uint32_t x1_15 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
000281c8                                  uint32_t rax_127 = (uint32_t)var_70[5];
000281cc                                  zmm3_3 = _mm_cvtepi32_ps((uint128_t)
000281cc                                      *(uint16_t*)((char*)var_60 + 0x14));
000281ee                                  SFP_Lerp(x1_15, _mm_cvtepi32_ps((uint128_t)rax_127), 
000281ee                                      x2_16, (uint32_t)zmm3_3, 
000281ee                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), &yi);
000281f8                                  float* rdi_8 = var_70;
00028205                                  void* rsi_7 = rax_100;
0002820d                                  *(uint16_t*)((char*)r13_14 + (rcx_24 << 2) + 0x14) =
0002820d                                      (int16_t)(int64_t)(long double)yi;
00028213                                  *(uint32_t*)((char*)r13_14 + (rcx_24 << 2) + 0x20) = 5;
0002821c                                  pSS_Struct_1 = pSS_Struct;
00028229                                  *(uint8_t*)((char*)r13_14 + (rcx_25 << 2) + 0x18) = 1;
0002822f                                  void* yi_7 = (char*)r13_14 + (rcx_25 << 2);
00028232                                  int64_t i_13 = 2;
0002827b                                  int64_t i_3;
0002827b                                  
0002827b                                  do
0002827b                                  {
00028261                                      uint8_t rax_131 = SFP_Lerp(
00028261                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00028261                                          (*(uint32_t*)rdi_8), 
00028261                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00028261                                          (*(uint32_t*)rsi_7), 
00028261                                          *(uint32_t*)((char*)rcx_30 + 0x1c0), yi_7);
00028266                                      yi_7 += 4;
0002826a                                      rsi_7 += 4;
0002826e                                      rdi_8 = &rdi_8[1];
00028272                                      (uint8_t)r15 &= rax_131;
00028275                                      i_3 = i_13;
00028275                                      i_13 -= 1;
0002827b                                  } while (i_3 != 1);
00028287                                  rdi = var_60;
0002828c                                  *(uint32_t*)((char*)r13_14 + (rcx_25 << 2) + 0x1c) |= 8;
00028296                                  rsi = var_70;
0002829f                                  uint32_t rax_133 = (uint32_t)rsi->touchIntegral[0];
000282a3                                  uint32_t x2_17 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000282ab                                  uint32_t x1_16 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
000282b1                                  zmm3_3 = _mm_cvtepi32_ps((uint128_t)
000282b1                                      *(uint16_t*)((char*)rdi + 0x12));
000282d7                                  SFP_Lerp(x1_16, _mm_cvtepi32_ps((uint128_t)rax_133), 
000282d7                                      x2_17, (uint32_t)zmm3_3, 
000282d7                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), &yi);
000282e6                                  *(uint16_t*)((char*)r13_14 + (rcx_25 << 2) + 0x10) =
000282e6                                      (int16_t)(int64_t)(long double)yi;
000282f0                                  uint32_t x2_18 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000282f8                                  uint32_t x1_17 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00028302                                  uint32_t rax_137 = (uint32_t)rsi->touchWidth[0];
00028306                                  zmm3_3 = _mm_cvtepi32_ps((uint128_t)
00028306                                      *(uint16_t*)((char*)rdi + 0x16));
0002832c                                  SFP_Lerp(x1_17, _mm_cvtepi32_ps((uint128_t)rax_137), 
0002832c                                      x2_18, (uint32_t)zmm3_3, 
0002832c                                      *(uint32_t*)((char*)rcx_30 + 0x1c0), &yi);
0002833b                                  *(uint16_t*)((char*)r13_14 + (rcx_25 << 2) + 0x14) =
0002833b                                      (int16_t)(int64_t)(long double)yi;
00028341                                  *(uint32_t*)((char*)r13_14 + (rcx_25 << 2) + 0x20) = 5;
00028341                                  
00028356                                  if (*(uint8_t*)((char*)rdi + 0x1c) & 0x40)
00028356                                  {
00028358                                      void* r13_17 = (char*)r13_14 + 0x1c;
0002835c                                      i_14 = 3;
0002836e                                      void* i_4;
0002836e                                      
0002836e                                      do
0002836e                                      {
00028361                                          *(uint32_t*)r13_17 |= 0x40;
00028366                                          r13_17 += 0x24;
0002836a                                          i_4 = i_14;
0002836a                                          i_14 -= 1;
0002836e                                      } while (i_4 != 1);
00028356                                  }
00028356                                  
00028377                                  r8_14 = var_a8_3;
0002837c                                  rdx_16 = arg_20 + 1;
0002837e                                  arg_20 = rdx_16;
00028388                              } while (rdx_16 < numSensors);
00027f21                          }
0002750f                      }
0002750f                      else if (transition == TWO_TO_NONE)
0002744d                          SetupOtherSensorFrames(pSS_Struct_1, 1, 0, transition);
00027519                      else if (transition == TWO_TO_ONE)
00027523                      {
00027a68                          struct edge_pair_t singlePair;
00027a68                          singlePair.edge[0] = *(uint32_t*)rdi;
00027a68                          singlePair.edge[1] = *(uint32_t*)((char*)rdi + 4);
00027a7b                          *(uint8_t*)((char*)rdi + 0x19) =
00027a7b                              FindMatchingEdgePair(rsi, singlePair);
00027a7e                          struct edge_set_t* rcx_15;
00027a7e                          (uint8_t)rcx_15 = pSS_Struct_1->numSensors;
00027a87                          FindBestMatches((uint8_t)rcx_15, rsi, rdi, &postulationRanking);
00027a8c                          int32_t rcx_16 = 1;
00027a8f                          arg_20 = 1;
00027a8f                          
00027a99                          if (numSensors > 1)
00027a99                          {
00027aa3                              uint64_t r8_7 = (uint64_t)(uint32_t)postulationRanking * 9;
00027aaa                              int64_t rax_57 = (char*)rdi - rsi;
00027aad                              uint64_t var_68_2 = r8_7;
00027abe                              uint64_t rdx_8 =
00027abe                                  (uint64_t)*(uint32_t*)((char*)postulationRanking)[4] * 9;
00027ad7                              uint64_t rdx_9 = (uint64_t)var_90 * 9;
00027ad7                              
00027ee5                              do
00027ee5                              {
00027b16                                  void* r14_11 =
00027b16                                      (uint64_t)((uint32_t)pSS_Struct_1->oldest + rcx_16)
00027b16                                      % 5 * 0x1cc + pSS_Struct_1;
00027b19                                  struct edge_set_t* rbx_2 = rsi;
00027b24                                  void* r13_8 =
00027b24                                      (uint64_t)pSS_Struct_1->thisSensor * 0x70 + r14_11;
00027b2c                                  *(uint8_t*)((char*)r13_8 + 0x6c) = 3;
00027b31                                  *(uint8_t*)((char*)r13_8 + (r8_7 << 2) + 0x18) = 1;
00027b37                                  void* yi_5 = (char*)r13_8 + (r8_7 << 2);
00027b3c                                  int64_t i_15 = 2;
00027b7d                                  uint128_t zmm1_11;
00027b7d                                  int64_t i_5;
00027b7d                                  
00027b7d                                  do
00027b7d                                  {
00027b5c                                      (uint32_t)zmm1_11 = rbx_2->edgePair[0].edge[0];
00027b5c                                      *(uint32_t*)((char*)zmm1_11)[4] =
00027b5c                                          rbx_2->edgePair[0].edge[0];
00027b5c                                      *(uint32_t*)((char*)zmm1_11)[8] =
00027b5c                                          rbx_2->edgePair[0].edge[0];
00027b5c                                      *(uint32_t*)((char*)zmm1_11)[0xc] =
00027b5c                                          rbx_2->edgePair[0].edge[0];
00027b69                                      uint8_t rax_64 = SFP_Lerp(
00027b69                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027b69                                          (uint32_t)zmm1_11, 
00027b69                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027b69                                          (*(uint32_t*)((char*)rbx_2 + rax_57)), 
00027b69                                          *(uint32_t*)((char*)r14_11 + 0x1c0), yi_5);
00027b6e                                      yi_5 += 4;
00027b72                                      rbx_2 = &rbx_2->edgePair[0].edge[1];
00027b76                                      (uint8_t)r15 &= rax_64;
00027b79                                      i_5 = i_15;
00027b79                                      i_15 -= 1;
00027b7d                                  } while (i_5 != 1);
00027b89                                  uint32_t x2_8 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027b95                                  uint32_t x1_8 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027ba3                                  zmm1_11 = (uint128_t)var_70[4];
00027bb4                                  uint32_t xi_1 = *(uint32_t*)((char*)r14_11 + 0x1c0);
00027bbb                                  uint128_t zmm3_2 = _mm_cvtepi32_ps((uint128_t)
00027bbb                                      *(uint16_t*)((char*)var_60 + 0x10));
00027bc5                                  SFP_Lerp(x1_8, _mm_cvtepi32_ps(zmm1_11), x2_8, 
00027bc5                                      (uint32_t)zmm3_2, xi_1, &yi);
00027bde                                  *(uint16_t*)((char*)r13_8 + (var_68_2 << 2) + 0x10) =
00027bde                                      (int16_t)(int64_t)(long double)yi;
00027be8                                  uint32_t x2_9 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027bf0                                  uint32_t x1_9 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027bfa                                  uint32_t rax_68 = (uint32_t)var_70[5];
00027bfe                                  zmm3_2 = _mm_cvtepi32_ps((uint128_t)
00027bfe                                      *(uint16_t*)((char*)var_60 + 0x14));
00027c20                                  SFP_Lerp(x1_9, _mm_cvtepi32_ps((uint128_t)rax_68), x2_9, 
00027c20                                      (uint32_t)zmm3_2, 
00027c20                                      *(uint32_t*)((char*)r14_11 + 0x1c0), &yi);
00027c2a                                  void* rsi_5 = var_60;
00027c37                                  struct edge_pair_t* rdi_4 = &rsi->edgePair[1];
00027c3f                                  *(uint16_t*)((char*)r13_8 + (var_68_2 << 2) + 0x14) =
00027c3f                                      (int16_t)(int64_t)(long double)yi;
00027c45                                  *(uint32_t*)((char*)r13_8 + (var_68_2 << 2) + 0x20) = 7;
00027c4e                                  pSS_Struct_1 = pSS_Struct;
00027c56                                  *(uint8_t*)((char*)r13_8 + (rdx_8 << 2) + 0x18) = 1;
00027c61                                  void* yi_6 = (char*)r13_8 + (rdx_8 << 2);
00027c64                                  int64_t i_12 = 2;
00027cad                                  uint128_t zmm1_13;
00027cad                                  int64_t i_6;
00027cad                                  
00027cad                                  do
00027cad                                  {
00027c86                                      (uint32_t)zmm1_13 = rdi_4->edge[0];
00027c86                                      *(uint32_t*)((char*)zmm1_13)[4] = rdi_4->edge[0];
00027c93                                      uint8_t rax_73 = SFP_Lerp(
00027c93                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027c93                                          (uint32_t)zmm1_13, 
00027c93                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027c93                                          (*(uint32_t*)rsi_5), 
00027c93                                          *(uint32_t*)((char*)r14_11 + 0x1c0), yi_6);
00027c98                                      yi_6 += 4;
00027c9c                                      rsi_5 += 4;
00027ca0                                      rdi_4 = &rdi_4->edge[1];
00027ca4                                      (uint8_t)r15 &= rax_73;
00027ca7                                      i_6 = i_12;
00027ca7                                      i_12 -= 1;
00027cad                                  } while (i_6 != 1);
00027cb4                                  rsi = var_70;
00027cb9                                  uint32_t x2_10 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027cc5                                  uint32_t x1_10 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027cd3                                  zmm1_13 = (uint128_t)rsi->touchIntegral[0];
00027ce4                                  uint32_t xi_2 = *(uint32_t*)((char*)r14_11 + 0x1c0);
00027ceb                                  zmm3_2 = _mm_cvtepi32_ps((uint128_t)
00027ceb                                      *(uint16_t*)((char*)var_60 + 0x10));
00027cf5                                  SFP_Lerp(x1_10, _mm_cvtepi32_ps(zmm1_13), x2_10, 
00027cf5                                      (uint32_t)zmm3_2, xi_2, &yi);
00027d0e                                  *(uint16_t*)((char*)r13_8 + (rdx_8 << 2) + 0x10) =
00027d0e                                      (int16_t)(int64_t)(long double)yi;
00027d18                                  uint32_t x2_11 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027d20                                  uint32_t x1_11 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027d2a                                  uint32_t rax_77 = (uint32_t)rsi->touchWidth[0];
00027d2e                                  zmm3_2 = _mm_cvtepi32_ps((uint128_t)
00027d2e                                      *(uint16_t*)((char*)var_60 + 0x14));
00027d50                                  SFP_Lerp(x1_11, _mm_cvtepi32_ps((uint128_t)rax_77), 
00027d50                                      x2_11, (uint32_t)zmm3_2, 
00027d50                                      *(uint32_t*)((char*)r14_11 + 0x1c0), &yi);
00027d64                                  *(uint16_t*)((char*)r13_8 + (rdx_8 << 2) + 0x14) =
00027d64                                      (int16_t)(int64_t)(long double)yi;
00027d6a                                  *(uint32_t*)((char*)r13_8 + (rdx_8 << 2) + 0x20) = 7;
00027d78                                  *(uint8_t*)((char*)r13_8 + (rdx_9 << 2) + 0x18) = 1;
00027dcb                                  (uint8_t)r15 &= SFP_Lerp(
00027dcb                                      *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027dcb                                      rsi->edgePair[0].edge[0], 
00027dcb                                      *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027dcb                                      (*(uint32_t*)var_60), 
00027dcb                                      *(uint32_t*)((char*)r14_11 + 0x1c0), 
00027dcb                                      (char*)r13_8 + (rdx_9 << 2));
00027de3                                  uint8_t rax_86 = SFP_Lerp(
00027de3                                      *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027de3                                      rsi->edgePair[1].edge[1], 
00027de3                                      *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027de3                                      (*(uint32_t*)((char*)var_60 + 4)), 
00027de3                                      *(uint32_t*)((char*)r14_11 + 0x1c0), 
00027de3                                      (char*)r13_8 + (rdx_9 << 2) + 4);
00027de8                                  (uint8_t)r15 &= rax_86;
00027df0                                  *(uint32_t*)((char*)r13_8 + (rdx_9 << 2) + 0x1c) |= 1;
00027dfa                                  uint32_t x2_12 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027e06                                  uint32_t rax_89 = (uint32_t)rsi->touchIntegral[0];
00027e0a                                  uint32_t x1_12 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027e10                                  zmm3_2 = _mm_cvtepi32_ps((uint128_t)
00027e10                                      *(uint16_t*)((char*)var_60 + 0x10));
00027e32                                  SFP_Lerp(x1_12, _mm_cvtepi32_ps((uint128_t)rax_89), 
00027e32                                      x2_12, (uint32_t)zmm3_2, 
00027e32                                      *(uint32_t*)((char*)r14_11 + 0x1c0), &yi);
00027e46                                  *(uint16_t*)((char*)r13_8 + (rdx_9 << 2) + 0x10) =
00027e46                                      (int16_t)(int64_t)(long double)yi;
00027e54                                  uint32_t rax_92 = (uint32_t)rsi->touchWidth[0];
00027e58                                  zmm3_2 = _mm_cvtepi32_ps((uint128_t)
00027e58                                      *(uint16_t*)((char*)var_60 + 0x14));
00027e88                                  SFP_Lerp(*(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027e88                                      _mm_cvtepi32_ps((uint128_t)rax_92), 
00027e88                                      *(uint32_t*)((char*)r12_2 + 0x1c0), (uint32_t)zmm3_2, 
00027e88                                      *(uint32_t*)((char*)r14_11 + 0x1c0), &yi);
00027e9c                                  *(uint16_t*)((char*)r13_8 + (rdx_9 << 2) + 0x14) =
00027e9c                                      (int16_t)(int64_t)(long double)yi;
00027ea2                                  *(uint32_t*)((char*)r13_8 + (rdx_9 << 2) + 0x20) = 7;
00027ea2                                  
00027eaf                                  if (rsi->specialCases & 0x40)
00027eaf                                  {
00027eb1                                      void* r13_11 = (char*)r13_8 + 0x1c;
00027eb5                                      i_14 = 3;
00027ec7                                      void* i_7;
00027ec7                                      
00027ec7                                      do
00027ec7                                      {
00027eba                                          *(uint32_t*)r13_11 |= 0x40;
00027ebf                                          r13_11 += 0x24;
00027ec3                                          i_7 = i_14;
00027ec3                                          i_14 -= 1;
00027ec7                                      } while (i_7 != 1);
00027eaf                                  }
00027eaf                                  
00027ed0                                  r8_7 = var_68_2;
00027ed5                                  rcx_16 = arg_20 + 1;
00027ed7                                  arg_20 = rcx_16;
00027ee5                              } while (rcx_16 < numSensors);
00027a99                          }
00027523                      }
00027523                      else if (transition != TWO_TO_TWO)
00028531                          (uint8_t)r15 = 0;
0002752d                      else
0002752d                      {
00027533                          (uint8_t)rcx_7 = pSS_Struct_1->numSensors;
00027544                          FindBestMatches((uint8_t)rcx_7, rsi, rdi, &postulationRanking);
00027549                          int32_t rcx_8 = 1;
0002754c                          arg_20 = 1;
0002754c                          
00027556                          if (numSensors > 1)
00027556                          {
00027560                              void* r9_2 = &rsi->edgePair[1];
00027564                              uint64_t r8_1 = (uint64_t)(uint32_t)postulationRanking * 9;
0002756b                              int128_t* rax_6 = (char*)rdi - rsi;
0002756e                              uint64_t var_88_1 = r8_1;
0002757c                              uint64_t rax_8 =
0002757c                                  (uint64_t)*(uint32_t*)((char*)postulationRanking)[4] * 9;
00027585                              void* rax_9 = (char*)rdi + 8;
00027594                              uint128_t* rax_11 = (char*)rsi - rdi;
00027594                              
00027a5d                              do
00027a5d                              {
000275d5                                  void* r13_5 =
000275d5                                      (uint64_t)((uint32_t)pSS_Struct_1->oldest + rcx_8) % 5
000275d5                                      * 0x1cc + pSS_Struct_1;
000275d8                                  void* rbx = r9_2;
000275db                                  void* r14_2 =
000275db                                      (uint64_t)pSS_Struct_1->thisSensor * 0x70 + r13_5;
000275e3                                  *(uint8_t*)((char*)r14_2 + 0x6c) = 2;
000275e8                                  *(uint8_t*)((char*)r14_2 + (r8_1 << 2) + 0x18) = 2;
000275ee                                  void* yi_1 = (char*)r14_2 + (r8_1 << 2);
000275f2                                  int64_t i_17 = 2;
0002766f                                  int64_t i_8;
0002766f                                  
0002766f                                  do
0002766f                                  {
00027636                                      (uint8_t)r15 &= SFP_Lerp(
00027636                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027636                                          (*(uint32_t*)((char*)rbx - 8)), 
00027636                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027636                                          (*(uint32_t*)rdi), 
00027636                                          *(uint32_t*)((char*)r13_5 + 0x1c0), yi_1);
00027657                                      uint8_t rax_19 = SFP_Lerp(
00027657                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027657                                          *(uint32_t*)rbx, 
00027657                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027657                                          (*(uint32_t*)((char*)rax_6 + rbx)), 
00027657                                          *(uint32_t*)((char*)r13_5 + 0x1c0), 
00027657                                          (char*)yi_1 + 8);
0002765c                                      yi_1 += 4;
00027660                                      rdi += 4;
00027664                                      (uint8_t)r15 &= rax_19;
00027667                                      rbx += 4;
0002766b                                      i_8 = i_17;
0002766b                                      i_17 -= 1;
0002766f                                  } while (i_8 != 1);
0002767b                                  uint32_t x2 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027687                                  uint32_t x1 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027695                                  uint128_t zmm1_1 = (uint128_t)var_70[4];
000276a6                                  uint32_t xi = *(uint32_t*)((char*)r13_5 + 0x1c0);
000276ad                                  uint128_t zmm3_1 = _mm_cvtepi32_ps((uint128_t)
000276ad                                      *(uint16_t*)((char*)var_60 + 0x10));
000276b7                                  SFP_Lerp(x1, _mm_cvtepi32_ps(zmm1_1), x2, 
000276b7                                      (uint32_t)zmm3_1, xi, &yi);
000276d0                                  *(uint16_t*)((char*)r14_2 + (var_88_1 << 2) + 0x10) =
000276d0                                      (int16_t)(int64_t)(long double)yi;
000276da                                  uint32_t x2_1 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000276e2                                  uint32_t x1_1 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
000276ec                                  uint32_t rax_23 =
000276ec                                      (uint32_t)*(uint16_t*)((char*)var_70 + 0x12);
000276f0                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
000276f0                                      *(uint16_t*)((char*)var_60 + 0x12));
00027712                                  SFP_Lerp(x1_1, _mm_cvtepi32_ps((uint128_t)rax_23), x2_1, 
00027712                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
00027712                                      &yi);
00027721                                  *(uint16_t*)((char*)r14_2 + (var_88_1 << 2) + 0x12) =
00027721                                      (int16_t)(int64_t)(long double)yi;
0002772b                                  uint32_t x2_2 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027733                                  uint32_t x1_2 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
0002773d                                  uint32_t rax_26 = (uint32_t)var_70[5];
00027741                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
00027741                                      *(uint16_t*)((char*)var_60 + 0x14));
00027763                                  SFP_Lerp(x1_2, _mm_cvtepi32_ps((uint128_t)rax_26), x2_2, 
00027763                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
00027763                                      &yi);
00027772                                  *(uint16_t*)((char*)r14_2 + (var_88_1 << 2) + 0x14) =
00027772                                      (int16_t)(int64_t)(long double)yi;
0002777c                                  uint32_t x2_3 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027784                                  uint32_t x1_3 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
0002778e                                  uint32_t rax_29 =
0002778e                                      (uint32_t)*(uint16_t*)((char*)var_70 + 0x16);
00027792                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
00027792                                      *(uint16_t*)((char*)var_60 + 0x16));
000277b4                                  SFP_Lerp(x1_3, _mm_cvtepi32_ps((uint128_t)rax_29), x2_3, 
000277b4                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
000277b4                                      &yi);
000277be                                  void* rdi_2 = rax_9;
000277d0                                  *(uint16_t*)((char*)r14_2 + (var_88_1 << 2) + 0x16) =
000277d0                                      (int16_t)(int64_t)(long double)yi;
000277d6                                  *(uint32_t*)((char*)r14_2 + (var_88_1 << 2) + 0x20) = 8;
000277df                                  pSS_Struct_1 = pSS_Struct;
000277ec                                  *(uint8_t*)((char*)r14_2 + (rax_8 << 2) + 0x18) = 2;
000277f2                                  void* yi_2 = (char*)r14_2 + (rax_8 << 2);
000277f6                                  float* r14_4 = var_70;
000277fb                                  int64_t i_11 = 2;
00027881                                  int64_t i_9;
00027881                                  
00027881                                  do
00027881                                  {
00027850                                      (uint8_t)r15 &= SFP_Lerp(
00027850                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027850                                          (*(uint32_t*)((char*)rax_11 + rdi_2)), 
00027850                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027850                                          (*(uint32_t*)((char*)rdi_2 - 8)), 
00027850                                          *(uint32_t*)((char*)r13_5 + 0x1c0), yi_2);
00027867                                      uint8_t rax_37 = SFP_Lerp(
00027867                                          *(uint32_t*)((char*)rbp_2 + 0x1c0), 
00027867                                          *(uint32_t*)r14_4, 
00027867                                          *(uint32_t*)((char*)r12_2 + 0x1c0), 
00027867                                          (*(uint32_t*)rdi_2), 
00027867                                          *(uint32_t*)((char*)r13_5 + 0x1c0), 
00027867                                          (char*)yi_2 + 8);
0002786c                                      yi_2 += 4;
00027870                                      rdi_2 += 4;
00027874                                      r14_4 = &r14_4[1];
00027878                                      (uint8_t)r15 &= rax_37;
0002787b                                      i_9 = i_11;
0002787b                                      i_11 -= 1;
00027881                                  } while (i_9 != 1);
0002788d                                  rdi = var_60;
00027892                                  *(uint32_t*)((char*)r14_2 + (rax_8 << 2) + 0x1c) |= 0x10;
000278a5                                  uint32_t rax_40 =
000278a5                                      (uint32_t)*(uint16_t*)((char*)var_70 + 0x12);
000278a9                                  uint32_t x2_4 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000278b1                                  uint32_t x1_4 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
000278b7                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
000278b7                                      *(uint16_t*)((char*)rdi + 0x10));
000278d9                                  SFP_Lerp(x1_4, _mm_cvtepi32_ps((uint128_t)rax_40), x2_4, 
000278d9                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
000278d9                                      &yi);
000278ed                                  *(uint16_t*)((char*)r14_2 + (rax_8 << 2) + 0x10) =
000278ed                                      (int16_t)(int64_t)(long double)yi;
000278f7                                  uint32_t x2_5 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000278ff                                  uint32_t x1_5 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
00027909                                  uint32_t rax_44 = (uint32_t)var_70[4];
0002790d                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
0002790d                                      *(uint16_t*)((char*)rdi + 0x12));
0002792f                                  SFP_Lerp(x1_5, _mm_cvtepi32_ps((uint128_t)rax_44), x2_5, 
0002792f                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
0002792f                                      &yi);
00027943                                  *(uint16_t*)((char*)r14_2 + (rax_8 << 2) + 0x12) =
00027943                                      (int16_t)(int64_t)(long double)yi;
0002794d                                  uint32_t x2_6 = *(uint32_t*)((char*)r12_2 + 0x1c0);
00027955                                  uint32_t x1_6 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
0002795f                                  uint32_t rax_48 =
0002795f                                      (uint32_t)*(uint16_t*)((char*)var_70 + 0x16);
00027963                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
00027963                                      *(uint16_t*)((char*)rdi + 0x14));
00027985                                  SFP_Lerp(x1_6, _mm_cvtepi32_ps((uint128_t)rax_48), x2_6, 
00027985                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
00027985                                      &yi);
00027999                                  *(uint16_t*)((char*)r14_2 + (rax_8 << 2) + 0x14) =
00027999                                      (int16_t)(int64_t)(long double)yi;
000279a3                                  uint32_t x2_7 = *(uint32_t*)((char*)r12_2 + 0x1c0);
000279ab                                  uint32_t x1_7 = *(uint32_t*)((char*)rbp_2 + 0x1c0);
000279b5                                  uint32_t rax_52 = (uint32_t)var_70[5];
000279b9                                  zmm3_1 = _mm_cvtepi32_ps((uint128_t)
000279b9                                      *(uint16_t*)((char*)rdi + 0x16));
000279db                                  SFP_Lerp(x1_7, _mm_cvtepi32_ps((uint128_t)rax_52), x2_7, 
000279db                                      (uint32_t)zmm3_1, *(uint32_t*)((char*)r13_5 + 0x1c0), 
000279db                                      &yi);
000279ef                                  void* rdx_6 = (char*)r14_2 + (rax_8 << 2);
000279f3                                  *(uint16_t*)((char*)r14_2 + (rax_8 << 2) + 0x16) =
000279f3                                      (int16_t)(int64_t)(long double)yi;
000279f9                                  *(uint32_t*)((char*)r14_2 + (rax_8 << 2) + 0x20) = 8;
000279f9                                  
00027a0a                                  if (!
00027a0a                                      (*(uint32_t*)rdx_6 <= *(uint32_t*)((char*)rdx_6 + 8)))
00027a0a                                  {
00027a0c                                      i_14 = *(uint64_t*)rdx_6;
00027a13                                      *(uint64_t*)rdx_6 = *(uint64_t*)((char*)rdx_6 + 8);
00027a16                                      *(uint64_t*)((char*)rdx_6 + 8) = i_14;
00027a0a                                  }
00027a0a                                  
00027a24                                  if (var_70[7] & 0x40
00027a24                                      || *(uint8_t*)((char*)rdi + 0x1c) & 0x40)
00027a24                                  {
00027a26                                      void* r14_6 = (char*)r14_2 + 0x1c;
00027a2a                                      i_14 = 3;
00027a3b                                      void* i_10;
00027a3b                                      
00027a3b                                      do
00027a3b                                      {
00027a2f                                          *(uint32_t*)r14_6 |= 0x40;
00027a33                                          r14_6 += 0x24;
00027a37                                          i_10 = i_14;
00027a37                                          i_14 -= 1;
00027a3b                                      } while (i_10 != 1);
00027a24                                  }
00027a24                                  
00027a44                                  r8_1 = var_88_1;
00027a49                                  r9_2 = &var_70[2];
00027a4d                                  rcx_8 = arg_20 + 1;
00027a4f                                  arg_20 = rcx_8;
00027a5d                              } while (rcx_8 < numSensors);
00027556                          }
0002752d                      }
00027505                  }
000274fb              }
000273fe          }
000273fe          else
000273fe          {
00027403              if (!touchCount)
00027436                  pSS_Struct_1->touchTrans = NONE_TO_NONE;
00027403              else if (touchCount == 1)
0002742a                  pSS_Struct_1->touchTrans = ONE_TO_NONE;
00027408              else if (touchCount == 2)
0002741e                  pSS_Struct_1->touchTrans = TWO_TO_NONE;
0002740d              else
00027415                  pSS_Struct_1->touchTrans = INVALID_TRANS;
00027415              
0002744d              SetupOtherSensorFrames(pSS_Struct_1, 1, 0, pSS_Struct_1->touchTrans);
000273fe          }
000273fe          
00028534          (uint8_t)i_14 = (uint8_t)r15;
000273d9      }
000273d9      else
000273d9      {
000273ea          SetupOtherSensorFrames(pSS_Struct_1, 0, 0x20, INVALID_TRANS);
000273ef          (uint8_t)i_14 = 1;
000273d9      }
000273d9      
0002854a      return (uint8_t)i_14;
000272ec  }

0002854b                                   cc cc cc cc cc cc cc cc cc                                                 .........

00028554    void SetupOtherSensorFrames(struct sub_sampler_working_t* pSS_Struct, uint8_t postulations, uint32_t specialCase, enum touch_trans_t transition)

00028554  {
00028563      char i = 1;
0002856c      int64_t rsi;
0002856c      (uint8_t)rsi = postulations;
0002856c      
00028579      if (pSS_Struct->numSensors <= 1)
00028579          return;
00028579      
000285d7      do
000285d7      {
0002858f          uint32_t r8_1 = (uint32_t)i + (uint32_t)pSS_Struct->oldest;
0002859c          i += 1;
000285bf          void* rcx_2 = (uint64_t)pSS_Struct->thisSensor * 0x70 +
000285bf              &pSS_Struct->sample[(int64_t)r8_1 % 5];
000285c2          *(uint32_t*)((char*)rcx_2 + 0x1c) |= specialCase;
000285c5          *(uint8_t*)((char*)rcx_2 + 0x6c) = (uint8_t)rsi;
000285c9          *(uint8_t*)((char*)rcx_2 + 0x18) = 0;
000285cd          *(uint32_t*)((char*)rcx_2 + 0x20) = transition;
000285d7      } while (i < pSS_Struct->numSensors);
00028554  }

000285e9                             cc cc cc cc cc cc cc                                                           .......

000285f0    void FindBestMatches(uint8_t sensors, struct edge_set_t const* oldSet, struct edge_set_t const* newSet, uint32_t* postulationRanking)

000285f0  {
000285fb      float zmm6[0x4];
000285fb      float var_18[0x4] = zmm6;
00028600      uint32_t sensors_1 = (uint32_t)sensors;
00028607      float zmm7[0x4];
00028607      float var_28[0x4] = zmm7;
0002860c      float zmm8[0x4];
0002860c      float var_38[0x4] = zmm8;
00028615      float zmm0[0x4];
00028615      uint64_t zmm1[0x2];
00028615      uint128_t zmm2;
00028615      float zmm3;
00028615      uint64_t zmm4[0x2];
00028615      float zmm5[0x4];
00028615      
00028615      if (sensors_1 == 2)
00028615      {
0002874f          if (oldSet->touchCount == 1 && newSet->touchCount == 2)
0002874f          {
00028755              zmm4 = 0x7fffffffffffffff;
0002875d              zmm6[0] = oldSet->edgePair[0].edge[1];
0002875d              zmm6[1] = oldSet->edgePair[0].edge[1];
0002875d              zmm6[2] = oldSet->edgePair[0].edge[1];
0002875d              zmm6[3] = oldSet->touchIntegral[0];
0002875d              *(uint16_t*)((char*)zmm6[3])[2] = oldSet->touchIntegral[1];
00028762              zmm5[0] = oldSet->edgePair[0].edge[0];
00028762              zmm5[1] = oldSet->edgePair[0].edge[0];
00028762              zmm5[2] = oldSet->edgePair[0].edge[0];
00028762              zmm5[3] = oldSet->edgePair[0].edge[0];
00028768              postulationRanking[2] = 0;
0002876f              zmm6[0] = zmm6[0] - zmm5[0];
00028773              zmm0 = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
00028776              zmm1 = _mm_cvtps_pd(*(uint64_t*)&zmm0[0]);
00028779              zmm0[0] = newSet->edgePair[1].edge[1];
00028779              zmm0[1] = newSet->touchIntegral[0];
00028779              *(uint16_t*)((char*)zmm0[1])[2] = newSet->touchIntegral[1];
00028779              zmm0[2] = newSet->touchWidth[0];
00028779              *(uint16_t*)((char*)zmm0[2])[2] = newSet->touchWidth[1];
00028779              zmm0[3] = newSet->touchCount;
00028779              *(uint8_t*)((char*)zmm0[3])[1] = newSet->best1TchIdx;
00028779              *(uint16_t*)((char*)zmm0[3])[2] = *(int64_t*)((char*)newSet + 0x1a);
0002877f              zmm0[0] = zmm0[0] - newSet->edgePair[1].edge[0];
00028789              zmm3 = (float)_mm_and_pd(zmm1, zmm4)[0];
0002878d              zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
00028790              zmm1 = _mm_cvtps_pd(*(uint64_t*)&zmm0[0]);
00028793              zmm0[0] = newSet->edgePair[0].edge[1];
00028793              zmm0[1] = newSet->edgePair[0].edge[1];
00028793              zmm0[2] = newSet->edgePair[0].edge[1];
00028793              zmm0[3] = newSet->touchIntegral[0];
00028793              *(uint16_t*)((char*)zmm0[3])[2] = newSet->touchIntegral[1];
00028799              zmm0[0] = zmm0[0] - newSet->edgePair[0].edge[0];
000287a2              (uint32_t)zmm2 = (float)_mm_and_pd(zmm1, zmm4)[0];
000287a6              zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
000287b0              zmm0[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm0[0]), zmm4)[0];
000287b4              (uint32_t)zmm2 = (uint32_t)zmm2 + zmm0[0];
000287b4              
000287bb              if (zmm3 > (uint32_t)zmm2)
000287bb              {
0002870c                  *(uint32_t*)postulationRanking = 1;
0002870f                  postulationRanking[1] = 2;
000287bb              }
000287bb              else
000287bb              {
000287c1                  zmm0 = zmm5;
000287c4                  zmm5[0] = zmm5[0] - newSet->edgePair[1].edge[0];
000287ca                  zmm0[0] = zmm0[0] - newSet->edgePair[0].edge[0];
000287cf                  zmm5 = _mm_unpacklo_ps(zmm5, *(uint64_t*)&zmm5[0]);
000287d5                  zmm1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0]);
000287d8                  zmm0 = zmm6;
000287db                  zmm6[0] = zmm6[0] - newSet->edgePair[1].edge[1];
000287e1                  zmm1 = _mm_and_pd(zmm1, zmm4);
000287e5                  zmm6 = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
000287e8                  zmm0[0] = zmm0[0] - newSet->edgePair[0].edge[1];
000287ee                  (uint32_t)zmm2 = (float)zmm1[0];
000287f2                  zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
000287f8                  zmm1 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm0[0]), zmm4);
000287fc                  zmm0[0] = (float)zmm1[0];
00028800                  (uint32_t)zmm2 = (uint32_t)zmm2 + zmm0[0];
0002880b                  zmm1[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm5[0]), zmm4)[0];
0002880f                  zmm0 = _mm_cvtps_pd(*(uint64_t*)&zmm6[0]);
00028812              label_28812:
00028812                  zmm0 = _mm_and_pd(zmm0, zmm4);
00028816                  zmm0[0] = (float)*(uint64_t*)&zmm0[0];
0002881a                  zmm1[0] = zmm1[0] + zmm0[0];
0002881a                  
00028821                  if (zmm1[0] >= (uint32_t)zmm2)
00028821                  {
0002870c                      *(uint32_t*)postulationRanking = 1;
0002870f                      postulationRanking[1] = 2;
00028821                  }
00028821                  else
00028821                  {
00028827                      postulationRanking[1] = 1;
0002882b                      *(uint32_t*)postulationRanking = 2;
00028821                  }
000287bb              }
0002874f          }
0002874f          else if (oldSet->touchCount != 2)
00028836          {
00028924          label_28924:
00028924              
00028932              for (uint32_t i = 0; i < 3; )
00028932              {
00028926                  *(uint32_t*)postulationRanking = i;
00028929                  i += 1;
0002892b                  postulationRanking = &postulationRanking[1];
00028932              }
00028836          }
00028836          else if (newSet->touchCount != 1)
00028840          {
00028913              if (oldSet->touchCount != 2 || newSet->touchCount != 2)
0002890d                  goto label_28924;
0002890d              
00028917              postulationRanking[1] = 1;
0002891b              postulationRanking[2] = 2;
0002891f              *(uint32_t*)postulationRanking = 0;
00028840          }
00028840          else
00028840          {
00028846              zmm4 = 0x7fffffffffffffff;
0002884e              zmm0[0] = newSet->edgePair[0].edge[1];
0002884e              zmm0[1] = newSet->edgePair[0].edge[1];
0002884e              zmm0[2] = newSet->edgePair[0].edge[1];
0002884e              zmm0[3] = newSet->touchIntegral[0];
0002884e              *(uint16_t*)((char*)zmm0[3])[2] = newSet->touchIntegral[1];
00028854              zmm8[0] = oldSet->edgePair[1].edge[1];
00028854              zmm8[1] = oldSet->touchIntegral[0];
00028854              *(uint16_t*)((char*)zmm8[1])[2] = oldSet->touchIntegral[1];
00028854              zmm8[2] = oldSet->touchWidth[0];
00028854              *(uint16_t*)((char*)zmm8[2])[2] = oldSet->touchWidth[1];
00028854              zmm8[3] = oldSet->touchCount;
00028854              *(uint8_t*)((char*)zmm8[3])[1] = oldSet->best1TchIdx;
00028854              *(uint16_t*)((char*)zmm8[3])[2] = *(int64_t*)((char*)oldSet + 0x1a);
0002885c              postulationRanking[2] = 0;
00028860              zmm0[0] = zmm0[0] - newSet->edgePair[0].edge[0];
00028865              zmm7[0] = oldSet->edgePair[1].edge[0];
00028865              zmm7[1] = oldSet->edgePair[1].edge[0];
0002886a              zmm6[0] = oldSet->edgePair[0].edge[1];
0002886a              zmm6[1] = oldSet->edgePair[0].edge[1];
0002886a              zmm6[2] = oldSet->edgePair[0].edge[1];
0002886a              zmm6[3] = oldSet->touchIntegral[0];
0002886a              *(uint16_t*)((char*)zmm6[3])[2] = oldSet->touchIntegral[1];
0002886f              zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
00028872              zmm5[0] = oldSet->edgePair[0].edge[0];
00028872              zmm5[1] = oldSet->edgePair[0].edge[0];
00028872              zmm5[2] = oldSet->edgePair[0].edge[0];
00028872              zmm5[3] = oldSet->edgePair[0].edge[0];
00028876              zmm1 = _mm_cvtps_pd(*(uint64_t*)&zmm0[0]);
0002887d              zmm8[0] = zmm8[0] - zmm7[0];
00028885              zmm3 = (float)_mm_and_pd(zmm1, zmm4)[0];
0002888c              zmm1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm8, *(uint64_t*)&zmm8[0])[0]);
00028892              zmm6[0] = zmm6[0] - zmm5[0];
0002889a              (uint32_t)zmm2 = (float)_mm_and_pd(zmm1, zmm4)[0];
0002889e              zmm0 = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
000288a4              zmm1 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm0[0]), zmm4);
000288a8              zmm0[0] = (float)zmm1[0];
000288ac              (uint32_t)zmm2 = (uint32_t)zmm2 + zmm0[0];
000288ac              
000288b3              if (!(zmm3 > (uint32_t)zmm2))
000288b3              {
000288b9                  zmm5[0] = zmm5[0] - newSet->edgePair[0].edge[0];
000288be                  zmm6[0] = zmm6[0] - newSet->edgePair[0].edge[1];
000288c4                  zmm7[0] = zmm7[0] - newSet->edgePair[0].edge[0];
000288c9                  zmm5 = _mm_unpacklo_ps(zmm5, *(uint64_t*)&zmm5[0]);
000288cc                  zmm6 = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
000288cf                  zmm7 = _mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0]);
000288d2                  zmm8[0] = zmm8[0] - newSet->edgePair[0].edge[1];
000288db                  zmm0 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm5[0]), zmm4);
000288df                  zmm8 = _mm_unpacklo_ps(zmm8, *(uint64_t*)&zmm8[0]);
000288e3                  (uint32_t)zmm2 = (float)*(uint64_t*)&zmm0[0];
000288ea                  zmm0 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm6[0]), zmm4);
000288ee                  zmm0[0] = (float)*(uint64_t*)&zmm0[0];
000288f2                  (uint32_t)zmm2 = (uint32_t)zmm2 + zmm0[0];
000288fd                  zmm1[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm7[0]), zmm4)[0];
00028901                  zmm0 = _mm_cvtps_pd(*(uint64_t*)&zmm8[0]);
00028905                  goto label_28812;
000288b3              }
000288b3              
0002870c              *(uint32_t*)postulationRanking = 1;
0002870f              postulationRanking[1] = 2;
00028840          }
00028615      }
00028615      else if (sensors_1 == 3)
00028738          onWarning__("FindBestMatches() for 3 sensor system missing!", 
00028738              "c:\development_work\csf_release_hp\driver\foureyes\subsample.c", 0x360);
0002861e      else if (sensors_1 == 4)
00028627      {
00028649          uint32_t* postulationRanking_1 = postulationRanking;
00028649          
0002865d          for (uint32_t i_1 = 0; i_1 < 3; )
0002865d          {
0002864f              *(uint32_t*)postulationRanking_1 = i_1;
00028652              i_1 += 1;
00028655              postulationRanking_1 = &postulationRanking_1[1];
0002865d          }
0002865d          
00028668          if (oldSet->touchCount == 1 && newSet->touchCount == 2)
00028668          {
0002866a              zmm5[0] = oldSet->edgePair[0].edge[1];
0002866a              zmm5[1] = oldSet->edgePair[0].edge[1];
0002866a              zmm5[2] = oldSet->edgePair[0].edge[1];
0002866a              zmm5[3] = oldSet->touchIntegral[0];
0002866a              *(uint16_t*)((char*)zmm5[3])[2] = oldSet->touchIntegral[1];
0002866f              zmm1[0] = newSet->edgePair[0].edge[1];
0002866f              *(uint32_t*)((char*)zmm1[0])[4] = newSet->edgePair[0].edge[1];
0002866f              zmm1[1] = newSet->edgePair[0].edge[1];
0002866f              *(uint16_t*)((char*)zmm1[1])[4] = newSet->touchIntegral[0];
0002866f              *(uint16_t*)((char*)zmm1[1])[6] = newSet->touchIntegral[1];
00028675              zmm4[0] = newSet->edgePair[1].edge[1];
00028675              *(uint16_t*)((char*)zmm4[0])[4] = newSet->touchIntegral[0];
00028675              *(uint16_t*)((char*)zmm4[0])[6] = newSet->touchIntegral[1];
00028675              zmm4[1] = newSet->touchWidth[0];
00028675              *(uint16_t*)((char*)zmm4[1])[2] = newSet->touchWidth[1];
00028675              *(uint8_t*)((char*)zmm4[1])[4] = newSet->touchCount;
00028675              *(uint8_t*)((char*)zmm4[1])[5] = newSet->best1TchIdx;
00028675              *(uint16_t*)((char*)zmm4[1])[6] = *(int64_t*)((char*)newSet + 0x1a);
0002867b              zmm5[0] = zmm5[0] + oldSet->edgePair[0].edge[0];
0002867f              zmm1[0] = zmm1[0] + newSet->edgePair[0].edge[0];
00028684              zmm4[0] = zmm4[0] + newSet->edgePair[1].edge[0];
0002868d              zmm5[0] = zmm5[0] - zmm1[0];
00028691              zmm5[0] = zmm5[0] - zmm4[0];
00028695              zmm0 = _mm_unpacklo_ps(zmm5, *(uint64_t*)&zmm5[0]);
00028698              zmm5 = _mm_unpacklo_ps(zmm5, *(uint64_t*)&zmm5[0]);
0002869b              zmm1 = _mm_cvtps_pd(*(uint64_t*)&zmm0[0]);
0002869e              zmm0 = _mm_cvtps_pd(*(uint64_t*)&zmm5[0]);
000286eb          label_286eb:
000286eb              zmm2 = 0x7fffffffffffffff;
000286f3              postulationRanking[2] = 0;
000286f7              zmm1 = _mm_and_pd(zmm1, zmm2);
000286fb              zmm0 = _mm_and_pd(zmm0, zmm2);
000286ff              zmm3 = (float)zmm1[0];
00028703              zmm0[0] = (float)*(uint64_t*)&zmm0[0];
00028703              
0002870a              if (zmm0[0] <= zmm3)
0002870a              {
00028718                  *(uint32_t*)postulationRanking = 2;
0002871b                  postulationRanking[1] = 1;
0002870a              }
0002870a              else
0002870a              {
0002870c                  *(uint32_t*)postulationRanking = 1;
0002870f                  postulationRanking[1] = 2;
0002870a              }
00028668          }
00028668          else if (oldSet->touchCount == 2 && newSet->touchCount == 1)
000286b0          {
000286b6              zmm4[0] = newSet->edgePair[0].edge[1];
000286b6              *(uint32_t*)((char*)zmm4[0])[4] = newSet->edgePair[0].edge[1];
000286b6              zmm4[1] = newSet->edgePair[0].edge[1];
000286b6              *(uint16_t*)((char*)zmm4[1])[4] = newSet->touchIntegral[0];
000286b6              *(uint16_t*)((char*)zmm4[1])[6] = newSet->touchIntegral[1];
000286bc              zmm1[0] = oldSet->edgePair[0].edge[1];
000286bc              *(uint32_t*)((char*)zmm1[0])[4] = oldSet->edgePair[0].edge[1];
000286bc              zmm1[1] = oldSet->edgePair[0].edge[1];
000286bc              *(uint16_t*)((char*)zmm1[1])[4] = oldSet->touchIntegral[0];
000286bc              *(uint16_t*)((char*)zmm1[1])[6] = oldSet->touchIntegral[1];
000286c1              zmm5[0] = oldSet->edgePair[1].edge[1];
000286c1              zmm5[1] = oldSet->touchIntegral[0];
000286c1              *(uint16_t*)((char*)zmm5[1])[2] = oldSet->touchIntegral[1];
000286c1              zmm5[2] = oldSet->touchWidth[0];
000286c1              *(uint16_t*)((char*)zmm5[2])[2] = oldSet->touchWidth[1];
000286c1              zmm5[3] = oldSet->touchCount;
000286c1              *(uint8_t*)((char*)zmm5[3])[1] = oldSet->best1TchIdx;
000286c1              *(uint16_t*)((char*)zmm5[3])[2] = *(int64_t*)((char*)oldSet + 0x1a);
000286c6              zmm4[0] = zmm4[0] + newSet->edgePair[0].edge[0];
000286cb              zmm1[0] = zmm1[0] + oldSet->edgePair[0].edge[0];
000286cf              zmm5[0] = zmm5[0] + oldSet->edgePair[1].edge[0];
000286d4              zmm0 = zmm4;
000286d7              zmm0[0] = zmm0[0] - zmm1[0];
000286db              zmm4[0] = zmm4[0] - zmm5[0];
000286df              zmm0 = _mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0]);
000286e2              zmm4 = _mm_unpacklo_ps(zmm4, zmm4[0]);
000286e5              zmm1 = _mm_cvtps_pd(*(uint64_t*)&zmm0[0]);
000286e8              zmm0 = _mm_cvtps_pd(zmm4[0]);
000286e8              goto label_286eb;
000286b0          }
00028627      }
00028627      else
0002863d          onError__("Unsupported number of sensors.", 
0002863d              "c:\development_work\csf_release_hp\driver\foureyes\subsample.c", 0x3a9);
000285f0  }

0002894a                                cc cc cc cc cc cc                                                            ......

00028950    uint8_t FindMatchingEdgePair(struct edge_pair_t* twoPairs, struct edge_pair_t singlePair)

00028950  {
00028950      uint64_t zmm1[0x2];
00028950      zmm1[0] = twoPairs->edge;
00028950      zmm1[1] = twoPairs;
00028955      uint128_t zmm2 = 0x7fffffffffffffff;
00028962      int64_t arg_10;
00028962      (uint32_t)arg_10 = singlePair.edge[0];
00028962      *(uint32_t*)((char*)arg_10)[4] = singlePair.edge[1];
00028967      zmm1[0] = zmm1[0] + twoPairs->edge[0];
0002896b      float zmm5[0x4] = *(uint32_t*)((char*)arg_10)[4];
00028971      float zmm4 = *(int64_t*)((char*)twoPairs + 0xc) + *(int64_t*)((char*)twoPairs + 8);
00028976      zmm5[0] = zmm5[0] + (uint32_t)arg_10;
0002897c      double zmm0[0x2] = zmm5;
0002897f      zmm5[0] = zmm5[0] - zmm4;
00028983      zmm0[0] = zmm0[0] - zmm1[0];
00028987      float temp0[0x4] = _mm_unpacklo_ps(zmm5, *(uint64_t*)&zmm5[0]);
0002898d      zmm1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0]);
00028993      zmm0 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0[0]), zmm2);
00028997      uint64_t temp0_5[0x2] = _mm_and_pd(zmm1, zmm2);
0002899b      zmm0[0] = (float)zmm0[0];
000289a6      int64_t rax;
000289a6      
000289a6      if (zmm0[0] <= (float)temp0_5[0])
000289a6      {
000289ab          (uint8_t)rax = 1;
000289ad          return 1;
000289a6      }
000289a6      
000289a8      (uint8_t)rax = 0;
000289aa      return 0;
00028950  }

000289ae                                            cc cc cc cc cc cc                                                    ......

000289b4    void __convention("sysv") ExecuteOrientationFilters(struct _ctl_context_t* pContext @ rcx)

000289b4  {
000289de      float entry_zmm6[0x4];
000289de      float var_38[0x4] = entry_zmm6;
000289e2      float entry_zmm7[0x4];
000289e2      float var_48[0x4] = entry_zmm7;
000289e6      uint128_t entry_zmm8;
000289e6      uint128_t var_58 = entry_zmm8;
000289eb      pContext->filterData.offBezelFilter.orientation = 0;
000289f2      pContext->filterData.offBezelFilter.confidence = 0f;
000289fc      char rsi = 1;
000289fc      
00028a15      if (pContext->triangulated[0].kPt[2].pt.y <= pContext->settings.panelSize.y)
00028a15      {
00028a29          pContext->filterData.offBezelFilter.orientation = 0;
00028a30          pContext->filterData.offBezelFilter.confidence = 0f;
00028a15      }
00028a15      else
00028a15      {
00028a17          pContext->filterData.offBezelFilter.orientation = 1;
00028a1d          pContext->filterData.offBezelFilter.confidence = -1f;
00028a15      }
00028a15      
00028a37      struct twoSensorTriangulationMngr_t* twoSensorTriangulation =
00028a37          &pContext->twoSensorTriangulation;
00028a4f      ProcessSimTwoTouchFilter(pContext, &pContext->filterData.simTwoTouchFilter, 
00028a4f          &pContext->ssOutput, twoSensorTriangulation);
00028a54      pContext->filterData.symmetryFilter.orientation = O_UNKNOWN;
00028a5b      pContext->filterData.symmetryFilter.confidence = 0f;
00028a62      float zmm2[0x4];
00028a62      zmm2[0] = pContext->filterData.generalTouchData.tonyTangents[2].symmetry;
00028a62      zmm2[1] = pContext->filterData.generalTouchData.tonyTangents[2].symmetry;
00028a62      zmm2[2] = pContext->filterData.generalTouchData.tonyTangents[2].symmetry;
00028a62      zmm2[3] = pContext->filterData.generalTouchData.tonyTangents[2].symmetry;
00028a6a      float zmm3[0x4] = 0x3f8ccccd;
00028a72      zmm2[0] = zmm2[0] * pContext->filterData.generalTouchData.tonyTangents[0].symmetry;
00028a84      pContext->filterData.symmetryFilter.verticalSymmetry = zmm2[0];
00028a8c      float zmm1_1[0x4];
00028a8c      zmm1_1[0] = pContext->filterData.generalTouchData.tonyTangents[3].symmetry;
00028a8c      zmm1_1[1] = pContext->filterData.generalTouchData.tonyTangents[3].symmetry;
00028a8c      zmm1_1[2] = pContext->filterData.generalTouchData.tonyTangents[3].symmetry;
00028a8c      zmm1_1[3] = pContext->filterData.generalTouchData.tonyTangents[3].symmetry;
00028a94      zmm1_1[0] =
00028a94          zmm1_1[0] * pContext->filterData.generalTouchData.tonyTangents[1].symmetry;
00028a9c      uint64_t zmm0_1[0x2] = zmm1_1;
00028a9f      pContext->filterData.symmetryFilter.horizontalSymmetry = zmm1_1[0];
00028aa7      zmm0_1[0] = zmm0_1[0] * 1.10000002f;
00028aa7      
00028aae      if (zmm2[0] <= zmm0_1[0])
00028aae      {
00028acf          zmm0_1 = zmm2;
00028ad2          zmm0_1[0] = zmm0_1[0] * 1.10000002f;
00028ad2          
00028ae6          if (!(zmm1_1[0] <= zmm0_1[0]) && !(0.649999976f <= zmm2[0]))
00028ae6          {
00028ae8              pContext->filterData.symmetryFilter.orientation = O_HORIZONTAL;
00028aee              pContext->filterData.symmetryFilter.confidence = -0.699999988f;
00028ae6          }
00028aae      }
00028aae      else if (!(0.649999976f <= zmm1_1[0]))
00028abb      {
00028abd          pContext->filterData.symmetryFilter.orientation = O_VERTICAL;
00028ac7          __builtin_strncpy(&pContext->filterData.symmetryFilter.confidence, "333?", 4);
00028abb      }
00028abb      
00028af4      float zmm10[0x4] = {0};
00028af8      pContext->filterData.largeBtmTouchFilter.orientation = 0;
00028aff      pContext->filterData.largeBtmTouchFilter.confidence = 0f;
00028b06      zmm2[0] = pContext->filterData.generalTouchData.tonyTangents[2].width[0];
00028b06      zmm2[1] = pContext->filterData.generalTouchData.tonyTangents[2].width[0];
00028b06      zmm2[2] = pContext->filterData.generalTouchData.tonyTangents[2].width[0];
00028b06      zmm2[3] = pContext->filterData.generalTouchData.tonyTangents[2].width[0];
00028b0e      zmm1_1[0] = pContext->filterData.generalTouchData.tonyTangents[2].width[1];
00028b0e      zmm1_1[1] = pContext->filterData.generalTouchData.tonyTangents[2].width[1];
00028b0e      zmm1_1[2] = pContext->filterData.generalTouchData.tonyTangents[2].width[1];
00028b0e      zmm1_1[3] = pContext->filterData.generalTouchData.tonyTangents[2].width[1];
00028b16      zmm0_1 = {0};
00028b16      
00028b1d      if (!(zmm2[0] > zmm1_1[0]))
00028b1f          zmm2 = zmm1_1;
00028b1f      
00028b59      int64_t j_1;
00028b59      
00028b59      for (uint8_t i = 0; i < 4; i += 1)
00028b59      {
00028b28          if (i != 2)
00028b28          {
00028b31              void* rdx_1 =
00028b31                  &pContext->filterData.generalTouchData.tonyTangents[(uint64_t)i].width;
00028b39              j_1 = 2;
00028b51              int64_t j;
00028b51              
00028b51              do
00028b51              {
00028b3e                  zmm1_1 = *(uint32_t*)rdx_1;
00028b3e                  
00028b45                  if (!(zmm1_1[0] <= zmm0_1[0]))
00028b47                      zmm0_1 = zmm1_1;
00028b47                  
00028b4a                  rdx_1 += 4;
00028b4e                  j = j_1;
00028b4e                  j_1 -= 1;
00028b51              } while (j != 1);
00028b28          }
00028b59      }
00028b59      
00028b5b      zmm0_1[0] = zmm0_1[0] * 1.29999995f;
00028b5b      
00028b66      if (!(zmm2[0] <= zmm0_1[0]))
00028b66      {
00028b68          pContext->filterData.largeBtmTouchFilter.orientation = 1;
00028b6e          pContext->filterData.largeBtmTouchFilter.confidence = -0.699999988f;
00028b66      }
00028b66      
00028b74      (uint8_t)j_1 = twoSensorTriangulation->prevNumTouchesFromEdges;
00028b7c      pContext->filterData.thirtyOneDegreeFilter.orientation = O_UNKNOWN;
00028b83      pContext->filterData.thirtyOneDegreeFilter.confidence = 0f;
00028b8a      uint128_t zmm9 = 0x7fffffffffffffff;
00028b8a      
00028b9f      if ((uint8_t)j_1 || twoSensorTriangulation->numTouchesFromEdges != 2)
00028b9f      {
00028cec          pContext->filterData.thirtyOneDegreeFilter.orientation = O_UNKNOWN;
00028cf3          pContext->filterData.thirtyOneDegreeFilter.confidence = 0f;
00028b9f      }
00028b9f      else
00028b9f      {
00028ba5          zmm1_1[0] = pContext->triangulated[0].kPt[0].pt.x;
00028ba5          zmm1_1[1] = pContext->triangulated[0].kPt[0].pt.x;
00028ba5          zmm1_1[2] = pContext->triangulated[0].kPt[0].sourceST[0];
00028ba5          *(uint8_t*)((char*)zmm1_1[2])[1] = pContext->triangulated[0].kPt[0].sourceST[1];
00028ba5          *(uint16_t*)((char*)zmm1_1[2])[2] =
00028ba5              *(uint16_t*)((char*)pContext->triangulated[0].kPt[0] + 0xa);
00028ba5          zmm1_1[3] = pContext->triangulated[0].kPt[0].pt.x;
00028bad          zmm0_1[0] = pContext->triangulated[0].kPt[2].pt.y;
00028bad          *(uint8_t*)((char*)zmm0_1[0])[4] = pContext->triangulated[0].kPt[2].sourceST[0];
00028bad          *(uint8_t*)((char*)zmm0_1[0])[5] = pContext->triangulated[0].kPt[2].sourceST[1];
00028bad          *(uint16_t*)((char*)zmm0_1[0])[6] =
00028bad              *(uint16_t*)((char*)pContext->triangulated[0].kPt[2] + 0xa);
00028bad          zmm0_1[1] = pContext->triangulated[0].kPt[2].pt.y;
00028bad          *(uint32_t*)((char*)zmm0_1[1])[4] = pContext->triangulated[0].kPt[2].pt.y;
00028bb5          zmm1_1[0] = zmm1_1[0] - pContext->triangulated[0].kPt[2].pt.x;
00028bbd          zmm0_1[0] = zmm0_1[0] - pContext->triangulated[0].kPt[0].pt.y;
00028bc5          zmm1_1[0] - 0f;
00028bc5          
00028bcb          if (FCMP_UO(zmm1_1[0], 0f) || !(zmm1_1[0] == 0f))
00028bcd              zmm0_1[0] - 0f;
00028bcd          
00028bd3          if ((FCMP_UO(zmm1_1[0], 0f) || !(zmm1_1[0] == 0f))
00028bd3              && (FCMP_UO(zmm0_1[0], 0f) || zmm0_1[0] != 0f))
00028bd3          {
00028bdb              zmm0_1 = _mm_unpacklo_ps(zmm0_1, zmm0_1[0]);
00028bde              zmm1_1 = _mm_unpacklo_ps(zmm1_1, *(uint64_t*)&zmm1_1[0]);
00028be1              zmm0_1 = _mm_cvtps_pd(zmm0_1[0]);
00028be4              zmm1_1 = _mm_cvtps_pd(*(uint64_t*)&zmm1_1[0]);
00028be7              zmm0_1 = atan2(zmm0_1[0], *(uint64_t*)&zmm1_1[0]);
00028bec              zmm2[0] = (float)zmm0_1[0];
00028bd3          }
00028bd3          else
00028bd5              zmm2 = {0};
00028bd5          
00028bf0          entry_zmm7 = 0x43340000;
00028bf8          entry_zmm8 = 0x400921fb54442d18;
00028c01          zmm2[0] = zmm2[0] * 180f;
00028c08          zmm0_1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm2, *(uint64_t*)&zmm2[0])[0]);
00028c0b          zmm0_1[0] = zmm0_1[0] / (uint64_t)entry_zmm8;
00028c10          entry_zmm6[0] = (float)zmm0_1[0];
00028c14          pContext->filterData.thirtyOneDegreeFilter.verticalPairAngle = entry_zmm6[0];
00028c1c          zmm1_1[0] = pContext->triangulated[0].kPt[1].pt.x;
00028c1c          zmm1_1[1] = pContext->triangulated[0].kPt[1].pt.x;
00028c1c          zmm1_1[2] = pContext->triangulated[0].kPt[1].sourceST[0];
00028c1c          *(uint8_t*)((char*)zmm1_1[2])[1] = pContext->triangulated[0].kPt[1].sourceST[1];
00028c1c          *(uint16_t*)((char*)zmm1_1[2])[2] =
00028c1c              *(uint16_t*)((char*)pContext->triangulated[0].kPt[1] + 0xa);
00028c1c          zmm1_1[3] = pContext->triangulated[0].kPt[1].pt.x;
00028c24          zmm0_1[0] = pContext->triangulated[0].kPt[3].pt.y;
00028c24          *(uint8_t*)((char*)zmm0_1[0])[4] = pContext->triangulated[0].kPt[3].sourceST[0];
00028c24          *(uint8_t*)((char*)zmm0_1[0])[5] = pContext->triangulated[0].kPt[3].sourceST[1];
00028c24          *(uint16_t*)((char*)zmm0_1[0])[6] =
00028c24              *(uint16_t*)((char*)pContext->triangulated[0].kPt[3] + 0xa);
00028c24          zmm0_1[1] = pContext->triangulated[0].kPt[3].pt.y;
00028c24          *(uint32_t*)((char*)zmm0_1[1])[4] = pContext->triangulated[0].kPt[3].pt.y;
00028c2c          zmm1_1[0] = zmm1_1[0] - pContext->triangulated[0].kPt[3].pt.x;
00028c34          zmm0_1[0] = zmm0_1[0] - pContext->triangulated[0].kPt[1].pt.y;
00028c3c          zmm1_1[0] - zmm10[0];
00028c3c          
00028c42          if (FCMP_UO(zmm1_1[0], zmm10[0]) || !(zmm1_1[0] == zmm10[0]))
00028c44              zmm0_1[0] - zmm10[0];
00028c44          
00028c4a          if ((FCMP_UO(zmm1_1[0], zmm10[0]) || !(zmm1_1[0] == zmm10[0]))
00028c4a              && (FCMP_UO(zmm0_1[0], zmm10[0]) || zmm0_1[0] != zmm10[0]))
00028c4a          {
00028c52              zmm0_1 = _mm_unpacklo_ps(zmm0_1, zmm0_1[0]);
00028c55              zmm1_1 = _mm_unpacklo_ps(zmm1_1, *(uint64_t*)&zmm1_1[0]);
00028c58              zmm0_1 = _mm_cvtps_pd(zmm0_1[0]);
00028c5b              zmm1_1 = _mm_cvtps_pd(*(uint64_t*)&zmm1_1[0]);
00028c5e              zmm0_1 = atan2(zmm0_1[0], *(uint64_t*)&zmm1_1[0]);
00028c63              zmm2[0] = (float)zmm0_1[0];
00028c4a          }
00028c4a          else
00028c4c              zmm2 = zmm10;
00028c4c          
00028c67          zmm2[0] = zmm2[0] * entry_zmm7[0];
00028c6e          zmm0_1 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm2, *(uint64_t*)&zmm2[0])[0]);
00028c79          zmm0_1[0] = zmm0_1[0] / (uint64_t)entry_zmm8;
00028c7e          entry_zmm6[0] = entry_zmm6[0] - 31f;
00028c82          entry_zmm6 = _mm_unpacklo_ps(entry_zmm6, *(uint64_t*)&entry_zmm6[0]);
00028c85          zmm1_1[0] = (float)zmm0_1[0];
00028c89          pContext->filterData.thirtyOneDegreeFilter.horizontalPairAngle = zmm1_1[0];
00028c91          zmm1_1[0] = zmm1_1[0] - 31f;
00028c9d          zmm1_1 = _mm_unpacklo_ps(zmm1_1, *(uint64_t*)&zmm1_1[0]);
00028ca8          zmm3[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm1_1[0]), zmm9)[0];
00028caf          zmm0_1 = _mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&entry_zmm6[0]), zmm9);
00028cb4          bool cond:5_1 = 5f <= zmm3[0];
00028cb7          zmm1_1[0] = (float)zmm0_1[0];
00028cb7          
00028cc0          if (!cond:5_1 && !(zmm1_1[0] <= zmm3[0]))
00028cc0          {
00028cc2              pContext->filterData.thirtyOneDegreeFilter.orientation = O_HORIZONTAL;
00028cc8              pContext->filterData.thirtyOneDegreeFilter.confidence = -0.699999988f;
00028cc0          }
00028cc0          else if (!(5f <= zmm1_1[0]) && !(zmm3[0] <= zmm1_1[0]))
00028cd8          {
00028cda              pContext->filterData.thirtyOneDegreeFilter.orientation = O_VERTICAL;
00028ce4              __builtin_strncpy(&pContext->filterData.thirtyOneDegreeFilter.confidence, 
00028ce4                  "333?", 4);
00028cd8          }
00028b9f      }
00028b9f      
00028d2b      struct fpoint_t A;
00028d2b      uint8_t diamondIdx;
00028d2b      uint8_t i_1;
00028d2b      
00028d2b      if (twoSensorTriangulation->numTouchesFromEdges != 2
00028d2b          || twoSensorTriangulation->prevNumTouchesFromEdges
00028d2b          || pContext->filterData.unstableFirstFilter.patternMatched != 1
00028d2b          || twoSensorTriangulation->occlusionState == OCCLUSION_ENTRY
00028d2b          || twoSensorTriangulation->occlusionState == OCCLUSION)
00028d2b      {
00028dd0          pContext->filterData.unstableFirstFilter.orientation = 0;
00028dd7          pContext->filterData.unstableFirstFilter.confidence = 0f;
00028dde          pContext->filterData.unstableFirstFilter.patternMatched = 0;
00028d2b      }
00028d2b      else
00028d2b      {
00028d31          int64_t rax_2;
00028d31          (uint32_t)rax_2 = pContext->filterData.unstableFirstFilter.unstableTouchPoint.x;
00028d31          *(uint32_t*)((char*)rax_2)[4] =
00028d31              pContext->filterData.unstableFirstFilter.unstableTouchPoint.y;
00028d38          entry_zmm6 = 0x4b18967f;
00028d40          diamondIdx = 0;
00028d43          pContext->filterData.unstableFirstFilter.patternMatched = 0;
00028d4a          i_1 = 0;
00028d4d          struct kite_t (* B_1)[0x6] = &pContext->triangulated;
00028d54          entry_zmm7 = 0x4b18967f;
00028d57          A.x = (uint32_t)rax_2;
00028d57          A.y = *(uint32_t*)((char*)rax_2)[4];
00028d57          
00028d92          do
00028d92          {
00028d6a              float zmm0_2[0x4] = DistanceSquare(&A, B_1);
00028d6a              
00028d72              if (!(entry_zmm6[0] <= zmm0_2[0]))
00028d72              {
00028d74                  entry_zmm7 = entry_zmm6;
00028d77                  diamondIdx = i_1;
00028d7a                  entry_zmm6 = zmm0_2;
00028d72              }
00028d72              else if (!(entry_zmm7[0] <= zmm0_2[0]))
00028d84                  entry_zmm7 = zmm0_2;
00028d84              
00028d87              i_1 += 1;
00028d8a              B_1 += 0x2c;
00028d92          } while (i_1 < 4);
00028d92          
00028d9c          if (!diamondIdx || diamondIdx == 2)
00028d9c          {
00028dba              pContext->filterData.unstableFirstFilter.orientation = 2;
00028dc4              pContext->filterData.unstableFirstFilter.confidence = 1f;
00028d9c          }
00028d9c          else if (diamondIdx == 1 || diamondIdx == 3)
00028da6          {
00028da8              pContext->filterData.unstableFirstFilter.orientation = 1;
00028dae              pContext->filterData.unstableFirstFilter.confidence = -1f;
00028da6          }
00028d2b      }
00028d2b      
00028df3      pContext->filterData.twentyfiveMMFilter.orientation = O_UNKNOWN;
00028dfa      pContext->filterData.twentyfiveMMFilter.confidence = 0f;
00028e14      pContext->filterData.twentyfiveMMFilter.horizontalPairDistanceSquare = DistanceSquare(
00028e14          &pContext->triangulated[0].kPt[3].pt, &pContext->triangulated[0].kPt[1]);
00028e1c      uint64_t zmm0_4[0x2] =
00028e1c          DistanceSquare(&pContext->triangulated, &pContext->triangulated[0].kPt[2].pt);
00028e21      zmm3 = 0x441c4000;
00028e29      float zmm1_2[0x4] = 0x441c4000;
00028e2c      zmm3[0] = 625f - zmm0_4[0];
00028e30      pContext->filterData.twentyfiveMMFilter.verticalPairDistanceSquare = zmm0_4[0];
00028e38      zmm1_2[0] =
00028e38          625f - pContext->filterData.twentyfiveMMFilter.horizontalPairDistanceSquare;
00028e43      zmm0_4 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm3, *(uint64_t*)&zmm3[0])[0]);
00028e46      zmm1_2 = _mm_unpacklo_ps(zmm1_2, *(uint64_t*)&zmm1_2[0]);
00028e49      zmm2 = _mm_cvtps_pd(*(uint64_t*)&zmm1_2[0]);
00028e51      zmm1_2[0] = (float)_mm_and_pd(zmm0_4, zmm9)[0];
00028e62      float zmm4 = (float)_mm_and_pd(zmm2, zmm9)[0];
00028e62      
00028e69      if (zmm1_2[0] <= zmm4)
00028e69      {
00028e85          if (!(200f <= zmm1_2[0]))
00028e85          {
00028e87              pContext->filterData.twentyfiveMMFilter.orientation = O_VERTICAL;
00028e91              pContext->filterData.twentyfiveMMFilter.confidence = 0.5f;
00028e85          }
00028e69      }
00028e69      else if (!(200f <= zmm4))
00028e6e      {
00028e70          pContext->filterData.twentyfiveMMFilter.orientation = O_HORIZONTAL;
00028e76          pContext->filterData.twentyfiveMMFilter.confidence = -0.5f;
00028e6e      }
00028e6e      
00028ea2      enum orientation_t rax_3;
00028ea2      float zmm10_1;
00028ea2      rax_3 = UseAwesomeLogicToFigureOutOrientation(&pContext->triangulated);
00028ea7      pContext->filterData.awesomeLogicFilter.orientation = rax_3;
00028ea7      
00028eaf      if (rax_3 == O_HORIZONTAL)
00028eca          pContext->filterData.awesomeLogicFilter.confidence = -0.800000012f;
00028eaf      else if (rax_3 == 2)
00028ebe          pContext->filterData.awesomeLogicFilter.confidence = 0.800000012f;
00028eb3      else
00028eb5          pContext->filterData.awesomeLogicFilter.confidence = 0f;
00028eb5      
00028ed4      int32_t rax_4;
00028ed4      (uint8_t)rax_4 = twoSensorTriangulation->numTouchesFromEdges;
00028edc      pContext->filterData.oneTrueTouchFilter.orientation = O_UNKNOWN;
00028ee3      pContext->filterData.oneTrueTouchFilter.confidence = 0f;
00028eed      float zmm6;
00028eed      
00028eed      if ((uint8_t)rax_4 == 1)
00028eed      {
00028eef          int64_t rax_5;
00028eef          (uint32_t)rax_5 = pContext->triangulated[0].kPt[0].pt.x;
00028eef          *(uint32_t*)((char*)rax_5)[4] = pContext->triangulated[0].kPt[0].pt.y;
00028ef6          pContext->filterData.oneTrueTouchFilter.prevSingleTchPt.x = (uint32_t)rax_5;
00028ef6          pContext->filterData.oneTrueTouchFilter.prevSingleTchPt.y =
00028ef6              *(uint32_t*)((char*)rax_5)[4];
00028eed      }
00028eed      else if ((uint8_t)rax_4 != 2 || twoSensorTriangulation->prevNumTouchesCalculated != 1)
00028f0d      {
00029003          pContext->filterData.oneTrueTouchFilter.confidence = 0f;
0002900a          pContext->filterData.oneTrueTouchFilter.orientation = O_UNKNOWN;
00028f0d      }
00028f0d      else
00028f0d      {
00028f13          int64_t rax_6;
00028f13          (uint32_t)rax_6 = pContext->filterData.oneTrueTouchFilter.prevSingleTchPt.x;
00028f13          *(uint32_t*)((char*)rax_6)[4] =
00028f13              pContext->filterData.oneTrueTouchFilter.prevSingleTchPt.y;
00028f1a          float zmm7 = 9999f;
00028f22          diamondIdx = 0;
00028f25          i_1 = 0;
00028f28          struct kite_t (* B_2)[0x6] = &pContext->triangulated;
00028f2f          A.x = (uint32_t)rax_6;
00028f2f          A.y = *(uint32_t*)((char*)rax_6)[4];
00028f37          zmm6 = 9999f;
00028f37          
00028f6d          do
00028f6d          {
00028f45              float zmm0_5 = DistanceSquare(&A, B_2);
00028f45              
00028f4d              if (!(zmm7 <= zmm0_5))
00028f4d              {
00028f4f                  zmm6 = zmm7;
00028f52                  diamondIdx = i_1;
00028f55                  zmm7 = zmm0_5;
00028f4d              }
00028f4d              else if (!(zmm6 <= zmm0_5))
00028f5f                  zmm6 = zmm0_5;
00028f5f              
00028f62              i_1 += 1;
00028f65              B_2 += 0x2c;
00028f6d          } while (i_1 < 4);
00028f6d          
00028f81          if (twoSensorTriangulation->occlusionState != OCCLUSION_ENTRY
00028f81              && twoSensorTriangulation->occlusionState != OCCLUSION
00028f81              && twoSensorTriangulation->occlusionState != OCCLUSION_EXIT)
00028f81          {
00028fc7          label_28fc7:
00028fc7              
00028fcf              if (!diamondIdx || diamondIdx == 2)
00028fcf              {
00028fed                  pContext->filterData.oneTrueTouchFilter.orientation = O_VERTICAL;
00028ff7                  pContext->filterData.oneTrueTouchFilter.confidence = 1f;
00028fcf              }
00028fcf              else if (diamondIdx == 1 || diamondIdx == 3)
00028fd9              {
00028fdb                  pContext->filterData.oneTrueTouchFilter.orientation = O_HORIZONTAL;
00028fe1                  pContext->filterData.oneTrueTouchFilter.confidence = -1f;
00028fd9              }
00028f81          }
00028f81          else if (!(400f <= zmm6 - zmm7))
00028f92          {
00028f9b              enum orientation_t rax_7;
00028f9b              rax_7 = UseAwesomeLogicToFigureOutOrientation(&pContext->triangulated);
00028fa0              pContext->filterData.oneTrueTouchFilter.orientation = rax_7;
00028fa0              
00028fa8              if (rax_7 != O_HORIZONTAL)
00028fa8              {
00028fb9                  if (rax_7 != O_VERTICAL)
00028fb9                      goto label_28fc7;
00028fb9                  
00028fbb                  pContext->filterData.oneTrueTouchFilter.confidence = 0.800000012f;
00028fa8              }
00028fa8              else
00028faa                  pContext->filterData.oneTrueTouchFilter.confidence = -0.800000012f;
00028f92          }
00028f0d      }
00028f0d      
00029023      pContext->filterData.fastOcclusionFilter.orientation = 0;
0002902a      pContext->filterData.fastOcclusionFilter.confidence = 0f;
0002902a      
00029039      if (pContext->twoSensorTriangulation.prevOcclusionState != 4
00029039          || pContext->twoSensorTriangulation.occlusionState != OCCLUSION_EXIT)
00029039      {
00029067          pContext->filterData.fastOcclusionFilter.orientation = 0;
0002906e          pContext->filterData.fastOcclusionFilter.confidence = 0f;
00029039      }
00029039      else if (pContext->twoSensorTriangulation.orientation != O_HORIZONTAL)
0002903d      {
00029055          pContext->filterData.fastOcclusionFilter.orientation = 1;
0002905b          pContext->filterData.fastOcclusionFilter.confidence = -1f;
0002903d      }
0002903d      else
0002903d      {
0002903f          pContext->filterData.fastOcclusionFilter.orientation = 2;
00029049          pContext->filterData.fastOcclusionFilter.confidence = 1f;
0002903d      }
0002903d      
00029075      pContext->filterData.pivotFilter.confidence = 0f;
0002907c      pContext->filterData.pivotFilter.orientation = 0;
0002908a      struct generalTouchData_t* generalTouchData = &pContext->filterData;
00029091      struct touchDownCircles_t (* B_3)[0x2] = &generalTouchData->touchDownCircle;
00029091      
00029099      if (pContext->twoSensorTriangulation.numTouchesFromEdges >= 2)
00029099      {
000290a7          uint64_t rax_8;
000290a7          (uint8_t)rax_8 = 0;
000290a9          struct fpoint_t* B = B_3;
000290ac          A.x = 0;
000290ac          
000291f0          do
000291f0          {
000290b3              (uint8_t)rax_8 ^= 1;
000290b3              
000290ce              if (*(int64_t*)((char*)B + 0x10) > 0 && !(3f <= *(int64_t*)((char*)B + 0x14))
000290ce                  && !*((char*)B + 0x1c))
000290ce              {
000290d7                  rax_8 = (uint64_t)(uint8_t)rax_8 << 5;
000290d7                  
000290f3                  if (*(uint32_t*)(rax_8 + B_3 + 0x10) > 0
000290f3                      && !(*(uint32_t*)(rax_8 + B_3 + 0x14) <= 9f))
000290f3                  {
000290f9                      zmm6 = 99999f;
00029101                      diamondIdx = 0;
00029103                      struct kite_t (* A_1)[0x6] = &pContext->triangulated;
0002910a                      (uint8_t)generalTouchData = 0;
0002910a                      
00029149                      do
00029149                      {
00029113                          float zmm0_6[0x4] = DistanceSquare(A_1, B);
0002911c                          float zmm1_3;
0002911c                          
0002911c                          if (zmm0_6[0] <= zmm10_1)
0002912f                              zmm1_3 = zmm10_1;
0002911c                          else
0002911c                          {
00029124                              double zmm0_7;
00029124                              zmm0_7 = sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_6, 
00029124                                  *(uint64_t*)&zmm0_6[0])[0])[0]);
00029129                              zmm1_3 = (float)zmm0_7;
0002911c                          }
0002911c                          
00029136                          if (!(zmm6 <= zmm1_3))
00029136                          {
00029138                              diamondIdx = (uint8_t)generalTouchData;
0002913b                              zmm6 = zmm1_3;
00029136                          }
00029136                          
0002913e                          (uint8_t)generalTouchData += 1;
00029141                          A_1 += 0x2c;
00029149                      } while ((uint8_t)generalTouchData < 4);
00029149                      
0002914b                      struct fpoint_t pt;
0002914b                      pt.x = B->x;
0002914b                      pt.y = B->y;
00029152                      generalTouchData = &pContext->filterData;
00029152                      
00029170                      if (IsPointInPolygon(pt, 
00029170                          &generalTouchData->boundaryPts[(uint64_t)diamondIdx], 4) == 1)
00029170                      {
0002917a                          if (diamondIdx == 1 || diamondIdx == 3)
0002917a                          {
0002919b                              pContext->filterData.pivotFilter.confidence = -0.800000012f;
000291a5                              pContext->filterData.pivotFilter.orientation = 1;
000291ab                          label_291ab:
000291ab                              struct fpoint_t tchDownPosition;
000291ab                              tchDownPosition.x = B->x;
000291ab                              tchDownPosition.y = B->y;
000291c7                              int32_t ssOutput;
000291c7                              ssOutput = &pContext->ssOutput;
000291cc                              CalculatePivotLocations(&pContext->filterData.pivotFilter, 
000291cc                                  &pContext->triangulated, diamondIdx, tchDownPosition, 
000291cc                                  ssOutput);
0002917a                          }
0002917a                          else if (!diamondIdx || diamondIdx == 2)
00029183                          {
00029185                              pContext->filterData.pivotFilter.confidence = 0.800000012f;
0002918f                              pContext->filterData.pivotFilter.orientation = 2;
00029199                              goto label_291ab;
00029183                          }
00029170                      }
00029170                      
000291d1                      B_3 = &generalTouchData->touchDownCircle;
000290f3                  }
000290ce              }
000290ce              
000291d9              (uint8_t)rax_8 = A.x;
000291e0              B = &B[4];
000291e4              (uint8_t)rax_8 += 1;
000291e7              A.x = (uint8_t)rax_8;
000291f0          } while ((uint8_t)rax_8 < 2);
000291f0          
000291f6          twoSensorTriangulation = &pContext->twoSensorTriangulation;
00029099      }
00029099      
0002922b      ProcessStraightLineFilter(&pContext->filterData.straightLineFilter, generalTouchData, 
0002922b          &pContext->triangulated, pContext->occludedSensor, 
0002922b          pContext->twoSensorTriangulation.orientation, &pContext->ssOutput);
00029230      struct fpoint_t rax_14;
00029230      rax_14.x = pContext->settings.panelSize.x;
00029230      rax_14.y = pContext->settings.panelSize.y;
00029245      struct fpoint_t panelSize;
00029245      panelSize.x = rax_14.x;
00029245      panelSize.y = rax_14.y;
0002924a      rax_14.x = pContext->occludedSensor;
00029280      enum orientation_t var_a8;
00029280      (uint8_t)var_a8 = rax_14.x;
00029284      ProcessQuadraticTouchTrackingFilter(&pContext->filterData.quadraticTTFilter, 
00029284          &pContext->triangulated, 
00029284          pContext->filterData.predictionFilter.hasSwitchedDuringThisOcclusion, 
00029284          pContext->settings.numSensors, (uint8_t)var_a8, &pContext->ssOutput, 
00029284          &pContext->filterData.generalTouchData.diamondWidths, &pContext->centreAngles, 
00029284          twoSensorTriangulation, panelSize);
0002929d      float* var_98;
0002929d      (uint32_t)var_98 = pContext->twoSensorTriangulation.orientation;
000292a1      enum orientation_t rax_15;
000292a1      (uint8_t)rax_15 = pContext->twoSensorTriangulation.numTouchesFromEdges;
000292ae      struct sub_sample_t* var_a0_1;
000292ae      (uint8_t)var_a0_1 = (uint8_t)rax_15;
000292b5      var_a8 = &pContext->filterData.generalTouchData.diamondWidths;
000292ba      ProcessPredictionFilter(&pContext->filterData.predictionFilter, 
000292ba          &pContext->triangulated, &pContext->ssOutput, 
000292ba          pContext->filterData.quadraticTTFilter.hasSwitchedDuringThisOcclusion, var_a8, 
000292ba          (uint8_t)var_a0_1, (uint32_t)var_98);
000292ba      
000292ce      if (!(pContext->settings.panelSize.x > 650f))
000292d0          rsi = 0;
000292d0      
000292d8      struct twoSensorTriangulationMngr_t* var_88;
000292d8      (uint8_t)var_88 = rsi;
000292e4      float* var_90;
000292e4      (uint8_t)var_90 = pContext->nearfieldData.nearfieldEdgesAltered;
0002930a      var_a8 = &pContext->ssOutput;
0002930f      int512_t zmm6_1;
0002930f      int512_t zmm7_1;
0002930f      int512_t zmm8;
0002930f      zmm6_1 = ProcessDoubleOcclusionFilter(&pContext->filterData.doubleOcclusionFilter, 
0002930f          &pContext->triangulated, &pContext->hasEdgesBetween, twoSensorTriangulation, 
0002930f          var_a8, &pContext->triangulateStatics, generalTouchData, (uint8_t)var_90, 
0002930f          (uint8_t)var_88);
00029328      (uint128_t)zmm6_1 = var_38;
0002932d      (uint128_t)zmm7_1 = var_48;
00029332      (uint128_t)zmm8 = var_58;
000289b4  }

0002934e                                            cc cc cc cc cc cc                                                    ......

00029354    enum orientation_t FilterManager(struct filterManager_t* filterData, struct twoSensorTriangulationMngr_t* twoSensorTriangulation)

00029354  {
00029354      uint8_t numTouchesFromEdges = twoSensorTriangulation->numTouchesFromEdges;
00029357      uint8_t prevNumTouchesCalculated = twoSensorTriangulation->prevNumTouchesCalculated;
00029365      filterData->decisionFilter = NO_DECISION_FILTER;
0002936f      enum orientation_t orientation;
0002936f      
0002936f      if (numTouchesFromEdges == 2)
0002936f      {
00029375          uint32_t prevNumTouchesCalculated_1 = (uint32_t)prevNumTouchesCalculated;
00029375          
0002937c          if (!prevNumTouchesCalculated_1)
0002937c          {
00029410              orientation = filterData->offBezelFilter.orientation;
00029410              
00029418              if (orientation)
00029418              {
0002941a              label_2941a:
0002941a                  filterData->decisionFilter = TOUCH_OFF_BEZEL_FILTER;
00029421                  goto label_294ca;
00029418              }
00029418              
00029426              orientation = filterData->unstableFirstFilter.orientation;
00029426              
0002942e              if (orientation)
0002942e              {
00029430                  filterData->decisionFilter = UNSTABLE_FIRST_FILTER;
0002943a                  goto label_294ca;
0002942e              }
0002942e              
0002943f              orientation = filterData->twentyfiveMMFilter.orientation;
0002943f              
00029447              if (orientation)
00029447              {
00029449                  filterData->decisionFilter = TWENTYFIVE_MM_FILTER;
00029453                  goto label_294ca;
00029447              }
00029447              
00029455              orientation = filterData->simTwoTouchFilter.orientation;
00029455              
0002945d              if (orientation)
0002945d              {
0002945f                  filterData->decisionFilter = SIM_TWO_TOUCH_FILTER;
00029469                  goto label_294ca;
0002945d              }
0002945d              
0002946b              orientation = filterData->largeBtmTouchFilter.orientation;
0002946b              
00029473              if (orientation)
00029473              {
00029475                  filterData->decisionFilter = BOTTOM_TOUCH_FILTER;
0002947f                  goto label_294ca;
00029473              }
00029473              
00029481              orientation = filterData->symmetryFilter.orientation;
00029481              
00029489              if (orientation)
00029489              {
0002948b                  filterData->decisionFilter = TOUCH_SYMMETRY_FILTER;
00029495                  goto label_294ca;
00029489              }
00029489              
00029497              orientation = filterData->awesomeLogicFilter.orientation;
00029497              
0002949f              if (!orientation)
0002949f                  goto label_294c8;
0002949f              
000294a1              filterData->decisionFilter = AWESOME_LOGIC_FILTER;
000294ab              goto label_294ca;
0002937c          }
0002937c          
00029385          if (prevNumTouchesCalculated_1 == 1)
00029385          {
000293f3              orientation = filterData->oneTrueTouchFilter.orientation;
000293f3              
000293fb              if (!orientation)
000293fb                  goto label_294c8;
000293fb              
00029401              filterData->decisionFilter = ONE_TRUE_TOUCH_FILTER;
0002940b              goto label_294ca;
00029385          }
00029385          
00029394          if (prevNumTouchesCalculated_1 == 2 && twoSensorTriangulation->occlusionState)
00029394          {
0002939a              orientation = filterData->offBezelFilter.orientation;
0002939a              
000293a2              if (orientation)
000293a2                  goto label_2941a;
000293a2              
000293a4              orientation = filterData->fastOcclusionFilter.orientation;
000293a4              
000293ac              if (orientation)
000293ac              {
000293ae                  filterData->decisionFilter = FAST_OCCLUSION_FILTER;
000293b8                  goto label_294ca;
000293ac              }
000293ac              
000293bd              orientation = filterData->pivotFilter.orientation;
000293bd              
000293c5              if (orientation)
000293c5              {
000293c7                  filterData->decisionFilter = PIVOT_FILTER;
000293d1                  goto label_294ca;
000293c5              }
000293c5              
000293d6              orientation = filterData->quadraticTTFilter.orientation;
000293d6              
000293de              if (!orientation)
000293de                  goto label_294c8;
000293de              
000293e4              filterData->decisionFilter = QUADRATIC_TT_FILTER;
000293ee              goto label_294ca;
00029394          }
0002936f      }
0002936f      else if (numTouchesFromEdges == 1)
000294b0      {
000294b2          orientation = filterData->doubleOcclusionFilter.orientation;
000294b2          
000294ba          if (!orientation)
000294ba          {
000294c8          label_294c8:
000294c8              orientation = O_UNKNOWN;
000294c8              goto label_294ca;
000294ba          }
000294ba          
000294bc          filterData->decisionFilter = DOUBLE_OCCLUSION_FILTER;
000294ca      label_294ca:
000294ca          
000294cc          if (orientation)
000294d1              return orientation;
000294b0      }
000294ce      return twoSensorTriangulation->orientation;
00029354  }

000294d2                                                        cc cc cc cc cc cc                                            ......

000294d8    void GenerateRequiredFilterData(struct filterManager_t* filterData, enum occlusionState_t occState, float* centreAngles, struct sub_sample_t* ssOut, struct triangulate_statics_t* triangulateStatics, struct kite_t* kite, uint8_t numTouches)

000294d8  {
000294fd      struct kite_t* kite_1 = kite;
0002950f      float* centreAngles_1 = centreAngles;
00029512      enum occlusionState_t occState_1 = occState;
00029518      float zmm6_1;
00029518      
00029518      if (numTouches != 2)
00029518      {
00029680          GenerateTouchBoundaryPoints(filterData, 0, kite_1, ssOut, triangulateStatics);
00029695          zmm6_1 =
00029695              GenerateTouchTonyTangents(filterData, 0, kite_1, ssOut, triangulateStatics);
00029518      }
00029518      else
00029518      {
00029526          int64_t rbx;
00029526          (uint8_t)rbx = 0;
00029526          
00029584          do
00029584          {
00029530              struct generalTouchData_t* filterData_1 = filterData;
00029530              
00029536              if (occState_1)
00029536              {
00029559                  (uint8_t)centreAngles = (uint8_t)rbx;
0002955f                  GenerateOccludedTouchBoundaryPoints(filterData_1, centreAngles_1, 
0002955f                      (uint8_t)centreAngles, ssOut, triangulateStatics);
0002957a                  occState = GenerateOccludedTouchTonyTangents(filterData, centreAngles_1, 
0002957a                      (uint8_t)rbx, kite_1, ssOut, triangulateStatics);
00029536              }
00029536              else
00029536              {
0002953b                  (uint8_t)occState = (uint8_t)rbx;
0002953d                  GenerateTouchBoundaryPoints(filterData_1, (uint8_t)occState, kite_1, 
0002953d                      ssOut, triangulateStatics);
00029552                  occState = GenerateTouchTonyTangents(filterData, (uint8_t)rbx, kite_1, 
00029552                      ssOut, triangulateStatics);
00029536              }
00029536              
0002957f              (uint8_t)rbx += 1;
00029584          } while ((uint8_t)rbx < 4);
00029584          
000295a7          if (!kite_1 || kite_1 == -0x2c || kite_1 == -0x58 || kite_1 == -0x84)
000295b5              onVerify__(
000295b5                  "c:\development_work\csf_release_hp\driver\tlcommon\safefloatpoint.c", 
000295b5                  0x92);
000295b5          
000295df          (uint32_t)kite = (kite_1->kPt[1].pt.x + kite_1->kPt[0].pt.x + kite_1->kPt[2].pt.x
000295df              + kite_1->kPt[3].pt.x) * 0.25f;
00029602          *(uint32_t*)((char*)kite)[4] = (kite_1->kPt[1].pt.y + kite_1->kPt[0].pt.y
00029602              + kite_1->kPt[2].pt.y + kite_1->kPt[3].pt.y) * 0.25f;
00029613          filterData->generalTouchData.centroid.x = (uint32_t)kite;
00029613          filterData->generalTouchData.centroid.y = *(uint32_t*)((char*)kite)[4];
0002961a          float zmm0_2[0x4] = DistanceSquare(&kite_1->kPt[3].pt, &kite_1->kPt[1]);
00029622          float zmm1_1;
00029622          
00029622          if (zmm0_2[0] <= zmm6_1)
00029635              zmm1_1 = zmm6_1;
00029622          else
00029622          {
0002962a              double zmm0_3;
0002962a              zmm0_3 =
0002962a                  sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_2, *(uint64_t*)&zmm0_2[0])[0])[0]);
0002962f              zmm1_1 = (float)zmm0_3;
00029622          }
00029622          
0002963e          filterData->doubleOcclusionFilter.distanceBetweenTouches[0] = zmm1_1;
00029646          float zmm0_4[0x4] = DistanceSquare(kite_1, &kite_1->kPt[2].pt);
0002964e          float zmm1_2;
0002964e          
0002964e          if (zmm0_4[0] <= zmm6_1)
00029661              zmm1_2 = zmm6_1;
0002964e          else
0002964e          {
00029656              double zmm0_5;
00029656              zmm0_5 =
00029656                  sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_4, *(uint64_t*)&zmm0_4[0])[0])[0]);
0002965b              zmm1_2 = (float)zmm0_5;
0002964e          }
0002964e          
00029664          filterData->doubleOcclusionFilter.distanceBetweenTouches[1] = zmm1_2;
00029518      }
00029518      
000296a4      float zmm0_6[0x4] = DistanceSquare(kite_1, &kite_1->kPt[3]);
000296ac      float zmm1_3;
000296ac      
000296ac      if (zmm0_6[0] <= zmm6_1)
000296bf          zmm1_3 = zmm6_1;
000296ac      else
000296ac      {
000296b4          double zmm0_7;
000296b4          zmm0_7 =
000296b4              sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_6, *(uint64_t*)&zmm0_6[0])[0])[0]);
000296b9          zmm1_3 = (float)zmm0_7;
000296ac      }
000296ac      
000296c9      filterData->generalTouchData.diamondWidths[0] = zmm1_3;
000296d1      float zmm0_8[0x4] = DistanceSquare(kite_1, &kite_1->kPt[1]);
000296d1      
000296d9      if (!(zmm0_8[0] <= zmm6_1))
000296e6          zmm6_1 = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_8, *(uint64_t*)&zmm0_8[0])[
000296e6              0])[0]);
000296e6      
000296f9      filterData->generalTouchData.diamondWidths[1] = zmm6_1;
000294d8  }

00029716                                                                    cc cc cc cc cc cc                                    ......

0002971c    void GenerateOccludedTouchBoundaryPoints(struct generalTouchData_t* touchData, float* centreAngles, uint8_t tchNum, struct sub_sample_t* ssOut, struct triangulate_statics_t* triangulateStatics)

0002971c  {
0002973c      void var_e8;
0002973c      int64_t rax_1 = __security_cookie ^ &var_e8;
00029747      char var_a5 = 1;
0002974c      char var_a4 = 1;
00029751      char var_a3 = 1;
00029756      char var_a2 = 1;
0002975b      char var_a1 = 1;
00029760      char var_9e = 1;
00029765      char var_8d = 1;
0002976a      char var_8c = 1;
0002976f      char var_8b = 1;
00029774      char var_89 = 1;
00029779      char var_86 = 1;
0002977e      char var_85 = 1;
00029783      char var_78 = 1;
00029788      char var_75 = 1;
0002978d      char var_74 = 1;
00029792      char var_71 = 1;
00029797      char var_6e = 1;
0002979c      char var_6d = 1;
000297a6      float* j_2 = nullptr;
000297aa      char var_97 = 0;
000297ae      char var_91 = 0;
000297b2      char var_7f = 0;
000297b6      char var_79 = 0;
000297ba      char var_a8 = 0;
000297be      char var_a7 = 0;
000297c2      char var_a6 = 0;
000297c6      char var_a0 = 0;
000297ca      char var_9f = 0;
000297ce      char var_9d = 0;
000297d2      char var_9c = 0;
000297d6      char var_9b = 0;
000297da      char var_9a = 0;
000297de      char var_99 = 0;
000297e2      char var_98 = 0;
000297e6      char var_96 = 0;
000297ea      char var_95 = 0;
000297ee      char var_94 = 0;
000297f2      char var_93 = 0;
000297f6      char var_92 = 0;
000297fa      char var_90 = 0;
000297fe      char var_8f = 0;
00029802      char var_8e = 0;
00029806      char var_8a = 0;
0002980a      char var_88 = 0;
0002980e      char var_87 = 0;
00029812      char var_84 = 0;
00029816      char var_83 = 0;
0002981a      char var_82 = 0;
0002981e      char var_81 = 0;
00029822      char var_80 = 0;
00029826      char var_7e = 0;
0002982a      char var_7d = 0;
0002982e      char var_7c = 0;
00029832      char var_7b = 0;
00029836      char var_7a = 0;
0002983a      char var_77 = 0;
0002983e      char var_76 = 0;
00029842      char var_73 = 0;
00029846      char var_72 = 0;
0002984a      char var_70 = 0;
0002984e      char var_6f = 0;
00029852      char var_6c = 0;
00029856      char var_6b = 0;
0002985a      char var_6a = 0;
0002985e      char var_69 = 0;
00029865      char var_68 = 0;
00029869      char var_67 = 0;
0002986d      char var_66 = 0;
00029871      char var_65 = 0;
00029875      char var_64 = 0;
00029879      char var_63 = 0;
0002987d      char var_62 = 0;
00029881      char var_61 = 0;
00029885      char var_60 = 1;
0002988a      char var_5f = 0;
0002988e      char var_5e = 0;
00029892      char var_5d = 1;
00029897      char var_5c = 1;
000298a8      char var_5b = 0;
000298ac      float* r12_1 = (uint64_t)tchNum << 2;
000298b0      char var_5a = 1;
000298b5      char var_59 = 1;
000298ba      char var_58 = 0;
000298be      char var_57 = 0;
000298c2      char var_56 = 1;
000298c7      void* rsi = &touchData->boundaryPts + (r12_1 << 3);
000298cf      char var_55 = 0;
000298d3      char var_54 = 0;
000298d7      char var_53 = 0;
000298db      char var_52 = 0;
000298df      char var_51 = 0;
000298e3      char var_50 = 0;
000298e7      char var_4f = 0;
000298eb      char var_4e = 0;
000298ef      char var_4d = 0;
000298f3      char var_4c = 0;
000298f7      char var_4b = 0;
000298fb      char var_4a = 0;
000298ff      char var_49 = 0;
00029903      int64_t var_c8 = 0;
00029908      int64_t var_c0 = 0;
0002990d      int64_t rdi = 0;
00029910      int64_t i_1 = 4;
000299ef      int64_t i;
000299ef      
000299ef      do
000299ef      {
00029914          void* j_4 = j_2;
00029917          float* j_3 = j_2;
0002991a          float* r9 = &var_c8;
0002991f          uint8_t* r11_1 = &ssOut->sensor[0].edgeSet[0].touchCount;
00029923          float* j_1 = 2;
000299bc          float* j;
000299bc          
000299bc          do
000299bc          {
0002992c              if (ADJ(r11_1)->sensor[0].edgeSet[0].touchCount == 2)
0002992c              {
00029932                  int64_t rcx = ((char*)j_4 + r12_1) * 3;
0002994f                  *(uint32_t*)r9 = *(uint32_t*)((char*)ssOut + ((
0002994f                      (uint64_t)(&var_a7)[rdi + (rcx << 1)]
0002994f                      + (((uint64_t)(&var_a8)[rcx << 1] + j_3) << 1)) << 2));
0002992c              }
0002992c              else if (ADJ(r11_1)->sensor[0].edgeSet[0].touchCount == 1)
00029958              {
0002995e                  void* rcx_3 = ((char*)j_4 + r12_1) * 3;
00029966                  (uint8_t)j_2 = (&var_a7)[rdi + (rcx_3 << 1)];
00029966                  
0002996e                  if ((&var_a3)[rcx_3 << 1] != (uint8_t)j_2)
000299a6                      *(uint32_t*)r9 = *(uint32_t*)((char*)ssOut
000299a6                          + (((uint64_t)(uint8_t)j_2 + (j_3 << 1)) << 2));
0002996e                  else
00029994                      *(uint32_t*)r9 = *(uint32_t*)((char*)r12_1 + centreAngles) - *(
00029994                          uint32_t*)((char*)ssOut
00029994                          + ((((uint64_t)(&var_a3)[rcx_3 << 1] ^ 1) + (j_3 << 1)) << 2))
00029994                          + *(uint32_t*)((char*)r12_1 + centreAngles);
00029958              }
00029958              
000299a9              j_4 += 1;
000299ac              r11_1 = &r11_1[0x70];
000299b0              j_3 += 0xe;
000299b4              r9 = &r9[1];
000299b8              j = j_1;
000299b8              j_1 -= 1;
000299bc          } while (j != 1);
000299c2          struct sensor_info_t* snsInfo = triangulateStatics->snsInfo;
000299d9          struct fpoint_t rax_11 = CTL_Triangulate((uint32_t)var_c8, 
000299d9              *(uint32_t*)((char*)var_c8)[4], snsInfo, &snsInfo[1]);
000299de          rdi += 1;
000299e1          j_2 = j_1;
000299e4          *(uint32_t*)rsi = rax_11.x;
000299e4          *(uint32_t*)((char*)rsi + 4) = rax_11.y;
000299e7          rsi += 8;
000299eb          i = i_1;
000299eb          i_1 -= 1;
000299ef      } while (i != 1);
00029a00      __security_check_cookie(rax_1 ^ &var_e8);
0002971c  }

00029a20  cc cc cc cc cc cc cc cc                                                                          ........

00029a28    void GenerateOccludedTouchTonyTangents(struct generalTouchData_t* touchData, float* centreAngles, uint8_t tchNum, struct kite_t* kite, struct sub_sample_t* ssOut, struct triangulate_statics_t* triangulateStatics)

00029a28  {
00029a55      void var_b8;
00029a55      int64_t rax_1 = __security_cookie ^ &var_b8;
00029a73      uint64_t tchNum_1 = (uint64_t)tchNum;
00029a7a      float zmm7[0x4] = {0};
00029a7e      char var_88 = 0;
00029a82      char var_86 = 0;
00029a86      char var_85 = 0;
00029a8a      char var_84 = 0;
00029a8e      char var_83 = 0;
00029a92      char var_82 = 0;
00029a96      char var_81 = 0;
00029a9a      char var_7f = 0;
00029a9e      char var_7e = 0;
00029aa2      char var_7d = 0;
00029aa6      char var_7a = 0;
00029aaa      char var_79 = 0;
00029ab7      char var_87 = 1;
00029abc      char var_80 = 1;
00029ac1      char var_7c = 1;
00029ac6      int64_t* rax_3 = tchNum_1 * 0x2c;
00029ace      struct fpoint_t r14;
00029ace      r14.x = *(uint32_t*)((char*)rax_3 + kite);
00029ace      r14.y = *(uint32_t*)(&kite->kPt[0].pt.y + rax_3);
00029ad2      char var_7b = 1;
00029ada      touchData->tonyTangents[tchNum_1].centrePt.x = r14.x;
00029ada      touchData->tonyTangents[tchNum_1].centrePt.y = r14.y;
00029ae2      (uint8_t)rax_3 = ssOut->sensor[0].edgeSet[0].touchCount;
00029ae2      
00029ae7      if ((uint8_t)rax_3 == 2)
00029ae7      {
00029ae9          uint64_t rax_4 = (uint64_t)(&var_88)[tchNum_1 << 2];
00029aef          zmm7 = ssOut->sensor[0].edgeSet[0].edgePair[rax_4].edge[1];
00029af5          zmm7[0] = zmm7[0] + *(uint32_t*)((char*)ssOut + (rax_4 << 3));
00029afa          zmm7[0] = zmm7[0] * 0.5f;
00029ae7      }
00029ae7      else if ((uint8_t)rax_3 == 1)
00029b08          zmm7 = centreAngles[tchNum_1];
00029b08      
00029b15      zmm7[0] = zmm7[0] + triangulateStatics->snsInfo->rotation_offset;
00029b1d      double temp0_1[0x2] = _mm_cvtps_pd(_mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0])[0]);
00029b20      temp0_1[0] = temp0_1[0] + 1.5707963267948966;
00029b2c      double zmm0_1;
00029b2c      double x;
00029b2c      zmm0_1 = cos(temp0_1[0]);
00029b3f      void* rax_7 = (tchNum_1 + 8) * 0x5c;
00029b4a      float zmm2 = (float)(zmm0_1
00029b4a          + _mm_cvtps_pd((uint64_t)touchData->tonyTangents[tchNum_1].centrePt.x));
00029b5d      double zmm0_2;
00029b5d      float zmm7_1[0x4];
00029b5d      float zmm8;
00029b5d      zmm0_2 = sin(x);
00029b6b      struct fpoint_t line1End;
00029b6b      line1End.x = touchData->boundaryPts[tchNum_1].boundingPts[1].x;
00029b6b      line1End.y = touchData->boundaryPts[tchNum_1].boundingPts[1].y;
00029b73      struct fpoint_t line1Start;
00029b73      line1Start.x = touchData->boundaryPts[tchNum_1].boundingPts[0].x;
00029b73      line1Start.y = touchData->boundaryPts[tchNum_1].boundingPts[0].y;
00029b7b      struct fpoint_t line2End;
00029b7b      line2End.x = r14.x;
00029b7b      line2End.y = r14.y;
00029b92      (uint32_t)zmm0_2 =
00029b92          (float)(zmm0_2 + _mm_cvtps_pd((uint64_t)*(uint32_t*)((char*)rax_7 + touchData)));
00029b96      int32_t var_94 = (uint32_t)zmm0_2;
00029b9c      struct fpoint_t line2Start;
00029b9c      line2Start.x = zmm2;
00029b9c      line2Start.y = zmm2;
00029ba1      struct fpoint_t rax_9 = LinesIntersection(line1Start, line1End, line2Start, line2End);
00029bae      touchData->tonyTangents[tchNum_1].ttCoord[0][0].x = rax_9.x;
00029bae      touchData->tonyTangents[tchNum_1].ttCoord[0][0].y = rax_9.y;
00029bb1      struct fpoint_t line1End_1;
00029bb1      line1End_1.x = touchData->boundaryPts[tchNum_1].boundingPts[3].x;
00029bb1      line1End_1.y = touchData->boundaryPts[tchNum_1].boundingPts[3].y;
00029bb9      struct fpoint_t line1Start_1;
00029bb9      line1Start_1.x = touchData->boundaryPts[tchNum_1].boundingPts[2].x;
00029bb9      line1Start_1.y = touchData->boundaryPts[tchNum_1].boundingPts[2].y;
00029bc1      struct fpoint_t rax_10 =
00029bc1          LinesIntersection(line1Start_1, line1End_1, line2Start, line2End);
00029bcc      touchData->tonyTangents[tchNum_1].ttCoord[0][1].x = rax_10.x;
00029bcc      touchData->tonyTangents[tchNum_1].ttCoord[0][1].y = rax_10.y;
00029bcf      float zmm0_3[0x4] = DistanceSquare(&touchData->tonyTangents[tchNum_1], 
00029bcf          &touchData->tonyTangents[tchNum_1].ttCoord[0][1]);
00029bd8      float zmm1_2;
00029bd8      
00029bd8      if (zmm0_3[0] <= zmm8)
00029beb          zmm1_2 = zmm8;
00029bd8      else
00029be5          zmm1_2 = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_3, *(uint64_t*)&zmm0_3[0])[
00029be5              0])[0])[0];
00029be5      
00029bef      char rcx_1 = (&var_87)[tchNum_1 << 2];
00029bf3      touchData->tonyTangents[tchNum_1].width[0] = zmm1_2;
00029bfc      uint8_t touchCount = ssOut->sensor[1].edgeSet[0].touchCount;
00029bfc      
00029c04      if (touchCount == 2)
00029c04      {
00029c06          uint64_t rax_11 = (uint64_t)rcx_1;
00029c09          zmm7_1 = *(uint32_t*)(&ssOut->sensor[1] + (rax_11 << 3));
00029c0f          zmm7_1[0] = zmm7_1[0] + ssOut->sensor[1].edgeSet[0].edgePair[rax_11].edge[1];
00029c15          zmm7_1[0] = zmm7_1[0] * 0.5f;
00029c04      }
00029c04      else if (touchCount == 1)
00029c23          zmm7_1 = centreAngles[tchNum_1];
00029c23      
00029c31      zmm7_1[0] = zmm7_1[0] + *(int64_t*)((char*)triangulateStatics->snsInfo + 0x14);
00029c39      double temp0_7[0x2] =
00029c39          _mm_cvtps_pd(_mm_unpacklo_ps(zmm7_1, *(uint64_t*)&zmm7_1[0])[0]);
00029c3c      temp0_7[0] = temp0_7[0] + 1.5707963267948966;
00029c48      double zmm0_4;
00029c48      double x_1;
00029c48      zmm0_4 = cos(*(uint64_t*)&temp0_7[0]);
00029c5d      float zmm2_1 = (float)(zmm0_4
00029c5d          + _mm_cvtps_pd((uint64_t)touchData->tonyTangents[tchNum_1].centrePt.x));
00029c6b      double zmm0_5;
00029c6b      float zmm8_1[0x4];
00029c6b      zmm0_5 = sin(x_1);
00029c75      struct fpoint_t line2End_1;
00029c75      line2End_1.x = touchData->tonyTangents[tchNum_1].centrePt.x;
00029c75      line2End_1.y = touchData->tonyTangents[tchNum_1].centrePt.y;
00029c82      struct fpoint_t line1End_2;
00029c82      line1End_2.x = touchData->boundaryPts[tchNum_1].boundingPts[3].x;
00029c82      line1End_2.y = touchData->boundaryPts[tchNum_1].boundingPts[3].y;
00029c8a      struct fpoint_t line1Start_2;
00029c8a      line1Start_2.x = touchData->boundaryPts[tchNum_1].boundingPts[0].x;
00029c8a      line1Start_2.y = touchData->boundaryPts[tchNum_1].boundingPts[0].y;
00029c99      (uint32_t)zmm0_5 =
00029c99          (float)(zmm0_5 + _mm_cvtps_pd((uint64_t)*(uint32_t*)((char*)rax_7 + touchData)));
00029ca5      int32_t var_94_1 = (uint32_t)zmm0_5;
00029cab      struct fpoint_t line2Start_1;
00029cab      line2Start_1.x = zmm2_1;
00029cab      line2Start_1.y = zmm2_1;
00029cb0      struct fpoint_t rax_14 =
00029cb0          LinesIntersection(line1Start_2, line1End_2, line2Start_1, line2End_1);
00029cbd      touchData->tonyTangents[tchNum_1].ttCoord[1][0].x = rax_14.x;
00029cbd      touchData->tonyTangents[tchNum_1].ttCoord[1][0].y = rax_14.y;
00029cc0      struct fpoint_t line1End_3;
00029cc0      line1End_3.x = touchData->boundaryPts[tchNum_1].boundingPts[2].x;
00029cc0      line1End_3.y = touchData->boundaryPts[tchNum_1].boundingPts[2].y;
00029cc8      struct fpoint_t line1Start_3;
00029cc8      line1Start_3.x = touchData->boundaryPts[tchNum_1].boundingPts[1].x;
00029cc8      line1Start_3.y = touchData->boundaryPts[tchNum_1].boundingPts[1].y;
00029cd0      struct fpoint_t rax_15 =
00029cd0          LinesIntersection(line1Start_3, line1End_3, line2Start_1, line2End_1);
00029cdb      touchData->tonyTangents[tchNum_1].ttCoord[1][1].x = rax_15.x;
00029cdb      touchData->tonyTangents[tchNum_1].ttCoord[1][1].y = rax_15.y;
00029cde      float zmm0_6[0x4] = DistanceSquare(&touchData->tonyTangents[tchNum_1].ttCoord[1], 
00029cde          &touchData->tonyTangents[tchNum_1].ttCoord[1][1]);
00029cde      
00029ce7      if (!(zmm0_6[0] <= zmm8_1[0]))
00029cf4          zmm8_1[0] = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_6, 
00029cf4              *(uint64_t*)&zmm0_6[0])[0])[0])[0];
00029cf4      
00029cf9      float zmm1_5[0x4] = touchData->tonyTangents[tchNum_1].width[0];
00029d02      int64_t zmm2_2 = 0x3f50624dd2f1a9fc;
00029d0a      touchData->tonyTangents[tchNum_1].width[1] = zmm8_1[0];
00029d0a      
00029d18      if (zmm1_5[0] <= zmm8_1[0])
00029d18      {
00029d41          float temp0_16[0x4] = _mm_unpacklo_ps(zmm8_1, *(uint64_t*)&zmm8_1[0]);
00029d45          float temp0_17[0x4] = _mm_cvtps_pd(*(uint64_t*)&temp0_16[0]);
00029d45          
00029d4d          if (!(*(uint64_t*)&temp0_17[0] <= zmm2_2))
00029d53              zmm2_2 = _mm_cvtps_pd(_mm_unpacklo_ps(temp0_16, *(uint64_t*)&temp0_16[0])[0]);
00029d53          
00029d57          temp0_17[0] = (float)zmm2_2;
00029d5b          zmm1_5[0] = zmm1_5[0] / temp0_17[0];
00029d5f          touchData->tonyTangents[tchNum_1].symmetry = zmm1_5[0];
00029d18      }
00029d18      else
00029d18      {
00029d1a          float temp0_12[0x4] = _mm_unpacklo_ps(zmm1_5, *(uint64_t*)&zmm1_5[0]);
00029d1d          float temp0_13[0x4] = _mm_cvtps_pd(*(uint64_t*)&temp0_12[0]);
00029d1d          
00029d24          if (!(*(uint64_t*)&temp0_13[0] <= zmm2_2))
00029d29              zmm2_2 = _mm_cvtps_pd(_mm_unpacklo_ps(temp0_12, *(uint64_t*)&temp0_12[0])[0]);
00029d29          
00029d2c          temp0_13[0] = (float)zmm2_2;
00029d30          zmm8_1[0] = zmm8_1[0] / temp0_13[0];
00029d35          touchData->tonyTangents[tchNum_1].symmetry = zmm8_1[0];
00029d18      }
00029d18      
00029d70      __security_check_cookie(rax_1 ^ &var_b8);
00029a28  }

00029d9f                                                                                               cc                                 .
00029da0  cc cc cc cc cc cc cc cc                                                                          ........

00029da8    void GenerateTouchBoundaryPoints(struct generalTouchData_t* tchData, uint8_t tchNum, struct kite_t* kite, struct sub_sample_t* ssOut, struct triangulate_statics_t* tStatics)

00029da8  {
00029ddd      uint64_t tchNum_1 = (uint64_t)tchNum;
00029dec      tchNum = kite->kPt[tchNum_1].sourceST[0];
00029df1      int64_t rbp;
00029df1      (uint8_t)rbp = kite->kPt[tchNum_1].sourceST[1];
00029dfb      int64_t r15;
00029dfb      (uint8_t)r15 = tchNum;
00029e01      int64_t rbx;
00029e01      (uint8_t)rbx = (uint8_t)rbp;
00029e07      (uint8_t)r15 u>>= 4;
00029e0b      (uint8_t)rbx u>>= 4;
00029e0e      uint64_t r13 = (uint64_t)(uint8_t)r15;
00029e12      (uint8_t)rbp &= 1;
00029e16      uint64_t rsi = r13 * 3;
00029e1f      int64_t r13_2 = r13 * 0xe + ((uint64_t)tchNum & 1);
00029e34      struct line_def_t line_1;
00029e34      CTL_SensorAngleToLine(*(uint32_t*)((char*)ssOut + (r13_2 << 3)), 
00029e34          tStatics->snsInfo + (rsi << 2), &line_1);
00029e39      uint64_t rdi = (uint64_t)(uint8_t)rbx;
00029e3c      uint64_t rbx_1 = rdi * 3;
00029e4d      int64_t rdi_2 = rdi * 0xe + (uint64_t)(uint8_t)rbp;
00029e62      struct line_def_t line_2;
00029e62      CTL_SensorAngleToLine(*(uint32_t*)((char*)ssOut + (rdi_2 << 3)), 
00029e62          tStatics->snsInfo + (rbx_1 << 2), &line_2);
00029e7f      struct line_def_t line;
00029e7f      CTL_SensorAngleToLine(ssOut->sensor[0].edgeSet[0].edgePair[r13_2].edge[1], 
00029e7f          tStatics->snsInfo + (rsi << 2), &line);
00029e9c      struct line_def_t line_3;
00029e9c      CTL_SensorAngleToLine(ssOut->sensor[0].edgeSet[0].edgePair[rdi_2].edge[1], 
00029e9c          tStatics->snsInfo + (rbx_1 << 2), &line_3);
00029ea1      float m = line_1.m;
00029ea7      float c = line_2.c;
00029ebf      float zmm0_5 = _divide(c - line_1.c, m - line_2.m);
00029ec4      float m_1 = line.m;
00029eca      int128_t zmm8;
00029eca      (uint32_t)zmm8 = line_3.c;
00029eca      *(uint32_t*)((char*)zmm8)[4] = line_3.c;
00029eed      (uint32_t)tStatics = zmm0_5;
00029f0e      *(uint32_t*)((char*)tStatics)[4] = m * zmm0_5 + line_1.c;
00029f1f      tchData->boundaryPts[tchNum_1].boundingPts[1].x = tStatics;
00029f27      float zmm0_6 = _divide((uint32_t)zmm8 - line.c, m_1 - line_3.m);
00029f33      struct generalTouchData_t* arg_8;
00029f33      (uint32_t)arg_8 = zmm0_6;
00029f42      *(uint32_t*)((char*)arg_8)[4] = m_1 * zmm0_6 + line.c;
00029f53      tchData->boundaryPts[tchNum_1].boundingPts[3].x = arg_8;
00029f5e      float zmm0_8;
00029f5e      
00029f5e      if ((uint8_t)r15)
00029f5e      {
00029fe3          float zmm0_9 = _divide(c - line.c, m_1 - line_2.m);
00029fe8          (uint32_t)zmm8 = (uint32_t)zmm8 - line_1.c;
00029ff8          (uint32_t)arg_8 = zmm0_9;
0002a00f          *(uint32_t*)((char*)arg_8)[4] = m_1 * zmm0_9 + line.c;
0002a020          tchData->boundaryPts[tchNum_1].boundingPts[0].x = arg_8;
0002a028          zmm0_8 = _divide((uint32_t)zmm8, m - line_3.m);
0002a037          *(uint32_t*)((char*)arg_8)[4] = m * zmm0_8 + line_1.c;
00029f5e      }
00029f5e      else
00029f5e      {
00029f60          (uint32_t)zmm8 = (uint32_t)zmm8 - line_1.c;
00029f74          float zmm0_7 = _divide((uint32_t)zmm8, m - line_3.m);
00029f88          (uint32_t)arg_8 = zmm0_7;
00029f9e          *(uint32_t*)((char*)arg_8)[4] = m * zmm0_7 + line_1.c;
00029faf          tchData->boundaryPts[tchNum_1].boundingPts[0].x = arg_8;
00029fb7          zmm0_8 = _divide(c - line.c, m_1 - line_2.m);
00029fc6          *(uint32_t*)((char*)arg_8)[4] = m_1 * zmm0_8 + line.c;
00029f5e      }
00029f5e      
0002a04d      (uint32_t)arg_8 = zmm0_8;
0002a06c      tchData->boundaryPts[tchNum_1].boundingPts[2].x = arg_8;
00029da8  }

0002a083           cc cc cc cc cc cc cc cc cc                                                                 .........

0002a08c    void GenerateTouchTonyTangents(struct generalTouchData_t* touchData, uint8_t tchNum, struct kite_t* kite, struct sub_sample_t* ssOut, struct triangulate_statics_t* triangulateStatics)

0002a08c  {
0002a0a8      struct triangulate_statics_t* triangulateStatics_1 = triangulateStatics;
0002a0b8      uint64_t tchNum_3 = (uint64_t)tchNum;
0002a0cb      uint8_t tchNum_2 = kite->kPt[tchNum_3].sourceST[0];
0002a0d0      int64_t rdi;
0002a0d0      (uint8_t)rdi = kite->kPt[tchNum_3].sourceST[1];
0002a0da      tchNum = tchNum_2;
0002a0dd      tchNum_2 &= 1;
0002a0e0      int64_t rbx;
0002a0e0      (uint8_t)rbx = (uint8_t)rdi;
0002a0e3      (uint8_t)rdi &= 1;
0002a0e6      tchNum u>>= 4;
0002a0ed      (uint8_t)rbx u>>= 4;
0002a0f2      uint8_t tchNum_4 = (uint8_t)rdi;
0002a0f2      
0002a0f6      if (!tchNum)
0002a0f6          tchNum_4 = tchNum_2;
0002a0f6      
0002a0fb      uint64_t tchNum_1 = (uint64_t)tchNum;
0002a106      uint8_t tchNum_5 = (uint8_t)rdi;
0002a106      
0002a10a      if (tchNum == 1)
0002a10a          tchNum_5 = tchNum_2;
0002a10a      
0002a121      int64_t rcx_1 = tchNum_1 * 0xe + (uint64_t)tchNum_2;
0002a124      struct edge_pair_t edgePair;
0002a124      edgePair.edge[0] = *(uint32_t*)((char*)ssOut + (rcx_1 << 3));
0002a124      edgePair.edge[1] = ssOut->sensor[0].edgeSet[0].edgePair[rcx_1].edge[1];
0002a128      struct line_def_t line;
0002a128      CTL_EdgesToCentreLine(edgePair, &triangulateStatics_1->snsInfo[tchNum_1], &line);
0002a134      uint64_t rcx_2 = (uint64_t)(uint8_t)rbx;
0002a14c      int64_t rcx_4 = rcx_2 * 0xe + (uint64_t)(uint8_t)rdi;
0002a14f      struct edge_pair_t edgePair_1;
0002a14f      edgePair_1.edge[0] = *(uint32_t*)((char*)ssOut + (rcx_4 << 3));
0002a14f      edgePair_1.edge[1] = ssOut->sensor[0].edgeSet[0].edgePair[rcx_4].edge[1];
0002a154      struct line_def_t line_1;
0002a154      CTL_EdgesToCentreLine(edgePair_1, &triangulateStatics_1->snsInfo[rcx_2], &line_1);
0002a15f      float m = line.m;
0002a174      float zmm0_1[0x4] = _divide(line_1.c - line.c, m - line_1.m);
0002a179      uint64_t tchNum_6 = (uint64_t)tchNum_4;
0002a188      (uint32_t)triangulateStatics = zmm0_1[0];
0002a197      *(uint32_t*)((char*)triangulateStatics)[4] = m * zmm0_1[0] + line.c;
0002a1a0      struct triangulate_statics_t* line2End = triangulateStatics;
0002a1a8      touchData->tonyTangents[tchNum_3].centrePt.x = line2End;
0002a1b0      zmm0_1 = ssOut->sensor[0].edgeSet[0].edgePair[tchNum_6].edge[1];
0002a1b7      zmm0_1[0] = zmm0_1[0] + *(uint32_t*)((char*)ssOut + (tchNum_6 << 3));
0002a1be      struct sensor_info_t* snsInfo = triangulateStatics_1->snsInfo;
0002a1c5      zmm0_1[0] = zmm0_1[0] * 0.5f;
0002a1cd      zmm0_1[0] = zmm0_1[0] + snsInfo->rotation_offset;
0002a1d5      double temp0_1[0x2] =
0002a1d5          _mm_cvtps_pd(_mm_unpacklo_ps(zmm0_1, *(uint64_t*)&zmm0_1[0])[0]);
0002a1d8      temp0_1[0] = temp0_1[0] + 1.5707963267948966;
0002a1e4      double zmm0_2;
0002a1e4      double x;
0002a1e4      zmm0_2 = cos(*(uint64_t*)&temp0_1[0]);
0002a1f7      void* rsi_1 = (tchNum_3 + 8) * 0x5c;
0002a20a      (uint32_t)triangulateStatics = (float)(zmm0_2
0002a20a          + _mm_cvtps_pd((uint64_t)touchData->tonyTangents[tchNum_3].centrePt.x));
0002a220      double zmm0_3 =
0002a220          sin(x) + _mm_cvtps_pd((uint64_t)*(uint32_t*)((char*)rsi_1 + touchData));
0002a22b      struct fpoint_t line1End;
0002a22b      line1End.x = touchData->boundaryPts[tchNum_3].boundingPts[1].x;
0002a22b      line1End.y = touchData->boundaryPts[tchNum_3].boundingPts[1].y;
0002a233      struct fpoint_t line1Start;
0002a233      line1Start.x = touchData->boundaryPts[tchNum_3].boundingPts[0].x;
0002a233      line1Start.y = touchData->boundaryPts[tchNum_3].boundingPts[0].y;
0002a23b      (uint32_t)zmm0_3 = (float)zmm0_3;
0002a247      *(uint32_t*)((char*)triangulateStatics)[4] = (uint32_t)zmm0_3;
0002a250      struct fpoint_t line2Start;
0002a250      line2Start.x = (uint32_t)triangulateStatics;
0002a250      line2Start.y = *(uint32_t*)((char*)triangulateStatics)[4];
0002a258      struct fpoint_t rax_8 = LinesIntersection(line1Start, line1End, line2Start, line2End);
0002a265      touchData->tonyTangents[tchNum_3].ttCoord[0][0].x = rax_8.x;
0002a265      touchData->tonyTangents[tchNum_3].ttCoord[0][0].y = rax_8.y;
0002a268      struct fpoint_t line1End_1;
0002a268      line1End_1.x = touchData->boundaryPts[tchNum_3].boundingPts[3].x;
0002a268      line1End_1.y = touchData->boundaryPts[tchNum_3].boundingPts[3].y;
0002a270      struct fpoint_t line1Start_1;
0002a270      line1Start_1.x = touchData->boundaryPts[tchNum_3].boundingPts[2].x;
0002a270      line1Start_1.y = touchData->boundaryPts[tchNum_3].boundingPts[2].y;
0002a278      struct fpoint_t rax_9 =
0002a278          LinesIntersection(line1Start_1, line1End_1, line2Start, line2End);
0002a283      touchData->tonyTangents[tchNum_3].ttCoord[0][1].x = rax_9.x;
0002a283      touchData->tonyTangents[tchNum_3].ttCoord[0][1].y = rax_9.y;
0002a286      float zmm0_4[0x4] = DistanceSquare(&touchData->tonyTangents[tchNum_3], 
0002a286          &touchData->tonyTangents[tchNum_3].ttCoord[0][1]);
0002a291      float zmm1_3;
0002a291      
0002a291      if (zmm0_4[0] <= 0f)
0002a2a4          zmm1_3 = (int32_t){0};
0002a291      else
0002a29e          zmm1_3 = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_4, *(uint64_t*)&zmm0_4[0])[
0002a29e              0])[0])[0];
0002a29e      
0002a2a7      touchData->tonyTangents[tchNum_3].width[0] = zmm1_3;
0002a2b0      uint64_t tchNum_7 = (uint64_t)tchNum_5;
0002a2b4      zmm0_4 = *(uint32_t*)(&ssOut->sensor[1] + (tchNum_7 << 3));
0002a2bb      zmm0_4[0] = zmm0_4[0] + ssOut->sensor[1].edgeSet[0].edgePair[tchNum_7].edge[1];
0002a2c2      struct sensor_info_t* snsInfo_1 = triangulateStatics_1->snsInfo;
0002a2c9      zmm0_4[0] = zmm0_4[0] * 0.5f;
0002a2d1      zmm0_4[0] = zmm0_4[0] + *(int64_t*)((char*)snsInfo_1 + 0x14);
0002a2d9      double temp0_7[0x2] =
0002a2d9          _mm_cvtps_pd(_mm_unpacklo_ps(zmm0_4, *(uint64_t*)&zmm0_4[0])[0]);
0002a2dc      temp0_7[0] = temp0_7[0] + 1.5707963267948966;
0002a2e8      double zmm0_5;
0002a2e8      double x_1;
0002a2e8      zmm0_5 = cos(*(uint64_t*)&temp0_7[0]);
0002a305      (uint32_t)triangulateStatics = (float)(zmm0_5
0002a305          + _mm_cvtps_pd((uint64_t)touchData->tonyTangents[tchNum_3].centrePt.x));
0002a30e      double zmm0_6;
0002a30e      float zmm7[0x4];
0002a30e      zmm0_6 = sin(x_1);
0002a318      struct fpoint_t line2End_1;
0002a318      line2End_1.x = touchData->tonyTangents[tchNum_3].centrePt.x;
0002a318      line2End_1.y = touchData->tonyTangents[tchNum_3].centrePt.y;
0002a320      struct fpoint_t line1End_2;
0002a320      line1End_2.x = touchData->boundaryPts[tchNum_3].boundingPts[3].x;
0002a320      line1End_2.y = touchData->boundaryPts[tchNum_3].boundingPts[3].y;
0002a328      struct fpoint_t line1Start_2;
0002a328      line1Start_2.x = touchData->boundaryPts[tchNum_3].boundingPts[0].x;
0002a328      line1Start_2.y = touchData->boundaryPts[tchNum_3].boundingPts[0].y;
0002a33f      (uint32_t)zmm0_6 =
0002a33f          (float)(zmm0_6 + _mm_cvtps_pd((uint64_t)*(uint32_t*)((char*)rsi_1 + touchData)));
0002a343      *(uint32_t*)((char*)triangulateStatics)[4] = (uint32_t)zmm0_6;
0002a354      struct fpoint_t rax_10 =
0002a354          LinesIntersection(line1Start_2, line1End_2, triangulateStatics, line2End_1);
0002a361      touchData->tonyTangents[tchNum_3].ttCoord[1][0].x = rax_10.x;
0002a361      touchData->tonyTangents[tchNum_3].ttCoord[1][0].y = rax_10.y;
0002a364      struct fpoint_t line1End_3;
0002a364      line1End_3.x = touchData->boundaryPts[tchNum_3].boundingPts[2].x;
0002a364      line1End_3.y = touchData->boundaryPts[tchNum_3].boundingPts[2].y;
0002a36c      struct fpoint_t line1Start_3;
0002a36c      line1Start_3.x = touchData->boundaryPts[tchNum_3].boundingPts[1].x;
0002a36c      line1Start_3.y = touchData->boundaryPts[tchNum_3].boundingPts[1].y;
0002a374      struct fpoint_t rax_11 =
0002a374          LinesIntersection(line1Start_3, line1End_3, triangulateStatics, line2End_1);
0002a37f      touchData->tonyTangents[tchNum_3].ttCoord[1][1].x = rax_11.x;
0002a37f      touchData->tonyTangents[tchNum_3].ttCoord[1][1].y = rax_11.y;
0002a382      float zmm0_7[0x4] = DistanceSquare(&touchData->tonyTangents[tchNum_3].ttCoord[1], 
0002a382          &touchData->tonyTangents[tchNum_3].ttCoord[1][1]);
0002a382      
0002a38a      if (!(zmm0_7[0] <= zmm7[0]))
0002a397          zmm7[0] = (float)sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_7, 
0002a397              *(uint64_t*)&zmm0_7[0])[0])[0])[0];
0002a397      
0002a39b      float zmm1_6[0x4] = touchData->tonyTangents[tchNum_3].width[0];
0002a3a4      int64_t zmm2_2 = 0x3f50624dd2f1a9fc;
0002a3ac      touchData->tonyTangents[tchNum_3].width[1] = zmm7[0];
0002a3ac      
0002a3b8      if (zmm1_6[0] <= zmm7[0])
0002a3b8      {
0002a3df          float temp0_16[0x4] = _mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0]);
0002a3e2          float temp0_17[0x4] = _mm_cvtps_pd(*(uint64_t*)&temp0_16[0]);
0002a3e2          
0002a3e9          if (!(*(uint64_t*)&temp0_17[0] <= zmm2_2))
0002a3ee              zmm2_2 = _mm_cvtps_pd(_mm_unpacklo_ps(temp0_16, *(uint64_t*)&temp0_16[0])[0]);
0002a3ee          
0002a3f1          temp0_17[0] = (float)zmm2_2;
0002a3f5          zmm1_6[0] = zmm1_6[0] / temp0_17[0];
0002a3f9          touchData->tonyTangents[tchNum_3].symmetry = zmm1_6[0];
0002a3b8      }
0002a3b8      else
0002a3b8      {
0002a3ba          float temp0_12[0x4] = _mm_unpacklo_ps(zmm1_6, *(uint64_t*)&zmm1_6[0]);
0002a3bd          float temp0_13[0x4] = _mm_cvtps_pd(*(uint64_t*)&temp0_12[0]);
0002a3bd          
0002a3c4          if (!(*(uint64_t*)&temp0_13[0] <= zmm2_2))
0002a3c9              zmm2_2 = _mm_cvtps_pd(_mm_unpacklo_ps(temp0_12, *(uint64_t*)&temp0_12[0])[0]);
0002a3c9          
0002a3cc          temp0_13[0] = (float)zmm2_2;
0002a3d0          zmm7[0] = zmm7[0] / temp0_13[0];
0002a3d4          touchData->tonyTangents[tchNum_3].symmetry = zmm7[0];
0002a3b8      }
0002a08c  }

0002a42a                                cc cc cc cc cc cc                                                            ......

0002a430    struct fpoint_t LinesIntersection(struct fpoint_t line1Start, struct fpoint_t line1End, struct fpoint_t line2Start, struct fpoint_t line2End) __pure

0002a430  {
0002a433      int64_t arg_20;
0002a433      (uint32_t)arg_20 = line2End.x;
0002a433      *(uint32_t*)((char*)arg_20)[4] = line2End.y;
0002a437      int64_t arg_18;
0002a437      (uint32_t)arg_18 = line2Start.x;
0002a437      *(uint32_t*)((char*)arg_18)[4] = line2Start.y;
0002a43b      int64_t arg_10;
0002a43b      (uint32_t)arg_10 = line1End.x;
0002a43b      *(uint32_t*)((char*)arg_10)[4] = line1End.y;
0002a43f      int64_t result;
0002a43f      (uint32_t)result = line1Start.x;
0002a43f      *(uint32_t*)((char*)result)[4] = line1Start.y;
0002a44f      float zmm3 = 100000000f;
0002a45b      float zmm0 = (uint32_t)arg_10 - (uint32_t)result;
0002a460      float zmm5 = *(uint32_t*)((char*)result)[4];
0002a465      zmm0 - 0f;
0002a46a      float zmm2;
0002a46a      
0002a46a      zmm2 = FCMP_UO(zmm0, 0f) || zmm0 != 0f
0002a46a          ? (*(uint32_t*)((char*)arg_10)[4] - zmm5) / zmm0 : 100000000f;
0002a46a      
0002a485      int128_t zmm6 = *(uint32_t*)((char*)arg_18)[4];
0002a48b      zmm0 = (uint32_t)arg_20 - (uint32_t)arg_18;
0002a491      zmm0 - 0f;
0002a491      
0002a496      if (FCMP_UO(zmm0, 0f) || !(zmm0 == 0f))
0002a4a2          zmm3 = (*(uint32_t*)((char*)arg_20)[4] - (uint32_t)zmm6) / zmm0;
0002a4a2      
0002a4a6      zmm2 - zmm3;
0002a4bb      zmm5 = zmm5 - zmm2 * (uint32_t)result;
0002a4bf      (uint32_t)zmm6 = (uint32_t)zmm6 - zmm3 * (uint32_t)arg_18;
0002a4c5      float zmm4;
0002a4c5      
0002a4c5      zmm4 =
0002a4c5          FCMP_UO(zmm2, zmm3) || zmm2 != zmm3 ? 1f / (zmm2 * -1f - zmm3 * -1f) : 10000000f;
0002a4c5      
0002a501      int32_t zmm1 = (uint32_t)zmm6 * -1f;
0002a511      (uint32_t)zmm6 = (uint32_t)zmm6 * zmm2;
0002a529      (uint32_t)result = (zmm1 - zmm5 * -1f) * zmm4;
0002a52f      *(uint32_t*)((char*)result)[4] = (zmm5 * zmm3 - (uint32_t)zmm6) * zmm4;
0002a53e      return result;
0002a430  }

0002a53f                                                                                               cc                                 .
0002a540  cc cc cc cc cc cc cc cc                                                                          ........

0002a548    void UpdateTrackingCircles(struct filterManager_t* filterData, struct touches_t* pOutputTouches)

0002a548  {
0002a565      int128_t zmm6 = {0};
0002a574      struct touches_t* B = pOutputTouches;
0002a577      uint32_t* rbx = &filterData->generalTouchData.touchDownCircle[0].TouchAge;
0002a57e      int64_t i_1 = 2;
0002a6eb      int64_t i;
0002a6eb      
0002a6eb      do
0002a6eb      {
0002a588          if (B->touches[0].touchState == TS_TOUCH_DOWN)
0002a588          {
0002a58a              int64_t rax_1;
0002a58a              (uint32_t)rax_1 = B->touches[0].position.x;
0002a58a              *(uint32_t*)((char*)rax_1)[4] = B->touches[0].position.y;
0002a58d              *((char*)ADJ(rbx) + 0x440) = 0;
0002a591              ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchDownLocation.x =
0002a591                  (uint32_t)rax_1;
0002a591              ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchDownLocation.y =
0002a591                  *(uint32_t*)((char*)rax_1)[4];
0002a595              struct fpoint_t rax_2;
0002a595              rax_2.x = B->touches[0].position.x;
0002a595              rax_2.y = B->touches[0].position.y;
0002a598              ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchAge = 0;
0002a59b              ADJ(rbx)->generalTouchData.touchDownCircle[0].DistFromTouchDown = 0f;
0002a59f              ADJ(rbx)->generalTouchData.touchDownCircle[0].DistFromTrackedPoint = 0f;
0002a5a3              ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.x =
0002a5a3                  rax_2.x;
0002a5a3              ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.y =
0002a5a3                  rax_2.y;
0002a588          }
0002a588          
0002a5ab          if (!B->touches[0].touchState)
0002a5ad              ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchAge = 0;
0002a5ad          
0002a5ba          float zmm0[0x4];
0002a5ba          float zmm1;
0002a5ba          
0002a5ba          if (B->touches[0].touchState == TS_TOUCH_UP && !*((char*)ADJ(rbx) + 0x440))
0002a5ba          {
0002a5c3              zmm0 = DistanceSquare(&rbx[-4], B);
0002a5c3              
0002a5cb              if (zmm0[0] <= (uint32_t)zmm6)
0002a5de                  zmm1 = (uint32_t)zmm6;
0002a5cb              else
0002a5cb              {
0002a5d3                  zmm0 =
0002a5d3                      sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0])[0]);
0002a5d8                  zmm1 = (float)*(uint64_t*)&zmm0[0];
0002a5cb              }
0002a5cb              
0002a5e4              if (3f <= zmm1)
0002a5ef                  *((char*)ADJ(rbx) + 0x440) = 1;
0002a5e4              else
0002a5e4              {
0002a5e6                  int64_t rax_3;
0002a5e6                  (uint32_t)rax_3 =
0002a5e6                      ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchDownLocation.x;
0002a5e6                  *(uint32_t*)((char*)rax_3)[4] =
0002a5e6                      ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchDownLocation.y;
0002a5ea                  B->touches[0].position.x = (uint32_t)rax_3;
0002a5ea                  B->touches[0].position.y = *(uint32_t*)((char*)rax_3)[4];
0002a5e4              }
0002a5ba          }
0002a5ba          
0002a5f7          if (B->touches[0].touchState == TS_TOUCH)
0002a5f7          {
0002a607              ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchAge += 1;
0002a610              zmm1 = ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.x
0002a610                  * 0.949999988f;
0002a618              float zmm2 =
0002a618                  ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.y
0002a618                  * 0.949999988f;
0002a620              ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.x = zmm1;
0002a625              ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.y = zmm2;
0002a62a              zmm0[0] = B->touches[0].position.x;
0002a62a              zmm0[1] = B->touches[0].position.x;
0002a62a              zmm0[2] = B->touches[0].position.x;
0002a62a              zmm0[3] = B->touches[0].position.x;
0002a62e              zmm0[0] = zmm0[0] * 0.0500000007f;
0002a636              zmm0[0] = zmm0[0] + zmm1;
0002a63a              ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.x =
0002a63a                  zmm0[0];
0002a650              ADJ(rbx)->generalTouchData.touchDownCircle[0].TrackedPointLocation.y =
0002a650                  B->touches[0].position.y * 0.0500000007f + zmm2;
0002a655              float zmm0_1[0x4] = DistanceSquare(&rbx[-4], B);
0002a65d              float zmm1_1;
0002a65d              
0002a65d              if (zmm0_1[0] <= (uint32_t)zmm6)
0002a670                  zmm1_1 = (uint32_t)zmm6;
0002a65d              else
0002a65d              {
0002a665                  double zmm0_2;
0002a665                  zmm0_2 = sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_1, 
0002a665                      *(uint64_t*)&zmm0_1[0])[0])[0]);
0002a66a                  zmm1_1 = (float)zmm0_2;
0002a65d              }
0002a65d              
0002a67a              ADJ(rbx)->generalTouchData.touchDownCircle[0].DistFromTouchDown = zmm1_1;
0002a67f              zmm0 = DistanceSquare(&rbx[-2], B);
0002a67f              
0002a687              if (zmm0[0] <= (uint32_t)zmm6)
0002a69a                  zmm1 = (uint32_t)zmm6;
0002a687              else
0002a687              {
0002a68f                  zmm0 =
0002a68f                      sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0])[0]);
0002a694                  zmm1 = (float)*(uint64_t*)&zmm0[0];
0002a687              }
0002a687              
0002a6a1              ADJ(rbx)->generalTouchData.touchDownCircle[0].DistFromTrackedPoint = zmm1;
0002a6a1              
0002a6a6              if (!*((char*)ADJ(rbx) + 0x440))
0002a6a6              {
0002a6af                  zmm0 = DistanceSquare(&rbx[-4], B);
0002a6af                  
0002a6b7                  if (zmm0[0] <= (uint32_t)zmm6)
0002a6ca                      zmm1 = (uint32_t)zmm6;
0002a6b7                  else
0002a6b7                  {
0002a6bf                      zmm0 = sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[
0002a6bf                          0])[0]);
0002a6c4                      zmm1 = (float)*(uint64_t*)&zmm0[0];
0002a6b7                  }
0002a6b7                  
0002a6d0                  if (3f <= zmm1)
0002a6db                      *((char*)ADJ(rbx) + 0x440) = 1;
0002a6d0                  else
0002a6d0                  {
0002a6d2                      int64_t rax_4;
0002a6d2                      (uint32_t)rax_4 =
0002a6d2                          ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchDownLocation.x;
0002a6d2                      *(uint32_t*)((char*)rax_4)[4] =
0002a6d2                          ADJ(rbx)->generalTouchData.touchDownCircle[0].TouchDownLocation.y;
0002a6d6                      B->touches[0].position.x = (uint32_t)rax_4;
0002a6d6                      B->touches[0].position.y = *(uint32_t*)((char*)rax_4)[4];
0002a6d0                  }
0002a6a6              }
0002a5f7          }
0002a5f7          
0002a6df          rbx = &rbx[8];
0002a6e3          B = &B->touches[1];
0002a6e7          i = i_1;
0002a6e7          i_1 -= 1;
0002a6eb      } while (i != 1);
0002a548  }

0002a716                                                                    cc cc cc cc cc cc                                    ......

0002a71c    void BoundRadiansTo90(float* radianPtr)

0002a71c  {
0002a72a      uint128_t zmm0;
0002a72a      
0002a72a      if (!(0f <= *(uint32_t*)radianPtr))
0002a72a      {
0002a73b          do
0002a73b          {
0002a730              (uint32_t)zmm0 = (*(uint32_t*)radianPtr) + 1.57079637f;
0002a737              *(uint32_t*)radianPtr = (uint32_t)zmm0;
0002a73b          } while (0f > (uint32_t)zmm0);
0002a72a      }
0002a72a      
0002a749      zmm0 = _mm_cvtps_pd((uint64_t)*(uint32_t*)radianPtr);
0002a749      
0002a764      while ((uint64_t)zmm0 > 0x3ff921fb54442d18)
0002a764      {
0002a752          (uint32_t)zmm0 = (*(uint32_t*)radianPtr) - 1.57079637f;
0002a756          *(uint32_t*)radianPtr = (uint32_t)zmm0;
0002a75d          zmm0 = _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0));
0002a764      }
0002a71c  }

0002a768                          cc cc cc cc cc cc cc cc                                                          ........

0002a770    void GetActualTouchCount(struct sub_sample_t* samples, uint8_t* touchCnt)

0002a770  {
0002a784      int64_t rdi;
0002a784      (uint8_t)rdi = touchCnt[3];
0002a78b      char rbx = 0;
0002a798      memmove(&touchCnt[1], touchCnt, 9);
0002a7a9      uint32_t r8 = (uint32_t)samples->sensor[(uint64_t)*((char*)samples + 0x728)].edgeSet[
0002a7a9          0x27].edgePair[0].edge[0];
0002a7a9      
0002a7b5      if (r8)
0002a7b5      {
0002a7bb          if (r8 == 1)
0002a7bb          {
0002a7cb              if ((uint8_t)rdi <= 1)
0002a800                  rbx = 1;
0002a7cb              else if ((uint8_t)rdi == 2)
0002a7d1              {
0002a7d3                  rbx = 1;
0002a7d5                  char rdx = (uint8_t)rdi;
0002a7d5                  
0002a7dc                  while ((&samples->sensor[0].edgeSet[0].touchCount)[
0002a7dc                      (uint64_t)samples[(int64_t)rdx].trueSensor * 0x70
0002a7dc                      + (int64_t)rdx * 0x1cc] != 2)
0002a7dc                  {
0002a7f9                      char temp1_1 = rdx;
0002a7f9                      rdx -= 1;
0002a7f9                      
0002a7fc                      if (temp1_1 - 1 < 0)
0002a7fc                          goto label_2a807;
0002a7dc                  }
0002a7dc                  
0002a7c3                  rbx = 2;
0002a7d1              }
0002a7bb          }
0002a7bb          else if (r8 == 2)
0002a7c3              rbx = 2;
0002a7b5      }
0002a7b5      
0002a807  label_2a807:
0002a807      touchCnt[3] = rbx;
0002a770  }

0002a81a                                                                                cc cc cc cc cc cc                            ......

0002a820    uint8_t PopulateDataToTriangulate(struct sub_sample_t* sample, uint8_t* touchCnt, struct triangulation_input_t* trigData, uint8_t numSensors, enum trans_state_t tchTrans)

0002a820  {
0002a835      struct sub_sample_t* sample_2;
0002a835      struct sub_sample_t* sample_3 = sample_2;
0002a844      char i = 0;
0002a846      int64_t rsi;
0002a846      (uint8_t)rsi = numSensors;
0002a849      struct triangulation_input_t* trigData_1 = trigData;
0002a84c      uint8_t* touchCnt_1 = touchCnt;
0002a84f      struct sub_sample_t* sample_1 = sample;
0002a852      int64_t rdi;
0002a852      (uint8_t)rdi = 0;
0002a852      
0002a858      if (!tchTrans)
0002aa56          *(uint8_t*)touchCnt = 0;
0002a858      else if (tchTrans == TT_ONE_TRANS)
0002a862      {
0002aa00          (uint8_t)sample_2 = 0;
0002aa00          
0002aa06          if ((uint8_t)rsi > 0)
0002aa06          {
0002aa08              enum touch_trans_t* rbp_1 = &sample_1->sensor[0].edgeSet[0].transitions;
0002aa08              
0002aa4b              do
0002aa4b              {
0002aa1c                  if (ADJ(rbp_1)->sensor[0].edgeSet[0].touchCount == 1 && (
0002aa1c                      ADJ(rbp_1)->sensor[0].edgeSet[0].transitions == ONE_TO_TWO
0002aa1c                      || ADJ(rbp_1)->sensor[0].edgeSet[0].transitions == TWO_TO_ONE))
0002aa1c                  {
0002aa30                      char* rcx_10 = &trigData_1[(uint64_t)(uint8_t)rdi];
0002aa35                      rcx_10[0x24] = (uint8_t)sample_2;
0002aa39                      memmove(rcx_10, &rbp_1[1], 0x24);
0002aa3e                      (uint8_t)rdi += 1;
0002aa1c                  }
0002aa1c                  
0002aa41                  (uint8_t)sample_2 += 1;
0002aa44                  rbp_1 = &rbp_1[0x1c];
0002aa4b              } while ((uint8_t)sample_2 < (uint8_t)rsi);
0002aa06          }
0002aa06          
0002aa4d          *(uint8_t*)touchCnt_1 = 1;
0002a862      }
0002a862      else if (tchTrans == 2)
0002a86c      {
0002a9be          (uint8_t)sample_2 = 0;
0002a9be          
0002a9c4          if ((uint8_t)rsi > 0)
0002a9c4          {
0002a9fc              do
0002a9fc              {
0002a9ce                  if (sample_1->sensor[0].edgeSet[0].touchCount == 1)
0002a9ce                  {
0002a9e1                      char* rcx_8 = &trigData_1[(uint64_t)(uint8_t)rdi];
0002a9e6                      rcx_8[0x24] = (uint8_t)sample_2;
0002a9ea                      memmove(rcx_8, sample_1, 0x24);
0002a9ef                      (uint8_t)rdi += 1;
0002a9ce                  }
0002a9ce                  
0002a9f2                  (uint8_t)sample_2 += 1;
0002a9f5                  sample_1 = &sample_1->sensor[1];
0002a9fc              } while ((uint8_t)sample_2 < (uint8_t)rsi);
0002a9c4          }
0002a9c4          
0002aa4d          *(uint8_t*)touchCnt_1 = 1;
0002a86c      }
0002a86c      else if (tchTrans == 4)
0002a876      {
0002a974          (uint8_t)sample_2 = 0;
0002a974          
0002a97a          if ((uint8_t)rsi > 0)
0002a97a          {
0002a9b3              do
0002a9b3              {
0002a97c                  uint8_t touchCount = sample_1->sensor[0].edgeSet[0].touchCount;
0002a97c                  
0002a985                  if (touchCount == 2 || touchCount == 1)
0002a985                  {
0002a998                      char* rcx_6 = &trigData_1[(uint64_t)(uint8_t)rdi];
0002a99d                      rcx_6[0x24] = (uint8_t)sample_2;
0002a9a1                      memmove(rcx_6, sample_1, 0x24);
0002a9a6                      (uint8_t)rdi += 1;
0002a985                  }
0002a985                  
0002a9a9                  (uint8_t)sample_2 += 1;
0002a9ac                  sample_1 = &sample_1->sensor[1];
0002a9b3              } while ((uint8_t)sample_2 < (uint8_t)rsi);
0002a97a          }
0002a97a          
0002a9b5          *(uint8_t*)touchCnt_1 = 2;
0002a876      }
0002a876      else if (tchTrans == 5)
0002a880      {
0002a886          (uint8_t)trigData_1 = 0;
0002a886          
0002a88c          if (numSensors > 0)
0002a88c          {
0002a88e              sample_2 = sample;
0002a88e              
0002a8c7              do
0002a8c7              {
0002a89a                  if (sample_2->sensor[0].edgeSet[0].touchCount == 2)
0002a89a                  {
0002a8ad                      char* rcx_1 = &trigData[(uint64_t)(uint8_t)rdi];
0002a8b1                      rcx_1[0x24] = (uint8_t)trigData_1;
0002a8b5                      memmove(rcx_1, sample_2, 0x24);
0002a8ba                      (uint8_t)rdi += 1;
0002a89a                  }
0002a89a                  
0002a8bd                  (uint8_t)trigData_1 += 1;
0002a8c0                  sample_2 = &sample_2->sensor[1];
0002a8c7              } while ((uint8_t)trigData_1 < (uint8_t)rsi);
0002a8c7              
0002a8c9              touchCnt_1 = touchCnt;
0002a88c          }
0002a88c          
0002a8ce          *(uint8_t*)touchCnt_1 = 2;
0002a8ce          
0002a8d6          if ((uint8_t)rdi < 3)
0002a8d6          {
0002a8d8              (uint8_t)rdi = 0;
0002a8db              (uint8_t)sample_2 = 0;
0002a8db              
0002a8e1              if ((uint8_t)rsi > 0)
0002a8e1              {
0002a8e8                  uint32_t* rbp = &sample_1->sensor[0].edgeSet[0].specialCases;
0002a8e8                  
0002a924                  do
0002a924                  {
0002a8f6                      if (ADJ(rbp)->sensor[0].edgeSet[0].touchCount == 1
0002a8f6                          && ADJ(rbp)->sensor[0].edgeSet[0].specialCases & 0x1f)
0002a8f6                      {
0002a90a                          char* rcx_3 = &trigData[(uint64_t)(uint8_t)rdi];
0002a90e                          rcx_3[0x24] = (uint8_t)sample_2;
0002a912                          memmove(rcx_3, &rbp[2], 0x24);
0002a917                          (uint8_t)rdi += 1;
0002a8f6                      }
0002a8f6                      
0002a91a                      (uint8_t)sample_2 += 1;
0002a91d                      rbp = &rbp[0x1c];
0002a924                  } while ((uint8_t)sample_2 < (uint8_t)rsi);
0002a924                  
0002a926                  touchCnt_1 = touchCnt;
0002a8e1              }
0002a8e1              
0002a92b              *(uint8_t*)touchCnt_1 = 1;
0002a8d6          }
0002a8d6          
0002a92f          trigData_1 = trigData;
0002a880      }
0002a880      
0002a938      if ((uint8_t)rsi > 4)
0002a93a          (uint8_t)rdi -= 1;
0002a93a      
0002a940      if ((uint8_t)rdi > 0)
0002a940      {
0002a958          do
0002a958          {
0002a94e              if (trigData_1[(uint64_t)i].sensorNum >= (uint8_t)rsi)
0002a950                  (uint8_t)rdi -= 1;
0002a950              
0002a953              i += 1;
0002a958          } while (i < (uint8_t)rdi);
0002a940      }
0002a940      
0002a973      return (uint8_t)rdi;
0002a820  }

0002aa5d                                                                                         cc cc cc                               ...
0002aa60  cc cc cc cc                                                                                      ....

0002aa64    uint8_t TriangulateSample(uint8_t numUsableSnsrs, uint8_t numTouches, struct triangulation_input_t* trigData, struct kite_t* kitesToMatch, struct triangulate_statics_t* tStatics)

0002aa64  {
0002aa69      struct kite_t* kitesToMatch_1 = kitesToMatch;
0002aa74      int64_t rdi;
0002aa74      int64_t var_18 = rdi;
0002aa81      char rbx = 0;
0002aa83      uint32_t numUsableSnsrs_1 = (uint32_t)numUsableSnsrs;
0002aa87      struct triangulation_input_t* trigData_1 = trigData;
0002aa8a      int32_t i = numUsableSnsrs_1 - 1;
0002aa8e      uint64_t rax;
0002aa8e      (uint8_t)rax = numTouches;
0002aa90      uint64_t rbp;
0002aa90      (uint8_t)rbp = 0;
0002aa96      int32_t i_1 = i;
0002aa96      
0002aa9b      if (i > 0)
0002aa9b      {
0002abe2          do
0002abe2          {
0002aaa1              struct kite_t* rsi_1 = (uint64_t)(uint32_t)(rbp + 1);
0002aaac              (uint8_t)rdi = (uint8_t)rsi_1;
0002aaac              
0002aab2              if ((uint8_t)rsi_1 < (uint8_t)numUsableSnsrs_1)
0002aab2              {
0002abc8                  do
0002abc8                  {
0002aaca                      if ((uint8_t)rax == 1)
0002aaca                      {
0002aad4                          struct edge_set_t* sensorASet =
0002aad4                              &trigData_1[(uint64_t)(uint8_t)rbp];
0002aad4                          
0002aadd                          if (sensorASet->touchCount != 1)
0002abbb                              (uint8_t)rax = numTouches;
0002aadd                          else
0002aadd                          {
0002aaeb                              struct edge_set_t* sensorBSet =
0002aaeb                                  &trigData_1[(uint64_t)(uint8_t)rdi];
0002aaeb                              
0002aaf4                              if (sensorBSet->touchCount != 1)
0002abbb                                  (uint8_t)rax = numTouches;
0002aaf4                              else
0002aaf4                              {
0002aafa                                  (uint8_t)kitesToMatch = *((char*)sensorBSet + 0x24);
0002aafe                                  (uint8_t)trigData = *((char*)sensorASet + 0x24);
0002ab19                                  rax = TR_TriangulationHandler(sensorASet, sensorBSet, 
0002ab19                                      (uint8_t)trigData, (uint8_t)kitesToMatch, tStatics, 
0002ab19                                      (uint64_t)rbx * 0xbc + kitesToMatch_1);
0002ab1e                                  bool cond:1_1 = (uint8_t)rax != 1;
0002ab20                                  (uint8_t)rax = numTouches;
0002ab20                                  
0002ab27                                  if (!cond:1_1)
0002ab2d                                      rbx += 1;
0002aaf4                              }
0002aadd                          }
0002aaca                      }
0002aaca                      else if ((uint8_t)rax == 2)
0002ab36                      {
0002ab3c                          rax = (uint64_t)(uint8_t)rbp;
0002ab44                          struct edge_set_t* sensorASet_1 = &trigData_1[rax];
0002ab44                          
0002ab4e                          if (sensorASet_1->touchCount != 2)
0002ab50                              rax = (uint64_t)(uint8_t)rdi;
0002ab50                          
0002ab65                          if ((sensorASet_1->touchCount == 2
0002ab65                              || trigData_1[rax].edgeSet.touchCount == 2)
0002ab65                              && sensorASet_1->touchCount >= 1)
0002ab65                          {
0002ab6f                              void* sensorBSet_1 = &trigData_1[(uint64_t)(uint8_t)rdi];
0002ab6f                              
0002ab78                              if (*(uint8_t*)((char*)sensorBSet_1 + 0x18) >= 1)
0002ab78                              {
0002ab7a                                  (uint8_t)kitesToMatch =
0002ab7a                                      *(uint8_t*)((char*)sensorBSet_1 + 0x24);
0002ab7e                                  (uint8_t)trigData = *((char*)sensorASet_1 + 0x24);
0002ab8d                                  void* r12_3 = (uint64_t)rbx * 0xbc + kitesToMatch_1;
0002ab9d                                  rax = TR_TriangulationHandler(sensorASet_1, sensorBSet_1, 
0002ab9d                                      (uint8_t)trigData, (uint8_t)kitesToMatch, tStatics, 
0002ab9d                                      r12_3);
0002ab9d                                  
0002aba4                                  if ((uint8_t)rax == 1)
0002aba4                                  {
0002abaf                                      if (*(uint32_t*)((char*)r12_3 + 0xb4) == 1)
0002abb4                                          rax = KI_SortKite(r12_3);
0002abb4                                      
0002abb9                                      rbx += 1;
0002aba4                                  }
0002ab78                              }
0002ab65                          }
0002ab65                          
0002abbb                          (uint8_t)rax = numTouches;
0002ab36                      }
0002ab36                      
0002abc2                      (uint8_t)rdi += 1;
0002abc8                  } while ((uint8_t)rdi < (uint8_t)numUsableSnsrs_1);
0002abc8                  
0002abce                  (uint8_t)rsi_1 = (uint8_t)rsi_1;
0002abd6                  i = i_1;
0002aab2              }
0002aab2              
0002abdb              rbp = (uint64_t)(uint8_t)rsi_1;
0002abe2          } while ((uint32_t)rbp < i);
0002aa9b      }
0002aa9b      
0002abe8      (uint8_t)rax = rbx;
0002ac01      return (uint8_t)rax;
0002aa64  }

0002ac02        cc cc cc cc cc cc                                                                            ......

0002ac08    uint8_t ResolveTouches(uint8_t* numTrigs, struct kite_t* kitesToMatch)

0002ac08  {
0002ac27      int64_t rsi;
0002ac27      (uint8_t)rsi = *(uint8_t*)numTrigs;
0002ac2d      uint8_t* numTrigs_2 = numTrigs;
0002ac30      char rdi = 1;
0002ac3e      void* rax;
0002ac3e      
0002ac3e      if ((uint8_t)rsi)
0002ac3e      {
0002ac4b          void* rbx_3 = (uint64_t)(uint8_t)rsi * 0xbc + kitesToMatch;
0002ac92          char i;
0002ac92          
0002ac92          do
0002ac92          {
0002ac52              if (*(uint32_t*)((char*)rbx_3 - 8) == 3)
0002ac52              {
0002ac54                  *(uint8_t*)numTrigs_2 -= 1;
0002ac58                  rax = (uint64_t)*(uint8_t*)numTrigs_2;
0002ac5d                  numTrigs = (uint64_t)(uint8_t)rsi;
0002ac61                  int32_t rdx = (int32_t)&numTrigs[-1];
0002ac61                  
0002ac66                  if (rdx < (uint32_t)rax)
0002ac86                      rax = memmove((int64_t)rdx * 0xbc + kitesToMatch, rbx_3, 
0002ac86                          (int64_t)((uint32_t)rax - (uint32_t)numTrigs + 1) * 0xbc);
0002ac52              }
0002ac52              
0002ac8b              rbx_3 -= 0xbc;
0002ac8e              i = (uint8_t)rsi;
0002ac8e              (uint8_t)rsi -= 1;
0002ac92          } while (i != 1);
0002ac3e      }
0002ac3e      
0002ac99      void* kiteA_2;
0002ac99      
0002ac99      if (*(uint8_t*)numTrigs_2 > 3)
0002ac99      {
0002ac9f          int64_t r13;
0002ac9f          (uint8_t)r13 = *(uint8_t*)numTrigs_2;
0002aca5          int64_t var_108;
0002aca5          __builtin_memset(&var_108, 0, 0x18);
0002aca5          
0002acb7          if ((uint8_t)r13 > 0)
0002acb7          {
0002acb9              int64_t* rbx_4 = &var_108;
0002acbe              struct kite_t* kitesToMatch_1 = kitesToMatch;
0002acc1              uint64_t i_3 = (uint64_t)(uint8_t)r13;
0002ad1f              uint64_t i_1;
0002ad1f              
0002ad1f              do
0002ad1f              {
0002acd0                  char var_e8[0x28];
0002acd0                  memmove(&var_e8, kitesToMatch_1, 0xbc);
0002acd5                  void var_c0;
0002acd5                  rax = &var_c0;
0002acdd                  numTrigs = 4;
0002ace2                  float zmm5 = 1.00000002e+20f;
0002acfa                  uint8_t* j;
0002acfa                  
0002acfa                  do
0002acfa                  {
0002aced                      if (!(zmm5 <= *(uint32_t*)rax))
0002acef                          zmm5 = *(uint32_t*)rax;
0002acef                      
0002acf3                      rax += 0x2c;
0002acf7                      j = numTrigs;
0002acf7                      numTrigs -= 1;
0002acfa                  } while (j != 1);
0002acfc                  *(uint32_t*)rbx_4 = zmm5;
0002acfc                  
0002ad07                  if (kitesToMatch_1->singleOcclusion == 1)
0002ad11                      *(uint32_t*)rbx_4 = zmm5 - 3.14159274f;
0002ad11                  
0002ad15                  kitesToMatch_1 = &kitesToMatch_1[1];
0002ad18                  rbx_4 += 4;
0002ad1c                  i_1 = i_3;
0002ad1c                  i_3 -= 1;
0002ad1f              } while (i_1 != 1);
0002acb7          }
0002acb7          
0002ad24          if ((uint8_t)r13)
0002ad24          {
0002ad26              void** r9_1 = &kiteA_2;
0002ad7f              char i_2;
0002ad7f              
0002ad7f              do
0002ad7f              {
0002ad2b                  char numTrigs_1 = 0;
0002ad2e                  (uint8_t)numTrigs = 1;
0002ad2e                  
0002ad35                  if (*(uint8_t*)numTrigs_2 > 1)
0002ad35                  {
0002ad37                      void* rdx_3 = &*(uint64_t*)((char*)var_108)[4];
0002ad37                      
0002ad59                      do
0002ad59                      {
0002ad3c                          *(uint32_t*)rdx_3;
0002ad3c                          *(uint32_t*)rdx_3;
0002ad3c                          int32_t zmm0;
0002ad3c                          *(uint8_t*)((char*)zmm0)[8] = *(uint8_t*)((char*)rdx_3 + 8);
0002ad3c                          *(uint8_t*)((char*)zmm0)[9] = *(uint8_t*)((char*)rdx_3 + 9);
0002ad3c                          
0002ad49                          if (!(*(uint32_t*)rdx_3
0002ad49                                  <= *(uint32_t*)(&var_108 + ((uint64_t)numTrigs_1 << 2))))
0002ad4b                              numTrigs_1 = (uint8_t)numTrigs;
0002ad4b                          
0002ad4e                          (uint8_t)numTrigs += 1;
0002ad51                          rdx_3 += 4;
0002ad59                      } while ((uint8_t)numTrigs < *(uint8_t*)numTrigs_2);
0002ad35                  }
0002ad35                  
0002ad5b                  numTrigs = (uint64_t)numTrigs_1;
0002ad62                  *(uint32_t*)(&var_108 + (numTrigs << 2)) = 0xe0ad78ec;
0002ad74                  *(uint64_t*)r9_1 = numTrigs * 0xbc + kitesToMatch;
0002ad77                  r9_1 = &r9_1[1];
0002ad7b                  i_2 = (uint8_t)r13;
0002ad7b                  (uint8_t)r13 -= 1;
0002ad7f              } while (i_2 != 1);
0002ad24          }
0002ac99      }
0002ac99      
0002ad81      uint32_t rcx_4 = (uint32_t)*(uint8_t*)numTrigs_2;
0002ad81      
0002ad90      if (!rcx_4 || rcx_4 == 1)
0002aeab          rdi = 0;
0002ad90      else
0002ad90      {
0002ad98          float retSquareError;
0002ad98          
0002ad98          if (rcx_4 == 2)
0002aea4              KI_Match2Kites(kitesToMatch, &kitesToMatch[1], &retSquareError);
0002ad98          else if (rcx_4 == 3)
0002ae8b              KI_Match3Kites(kitesToMatch, &kitesToMatch[1], &kitesToMatch[2], 
0002ae8b                  &retSquareError);
0002ada0          else
0002ada0          {
0002ada8              struct kite_t* kiteB;
0002ada8              struct kite_t* kiteC;
0002ada8              struct kite_t* kiteB_1;
0002ada8              void* kiteA;
0002ada8              
0002ada8              if (rcx_4 == 4)
0002ada8              {
0002ae42                  kiteA = kiteA_2;
0002ae5c                  KI_Match3Kites(kiteA, kiteB, kiteC, &retSquareError);
0002ae66                  *(uint32_t*)((char*)kiteA + 0xb4) = 5;
0002aea4                  KI_Match2Kites(kiteA, kiteB_1, &retSquareError);
0002ada8              }
0002ada8              else
0002ada8              {
0002adb0                  struct kite_t* kiteC_1;
0002adb0                  
0002adb0                  if (rcx_4 == 5)
0002adb0                  {
0002ae0a                      struct kite_t* kiteA_1 = kiteA_2;
0002ae24                      KI_Match3Kites(kiteA_1, kiteB, kiteC, &retSquareError);
0002ae33                      kiteA_1->state = K_FORCED;
0002ae8b                      KI_Match3Kites(kiteA_1, kiteB_1, kiteC_1, &retSquareError);
0002adb0                  }
0002adb0                  else if (rcx_4 != 6)
0002aeab                      rdi = 0;
0002adb4                  else
0002adb4                  {
0002adba                      kiteA = kiteA_2;
0002add4                      KI_Match3Kites(kiteA, kiteB, kiteC, &retSquareError);
0002adee                      *(uint32_t*)((char*)kiteA + 0xb4) = 5;
0002adf8                      KI_Match3Kites(kiteA, kiteB_1, kiteC_1, &retSquareError);
0002aea4                      struct kite_t* kiteB_2;
0002aea4                      KI_Match2Kites(kiteA, kiteB_2, &retSquareError);
0002adb4                  }
0002ada8              }
0002ada0          }
0002ad90      }
0002ad90      
0002aeb6      (uint8_t)rax = rdi;
0002aed1      return (uint8_t)rax;
0002ac08  }

0002aed2                                                        cc cc cc cc cc cc                                            ......

0002aed8    uint8_t IsPointInTriangle(struct fpoint_t* triangle, struct fpoint_t point)

0002aed8  {
0002aedf      struct fpoint_t r8;
0002aedf      r8.x = triangle->x;
0002aedf      r8.y = triangle->y;
0002aee2      struct fpoint_t rax;
0002aee2      rax.x = *(int64_t*)((char*)triangle + 0x10);
0002aee2      rax.y = *(int64_t*)((char*)triangle + 0x14);
0002aeeb      struct fpoint_t arg_8;
0002aeeb      arg_8.x = rax.x;
0002aeeb      arg_8.y = rax.y;
0002aeef      struct fpoint_t rax_1;
0002aeef      rax_1.x = *(int64_t*)((char*)triangle + 8);
0002aeef      rax_1.y = *(int64_t*)((char*)triangle + 0xc);
0002aef3      struct fpoint_t arg_10;
0002aef3      arg_10.x = r8.x;
0002aef3      arg_10.y = r8.y;
0002af1b      float x = arg_8.x - arg_10.x;
0002af21      float y = arg_8.y - arg_10.y;
0002af27      arg_8.x = rax_1.x;
0002af27      arg_8.y = rax_1.y;
0002af2b      arg_10.x = r8.x;
0002af2b      arg_10.y = r8.y;
0002af3b      float y_2 = y;
0002af41      struct fpoint_t rcx;
0002af41      rcx.x = x;
0002af41      rcx.y = x;
0002af45      x = arg_8.x - arg_10.x;
0002af4b      y = arg_8.y;
0002af51      arg_8.x = point.x;
0002af51      arg_8.y = point.y;
0002af55      y = y - arg_10.y;
0002af5b      float x_2 = x;
0002af67      arg_10.x = r8.x;
0002af67      arg_10.y = r8.y;
0002af6b      x = arg_8.x - arg_10.x;
0002af71      float y_3 = y;
0002af77      y = arg_8.y;
0002af7d      int64_t rdx;
0002af7d      (uint32_t)rdx = x_2;
0002af7d      *(uint32_t*)((char*)rdx)[4] = x_2;
0002af81      arg_8.x = rcx.x;
0002af81      arg_8.y = rcx.y;
0002af85      y = y - arg_10.y;
0002af91      float x_1 = x;
0002af97      arg_10.x = rcx.x;
0002af97      arg_10.y = rcx.y;
0002af9b      int128_t zmm6;
0002af9b      (uint32_t)zmm6 = arg_8.y * arg_10.y;
0002afa1      x = arg_8.x;
0002afa7      float y_1 = y;
0002afad      struct fpoint_t rax_2;
0002afad      rax_2.x = x_1;
0002afad      rax_2.y = x_1;
0002afb2      arg_8.x = (uint32_t)rdx;
0002afb2      arg_8.y = *(uint32_t*)((char*)rdx)[4];
0002afbc      x = x * arg_10.x;
0002afc2      arg_10.x = rcx.x;
0002afc2      arg_10.y = rcx.y;
0002afc6      float zmm5 = arg_8.y * arg_10.y;
0002afcc      (uint32_t)zmm6 = (uint32_t)zmm6 + x;
0002afd0      x = arg_8.x;
0002afd6      arg_8.x = rax_2.x;
0002afd6      arg_8.y = rax_2.y;
0002afda      x = x * arg_10.x;
0002afe6      arg_10.x = rcx.x;
0002afe6      arg_10.y = rcx.y;
0002afea      float zmm4 = arg_8.y * arg_10.y;
0002aff0      zmm5 = zmm5 + x;
0002aff4      x = arg_8.x;
0002affa      arg_8.x = (uint32_t)rdx;
0002affa      arg_8.y = *(uint32_t*)((char*)rdx)[4];
0002affe      x = x * arg_10.x;
0002b00a      arg_10.x = (uint32_t)rdx;
0002b00a      arg_10.y = *(uint32_t*)((char*)rdx)[4];
0002b00e      int128_t zmm8;
0002b00e      (uint32_t)zmm8 = arg_8.y * arg_10.y;
0002b014      zmm4 = zmm4 + x;
0002b018      x = arg_8.x;
0002b01e      arg_8.x = rax_2.x;
0002b01e      arg_8.y = rax_2.y;
0002b022      x = x * arg_10.x;
0002b02e      arg_10.x = (uint32_t)rdx;
0002b02e      arg_10.y = *(uint32_t*)((char*)rdx)[4];
0002b032      int128_t zmm7;
0002b032      (uint32_t)zmm7 = arg_8.y * arg_10.y;
0002b038      (uint32_t)zmm8 = (uint32_t)zmm8 + x;
0002b051      (uint32_t)zmm7 = (uint32_t)zmm7 + arg_8.x * arg_10.x;
0002b064      float zmm0 = _divide(1f, (uint32_t)zmm8 * (uint32_t)zmm6 - zmm5 * zmm5);
0002b06c      (uint32_t)zmm8 = (uint32_t)zmm8 * zmm4;
0002b075      (uint32_t)zmm8 = (uint32_t)zmm8 - (uint32_t)zmm7 * zmm5;
0002b07d      (uint32_t)zmm7 = (uint32_t)zmm7 * (uint32_t)zmm6;
0002b085      (uint32_t)zmm7 = (uint32_t)zmm7 - zmm4 * zmm5;
0002b089      (uint32_t)zmm8 = (uint32_t)zmm8 * zmm0;
0002b08e      (uint32_t)zmm7 = (uint32_t)zmm7 * zmm0;
0002b08e      
0002b09b      if ((uint32_t)zmm8 <= 0f || (uint32_t)zmm7 <= 0f)
0002b0ac          rax_2.x = 0;
0002b09b      else
0002b09b      {
0002b09d          (uint32_t)zmm7 = (uint32_t)zmm7 + (uint32_t)zmm8;
0002b09d          
0002b0a6          if (1f <= (uint32_t)zmm7)
0002b0ac              rax_2.x = 0;
0002b0a6          else
0002b0a8              rax_2.x = 1;
0002b09b      }
0002b09b      
0002b0c8      return rax_2.x;
0002aed8  }

0002b0c9                             cc cc cc cc cc cc cc                                                           .......

0002b0d0    void EliminatePtsNotInTriangle(struct fpoint_t* triangle, struct kite_t* kite)

0002b0d0  {
0002b15d      for (char i = 0; i < 4; i += 1)
0002b15d      {
0002b0e6          struct fpoint_t* rdx_1 = (uint64_t)i * 0x2c;
0002b0ea          struct fpoint_t point;
0002b0ea          point.x = *(uint32_t*)((char*)rdx_1 + kite);
0002b0ea          point.y = *(uint32_t*)(&rdx_1->y + kite);
0002b0ee          uint8_t rax_1 = IsPointInTriangle(triangle, point);
0002b0ee          
0002b0f5          if (!rax_1)
0002b0f5          {
0002b100              if (!i || i == 2)
0002b100              {
0002b139                  if (kite->state == K_FORCED && kite->solvedIdx[0] != 1)
0002b139                  {
0002b164                      kite->state = K_INVALID;
0002b164                      break;
0002b139                  }
0002b139                  
0002b13b                  kite->solvedIdx[0] = 1;
0002b143                  kite->solvedIdx[1] = 3;
0002b100              }
0002b100              else
0002b100              {
0002b113                  if (kite->state == K_FORCED && kite->solvedIdx[0] != rax_1)
0002b113                  {
0002b164                      kite->state = K_INVALID;
0002b164                      break;
0002b113                  }
0002b113                  
0002b115                  kite->solvedIdx[0] = 0;
0002b11d                  kite->solvedIdx[1] = 2;
0002b100              }
0002b100              
0002b14b              kite->state = K_FORCED;
0002b0f5          }
0002b15d      }
0002b0d0  }

0002b175                                                                 cc cc cc cc cc cc cc                                   .......

0002b17c    uint8_t FinalTriangulation(struct sub_sample_t* sample, struct true_edge_set_t* trueEdges, struct kite_t const* kites, uint8_t numKites, uint8_t numTouches, struct touches_t* retTouches, float* triangErr)

0002b17c  {
0002b19d      struct touches_t* retTouches_1 = retTouches;
0002b1b6      int64_t rbp;
0002b1b6      (uint8_t)rbp = numKites;
0002b1b9      int64_t rsi;
0002b1b9      (uint8_t)rsi = 0;
0002b1bc      int64_t r15;
0002b1bc      (uint8_t)r15 = 0;
0002b1bf      struct sub_sample_t* rdi;
0002b1bf      (uint8_t)rdi = 0;
0002b1c2      memset(retTouches_1, 0, 0x30);
0002b1d2      memset(trueEdges, 0, 0x9c);
0002b1e2      int32_t var_98[0xc];
0002b1e2      memset(&var_98, 0, 0x30);
0002b1f2      int32_t var_c8[0xc];
0002b1f2      memset(&var_c8, 0, 0x30);
0002b1ff      struct frame_id_t rax;
0002b1ff      rax.id = sample->id.id;
0002b1ff      rax.deltaTimeStamp = sample->id.deltaTimeStamp;
0002b205      trueEdges->id.id = rax.id;
0002b205      trueEdges->id.deltaTimeStamp = rax.deltaTimeStamp;
0002b20c      uint64_t rax_1 = (uint64_t)sample->id.id;
0002b212      retTouches_1->id.id = (uint16_t)rax_1;
0002b212      retTouches_1->id.deltaTimeStamp = *(uint16_t*)((char*)rax_1)[2];
0002b212      
0002b219      if ((uint8_t)rbp > 0)
0002b219      {
0002b227          int64_t r10_1 = 0;
0002b22a          char* r11_1 = &kites->solvedIdx[1];
0002b232          uint64_t i_1 = (uint64_t)(uint8_t)rbp;
0002b345          var_c4;
0002b345          var_c0;
0002b345          var_94;
0002b345          var_90;
0002b345          uint64_t rdx;
0002b345          void* r8;
0002b345          uint64_t i;
0002b345          
0002b345          do
0002b345          {
0002b23e              int64_t j_2 = 2;
0002b247              rax_1 = (uint64_t)ADJ(r11_1)->solvedIdx[0] * 0x2c + r10_1;
0002b24a              void* r9 = &kites->kPt[0].sourceST[rax_1];
0002b24f              r8 = &kites->kPt[0].sourceLines + rax_1;
0002b2b1              int64_t j;
0002b2b1              
0002b2b1              do
0002b2b1              {
0002b254                  (uint8_t)rax_1 = *(uint8_t*)r9;
0002b25d                  (uint8_t)rax_1 u>>= 4;
0002b260                  uint64_t rcx_5 = (uint64_t)(uint8_t)rax_1;
0002b263                  rdx = rcx_5 * 3;
0002b263                  
0002b26c                  if (!
0002b26c                      ((*(uint32_t*)((char*)r8 + 8)) <= *(uint32_t*)(&var_90 + (rdx << 2))))
0002b26c                  {
0002b271                      var_98[rdx] = *(uint32_t*)r8;
0002b279                      *(uint32_t*)(&var_94 + (rdx << 2)) = *(uint32_t*)((char*)r8 + 4);
0002b281                      *(uint32_t*)(&var_90 + (rdx << 2)) = *(uint32_t*)((char*)r8 + 8);
0002b29a                      (uint8_t)rsi += 1;
0002b2a1                      trueEdges->edgeSet[rcx_5].edgePair[0].edge = *(uint64_t*)(
0002b2a1                          (char*)sample
0002b2a1                          + ((((uint64_t)*(uint8_t*)r9 & 0xf) + rcx_5 * 0xe) << 3));
0002b26c                  }
0002b26c                  
0002b2a6                  r8 += 0xc;
0002b2aa                  r9 += 1;
0002b2ad                  j = j_2;
0002b2ad                  j_2 -= 1;
0002b2b1              } while (j != 1);
0002b2b1              
0002b2bb              if (numTouches == 2)
0002b2bb              {
0002b2c1                  int64_t j_3 = 2;
0002b2ca                  rax_1 = (uint64_t)ADJ(r11_1)->solvedIdx[1] * 0x2c + r10_1;
0002b2cd                  void* r9_1 = &kites->kPt[0].sourceST[rax_1];
0002b2d2                  r8 = &kites->kPt[0].sourceLines + rax_1;
0002b334                  int64_t j_1;
0002b334                  
0002b334                  do
0002b334                  {
0002b2d7                      (uint8_t)rax_1 = *(uint8_t*)r9_1;
0002b2e0                      (uint8_t)rax_1 u>>= 4;
0002b2e3                      uint64_t rcx_7 = (uint64_t)(uint8_t)rax_1;
0002b2e6                      rdx = rcx_7 * 3;
0002b2e6                      
0002b2ef                      if (!((*(uint32_t*)((char*)r8 + 8))
0002b2ef                          <= *(uint32_t*)(&var_c0 + (rdx << 2))))
0002b2ef                      {
0002b2f4                          var_c8[rdx] = *(uint32_t*)r8;
0002b2fc                          *(uint32_t*)(&var_c4 + (rdx << 2)) = *(uint32_t*)((char*)r8 + 4);
0002b304                          *(uint32_t*)(&var_c0 + (rdx << 2)) = *(uint32_t*)((char*)r8 + 8);
0002b31d                          (uint8_t)r15 += 1;
0002b324                          trueEdges->edgeSet[rcx_7].edgePair[1].edge = *(uint64_t*)(
0002b324                              (char*)sample
0002b324                              + ((((uint64_t)*(uint8_t*)r9_1 & 0xf) + rcx_7 * 0xe) << 3));
0002b2ef                      }
0002b2ef                      
0002b329                      r8 += 0xc;
0002b32d                      r9_1 += 1;
0002b330                      j_1 = j_3;
0002b330                      j_3 -= 1;
0002b334                  } while (j_1 != 1);
0002b2bb              }
0002b2bb              
0002b33b              r10_1 += 0xbc;
0002b33e              r11_1 = &r11_1[0xbc];
0002b341              i = i_1;
0002b341              i_1 -= 1;
0002b345          } while (i != 1);
0002b34b          retTouches_1 = retTouches;
0002b353          (uint8_t)rdi = 0;
0002b353          
0002b35a          if ((uint8_t)rsi > 1)
0002b35a          {
0002b360              (uint8_t)r8 = 0;
0002b363              (uint8_t)rdx = 0;
0002b368              struct line_def_t lines;
0002b368              var_64;
0002b368              var_60;
0002b368              
0002b368              if ((uint8_t)rsi > 0)
0002b368              {
0002b36e                  while ((uint8_t)r8 < 4)
0002b36e                  {
0002b374                      uint64_t r9_2 = (uint64_t)(uint8_t)r8 * 3;
0002b374                      
0002b38a                      if (!(_mm_cvtps_pd((uint64_t)*(uint32_t*)(&var_90 + (r9_2 << 2)))
0002b38a                          <= 0.0001))
0002b38a                      {
0002b38c                          uint64_t rax_17 = (uint64_t)(uint8_t)rdx;
0002b38f                          (uint8_t)rdx += 1;
0002b391                          uint64_t rcx_9 = rax_17 * 3;
0002b39a                          *(uint32_t*)(&lines + (rcx_9 << 2)) = var_98[r9_2];
0002b3a6                          *(uint32_t*)(&var_64 + (rcx_9 << 2)) =
0002b3a6                              *(uint32_t*)(&var_94 + (r9_2 << 2));
0002b3b2                          *(uint32_t*)(&var_60 + (rcx_9 << 2)) =
0002b3b2                              *(uint32_t*)(&var_90 + (r9_2 << 2));
0002b38a                      }
0002b38a                      
0002b3b9                      (uint8_t)r8 += 1;
0002b3b9                      
0002b3bf                      if ((uint8_t)rdx >= (uint8_t)rsi)
0002b3bf                          break;
0002b36e                  }
0002b368              }
0002b368              
0002b3d4              rax_1 = MinDistTriangQ(&lines, (uint8_t)rdx, triangErr);
0002b3d9              (uint8_t)rdi = 1;
0002b3dc              retTouches_1->touches[0].position.x = (uint32_t)rax_1;
0002b3dc              retTouches_1->touches[0].position.y = *(uint32_t*)((char*)rax_1)[4];
0002b3dc              
0002b3e3              if ((uint8_t)r15 > 1)
0002b3e3              {
0002b3e5                  float* r8_1;
0002b3e5                  (uint8_t)r8_1 = 0;
0002b3e8                  (uint8_t)rdx = 0;
0002b3e8                  
0002b3ed                  if ((uint8_t)r15 > 0)
0002b3ed                  {
0002b3f3                      while ((uint8_t)r8_1 < 4)
0002b3f3                      {
0002b3f9                          uint64_t r9_3 = (uint64_t)(uint8_t)r8_1 * 3;
0002b3f9                          
0002b40f                          if (!(_mm_cvtps_pd((uint64_t)*(uint32_t*)(&var_c0 + (r9_3 << 2)))
0002b40f                              <= 0.0001))
0002b40f                          {
0002b411                              uint64_t rax_22 = (uint64_t)(uint8_t)rdx;
0002b414                              (uint8_t)rdx += 1;
0002b416                              uint64_t rcx_11 = rax_22 * 3;
0002b41f                              *(uint32_t*)(&lines + (rcx_11 << 2)) = var_c8[r9_3];
0002b42b                              *(uint32_t*)(&var_64 + (rcx_11 << 2)) =
0002b42b                                  *(uint32_t*)(&var_c4 + (r9_3 << 2));
0002b437                              *(uint32_t*)(&var_60 + (rcx_11 << 2)) =
0002b437                                  *(uint32_t*)(&var_c0 + (r9_3 << 2));
0002b40f                          }
0002b40f                          
0002b43e                          (uint8_t)r8_1 += 1;
0002b43e                          
0002b444                          if ((uint8_t)rdx >= (uint8_t)r15)
0002b444                              break;
0002b3f3                      }
0002b3ed                  }
0002b3ed                  
0002b452                  rax_1 = MinDistTriangQ(&lines, (uint8_t)rdx, &triangErr[1]);
0002b457                  (uint8_t)rdi = 2;
0002b45a                  retTouches_1->touches[1].position.x = (uint32_t)rax_1;
0002b45a                  retTouches_1->touches[1].position.y = *(uint32_t*)((char*)rax_1)[4];
0002b3e3              }
0002b35a          }
0002b219      }
0002b219      
0002b46e      retTouches_1->touchCount = (uint8_t)rdi;
0002b472      (uint8_t)rax_1 = (uint8_t)rdi == numTouches;
0002b487      return (uint8_t)rax_1;
0002b17c  }

0002b488                          cc cc cc cc cc cc cc cc                                                          ........

0002b490    float FindDeltaAngle(float angleA, float angleB)

0002b490  {
0002b490      float zmm3[0x4] = angleA;
0002b493      angleA = 2.38107416e+38f;
0002b49b      float temp0[0x4] = _mm_unpacklo_ps(zmm3, *(uint64_t*)&zmm3[0]);
0002b49b      
0002b4a5      if (_mm_cvtps_pd(*(uint64_t*)&temp0[0])[0] > angleA)
0002b55e          zmm3 = {0};
0002b4a5      else
0002b4a5      {
0002b4ab          int64_t zmm4 = -0x3ff6de04abbbd2e8;
0002b4b3          zmm3 = _mm_unpacklo_ps(temp0, *(uint64_t*)&temp0[0]);
0002b4b3          
0002b4bd          if (zmm4 > _mm_cvtps_pd(*(uint64_t*)&zmm3[0])[0])
0002b55e              zmm3 = {0};
0002b4bd          else
0002b4bd          {
0002b4c3              float temp0_4 = _mm_unpacklo_ps(angleB, angleB);
0002b4c3              
0002b4cd              if (_mm_cvtps_pd(temp0_4)[0] > angleA)
0002b55e                  zmm3 = {0};
0002b4cd              else
0002b4cd              {
0002b4d3                  angleB = _mm_unpacklo_ps(temp0_4, temp0_4);
0002b4d3                  
0002b4dd                  if (zmm4 > _mm_cvtps_pd(angleB))
0002b55e                      zmm3 = {0};
0002b4dd                  else
0002b4dd                  {
0002b4ea                      double zmm2[0x2] = 0x400921fb54442d18;
0002b4ea                      
0002b4ff                      while (true)
0002b4ff                      {
0002b4ff                          zmm3 = _mm_unpacklo_ps(zmm3, *(uint64_t*)&zmm3[0]);
0002b4ff                          
0002b509                          if (!(_mm_cvtps_pd(*(uint64_t*)&zmm3[0]) > zmm2[0]))
0002b509                              break;
0002b509                          
0002b4fb                          zmm3[0] = zmm3[0] + 0f - 3.14159274f;
0002b4ff                      }
0002b4ff                      
0002b518                      float temp0_10;
0002b518                      
0002b518                      while (true)
0002b518                      {
0002b518                          temp0_10 = _mm_unpacklo_ps(angleB, angleB);
0002b518                          
0002b522                          if (!(_mm_cvtps_pd(temp0_10) > zmm2[0]))
0002b522                              break;
0002b522                          
0002b514                          angleB = temp0_10 + 0f - 3.14159274f;
0002b518                      }
0002b518                      
0002b524                      zmm2 = 0x7fffffffffffffff;
0002b52c                      zmm3[0] = zmm3[0] - temp0_10;
0002b533                      float temp0_13 =
0002b533                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm3, *(uint64_t*)&zmm3[0])[0]);
0002b536                      zmm3 = 0x3fc90fdb;
0002b546                      angleB = (float)_mm_and_pd(temp0_13, zmm2) - 1.57079637f;
0002b558                      zmm3[0] = 1.57079637f - (float)_mm_and_pd(
0002b558                          _mm_cvtps_pd(_mm_unpacklo_ps(angleB, angleB)), zmm2);
0002b4dd                  }
0002b4cd              }
0002b4bd          }
0002b4a5      }
0002b4a5      
0002b564      return zmm3[0];
0002b490  }

0002b565                 cc cc cc cc cc cc cc                                                                   .......

0002b56c    void ConvertToRad(uint8_t sensor, float* edges, uint8_t edgeCnt, float* angles)

0002b56c  {
0002b56c      char r10 = 0;
0002b56c      
0002b572      if (!edgeCnt)
0002b572          return;
0002b572      
0002b584      uint32_t sensor_1 = (uint32_t)sensor;
0002b584      
0002b5d2      do
0002b5d2      {
0002b58e          uint64_t rax_1;
0002b58e          
0002b58e          if (!sensor_1)
0002b58e          {
0002b5b5          label_2b5b5:
0002b5b5              rax_1 = (uint64_t)r10;
0002b5c6              angles[rax_1] = edges[rax_1] * 0.001953125f + 0.785398185f;
0002b58e          }
0002b58e          else if (sensor_1 == 1)
0002b593          {
0002b59f          label_2b59f:
0002b59f              rax_1 = (uint64_t)r10;
0002b5c6              angles[rax_1] = 0.785398185f - edges[rax_1] * 0.001953125f;
0002b593          }
0002b593          else
0002b593          {
0002b598              if (sensor_1 == 2)
0002b598                  goto label_2b5b5;
0002b598              
0002b59d              if (sensor_1 == 3)
0002b59d                  goto label_2b59f;
0002b593          }
0002b5cc          r10 += 1;
0002b5d2      } while (r10 < edgeCnt);
0002b56c  }

0002b5d6                                                                    cc cc cc cc cc cc                                    ......

0002b5dc    struct fpoint_t SingleOcclusionTouchCentre(struct edge_pair_t* occludedSensorEdges, enum edge_type_t occludedEdgeIdx, struct sensor_info_t* occludedSensor, struct edge_pair_t* twoTouchSensorEdges, enum edge_type_t twoTouchEdgeIdx, struct sensor_info_t* twoTouchSensor, uint8_t kitePos)

0002b5dc  {
0002b5f4      int64_t twoTouchEdgeIdx_1 = (int64_t)twoTouchEdgeIdx;
0002b601      int64_t occludedEdgeIdx_1 = (int64_t)occludedEdgeIdx;
0002b61b      struct fpoint_t rax = CTL_Triangulate(twoTouchSensorEdges->edge[twoTouchEdgeIdx_1], 
0002b61b          occludedSensorEdges->edge[occludedEdgeIdx_1], twoTouchSensor, occludedSensor);
0002b620      struct sensor_info_t sensorBInfo;
0002b620      sensorBInfo.position.x = rax.x;
0002b620      sensorBInfo.position.y = rax.y;
0002b625      rax.x = kitePos;
0002b643      sensorBInfo.rotation_offset = 0;
0002b653      float sensorBAngle = (twoTouchSensor->rotation_offset
0002b653          + twoTouchSensorEdges->edge[twoTouchEdgeIdx_1]
0002b653          + occludedSensorEdges->edge[occludedEdgeIdx_1] + occludedSensor->rotation_offset)
0002b653          * 0.5f;
0002b653      
0002b65d      if (rax.x == 1 || rax.x == 3)
0002b65f          sensorBAngle = sensorBAngle + 1.57079637f;
0002b65f      
0002b69d      return CTL_Triangulate(
0002b69d          (twoTouchSensorEdges->edge[1] + twoTouchSensorEdges->edge[0]) * 0.5f, 
0002b69d          sensorBAngle, twoTouchSensor, &sensorBInfo);
0002b5dc  }

0002b69e                                                                                            cc cc                                ..
0002b6a0  cc cc cc cc                                                                                      ....

0002b6a4    struct kite_t* TriangulateSingleOcclusion(struct kite_t* __return, struct edge_set_t* occludedSensor, uint8_t occludedSensorNum, struct edge_set_t* twoTouchSensor, uint8_t twoTouchSensorNum, struct triangulate_statics_t* statics)

0002b6a4  {
0002b6cd      struct triangulate_statics_t* statics_1 = statics;
0002b6d8      uint32_t occludedSensorNum_1 = (uint32_t)occludedSensorNum;
0002b6e3      char var_a8 = 0;
0002b6ea      int32_t var_a4 = 0;
0002b6f1      int128_t zmm6;
0002b6f1      int128_t var_48 = zmm6;
0002b6f6      int32_t var_e0 = 0xbf800000;
0002b6ff      int32_t var_d4 = 0x3f800000;
0002b708      int32_t var_c8 = 0xbf800000;
0002b711      int32_t var_bc = 0x3f800000;
0002b71a      char var_a0 = 0;
0002b721      int32_t var_9c = 1;
0002b728      char var_98 = 1;
0002b72f      int32_t var_94 = 1;
0002b736      char var_90 = 0;
0002b73d      int32_t var_8c = 1;
0002b744      char var_88 = 1;
0002b74b      int32_t var_84 = 1;
0002b752      struct sensor_info_t* snsInfo = statics_1->snsInfo;
0002b761      struct edge_set_t* twoTouchSensor_1 = twoTouchSensor;
0002b77a      struct kite_t* kite = __return;
0002b78d      char var_80 = 0;
0002b791      int32_t var_7c = 0;
0002b795      float zmm1 = snsInfo->position.x * -1f;
0002b799      float var_dc =
0002b799          *(int64_t*)((char*)snsInfo + 0x1c) - *(int64_t*)((char*)snsInfo + 0x18) * -1f;
0002b7ac      char var_78 = 0;
0002b7b0      int32_t var_74 = 0;
0002b7b4      char var_70 = 0;
0002b7b8      float var_d0 =
0002b7b8          *(int64_t*)((char*)snsInfo + 0x28) - *(int64_t*)((char*)snsInfo + 0x24);
0002b7c6      int32_t var_6c = 0;
0002b7d8      float var_c4 = snsInfo->position.y - zmm1;
0002b7e1      float var_b8 = *(int64_t*)((char*)snsInfo + 0x10) - *(int64_t*)((char*)snsInfo + 0xc);
0002b7ea      memset(__return, 0, 0xbc);
0002b7ef      uint32_t twoTouchSensorNum_1 = (uint32_t)twoTouchSensorNum;
0002b7fd      kite->solvedIdx[0] = 0xff;
0002b806      kite->solvedIdx[1] = 0xff;
0002b812      int32_t temp0;
0002b812      int32_t temp1;
0002b812      temp0 = HIGHD((int64_t)(occludedSensorNum_1 - twoTouchSensorNum_1 + 4));
0002b812      temp1 = LOWD((int64_t)(occludedSensorNum_1 - twoTouchSensorNum_1 + 4));
0002b813      int32_t rdx_1 = temp0 & 3;
0002b813      
0002b820      if (((temp1 + rdx_1) & 3) - rdx_1 != 2)
0002b820      {
0002b84c          (uint32_t)zmm6 = 0.00400000019f / (occludedSensor->edgePair[0].edge[1]
0002b84c              - occludedSensor->edgePair[0].edge[0]);
0002b858          int32_t rax_6;
0002b858          (uint8_t)rax_6 = (uint8_t)twoTouchSensorNum_1;
0002b85b          void* r14_1 = &kite->kPt[0].sourceST;
0002b865          (uint8_t)kite = 0;
0002b86a          (uint8_t)rax_6 <<= 4;
0002b86d          int32_t* rdx_2 = &var_9c;
0002b875          char var_148_1 = (uint8_t)rax_6;
0002b879          (uint8_t)rax_6 = (uint8_t)occludedSensorNum_1;
0002b87c          void* var_68_1 = r14_1;
0002b884          (uint8_t)rax_6 <<= 4;
0002b887          int32_t* var_138_1 = &var_9c;
0002b88f          char var_147_1 = (uint8_t)rax_6;
0002b897          uint64_t r8 = (uint64_t)(uint8_t)twoTouchSensorNum_1 * 3;
0002b89f          uint64_t var_100_1 = r8;
0002b8a7          uint64_t r15_1 = (uint64_t)(uint8_t)occludedSensorNum_1 * 3;
0002b8b5          struct line_def_t lineB;
0002b8b5          struct line_def_t line;
0002b8b5          
0002b8b5          while (true)
0002b8b5          {
0002b8b5              struct sensor_info_t* snsInfo_5 = statics_1->snsInfo;
0002b8bc              uint64_t rsi = (uint64_t)rdx_2[-3];
0002b8c0              uint64_t rdi = (uint64_t)rdx_2[-1];
0002b8c4              int64_t rbx_1 = (int64_t)rdx_2[-2];
0002b8dc              void* twoTouchSensorEdges = &twoTouchSensor_1->edgePair[rsi];
0002b8ed              struct fpoint_t rax_10 = SingleOcclusionTouchCentre(
0002b8ed                  &occludedSensor->edgePair[rdi], *(uint32_t*)rdx_2, 
0002b8ed                  (char*)snsInfo_5 + (r15_1 << 2), twoTouchSensorEdges, (uint32_t)rbx_1, 
0002b8ed                  (char*)snsInfo_5 + (r8 << 2), (uint8_t)kite);
0002b902              *(uint32_t*)((char*)r14_1 - 8) = rax_10.x;
0002b902              *(uint32_t*)((char*)r14_1 - 4) = rax_10.y;
0002b90e              struct sensor_info_t* snsInfo_7 = statics->snsInfo;
0002b93f              float zmm0_2 = FindDeltaAngle(
0002b93f                  *(uint32_t*)((char*)occludedSensor
0002b93f                      + (((int64_t)*(uint32_t*)var_138_1 + (rdi << 1)) << 2))
0002b93f                      + (&snsInfo_7->rotation_offset)[r15_1], 
0002b93f                  *(uint32_t*)((char*)twoTouchSensor + ((rbx_1 + (rsi << 1)) << 2))
0002b93f                  + (&snsInfo_7->rotation_offset)[var_100_1]);
0002b944              int64_t rax_13;
0002b944              (uint8_t)rax_13 = var_148_1;
0002b94c              (uint8_t)rax_13 |= (uint8_t)rsi;
0002b94f              statics_1 = statics;
0002b957              *(uint32_t*)((char*)r14_1 + 0x20) = zmm0_2;
0002b95d              *(uint8_t*)r14_1 = (uint8_t)rax_13;
0002b960              (uint8_t)rax_13 = var_147_1;
0002b964              (uint8_t)rax_13 |= (uint8_t)rdi;
0002b967              *(uint8_t*)((char*)r14_1 + 1) = (uint8_t)rax_13;
0002b96b              struct sensor_info_t* snsInfo_1 = statics_1->snsInfo;
0002b972              struct edge_pair_t edgePair;
0002b972              edgePair.edge[0] = *(uint32_t*)twoTouchSensorEdges;
0002b972              edgePair.edge[1] = *(uint32_t*)((char*)twoTouchSensorEdges + 4);
0002b97a              CTL_EdgesToCentreLine(edgePair, (char*)snsInfo_1 + (var_100_1 << 2), 
0002b97a                  (char*)r14_1 + 4);
0002b98b              int64_t rax_14 = *(uint64_t*)(statics_1->snsInfo + (r15_1 << 2));
0002b98f              line.m = (uint32_t)rax_14;
0002b98f              line.c = *(uint32_t*)((char*)rax_14)[4];
0002b997              int64_t rax_15 = *(uint64_t*)((char*)r14_1 - 8);
0002b9b8              float zmm1_2 = *(uint32_t*)((char*)rax_15)[4];
0002b9c2              float zmm2_1 = (line.c - zmm1_2) / (line.m - (uint32_t)rax_15);
0002b9c6              float zmm0_3 = *(uint32_t*)((char*)r14_1 - 4);
0002b9cc              lineB.m = zmm2_1;
0002b9dc              lineB.c = zmm1_2 - zmm2_1 * (uint32_t)rax_15;
0002b9e2              zmm1_2 = *(uint32_t*)((char*)r14_1 - 8);
0002b9ea              *(uint32_t*)((char*)r14_1 + 0x10) = lineB.m;
0002b9f1              *(uint32_t*)((char*)r14_1 + 0x14) = lineB.c;
0002b9f8              *(uint32_t*)((char*)r14_1 + 0x18) = lineB.weight;
0002b9fc              struct sensor_info_t* snsInfo_2 = statics_1->snsInfo;
0002ba10              float zmm0_4;
0002ba10              float zmm6_1;
0002ba10              zmm0_4 = atan2f(zmm0_3 - (&snsInfo_2->position.y)[r15_1], 
0002ba10                  zmm1_2 - *(uint32_t*)((char*)snsInfo_2 + (r15_1 << 2)));
0002ba27              *(uint32_t*)((char*)r14_1 + 0x1c) =
0002ba27                  zmm0_4 - (&statics_1->snsInfo->rotation_offset)[r15_1];
0002ba2d              BoundRadiansTo90((char*)r14_1 + 0x1c);
0002ba32              twoTouchSensor_1 = twoTouchSensor;
0002ba3a              *(uint32_t*)((char*)r14_1 + 0x18) = zmm6_1;
0002ba3a              
0002ba44              if (twoTouchSensor_1->specialCases & 0x40)
0002ba44              {
0002ba57                  float zmm0_5 = *(uint32_t*)((char*)r14_1 + 0xc) * 0.150000006f;
0002ba5f                  *(uint32_t*)((char*)r14_1 + 0x18) = zmm6_1 * 0.150000006f;
0002ba65                  *(uint32_t*)((char*)r14_1 + 0xc) = zmm0_5;
0002ba44              }
0002ba44              
0002ba70              (uint8_t)kite += 1;
0002ba73              r14_1 += 0x2c;
0002ba77              rdx_2 = &var_138_1[4];
0002ba7b              var_138_1 = rdx_2;
0002ba7b              
0002ba84              if ((uint8_t)kite >= 4)
0002ba84                  break;
0002ba84              
0002b8ad              r8 = var_100_1;
0002b8b5          }
0002b8b5          
0002ba8a          kite = __return;
0002ba9d          kite->state = K_POPULATED;
0002baa9          kite->singleOcclusion = 1;
0002babf          struct sensor_info_t* sensorInfo = statics_1->snsInfo + (r15_1 << 2);
0002bac3          int64_t rax_21;
0002bac3          (uint32_t)rax_21 = sensorInfo->position.x;
0002bac3          *(uint32_t*)((char*)rax_21)[4] = sensorInfo->position.y;
0002bac6          struct fpoint_t triangle;
0002bac6          triangle.x = (uint32_t)rax_21;
0002bac6          triangle.y = *(uint32_t*)((char*)rax_21)[4];
0002bace          CTL_SensorAngleToLine(occludedSensor->edgePair[0].edge[0], sensorInfo, &line);
0002badb          int64_t rax_22;
0002badb          (uint32_t)rax_22 = line.m;
0002badb          *(uint32_t*)((char*)rax_22)[4] = line.c;
0002bae8          lineB.m = (uint32_t)rax_22;
0002bae8          lineB.c = *(uint32_t*)((char*)rax_22)[4];
0002baf3          lineB.weight = line.weight;
0002baff          struct line_def_t lineA;
0002baff          lineA.m = (&var_e0)[r15_1];
0002bb09          lineA.c = (&var_dc)[r15_1];
0002bb14          void var_d8;
0002bb14          lineA.weight = *(uint32_t*)(&var_d8 + (r15_1 << 2));
0002bb1c          struct fpoint_t rax_27 = SFP_LineIntersect(&lineA, &lineB);
0002bb2f          struct fpoint_t var_58;
0002bb2f          var_58.x = rax_27.x;
0002bb2f          var_58.y = rax_27.y;
0002bb42          CTL_SensorAngleToLine(occludedSensor->edgePair[0].edge[1], 
0002bb42              statics_1->snsInfo + (r15_1 << 2), &line);
0002bb54          int64_t rax_29;
0002bb54          (uint32_t)rax_29 = line.m;
0002bb54          *(uint32_t*)((char*)rax_29)[4] = line.c;
0002bb5c          lineB.m = (uint32_t)rax_29;
0002bb5c          lineB.c = *(uint32_t*)((char*)rax_29)[4];
0002bb67          lineB.weight = line.weight;
0002bb73          lineA.m = (&var_e0)[r15_1];
0002bb7d          lineA.c = (&var_dc)[r15_1];
0002bb88          lineA.weight = *(uint32_t*)(&var_d8 + (r15_1 << 2));
0002bb90          struct fpoint_t rax_34 = SFP_LineIntersect(&lineA, &lineB);
0002bba0          struct fpoint_t var_50;
0002bba0          var_50.x = rax_34.x;
0002bba0          var_50.y = rax_34.y;
0002bba8          EliminatePtsNotInTriangle(&triangle, kite);
0002bbb6          uint8_t kitePos = 0;
0002bbb6          
0002bbbc          if (kite->state == K_INVALID)
0002bbbc          {
0002bbc2              void* r12 = var_68_1;
0002bbca              int32_t* rdx_11 = &var_9c;
0002bbd2              int32_t* var_140_2 = &var_9c;
0002bbd2              
0002bd7f              do
0002bd7f              {
0002bbd7                  struct sensor_info_t* snsInfo_6 = statics_1->snsInfo;
0002bbde                  uint64_t rsi_1 = (uint64_t)rdx_11[-3];
0002bbe2                  uint64_t rdi_1 = (uint64_t)rdx_11[-1];
0002bbe6                  int64_t rbx_2 = (int64_t)rdx_11[-2];
0002bc06                  void* twoTouchSensorEdges_1 = &twoTouchSensor_1->edgePair[rsi_1];
0002bc16                  struct fpoint_t rax_37 = SingleOcclusionTouchCentre(
0002bc16                      &occludedSensor->edgePair[rdi_1], *(uint32_t*)rdx_11, 
0002bc16                      (char*)snsInfo_6 + (r15_1 << 2), twoTouchSensorEdges_1, 
0002bc16                      (uint32_t)rbx_2, (char*)snsInfo_6 + (var_100_1 << 2), kitePos);
0002bc2b                  *(uint32_t*)((char*)r12 - 8) = rax_37.x;
0002bc2b                  *(uint32_t*)((char*)r12 - 4) = rax_37.y;
0002bc38                  struct sensor_info_t* snsInfo_8 = statics->snsInfo;
0002bc68                  float zmm0_8 = FindDeltaAngle(
0002bc68                      *(uint32_t*)((char*)occludedSensor
0002bc68                          + (((int64_t)*(uint32_t*)var_140_2 + (rdi_1 << 1)) << 2))
0002bc68                          + (&snsInfo_8->rotation_offset)[r15_1], 
0002bc68                      *(uint32_t*)((char*)twoTouchSensor + ((rbx_2 + (rsi_1 << 1)) << 2))
0002bc68                      + (&snsInfo_8->rotation_offset)[var_100_1]);
0002bc6d                  int64_t rax_40;
0002bc6d                  (uint8_t)rax_40 = var_148_1;
0002bc76                  (uint8_t)rax_40 |= (uint8_t)rsi_1;
0002bc79                  statics_1 = statics;
0002bc81                  *(uint32_t*)((char*)r12 + 0x20) = zmm0_8;
0002bc88                  *(uint8_t*)r12 = (uint8_t)rax_40;
0002bc8c                  (uint8_t)rax_40 = var_147_1;
0002bc90                  (uint8_t)rax_40 |= (uint8_t)rdi_1;
0002bc93                  *(uint8_t*)((char*)r12 + 1) = (uint8_t)rax_40;
0002bc98                  struct sensor_info_t* snsInfo_3 = statics_1->snsInfo;
0002bc9f                  struct edge_pair_t edgePair_1;
0002bc9f                  edgePair_1.edge[0] = *(uint32_t*)twoTouchSensorEdges_1;
0002bc9f                  edgePair_1.edge[1] = *(uint32_t*)((char*)twoTouchSensorEdges_1 + 4);
0002bca7                  CTL_EdgesToCentreLine(edgePair_1, (char*)snsInfo_3 + (var_100_1 << 2), 
0002bca7                      (char*)r12 + 4);
0002bcb8                  int64_t rax_41 = *(uint64_t*)(statics_1->snsInfo + (r15_1 << 2));
0002bcbc                  lineA.m = (uint32_t)rax_41;
0002bcbc                  lineA.c = *(uint32_t*)((char*)rax_41)[4];
0002bcc1                  int64_t rax_42 = *(uint64_t*)((char*)r12 - 8);
0002bcdd                  float zmm1_5 = *(uint32_t*)((char*)rax_42)[4];
0002bce7                  float zmm2_2 = (lineA.c - zmm1_5) / (lineA.m - (uint32_t)rax_42);
0002bceb                  float zmm0_9 = *(uint32_t*)((char*)r12 - 4);
0002bcf2                  lineB.m = zmm2_2;
0002bd02                  lineB.c = zmm1_5 - zmm2_2 * (uint32_t)rax_42;
0002bd08                  zmm1_5 = *(uint32_t*)((char*)r12 - 8);
0002bd11                  *(uint32_t*)((char*)r12 + 0x10) = lineB.m;
0002bd19                  *(uint32_t*)((char*)r12 + 0x14) = lineB.c;
0002bd21                  *(uint32_t*)((char*)r12 + 0x18) = lineB.weight;
0002bd26                  struct sensor_info_t* snsInfo_4 = statics_1->snsInfo;
0002bd52                  *(uint32_t*)((char*)r12 + 0x1c) = atan2f(
0002bd52                      zmm0_9 - (&snsInfo_4->position.y)[r15_1], 
0002bd52                      zmm1_5 - *(uint32_t*)((char*)snsInfo_4 + (r15_1 << 2)))
0002bd52                      - (&statics_1->snsInfo->rotation_offset)[r15_1];
0002bd59                  BoundRadiansTo90((char*)r12 + 0x1c);
0002bd63                  rdx_11 = &var_140_2[4];
0002bd67                  kitePos += 1;
0002bd6a                  r12 += 0x2c;
0002bd6e                  var_140_2 = rdx_11;
0002bd77                  twoTouchSensor_1 = twoTouchSensor;
0002bd7f              } while (kitePos < 4);
0002bd7f              
0002bd85              kite = __return;
0002bd98              EliminatePtsNotInTriangle(&triangle, kite);
0002bbbc          }
0002b820      }
0002b820      else
0002b822          kite->state = K_INVALID;
0002b822      
0002bdbf      return kite;
0002b6a4  }

0002bdc0  cc cc cc cc cc cc cc cc                                                                          ........

0002bdc8    uint8_t TR_TriangulationHandler(struct edge_set_t* sensorASet, struct edge_set_t* sensorBSet, uint8_t sensorA, uint8_t sensorB, struct triangulate_statics_t* statics, struct kite_t* retKite)

0002bdc8  {
0002bdd5      uint32_t touchCount_2 = (uint32_t)sensorASet->touchCount;
0002bddf      int64_t rdi;
0002bddf      (uint8_t)rdi = sensorB;
0002bde8      struct kite_t* rax_2;
0002bde8      
0002bde8      if (touchCount_2 == 1)
0002bde8      {
0002be49          uint32_t touchCount_1 = (uint32_t)sensorBSet->touchCount;
0002be4f          struct kite_t __return_3;
0002be4f          
0002be4f          if (touchCount_1 == 1)
0002be9e              rax_2 = Triangulate1Touch(&__return_3, sensorASet, sensorBSet, sensorA, 
0002be9e                  (uint8_t)rdi, statics);
0002be4f          else
0002be4f          {
0002be53              if (touchCount_1 != 2)
0002be55                  return 0;
0002be55              
0002be42              void __return_1;
0002be42              rax_2 = TriangulateSingleOcclusion(&__return_1, sensorASet, sensorA, 
0002be42                  sensorBSet, (uint8_t)rdi, statics);
0002be4f          }
0002bde8      }
0002bde8      else
0002bde8      {
0002bded          if (touchCount_2 != 2)
0002be55              return 0;
0002be55          
0002bdef          uint32_t touchCount = (uint32_t)sensorBSet->touchCount;
0002bdf5          void __return;
0002bdf5          
0002bdf5          if (touchCount == 1)
0002be42              rax_2 = TriangulateSingleOcclusion(&__return, sensorBSet, (uint8_t)rdi, 
0002be42                  sensorASet, sensorA, statics);
0002bdf5          else
0002bdf5          {
0002bdf9              if (touchCount != 2)
0002be55                  return 0;
0002be55              
0002be1e              struct kite_t __return_2;
0002be1e              rax_2 = Triangulate2TouchNoOcclusion(&__return_2, sensorASet, sensorBSet, 
0002be1e                  sensorA, sensorB, statics);
0002bdf5          }
0002bde8      }
0002bde8      
0002beb4      memmove(retKite, rax_2, 0xbc);
0002becb      return 1;
0002bdc8  }

0002becc                                      cc cc cc cc cc cc cc cc                                                  ........

0002bed4    struct kite_t* Triangulate2TouchNoOcclusion(struct kite_t* __return, struct edge_set_t* sensorASet, struct edge_set_t* sensorBSet, uint8_t sensorA, uint8_t sensorB, struct triangulate_statics_t* statics)

0002bed4  {
0002bf0b      uint64_t sensorA_1 = (uint64_t)sensorA;
0002bf28      memset(__return, 0, 0xbc);
0002bf34      uint64_t r12 = sensorA_1 * 3;
0002bf3e      void* sensorInfo = statics->snsInfo + (r12 << 2);
0002bf45      __return->solvedIdx[0] = 0xff;
0002bf4d      __return->solvedIdx[1] = 0xff;
0002bf55      struct line_def_t lines_1;
0002bf55      CTL_EdgesetsToCentreLines(sensorASet, sensorInfo, &lines_1);
0002bf61      uint64_t sensorB_1 = (uint64_t)sensorB;
0002bf6e      uint64_t rbp = sensorB_1 * 3;
0002bf79      struct line_def_t lines;
0002bf79      CTL_EdgesetsToCentreLines(sensorBSet, statics->snsInfo + (rbp << 2), &lines);
0002bf7e      int128_t zmm9;
0002bf7e      (uint32_t)zmm9 = lines_1.m;
0002bf7e      *(uint32_t*)((char*)zmm9)[4] = lines_1.m;
0002bf7e      *(uint32_t*)((char*)zmm9)[8] = lines_1.m;
0002bf85      float var_c0;
0002bf85      int128_t zmm11 = var_c0;
0002bf8c      float c_1 = lines_1.c;
0002bfa4      float var_c4;
0002bfa4      float zmm0_1 = _divide((uint32_t)zmm11 - c_1, (uint32_t)zmm9 - var_c4);
0002bfad      int128_t zmm12;
0002bfad      (uint32_t)zmm12 = sensorBSet->edgePair[1].edge[1];
0002bfad      *(uint16_t*)((char*)zmm12)[4] = sensorBSet->touchIntegral[0];
0002bfad      *(uint16_t*)((char*)zmm12)[6] = sensorBSet->touchIntegral[1];
0002bfad      *(uint16_t*)((char*)zmm12)[8] = sensorBSet->touchWidth[0];
0002bfad      *(uint16_t*)((char*)zmm12)[0xa] = sensorBSet->touchWidth[1];
0002bfad      *(uint8_t*)((char*)zmm12)[0xc] = sensorBSet->touchCount;
0002bfad      *(uint8_t*)((char*)zmm12)[0xd] = sensorBSet->best1TchIdx;
0002bfb3      int128_t zmm8;
0002bfb3      (uint32_t)zmm8 = sensorASet->edgePair[0].edge[1];
0002bfb3      *(uint32_t*)((char*)zmm8)[4] = sensorASet->edgePair[0].edge[1];
0002bfb3      *(uint32_t*)((char*)zmm8)[8] = sensorASet->edgePair[0].edge[1];
0002bfb3      *(uint16_t*)((char*)zmm8)[0xc] = sensorASet->touchIntegral[0];
0002bfb3      *(uint16_t*)((char*)zmm8)[0xe] = sensorASet->touchIntegral[1];
0002bfc3      (uint32_t)zmm12 = (uint32_t)zmm12 + sensorBSet->edgePair[1].edge[0];
0002bfc9      (uint32_t)zmm8 = (uint32_t)zmm8 + sensorASet->edgePair[0].edge[0];
0002bfd2      (uint32_t)zmm12 = (uint32_t)zmm12 * 0.5f;
0002bfdb      (uint32_t)zmm8 = (uint32_t)zmm8 * 0.5f;
0002bfec      float var_d4 = (uint32_t)zmm9 * zmm0_1 + c_1;
0002bff2      int64_t rax_2 = zmm0_1;
0002bff7      __return->kPt[0].pt.x = (uint32_t)rax_2;
0002bff7      __return->kPt[0].pt.y = *(uint32_t*)((char*)rax_2)[4];
0002bffa      struct sensor_info_t* snsInfo = statics->snsInfo;
0002c00e      float zmm0_2 = FindDeltaAngle((uint32_t)zmm8 + (&snsInfo->rotation_offset)[r12], 
0002c00e          (uint32_t)zmm12 + (&snsInfo->rotation_offset)[rbp]);
0002c018      (uint8_t)sensorB_1 <<= 4;
0002c022      (uint8_t)sensorA_1 <<= 4;
0002c029      float c = lines.c;
0002c02f      float b = (uint32_t)zmm9 - lines.m;
0002c035      __return->kPt[0].deltaAngle = zmm0_2;
0002c03b      __return->kPt[0].sourceLines[0].m = lines_1.m;
0002c042      uint8_t rcx_2 = (uint8_t)sensorB_1 | 1;
0002c048      __return->kPt[0].sourceLines[0].c = lines_1.c;
0002c054      __return->kPt[0].sourceLines[0].weight = lines_1.weight;
0002c05a      __return->kPt[0].sourceST[0] = (uint8_t)sensorA_1;
0002c05e      __return->kPt[0].sourceLines[1].m = var_c4;
0002c065      __return->kPt[0].sourceST[1] = rcx_2;
0002c069      __return->kPt[0].sourceLines[1].c = var_c0;
0002c070      float var_bc;
0002c070      __return->kPt[0].sourceLines[1].weight = var_bc;
0002c078      float zmm0_3 = _divide(c - c_1, b);
0002c07d      (uint32_t)zmm9 = (uint32_t)zmm9 * zmm0_3;
0002c088      (uint32_t)zmm9 = (uint32_t)zmm9 + c_1;
0002c096      int32_t var_d4_1 = (uint32_t)zmm9;
0002c09d      int64_t rax_9 = zmm0_3;
0002c0a2      __return->kPt[1].pt.x = (uint32_t)rax_9;
0002c0a2      __return->kPt[1].pt.y = *(uint32_t*)((char*)rax_9)[4];
0002c0a6      struct sensor_info_t* snsInfo_1 = statics->snsInfo;
0002c0ad      c_1 = (sensorBSet->edgePair[0].edge[1] + sensorBSet->edgePair[0].edge[0]) * 0.5f;
0002c0b5      (uint32_t)zmm8 = (uint32_t)zmm8 + (&snsInfo_1->rotation_offset)[r12];
0002c0c9      float zmm0_4 =
0002c0c9          FindDeltaAngle((uint32_t)zmm8, c_1 + (&snsInfo_1->rotation_offset)[rbp]);
0002c0ce      int32_t var_ac;
0002c0ce      zmm9 = var_ac;
0002c0d5      float var_a8;
0002c0d5      zmm8 = var_a8;
0002c0e1      __return->kPt[1].sourceST[0] = (uint8_t)sensorA_1;
0002c0e5      __return->kPt[1].sourceST[1] = (uint8_t)sensorB_1;
0002c0f3      __return->kPt[1].deltaAngle = zmm0_4;
0002c0f9      int64_t rax_10;
0002c0f9      (uint32_t)rax_10 = lines_1.m;
0002c0f9      *(uint32_t*)((char*)rax_10)[4] = lines_1.c;
0002c0fc      __return->kPt[1].sourceLines[0].m = (uint32_t)rax_10;
0002c0fc      __return->kPt[1].sourceLines[0].c = *(uint32_t*)((char*)rax_10)[4];
0002c110      __return->kPt[1].sourceLines[0].weight = lines_1.weight;
0002c116      __return->kPt[1].sourceLines[1].m = lines.m;
0002c11d      __return->kPt[1].sourceLines[1].c = lines.c;
0002c124      __return->kPt[1].sourceLines[1].weight = lines.weight;
0002c128      float zmm0_5 = _divide(c - (uint32_t)zmm8, (uint32_t)zmm9 - lines.m);
0002c14a      c = (sensorASet->edgePair[1].edge[1] + sensorASet->edgePair[1].edge[0]) * 0.5f;
0002c152      float var_d4_2 = (uint32_t)zmm9 * zmm0_5 + (uint32_t)zmm8;
0002c15b      int64_t rax_15 = zmm0_5;
0002c160      __return->kPt[2].pt.x = (uint32_t)rax_15;
0002c160      __return->kPt[2].pt.y = *(uint32_t*)((char*)rax_15)[4];
0002c164      struct sensor_info_t* snsInfo_2 = statics->snsInfo;
0002c17b      float zmm0_6 = FindDeltaAngle(c + (&snsInfo_2->rotation_offset)[r12], 
0002c17b          c_1 + (&snsInfo_2->rotation_offset)[rbp]);
0002c191      (uint8_t)sensorA_1 |= 1;
0002c195      __return->kPt[2].sourceLines[0].m = var_ac;
0002c19c      __return->kPt[2].deltaAngle = zmm0_6;
0002c1a5      (uint32_t)zmm11 = (uint32_t)zmm11 - (uint32_t)zmm8;
0002c1aa      __return->kPt[2].sourceLines[0].c = var_a8;
0002c1ba      float var_a4;
0002c1ba      __return->kPt[2].sourceLines[0].weight = var_a4;
0002c1be      int64_t rax_19;
0002c1be      (uint32_t)rax_19 = lines.m;
0002c1be      *(uint32_t*)((char*)rax_19)[4] = lines.c;
0002c1c1      __return->kPt[2].sourceST[0] = (uint8_t)sensorA_1;
0002c1c5      __return->kPt[2].sourceLines[1].m = (uint32_t)rax_19;
0002c1c5      __return->kPt[2].sourceLines[1].c = *(uint32_t*)((char*)rax_19)[4];
0002c1c9      float weight = lines.weight;
0002c1cc      __return->kPt[2].sourceST[1] = (uint8_t)sensorB_1;
0002c1d0      __return->kPt[2].sourceLines[1].weight = weight;
0002c1d4      float zmm0_7 = _divide((uint32_t)zmm11, (uint32_t)zmm9 - var_c4);
0002c1d9      (uint32_t)zmm9 = (uint32_t)zmm9 * zmm0_7;
0002c1e4      (uint32_t)zmm9 = (uint32_t)zmm9 + (uint32_t)zmm8;
0002c1e9      int32_t var_d4_3 = (uint32_t)zmm9;
0002c1f0      int64_t rax_20 = zmm0_7;
0002c1f5      __return->kPt[3].pt.x = (uint32_t)rax_20;
0002c1f5      __return->kPt[3].pt.y = *(uint32_t*)((char*)rax_20)[4];
0002c1fc      struct sensor_info_t* snsInfo_3 = statics->snsInfo;
0002c203      (uint32_t)zmm12 = (uint32_t)zmm12 + (&snsInfo_3->rotation_offset)[rbp];
0002c218      float zmm0_8 =
0002c218          FindDeltaAngle(c + (&snsInfo_3->rotation_offset)[r12], (uint32_t)zmm12);
0002c21d      bool cond:0 = statics->numSensors <= 2;
0002c225      __return->kPt[3].sourceST[1] = rcx_2;
0002c231      __return->kPt[3].deltaAngle = zmm0_8;
0002c23a      __return->kPt[3].sourceST[0] = (uint8_t)sensorA_1;
0002c243      __return->state = K_POPULATED;
0002c24e      __return->kPt[3].sourceLines[0].m = var_ac;
0002c258      __return->kPt[3].sourceLines[0].c = var_a8;
0002c267      __return->kPt[3].sourceLines[0].weight = var_a4;
0002c270      __return->kPt[3].sourceLines[1].m = var_c4;
0002c27a      __return->kPt[3].sourceLines[1].c = var_c0;
0002c284      __return->kPt[3].sourceLines[1].weight = var_bc;
0002c284      
0002c28b      if (!cond:0)
0002c28b      {
0002c28d          struct sensor_info_t* snsInfo_4 = statics->snsInfo;
0002c297          struct fpoint_t screenMax;
0002c297          screenMax.x = *(int64_t*)((char*)snsInfo_4 + 0x18);
0002c297          screenMax.y = *(int64_t*)((char*)snsInfo_4 + 0x1c);
0002c29b          struct fpoint_t screenMin;
0002c29b          screenMin.x = snsInfo_4->position.x;
0002c29b          screenMin.y = snsInfo_4->position.y;
0002c29e          KI_KitePairsOnScreen(__return, screenMin, screenMax);
0002c28b      }
0002c28b      
0002c2de      return __return;
0002bed4  }

0002c2df                                                                                               cc                                 .
0002c2e0  cc cc cc cc cc cc cc cc                                                                          ........

0002c2e8    struct kite_t* Triangulate1Touch(struct kite_t* __return, struct edge_set_t* sensorASet, struct edge_set_t* sensorBSet, uint8_t sensorA, uint8_t sensorB, struct triangulate_statics_t* statics)

0002c2e8  {
0002c30a      uint64_t sensorA_1 = (uint64_t)sensorA;
0002c311      memset(__return, 0, 0xbc);
0002c31e      float edgePair[0x2];
0002c31e      edgePair[0] = sensorASet->edgePair[0].edge[0];
0002c31e      edgePair[1] = sensorASet->edgePair[0].edge[1];
0002c329      uint64_t rsi = sensorA_1 * 3;
0002c332      struct sensor_info_t* sensorInfo = statics->snsInfo + (rsi << 2);
0002c336      __return->solvedIdx[0] = 0xff;
0002c33e      __return->solvedIdx[1] = 0xff;
0002c346      struct line_def_t line;
0002c346      CTL_EdgesToCentreLine(edgePair, sensorInfo, &line);
0002c34b      struct sensor_info_t* snsInfo = statics->snsInfo;
0002c352      uint64_t sensorB_1 = (uint64_t)sensorB;
0002c35a      float edgePair_1[0x2];
0002c35a      edgePair_1[0] = sensorBSet->edgePair[0].edge[0];
0002c35a      edgePair_1[1] = sensorBSet->edgePair[0].edge[1];
0002c35e      uint64_t rbx = sensorB_1 * 3;
0002c36c      struct line_def_t line_1;
0002c36c      CTL_EdgesToCentreLine(edgePair_1, (char*)snsInfo + (rbx << 2), &line_1);
0002c377      float m = line.m;
0002c38c      float zmm0_1 = _divide(line_1.c - line.c, m - line_1.m);
0002c3c6      float var_54 = m * zmm0_1 + line.c;
0002c3cc      int64_t rax_1 = zmm0_1;
0002c3d1      __return->kPt[0].pt.x = (uint32_t)rax_1;
0002c3d1      __return->kPt[0].pt.y = *(uint32_t*)((char*)rax_1)[4];
0002c3d4      struct sensor_info_t* snsInfo_1 = statics->snsInfo;
0002c3eb      float zmm0_2 = FindDeltaAngle(
0002c3eb          (sensorASet->edgePair[0].edge[1] + sensorASet->edgePair[0].edge[0]) * 0.5f
0002c3eb              + (&snsInfo_1->rotation_offset)[rsi], 
0002c3eb          (sensorBSet->edgePair[0].edge[1] + sensorBSet->edgePair[0].edge[0]) * 0.5f
0002c3eb          + (&snsInfo_1->rotation_offset)[rbx]);
0002c3fc      (uint8_t)sensorA_1 <<= 4;
0002c400      (uint8_t)sensorB_1 <<= 4;
0002c404      __return->kPt[0].deltaAngle = zmm0_2;
0002c40a      __return->kPt[0].sourceLines[0].m = line.m;
0002c414      __return->kPt[0].sourceLines[0].c = line.c;
0002c420      __return->kPt[0].sourceLines[0].weight = line.weight;
0002c424      int64_t rax_5;
0002c424      (uint32_t)rax_5 = line_1.m;
0002c424      *(uint32_t*)((char*)rax_5)[4] = line_1.c;
0002c42a      __return->kPt[0].sourceLines[1].m = (uint32_t)rax_5;
0002c42a      __return->kPt[0].sourceLines[1].c = *(uint32_t*)((char*)rax_5)[4];
0002c42e      float weight = line_1.weight;
0002c435      __return->kPt[0].sourceST[0] = (uint8_t)sensorA_1;
0002c439      __return->kPt[0].sourceST[1] = (uint8_t)sensorB_1;
0002c43d      __return->kPt[0].sourceLines[1].weight = weight;
0002c441      memmove(&__return->kPt[1].pt.x, __return, 0x2c);
0002c450      memmove(&__return->kPt[2], __return, 0x2c);
0002c462      memmove(&__return->kPt[3], __return, 0x2c);
0002c46f      __return->solvedIdx[1] = 0;
0002c477      __return->solvedIdx[0] = 0;
0002c47f      __return->state = K_SINGLE_TOUCH;
0002c49c      return __return;
0002c2e8  }

0002c49d                                                                                         cc cc cc                               ...
0002c4a0  cc cc cc cc                                                                                      ....

0002c4a4    struct fpoint_t MinDistTriangQ(struct line_def_t* lines, uint8_t numLines, float* dist2)

0002c4a4  {
0002c4af      int128_t zmm6 = {0};
0002c4c0      float zmm4[0x4] = {0};
0002c4c3      float zmm8[0x4] = {0};
0002c4c7      int128_t zmm5 = {0};
0002c4ca      int128_t zmm9 = {0};
0002c4ce      int128_t zmm7 = {0};
0002c4d1      int128_t zmm10;
0002c4d1      int128_t var_58 = zmm10;
0002c4d8      double zmm0[0x2];
0002c4d8      float zmm1[0x4];
0002c4d8      uint128_t zmm2;
0002c4d8      
0002c4d8      if (numLines)
0002c4d8      {
0002c4da          struct line_def_t* lines_1 = lines;
0002c4dd          uint64_t r9_1 = (uint64_t)numLines;
0002c549          uint64_t i;
0002c549          
0002c549          do
0002c549          {
0002c4e1              zmm1[0] = lines_1->m;
0002c4e1              zmm1[1] = lines_1->m;
0002c4e1              zmm1[2] = lines_1->m;
0002c4e1              zmm1[3] = lines_1->m;
0002c4e5              float weight = lines_1->weight;
0002c4ea              (uint32_t)zmm2 = lines_1->c;
0002c4ea              *(uint32_t*)((char*)zmm2)[4] = lines_1->c;
0002c4ef              zmm1[0] = zmm1[0] * zmm1[0];
0002c4f3              zmm0 = zmm1;
0002c4f6              zmm0[0] = zmm0[0] + 1f;
0002c4fe              weight = weight / zmm0[0];
0002c502              zmm0 = {0};
0002c505              zmm1[0] = zmm1[0] * weight;
0002c509              (uint32_t)zmm9 = (uint32_t)zmm9 + weight;
0002c50e              zmm8[0] = zmm8[0] + zmm1[0];
0002c513              zmm1[0] = lines_1->m;
0002c513              zmm1[1] = lines_1->m;
0002c513              zmm1[2] = lines_1->m;
0002c513              zmm1[3] = lines_1->m;
0002c517              zmm1[0] = zmm1[0] * weight;
0002c51b              zmm0[0] = zmm0[0] - zmm1[0];
0002c51f              zmm1 = zmm2;
0002c522              (uint32_t)zmm2 = (uint32_t)zmm2 * weight;
0002c526              zmm1[0] = zmm1[0] * lines_1->m;
0002c52a              zmm4[0] = zmm4[0] + zmm0[0];
0002c52e              zmm0 = {0};
0002c531              lines_1 = &lines_1[1];
0002c535              i = r9_1;
0002c535              r9_1 -= 1;
0002c539              zmm0[0] = zmm0[0] - (uint32_t)zmm2;
0002c53d              zmm1[0] = zmm1[0] * weight;
0002c541              (uint32_t)zmm7 = (uint32_t)zmm7 + zmm0[0];
0002c545              (uint32_t)zmm5 = (uint32_t)zmm5 + zmm1[0];
0002c549          } while (i != 1);
0002c4d8      }
0002c4d8      
0002c54b      zmm2 = 0x7fffffffffffffff;
0002c55b      float temp0_1[0x4] = _mm_unpacklo_ps(zmm4, *(uint64_t*)&zmm4[0]);
0002c565      zmm1[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_1[0]), zmm2)[0];
0002c565      
0002c56c      if (9.99999997e-07f <= zmm1[0])
0002c56c      {
0002c598          (uint32_t)zmm5 = (uint32_t)zmm5 / temp0_1[0];
0002c59c          zmm8[0] = zmm8[0] / temp0_1[0];
0002c5a1          temp0_1[0] = temp0_1[0] / (uint32_t)zmm9;
0002c5a6          zmm4 = temp0_1 ^ __mask@@NegFloat@;
0002c5ad          zmm8 ^= __mask@@NegFloat@;
0002c5b5          zmm5 ^= __mask@@NegFloat@;
0002c5bc          zmm4[0] = zmm4[0] - zmm8[0];
0002c5c1          zmm10 = zmm5;
0002c5c5          float temp0_4[0x4] = _mm_unpacklo_ps(zmm4, *(uint64_t*)&zmm4[0]);
0002c5cf          zmm1[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_4[0]), zmm2)[0];
0002c5cf          
0002c5d6          if (9.99999997e-07f <= zmm1[0])
0002c5d6          {
0002c5e8              (uint32_t)zmm7 = (uint32_t)zmm7 / (uint32_t)zmm9;
0002c5f4              (uint32_t)zmm5 = (uint32_t)zmm5 - (zmm7 ^ __mask@@NegFloat@);
0002c5f8              (uint32_t)zmm5 = (uint32_t)zmm5 / temp0_4[0];
0002c5fc              zmm4 = zmm8;
0002c600              zmm4[0] = zmm4[0] * (uint32_t)zmm5;
0002c604              zmm4[0] = zmm4[0] + (uint32_t)zmm10;
0002c5d6          }
0002c5d6          else
0002c5d6          {
0002c5d8              zmm5 = 0xc47a0000;
0002c5e0              zmm4 = 0xc47a0000;
0002c5d6          }
0002c56c      }
0002c56c      else
0002c56c      {
0002c576          temp0_1[0] = temp0_1[0] / (uint32_t)zmm9;
0002c57b          (uint32_t)zmm5 = (uint32_t)zmm5 / zmm8[0];
0002c580          zmm4 = temp0_1 ^ 0x80000000;
0002c583          (uint32_t)zmm7 = (uint32_t)zmm7 / (uint32_t)zmm9;
0002c588          zmm5 ^= 0x80000000;
0002c58b          zmm4[0] = zmm4[0] * (uint32_t)zmm5;
0002c592          zmm4[0] = zmm4[0] + (zmm7 ^ 0x80000000);
0002c56c      }
0002c56c      
0002c609      *(uint32_t*)dist2 = 0f;
0002c613      float arg_1c = zmm4[0];
0002c613      
0002c61b      if (numLines)
0002c61b      {
0002c61d          uint64_t rax_1 = (uint64_t)numLines;
0002c65c          uint64_t i_1;
0002c65c          
0002c65c          do
0002c65c          {
0002c620              (uint32_t)zmm2 = lines->m;
0002c620              *(uint32_t*)((char*)zmm2)[4] = lines->m;
0002c620              *(uint32_t*)((char*)zmm2)[8] = lines->m;
0002c627              lines = &lines[1];
0002c62b              i_1 = rax_1;
0002c62b              rax_1 -= 1;
0002c62f              zmm0 = zmm2;
0002c632              (uint32_t)zmm2 = (uint32_t)zmm2 * (uint32_t)zmm2;
0002c636              zmm0[0] = zmm0[0] * (uint32_t)zmm5;
0002c63a              (uint32_t)zmm2 = (uint32_t)zmm2 + 1f;
0002c642              zmm4[0] = zmm4[0] - zmm0[0];
0002c646              zmm4[0] = zmm4[0] - *(int64_t*)((char*)lines + -8);
0002c64b              zmm4[0] = zmm4[0] * zmm4[0];
0002c64f              zmm4[0] = zmm4[0] * *(int64_t*)((char*)lines + -4);
0002c654              zmm4[0] = zmm4[0] / (uint32_t)zmm2;
0002c658              (uint32_t)zmm6 = (uint32_t)zmm6 + zmm4[0];
0002c65c          } while (i_1 != 1);
0002c65e          *(uint32_t*)dist2 = (uint32_t)zmm6;
0002c61b      }
0002c61b      
0002c663      zmm1 = *(uint32_t*)dist2;
0002c68f      zmm0 = _mm_cvtepi32_ps((uint128_t)numLines);
0002c692      zmm1[0] = zmm1[0] / zmm0[0];
0002c696      *(uint32_t*)dist2 = zmm1[0];
0002c69f      return (uint32_t)zmm5;
0002c4a4  }

0002c6a0  cc cc cc cc cc cc cc cc                                                                          ........

0002c6a8    struct fpoint_t MinDistTriangQbyCam(struct line_def_t* lines, uint8_t camBits, float* dist2, uint8_t numSensors)

0002c6a8  {
0002c6bc      char r10 = 0;
0002c6c6      int64_t rsi;
0002c6c6      (uint8_t)rsi = camBits;
0002c6c9      struct line_def_t* lines_1 = lines;
0002c6cc      camBits = 0;
0002c6cf      int64_t rbx;
0002c6cf      (uint8_t)rbx = 0;
0002c6d2      *(uint32_t*)dist2 = 0f;
0002c6da      int128_t zmm9;
0002c6da      int128_t var_48 = zmm9;
0002c6e4      (uint8_t)lines = 0;
0002c6e7      float zmm8[0x4] = {0};
0002c6eb      float zmm4[0x4] = {0};
0002c6ee      int128_t zmm5 = {0};
0002c6f1      int128_t zmm10 = {0};
0002c6f5      int128_t zmm6 = {0};
0002c6fb      uint32_t rdi_1;
0002c6fb      
0002c6fb      if (numSensors > 0)
0002c6fb      {
0002c701          rdi_1 = (uint32_t)(uint8_t)rsi;
0002c701          
0002c714          do
0002c714          {
0002c70b              if (TEST_BITD(rdi_1, (uint32_t)(uint8_t)lines))
0002c70d                  camBits += 1;
0002c70d              
0002c70f              (uint8_t)lines += 1;
0002c714          } while ((uint8_t)lines < numSensors);
0002c6fb      }
0002c6fb      
0002c719      int32_t arg_18;
0002c719      float arg_1c;
0002c719      uint128_t zmm0;
0002c719      float zmm2[0x4];
0002c719      float zmm3[0x4];
0002c719      
0002c719      if (numSensors <= 0 || camBits != 2)
0002c719      {
0002c7cb          (uint8_t)lines = 0;
0002c7d1          double zmm1[0x2];
0002c7d1          
0002c7d1          if (numSensors > 0)
0002c7d1          {
0002c7d7              struct line_def_t* lines_2 = lines_1;
0002c7d7              
0002c84d              do
0002c84d              {
0002c7e0                  if (TEST_BITD((uint32_t)(uint8_t)rsi, (uint32_t)(uint8_t)lines))
0002c7e0                  {
0002c7e2                      zmm1[0] = lines_2->m;
0002c7e2                      *(uint32_t*)((char*)zmm1[0])[4] = lines_2->m;
0002c7e2                      zmm1[1] = lines_2->m;
0002c7e2                      *(uint32_t*)((char*)zmm1[1])[4] = lines_2->m;
0002c7e6                      zmm3[0] = lines_2->weight;
0002c7e6                      zmm3[1] = lines_2->weight;
0002c7e6                      zmm3[2] = lines_2->weight;
0002c7e6                      zmm3[3] = lines_2->weight;
0002c7eb                      zmm2[0] = lines_2->c;
0002c7eb                      zmm2[1] = lines_2->c;
0002c7eb                      zmm2[2] = lines_2->c;
0002c7eb                      zmm2[3] = lines_2->c;
0002c7f0                      (uint8_t)rbx += 1;
0002c7f2                      zmm1[0] = zmm1[0] * zmm1[0];
0002c7f9                      (uint32_t)zmm0 = (uint32_t)zmm1 + 1f;
0002c801                      zmm3[0] = zmm3[0] / (uint32_t)zmm0;
0002c808                      zmm1[0] = zmm1[0] * zmm3[0];
0002c80c                      (uint32_t)zmm10 = (uint32_t)zmm10 + zmm3[0];
0002c811                      zmm8[0] = zmm8[0] + zmm1[0];
0002c816                      zmm1[0] = lines_2->m;
0002c816                      *(uint32_t*)((char*)zmm1[0])[4] = lines_2->m;
0002c816                      zmm1[1] = lines_2->m;
0002c816                      *(uint32_t*)((char*)zmm1[1])[4] = lines_2->m;
0002c81a                      zmm1[0] = zmm1[0] * zmm3[0];
0002c81e                      (uint32_t)zmm0 = {0} - zmm1[0];
0002c822                      zmm1 = zmm2;
0002c825                      zmm2[0] = zmm2[0] * zmm3[0];
0002c829                      zmm1[0] = zmm1[0] * lines_2->m;
0002c82d                      zmm4[0] = zmm4[0] + (uint32_t)zmm0;
0002c834                      (uint32_t)zmm0 = {0} - zmm2[0];
0002c838                      zmm1[0] = zmm1[0] * zmm3[0];
0002c83c                      (uint32_t)zmm6 = (uint32_t)zmm6 + (uint32_t)zmm0;
0002c840                      (uint32_t)zmm5 = (uint32_t)zmm5 + zmm1[0];
0002c7e0                  }
0002c7e0                  
0002c844                  (uint8_t)lines += 1;
0002c846                  lines_2 = &lines_2[1];
0002c84d              } while ((uint8_t)lines < numSensors);
0002c7d1          }
0002c7d1          
0002c84f          zmm2 = 0x7fffffffffffffff;
0002c85f          float temp0_5[0x4] = _mm_unpacklo_ps(zmm4, *(uint64_t*)&zmm4[0]);
0002c869          zmm1[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_5[0]), zmm2);
0002c869          
0002c870          if (9.99999997e-07f <= zmm1[0])
0002c870          {
0002c8a4              (uint32_t)zmm5 = (uint32_t)zmm5 / temp0_5[0];
0002c8a8              zmm8[0] = zmm8[0] / temp0_5[0];
0002c8ad              temp0_5[0] = temp0_5[0] / (uint32_t)zmm10;
0002c8b2              zmm8 ^= 0x80000000;
0002c8b6              zmm5 ^= 0x80000000;
0002c8b9              zmm9 = zmm5;
0002c8bd              zmm4 = temp0_5 ^ 0x80000000;
0002c8c0              zmm4[0] = zmm4[0] - zmm8[0];
0002c8c5              float temp0_8[0x4] = _mm_unpacklo_ps(zmm4, *(uint64_t*)&zmm4[0]);
0002c8cf              zmm1[0] = (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_8[0]), zmm2);
0002c8cf              
0002c8d6              if (9.99999997e-07f <= zmm1[0])
0002c8d6              {
0002c8e8                  (uint32_t)zmm6 = (uint32_t)zmm6 / (uint32_t)zmm10;
0002c8f0                  (uint32_t)zmm5 = (uint32_t)zmm5 - (zmm6 ^ 0x80000000);
0002c8f4                  (uint32_t)zmm5 = (uint32_t)zmm5 / temp0_8[0];
0002c8f8                  zmm4 = zmm8;
0002c8fc                  zmm4[0] = zmm4[0] * (uint32_t)zmm5;
0002c900                  zmm4[0] = zmm4[0] + (uint32_t)zmm9;
0002c8d6              }
0002c8d6              else
0002c8d6              {
0002c8d8                  zmm5 = 0xc47a0000;
0002c8e0                  zmm4 = 0xc47a0000;
0002c8d6              }
0002c870          }
0002c870          else
0002c870          {
0002c87a              temp0_5[0] = temp0_5[0] / (uint32_t)zmm10;
0002c87f              (uint32_t)zmm5 = (uint32_t)zmm5 / zmm8[0];
0002c884              zmm4 = temp0_5 ^ 0x80000000;
0002c887              (uint32_t)zmm6 = (uint32_t)zmm6 / (uint32_t)zmm10;
0002c88c              zmm5 ^= 0x80000000;
0002c88f              zmm4[0] = zmm4[0] * (uint32_t)zmm5;
0002c896              zmm4[0] = zmm4[0] + (zmm6 ^ 0x80000000);
0002c870          }
0002c870          
0002c905          arg_18 = (uint32_t)zmm5;
0002c90b          arg_1c = zmm4[0];
0002c90b          
0002c914          if (numSensors > 0)
0002c914          {
0002c96a              do
0002c96a              {
0002c921                  if (TEST_BITD((uint32_t)(uint8_t)rsi, (uint32_t)r10))
0002c921                  {
0002c923                      zmm1[0] = lines_1->m;
0002c923                      *(uint32_t*)((char*)zmm1[0])[4] = lines_1->m;
0002c923                      zmm1[1] = lines_1->m;
0002c923                      *(uint32_t*)((char*)zmm1[1])[4] = lines_1->m;
0002c92e                      zmm1[0] = zmm1[0] * zmm1[0];
0002c932                      (uint32_t)zmm0 = (uint32_t)zmm1 * (uint32_t)zmm5;
0002c936                      zmm1[0] = zmm1[0] + 1f;
0002c93e                      zmm4[0] = zmm4[0] - (uint32_t)zmm0;
0002c942                      zmm4[0] = zmm4[0] - lines_1->c;
0002c948                      zmm4[0] = zmm4[0] * zmm4[0];
0002c94c                      zmm4[0] = zmm4[0] * lines_1->weight;
0002c952                      zmm4[0] = zmm4[0] / zmm1[0];
0002c956                      zmm4[0] = zmm4[0] + *(uint32_t*)dist2;
0002c95b                      *(uint32_t*)dist2 = zmm4[0];
0002c921                  }
0002c921                  
0002c960                  r10 += 1;
0002c963                  lines_1 = &lines_1[1];
0002c96a              } while (r10 < numSensors);
0002c914          }
0002c914          
0002c96c          zmm1 = *(uint32_t*)dist2;
0002c978          zmm0 = _mm_cvtepi32_ps((uint128_t)(uint8_t)rbx);
0002c97b          zmm1[0] = zmm1[0] / (uint32_t)zmm0;
0002c97f          *(uint32_t*)dist2 = zmm1[0];
0002c719      }
0002c719      else
0002c719      {
0002c71f          (uint8_t)dist2 = 1;
0002c722          (uint8_t)lines = 0;
0002c722          
0002c749          do
0002c749          {
0002c72b              if (TEST_BITD(rdi_1, (uint32_t)(uint8_t)lines))
0002c72b              {
0002c72d                  (uint8_t)rbx += 1;
0002c72f                  uint32_t rdx = (uint32_t)(uint8_t)rbx;
0002c72f                  
0002c735                  if (rdx == 1)
0002c741                      r10 = (uint8_t)lines;
0002c735                  else if (rdx == 2)
0002c73c                      (uint8_t)dist2 = (uint8_t)lines;
0002c72b              }
0002c72b              
0002c744              (uint8_t)lines += 1;
0002c749          } while ((uint8_t)lines < numSensors);
0002c749          
0002c757          uint64_t rcx = (uint64_t)r10 * 3;
0002c75f          uint64_t rdx_2 = (uint64_t)(uint8_t)dist2 * 3;
0002c763          zmm3 = *(uint32_t*)((char*)lines_1 + (rcx << 2));
0002c76c          zmm3[0] = zmm3[0] - *(uint32_t*)((char*)lines_1 + (rdx_2 << 2));
0002c772          zmm2 = _mm_unpacklo_ps(zmm3, *(uint64_t*)&zmm3[0]);
0002c772          
0002c784          if (!(0x3eb0c6f7a0000000 <= __andpd_xmmxuq_memxuq(
0002c784              _mm_cvtps_pd(*(uint64_t*)&zmm2[0]), __mask@@AbsDouble@)[0]))
0002c784          {
0002c789              if (0f <= zmm2[0])
0002c795                  zmm2 = 0x358637bd;
0002c789              else
0002c78b                  zmm2 = 0xb58637bd;
0002c784          }
0002c784          
0002c7a4          (uint32_t)zmm0 = (&lines_1->c)[rdx_2] - (&lines_1->c)[rcx];
0002c7ab          (uint32_t)zmm0 = (uint32_t)zmm0 / zmm2[0];
0002c7af          zmm3[0] = zmm3[0] * (uint32_t)zmm0;
0002c7b3          arg_18 = (uint32_t)zmm0;
0002c7b9          zmm3[0] = zmm3[0] + (&lines_1->c)[rcx];
0002c7c0          arg_1c = zmm3[0];
0002c719      }
0002c9b3      return arg_18;
0002c6a8  }

0002c9b4                                                              cc cc cc cc cc cc cc cc                                  ........

0002c9bc    struct fpoint_t DoLineTriangulation(struct line_def_t const* lines, float s1, float s2, float t1, float t2, float r1, float* dist2)

0002c9bc  {
0002c9c0      float r1_3[0x4] = s1;
0002c9c3      s1 = nanf;
0002c9d8      struct line_def_t* lines_1 = lines;
0002c9db      float temp0[0x4] = _mm_unpacklo_ps(r1_3, *(uint64_t*)&r1_3[0]);
0002c9de      float r1_1[0x4];
0002c9de      float r1_2[0x4] = r1_1;
0002c9f1      double t2_1[0x2];
0002c9f1      float t1_1;
0002c9f1      
0002c9f1      if (9.99999997e-07f <= (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0[0]), s1)[0])
0002c9f1      {
0002ca22          r1_1 = r1;
0002ca2c          t1 = (t1 / temp0[0]) ^ (int32_t)__mask@@NegFloat@;
0002ca33          r1_1[0] = r1_1[0] / temp0[0];
0002ca37          temp0[0] = temp0[0] / s2;
0002ca3b          t1_1 = t1;
0002ca3e          r1_3 = temp0 ^ __mask@@NegFloat@;
0002ca45          r1_1 ^= __mask@@NegFloat@;
0002ca4c          r1_3[0] = r1_3[0] - r1_1[0];
0002ca50          float temp0_3[0x4] = _mm_unpacklo_ps(r1_3, *(uint64_t*)&r1_3[0]);
0002ca50          
0002ca61          if (9.99999997e-07f
0002ca61              <= (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&temp0_3[0]), s1)[0])
0002ca61          {
0002ca70              t2_1 = t2;
0002ca79              t2_1[0] = t2_1[0] / s2;
0002ca88              t1 = (t1 - (t2_1 ^ __mask@@NegFloat@)[0]) / temp0_3[0];
0002ca8c              r1_3 = r1_1;
0002ca8f              r1_3[0] = r1_3[0] * t1;
0002ca93              r1_3[0] = r1_3[0] + t1_1;
0002ca61          }
0002ca61          else
0002ca61          {
0002ca63              t1 = -1000f;
0002ca6b              r1_3 = 0xc47a0000;
0002ca61          }
0002c9f1      }
0002c9f1      else
0002c9f1      {
0002ca01          t2_1 = t2;
0002ca07          temp0[0] = temp0[0] / s2;
0002ca0b          t2_1[0] = t2_1[0] / s2;
0002ca0f          t1 = (t1 / r1) ^ 0x80000000;
0002ca12          r1_3 = temp0 ^ 0x80000000;
0002ca18          r1_3[0] = r1_3[0] * t1;
0002ca1c          r1_3[0] = r1_3[0] + (t2_1 ^ 0x80000000)[0];
0002c9f1      }
0002c9f1      
0002ca9c      t1_1 = (int32_t){0};
0002caa4      int64_t i_1 = 4;
0002caa9      *(uint32_t*)dist2 = 0f;
0002caac      float var_34 = r1_3[0];
0002caee      int64_t i;
0002caee      
0002caee      do
0002caee      {
0002cab2          s2 = lines_1->m;
0002cab9          lines_1 = &lines_1[1];
0002cabd          i = i_1;
0002cabd          i_1 -= 1;
0002cac1          t2_1 = s2;
0002cac8          t2_1[0] = t2_1[0] * t1;
0002cad8          s1 = r1_3[0] - t2_1[0] - *(int64_t*)((char*)lines_1 + -8);
0002caea          t1_1 = t1_1 + s1 * s1 * *(int64_t*)((char*)lines_1 + -4) / (s2 * s2 + 1f);
0002caee      } while (i != 1);
0002cb02      *(uint32_t*)dist2 = t1_1 * 0.25f;
0002cb0e      return t1;
0002c9bc  }

0002cb0f                                               cc cc cc cc cc cc cc cc cc                                         .........

0002cb18    float __convention("sysv") MinDistTriangQPertLines(struct line_def_t const* lines @ rcx, struct line_def_t* pertLines @ rdx, float* pertDist2 @ r8)

0002cb18  {
0002cb33      int128_t entry_zmm6;
0002cb33      int128_t var_28 = entry_zmm6;
0002cb37      int128_t entry_zmm7;
0002cb37      int128_t var_38 = entry_zmm7;
0002cb3b      int128_t zmm8;
0002cb3b      int128_t var_48 = zmm8;
0002cb40      struct line_def_t* pertLines_1 = pertLines;
0002cb4c      float* rdx = &lines->c;
0002cb50      int128_t zmm9;
0002cb50      int128_t var_58 = zmm9;
0002cb83      int128_t zmm11 = {0};
0002cb87      int128_t zmm12 = {0};
0002cb8e      int128_t* rax_1 = (char*)pertLines_1 - lines;
0002cb91      void* rbx = nullptr;
0002cb93      int64_t i_2 = 4;
0002cb97      int64_t rcx = 0;
0002cb9a      int128_t zmm13 = {0};
0002cb9e      int128_t zmm14 = {0};
0002cba2      int128_t zmm15 = {0};
0002cc9d      int64_t i;
0002cc9d      
0002cc9d      do
0002cc9d      {
0002cba6          int128_t zmm2;
0002cba6          (uint32_t)zmm2 = pertLines_1->m;
0002cba6          *(uint32_t*)((char*)zmm2)[4] = pertLines_1->m;
0002cba6          *(uint32_t*)((char*)zmm2)[8] = pertLines_1->m;
0002cbab          (uint32_t)entry_zmm6 = ADJ(rdx)->m;
0002cbab          *(uint32_t*)((char*)entry_zmm6)[4] = ADJ(rdx)->m;
0002cbab          *(uint32_t*)((char*)entry_zmm6)[8] = ADJ(rdx)->m;
0002cbb0          int128_t weight = pertLines_1->weight;
0002cbb6          rcx += 4;
0002cbba          pertLines_1 = &pertLines_1[1];
0002cbc7          int128_t zmm0;
0002cbc7          (uint32_t)zmm0 = (uint32_t)entry_zmm6 * (uint32_t)entry_zmm6;
0002cbcf          (uint32_t)zmm0 = (uint32_t)zmm0 + 1f;
0002cbdf          (uint32_t)entry_zmm7 = ADJ(rdx)->c;
0002cbdf          *(uint32_t*)((char*)entry_zmm7)[4] = ADJ(rdx)->c;
0002cbdf          *(uint32_t*)((char*)entry_zmm7)[8] = ADJ(rdx)->c;
0002cbea          (uint32_t)weight = (uint32_t)weight / ((uint32_t)zmm2 * (uint32_t)zmm2 + 1f);
0002cbf4          (uint32_t)zmm8 = ADJ(rdx)->weight / (uint32_t)zmm0;
0002cbf9          int128_t zmm3;
0002cbf9          (uint32_t)zmm3 = (uint32_t)zmm2 * (uint32_t)weight;
0002cc01          (uint32_t)zmm14 = (uint32_t)zmm14 + (uint32_t)zmm8;
0002cc06          (uint32_t)zmm2 = (uint32_t)zmm2 * (uint32_t)zmm3;
0002cc0a          float zmm5 = (uint32_t)entry_zmm6 * (uint32_t)zmm8;
0002cc0f          (uint32_t)zmm9 = (uint32_t)entry_zmm7 * (uint32_t)zmm8;
0002cc14          (uint32_t)zmm0 = {0} - zmm5;
0002cc18          (uint32_t)zmm12 = (uint32_t)zmm12 + (uint32_t)zmm0;
0002cc21          (uint32_t)zmm0 = {0} - (uint32_t)zmm9;
0002cc26          (uint32_t)entry_zmm6 = (uint32_t)entry_zmm6 * zmm5;
0002cc2a          (uint32_t)entry_zmm7 = (uint32_t)entry_zmm7 * zmm5;
0002cc2e          (uint32_t)zmm2 = (uint32_t)zmm2 - (uint32_t)entry_zmm6;
0002cc32          (uint32_t)zmm15 = (uint32_t)zmm15 + (uint32_t)zmm0;
0002cc37          (uint32_t)zmm11 = (uint32_t)zmm11 + (uint32_t)entry_zmm6;
0002cc47          void var_13c;
0002cc47          *(uint32_t*)(&var_13c + rcx) = (uint32_t)zmm2;
0002cc4d          zmm2 = *(uint32_t*)((char*)rax_1 + rdx);
0002cc52          rdx = &rdx[3];
0002cc56          i = i_2;
0002cc56          i_2 -= 1;
0002cc5a          float zmm1 = (uint32_t)zmm2;
0002cc60          (uint32_t)zmm2 = (uint32_t)zmm2 * (uint32_t)weight;
0002cc64          (uint32_t)zmm0 = (zmm3 ^ 0x80000000) + zmm5;
0002cc68          (uint32_t)zmm13 = (uint32_t)zmm13 + (uint32_t)entry_zmm7;
0002cc74          void var_12c;
0002cc74          *(uint32_t*)(&var_12c + rcx) = (uint32_t)zmm0;
0002cc7a          (uint32_t)zmm2 = (zmm2 ^ 0x80000000) + (uint32_t)zmm9;
0002cc86          (uint32_t)zmm0 = (uint32_t)weight - (uint32_t)zmm8;
0002cc8b          void var_11c;
0002cc8b          *(uint32_t*)(&var_11c + rcx) = zmm1 * (uint32_t)zmm3 - (uint32_t)entry_zmm7;
0002cc91          void var_fc;
0002cc91          *(uint32_t*)(&var_fc + rcx) = (uint32_t)zmm2;
0002cc97          void var_10c;
0002cc97          *(uint32_t*)(&var_10c + rcx) = (uint32_t)zmm0;
0002cc9d      } while (i != 1);
0002cccd      float dist2;
0002cccd      DoLineTriangulation(lines, (uint32_t)zmm12, (uint32_t)zmm14, (uint32_t)zmm13, 
0002cccd          (uint32_t)zmm15, (uint32_t)zmm11, &dist2);
0002ccda      void lines_1;
0002ccda      void* rsi = &lines_1;
0002cce2      uint64_t i_3 = (uint64_t)(uint32_t)(i_2 + 4);
0002cce6      int32_t* rdi_1 = (char*)pertLines - &lines_1;
0002cd96      int512_t zmm6;
0002cd96      int512_t zmm7;
0002cd96      uint64_t i_1;
0002cd96      
0002cd96      do
0002cd96      {
0002ccfa          memmove(&lines_1, lines, 0x30);
0002cd16          void var_138;
0002cd16          float r1 = (uint32_t)zmm11 + *(uint32_t*)(&var_138 + rbx);
0002cd1c          void var_128;
0002cd1c          float s1 = (uint32_t)zmm12 + *(uint32_t*)(&var_128 + rbx);
0002cd22          void var_118;
0002cd22          float t1 = (uint32_t)zmm13 + *(uint32_t*)(&var_118 + rbx);
0002cd28          *(uint32_t*)rsi = *(uint32_t*)((char*)rdi_1 + rsi);
0002cd36          *(uint32_t*)((char*)rsi + 4) = *(uint32_t*)((char*)rdi_1 + rsi + 4);
0002cd39          int32_t rax_4 = *(uint32_t*)((char*)rdi_1 + rsi + 8);
0002cd3d          void var_f8;
0002cd3d          float t2 = (uint32_t)zmm15 + *(uint32_t*)(&var_f8 + rbx);
0002cd46          void var_108;
0002cd46          float s2 = (uint32_t)zmm14 + *(uint32_t*)(&var_108 + rbx);
0002cd4c          *(uint32_t*)(&var_138 + rbx) = r1;
0002cd52          *(uint32_t*)((char*)rsi + 8) = rax_4;
0002cd64          *(uint32_t*)(&var_128 + rbx) = s1;
0002cd6a          *(uint32_t*)(&var_118 + rbx) = t1;
0002cd76          *(uint32_t*)(&var_108 + rbx) = s2;
0002cd7c          *(uint32_t*)(&var_f8 + rbx) = t2;
0002cd85          zmm6 = DoLineTriangulation(&lines_1, s1, s2, t1, t2, r1, (char*)rbx + pertDist2);
0002cd8a          rsi += 0xc;
0002cd8e          rbx += 4;
0002cd92          i_1 = i_3;
0002cd92          i_3 -= 1;
0002cd96      } while (i_1 != 1);
0002cdb9      (uint128_t)zmm6 = var_28;
0002cdbe      (uint128_t)zmm7 = var_38;
0002cdf9      return dist2;
0002cb18  }

0002cdfa                                                                                cc cc cc cc cc cc                            ......

0002ce00    float FE_Linearize(struct _ctl_context_t* pContext, uint8_t sensor, float edge)

0002ce00  {
0002ce06      float edge_2 = edge;
0002ce0d      float zmm1 = pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[1];
0002ce16      zmm1 - 0f;
0002ce16      
0002ce1b      if (!FCMP_UO(zmm1, 0f) && !(zmm1 != 0f))
0002ce1d          return edge;
0002ce1d      
0002ce39      edge = edge * edge_2;
0002ce49      float edge_1 = edge;
0002ce4c      edge = edge * edge_2;
0002ce61      float zmm3 = (pContext->settings.temperature.factory - (
0002ce61          pContext->settings.sensor[(uint64_t)sensor].camToBoardTempOffset
0002ce61          + pContext->temperature)) * pContext->settings.temperature.correction + zmm1;
0002ce68      zmm1 = edge * pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[3];
0002ce75      edge = edge * edge_2;
0002ce82      zmm3 = zmm3 * edge_2 + pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[0]
0002ce82          + edge_1 * pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[2];
0002ce89      edge_1 = edge * pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[4];
0002ce96      edge = edge * edge_2;
0002ce9d      zmm3 = zmm3 + zmm1 + edge_1;
0002cea1      edge_1 = pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[6];
0002ceb3      edge_1 - 0f;
0002ceb6      zmm3 = zmm3 + edge * pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[5];
0002ceb6      
0002cebc      if (!FCMP_UO(edge_1, 0f) && edge_1 == 0f)
0002cede          return zmm3;
0002cede      
0002cebe      edge = edge * edge_2;
0002ced7      return zmm3 + edge_1 * edge
0002ced7          + edge * edge_2 * pContext->settings.sensor[(uint64_t)sensor].PolyCoffs[7];
0002ce00  }

0002cedf                                                                                               cc                                 .
0002cee0  cc cc cc cc cc cc cc cc                                                                          ........

0002cee8    float Edge_Interpolate(uint16_t adc2, uint16_t adc1, uint16_t trg2, uint16_t trg1, uint16_t adcPix2)

0002cee8  {
0002cee8      uint128_t zmm0 = 0xbf800000;
0002cef3      uint32_t adc2_1 = (uint32_t)adc2;
0002cefa      uint32_t trg2_1 = (uint32_t)trg2;
0002cefe      uint32_t rdx_1 = adc2_1 - (uint32_t)adc1;
0002cf07      uint32_t rcx_1 = trg2_1 - (uint32_t)trg1;
0002cf09      uint32_t rdx_2 = rdx_1 - rcx_1;
0002cf09      
0002cf0b      if (rdx_1 != rcx_1)
0002cf0b      {
0002cf1f          uint128_t zmm1 = _mm_cvtepi32_ps((uint128_t)rdx_2);
0002cf29          (uint32_t)zmm0 =
0002cf29              _mm_cvtepi32_ps((uint128_t)((uint32_t)adcPix2 * rdx_2 - adc2_1 + trg2_1))
0002cf29              / (uint32_t)zmm1;
0002cf0b      }
0002cf0b      
0002cf2d      return (uint32_t)zmm0;
0002cee8  }

0002cf2e                                            cc cc cc cc cc cc                                                    ......

0002cf34    void ProcessSimTwoTouchFilter(struct _ctl_context_t* pContext, struct sim_two_touch_t* simTwoTouch, struct sub_sample_t* ssOut, struct twoSensorTriangulationMngr_t* twoSensorTriangulation)

0002cf34  {
0002cf48      struct twoSensorTriangulationMngr_t* twoSensorTriangulation_1 =
0002cf48          twoSensorTriangulation;
0002cf4b      struct sub_sample_t* ssOut_1 = ssOut;
0002cf4e      simTwoTouch->orientation = O_UNKNOWN;
0002cf54      simTwoTouch->confidence = 0f;
0002cf5a      (uint8_t)twoSensorTriangulation = twoSensorTriangulation->numTouchesFromEdges;
0002cf5e      struct sim_two_touch_t* simTwoTouch_1 = simTwoTouch;
0002cf5e      
0002cf6f      if ((uint8_t)twoSensorTriangulation != 2
0002cf6f          || twoSensorTriangulation_1->prevNumTouchesFromEdges)
0002cf6f      {
0002d0d7          (uint8_t)ssOut = pContext->currentSensor;
0002d0da          UpdateSimTwoTouchFilter(pContext, simTwoTouch, (uint8_t)ssOut, 
0002d0da              (uint8_t)twoSensorTriangulation);
0002d0da          return;
0002cf6f      }
0002cf6f      
0002cf75      (uint8_t)twoSensorTriangulation = simTwoTouch->lastDipIndex;
0002cf7c      int32_t arg_20 = 0xffffffff;
0002cf81      int32_t arg_24 = 0xffffffff;
0002cf86      (uint8_t)simTwoTouch = 0;
0002cf89      (uint8_t)twoSensorTriangulation_1 = 0;
0002cf8c      (uint8_t)pContext = 0;
0002cf8f      (uint8_t)ssOut = 0;
0002cf92      char arg_13 = 0;
0002cf97      uint64_t rbx;
0002cf97      (uint8_t)rbx = 0;
0002cf9a      char arg_12 = 0;
0002cf9e      char arg_10[0x2];
0002cf9e      arg_10[0] = 0;
0002cfa2      arg_10[1] = 0;
0002cfa6      int64_t rdi;
0002cfa6      (uint8_t)rdi = 0;
0002cfa6      
0002cfb4      while ((uint8_t)rdi < simTwoTouch_1->numDataFrames)
0002cfb4      {
0002cfbc          if ((uint8_t)twoSensorTriangulation_1 != (uint8_t)pContext)
0002cfbc          {
0002cfbe              rbx = (uint64_t)(uint8_t)rbx;
0002cfbe              
0002cfc4              if ((uint8_t)simTwoTouch != (uint8_t)ssOut)
0002cfc4                  rbx = 1;
0002cfbc          }
0002cfbc          
0002cfc8          uint64_t rdx = (uint64_t)(uint8_t)twoSensorTriangulation;
0002cfda          pContext = (uint64_t)simTwoTouch_1->minWaveformDip[rdx][0].sensor;
0002cfe0          (&arg_10)[pContext][0] = 0;
0002cfe5          arg_11;
0002cfe5          *(uint8_t*)(&arg_11 + (pContext << 1)) = 0;
0002cfea          (uint8_t)pContext = 0;
0002cfea          
0002d03b          do
0002d03b          {
0002cff3              simTwoTouch = ((uint64_t)(uint8_t)pContext + rdx * 6) * 5;
0002cff3              
0002cffc              if (*(uint16_t*)((char*)simTwoTouch_1 + (simTwoTouch << 2)) > 0)
0002cffc              {
0002cffe                  ssOut = (uint64_t)(&simTwoTouch_1->minWaveformDip[0][0].sensor)[
0002cffe                      simTwoTouch << 2];
0002d004                  int32_t zmm1 =
0002d004                      (&simTwoTouch_1->minWaveformDip[0][0].linEdge)[simTwoTouch];
0002d00e                  twoSensorTriangulation_1 = ssOut * 0x70;
0002d00e                  
0002d021                  if (!(zmm1 < *(uint32_t*)((char*)twoSensorTriangulation_1 + ssOut_1)) &&
0002d021                      *(uint32_t*)(&twoSensorTriangulation_1->quickTapSavedFrames + ssOut_1)
0002d021                      >= zmm1)
0002d021                  {
0002d03f                      twoSensorTriangulation_1 = (uint64_t)(uint8_t)ssOut;
0002d03f                      
0002d048                      if (!*(uint8_t*)(&arg_11 + (twoSensorTriangulation_1 << 1)))
0002d04a                          (&arg_20)[twoSensorTriangulation_1] = 0;
0002d04a                      
0002d04e                      (&arg_10)[twoSensorTriangulation_1][0] = 1;
0002d053                      break;
0002d021                  }
0002d021                  
0002d033                  if (!(zmm1 < *(uint32_t*)(
0002d033                      &twoSensorTriangulation_1->quickTapSavedFrames[0].edges[1] + ssOut_1)) &&
0002d033                      *(uint32_t*)(
0002d033                      &twoSensorTriangulation_1->quickTapSavedFrames[0].edges[2] + ssOut_1)
0002d033                      >= zmm1)
0002d033                  {
0002d055                      twoSensorTriangulation_1 = (uint64_t)(uint8_t)ssOut;
0002d055                      
0002d05e                      if (!(&arg_10)[twoSensorTriangulation_1][0])
0002d060                          (&arg_20)[twoSensorTriangulation_1] = 1;
0002d060                      
0002d065                      *(uint8_t*)(&arg_11 + (twoSensorTriangulation_1 << 1)) = 1;
0002d065                      break;
0002d033                  }
0002cffc              }
0002cffc              
0002d035              (uint8_t)pContext += 1;
0002d03b          } while ((uint8_t)pContext < 6);
0002d03b          
0002d06d          if ((uint8_t)twoSensorTriangulation <= 0)
0002d074              (uint8_t)twoSensorTriangulation = 7;
0002d06d          else
0002d06f              (uint8_t)twoSensorTriangulation -= 1;
0002d06f          
0002d077          (uint8_t)rdi += 1;
0002d077          
0002d07d          if ((uint8_t)rbx)
0002d07d              break;
0002d07d          
0002d07f          (uint8_t)ssOut = arg_13;
0002d084          (uint8_t)simTwoTouch = arg_12;
0002d088          (uint8_t)pContext = arg_10[1];
0002d08c          (uint8_t)twoSensorTriangulation_1 = arg_10[0];
0002cfb4      }
0002cfb4      
0002d0a3      if (arg_20 == 0xffffffff || arg_24 == 0xffffffff)
0002d0a3          return;
0002d0a3      
0002d0a9      if (arg_20 == arg_24)
0002d0a9      {
0002d0c3          simTwoTouch_1->orientation = O_HORIZONTAL;
0002d0ca          simTwoTouch_1->confidence = -0.800000012f;
0002d0a9      }
0002d0a9      else
0002d0a9      {
0002d0ab          simTwoTouch_1->orientation = O_VERTICAL;
0002d0b6          simTwoTouch_1->confidence = 0.800000012f;
0002d0a9      }
0002cf34  }

0002d0f2                                                        cc cc cc cc cc cc                                            ......

0002d0f8    void UpdateSimTwoTouchFilter(struct _ctl_context_t* pContext, struct sim_two_touch_t* simTwoTouchData, uint8_t sensor, uint8_t numTouches)

0002d0f8  {
0002d111      int64_t rdi = 0;
0002d113      int64_t rbp;
0002d113      (uint8_t)rbp = sensor;
0002d116      struct sim_two_touch_t* simTwoTouchData_1 = simTwoTouchData;
0002d116      
0002d11f      if (numTouches)
0002d11f      {
0002d1e7          simTwoTouchData->numDataFrames = 0;
0002d1ee          simTwoTouchData->lastDipIndex = 0;
0002d1f5          simTwoTouchData->currentDipIndex = 0;
0002d207          memset(simTwoTouchData_1, 0, 0x3c0);
0002d207          return;
0002d11f      }
0002d11f      
0002d125      int64_t i_1 = 6;
0002d1ad      int64_t i;
0002d1ad      
0002d1ad      do
0002d1ad      {
0002d12f          (uint8_t)simTwoTouchData = (uint8_t)rbp;
0002d13d          int64_t r8 = (rdi + (uint64_t)simTwoTouchData_1->currentDipIndex * 6) * 5;
0002d14d          (&simTwoTouchData_1->minWaveformDip[0][0].linEdge)[r8] = FE_Linearize(pContext, 
0002d14d              (uint8_t)simTwoTouchData, 
0002d14d              (&simTwoTouchData_1->minWaveformDip[0][0].interpolatedEdge)[r8]);
0002d15b          (uint8_t)r8 = 1;
0002d162          int64_t rax_4 = rdi + (uint64_t)simTwoTouchData_1->currentDipIndex * 6;
0002d16f          int64_t rcx_3;
0002d16f          (uint8_t)rcx_3 = (uint8_t)rbp;
0002d175          ConvertToRad((uint8_t)rcx_3, 
0002d175              &simTwoTouchData_1->minWaveformDip[0][rax_4].linEdge, (uint8_t)r8, 
0002d175              &simTwoTouchData_1->minWaveformDip[0][rax_4].linEdge);
0002d175          
0002d17d          if ((uint8_t)rbp == 1)
0002d17d          {
0002d196              int64_t rcx_5 = (rdi + (uint64_t)simTwoTouchData_1->currentDipIndex * 6) * 5;
0002d1a0              (&simTwoTouchData_1->minWaveformDip[0][0].linEdge)[rcx_5] =
0002d1a0                  1.57079637f - (&simTwoTouchData_1->minWaveformDip[0][0].linEdge)[rcx_5];
0002d17d          }
0002d17d          
0002d1a6          rdi += 1;
0002d1a9          i = i_1;
0002d1a9          i_1 -= 1;
0002d1ad      } while (i != 1);
0002d1b3      uint32_t currentDipIndex = (uint32_t)simTwoTouchData_1->currentDipIndex;
0002d1ba      simTwoTouchData_1->lastDipIndex = (uint8_t)currentDipIndex;
0002d1c2      char temp1_1;
0002d1c2      char temp2_1;
0002d1c2      temp1_1 = HIGHD((int64_t)(currentDipIndex + 1));
0002d1c2      temp2_1 = LOWD((int64_t)(currentDipIndex + 1));
0002d1c3      char rdx_1 = temp1_1 & 7;
0002d1cd      simTwoTouchData_1->currentDipIndex = ((temp2_1 + rdx_1) & 7) - rdx_1;
0002d1d3      uint8_t numDataFrames = simTwoTouchData_1->numDataFrames;
0002d1d3      
0002d1db      if (numDataFrames < 8)
0002d1df          simTwoTouchData_1->numDataFrames = numDataFrames + 1;
0002d0f8  }

0002d227                       cc cc cc cc cc cc cc cc cc                                                         .........

0002d230    void TTS_TrackTouches(struct track_state_data_t* pTrackStateData, struct touches_t* inputTouches, struct touches_t* outputTouches, uint8_t const stable, uint8_t pretouchUnlink)

0002d230  {
0002d250      void var_d8;
0002d250      int64_t rax_1 = __security_cookie ^ &var_d8;
0002d25b      int64_t i_3 = 0;
0002d25e      int64_t r14;
0002d25e      (uint8_t)r14 = stable;
0002d264      uint8_t rdi = 1;
0002d264      
0002d273      if (pretouchUnlink == 1)
0002d273      {
0002d288          if (stable || !pTrackStateData->lastStateWasSingleTouch
0002d288                  || inputTouches->id.id <= 0)
0002d29c              pTrackStateData->numConsecutiveUnstableTouches = 0;
0002d288          else if (pTrackStateData->stabilityOfPreTouch)
0002d293              pTrackStateData->numConsecutiveUnstableTouches += 1;
0002d273      }
0002d273      
0002d2ad      int64_t rcx = (int64_t)((uint32_t)pTrackStateData->touchLatestIndex + 1);
0002d2bd      uint64_t rdx_1 = rcx / 5;
0002d2c5      uint8_t rcx_1 = (uint8_t)rcx - ((uint8_t)rdx_1 + (char)(rdx_1 << 2));
0002d2c8      int64_t rbp;
0002d2c8      (uint8_t)rbp = rcx_1;
0002d2cb      pTrackStateData->touchLatestIndex = rcx_1;
0002d2d1      char temp0 = (uint8_t)rbp;
0002d2d1      (uint8_t)rbp -= 1;
0002d2d1      
0002d2d4      if (temp0 - 1 < 0)
0002d2d6          (uint8_t)rbp += 5;
0002d2d6      
0002d2ee      memset(&pTrackStateData->touchHistory[(uint64_t)rcx_1], 0, 0x30);
0002d2f3      char i = 0;
0002d2fa      uint64_t rdx_2;
0002d2fa      
0002d2fa      if (inputTouches->touchCount > 0)
0002d2fa      {
0002d377          do
0002d377          {
0002d2fc              uint64_t i_2 = (uint64_t)i;
0002d300              i += 1;
0002d30e              rdx_2 = i_2 * 0x14;
0002d321              *(uint64_t*)((uint64_t)pTrackStateData->touchLatestIndex * 0x30 + rdx_2
0002d321                  + pTrackStateData) = *(uint64_t*)(rdx_2 + inputTouches);
0002d33b              *(uint32_t*)(&pTrackStateData->touchHistory[0].touches[0].width
0002d33b                  + (uint64_t)pTrackStateData->touchLatestIndex * 0x30 + rdx_2) =
0002d33b                  *(uint32_t*)(&inputTouches->touches[0].width + rdx_2);
0002d355              *(uint32_t*)(&pTrackStateData->touchHistory[0].touches[0].height
0002d355                  + (uint64_t)pTrackStateData->touchLatestIndex * 0x30 + rdx_2) =
0002d355                  *(uint32_t*)(&inputTouches->touches[0].height + rdx_2);
0002d36b              *(uint32_t*)(&pTrackStateData->touchHistory[0].touches[0].touchState
0002d36b                  + (uint64_t)pTrackStateData->touchLatestIndex * 0x30 + rdx_2) = 6;
0002d377          } while (i < inputTouches->touchCount);
0002d2fa      }
0002d2fa      
0002d384      uint64_t rax_14;
0002d384      (uint8_t)rax_14 = inputTouches->touchCount;
0002d38a      (&pTrackStateData->touchHistory[0].touchCount)[
0002d38a          (uint64_t)pTrackStateData->touchLatestIndex * 0x30] = (uint8_t)rax_14;
0002d399      int32_t rax_16;
0002d399      (uint16_t)rax_16 = inputTouches->id.id;
0002d399      *(uint16_t*)((char*)rax_16)[2] = inputTouches->id.deltaTimeStamp;
0002d39f      (&pTrackStateData->touchHistory[0].id)[(uint64_t)pTrackStateData->touchLatestIndex
0002d39f          * 0xc].id = rax_16;
0002d39f      
0002d3ab      if (pretouchUnlink == 1)
0002d3ab      {
0002d3bc          int64_t rax_18;
0002d3bc          (uint32_t)rax_18 = pTrackStateData->lastStableTouchPos.x;
0002d3bc          *(uint32_t*)((char*)rax_18)[4] = pTrackStateData->lastStableTouchPos.y;
0002d3c7          void* rcx_23 =
0002d3c7              &pTrackStateData->touchHistory[(uint64_t)pTrackStateData->touchLatestIndex];
0002d3c7          
0002d3e7          if (!(uint8_t)r14 && inputTouches->id.id > 0
0002d3e7              && pTrackStateData->lastStateWasSingleTouch
0002d3e7              && pTrackStateData->numConsecutiveUnstableTouches <= 5)
0002d3e7          {
0002d3e9              *(uint32_t*)rcx_23 = (uint32_t)rax_18;
0002d3e9              *(uint32_t*)((char*)rcx_23 + 4) = *(uint32_t*)((char*)rax_18)[4];
0002d3e9              
0002d3f0              if (!*(uint32_t*)((char*)rcx_23 + 8))
0002d3f2                  *(uint8_t*)((char*)rcx_23 + 0x28) += 1;
0002d3f2              
0002d3f6              *(uint32_t*)((char*)rcx_23 + 8) = 6;
0002d3e7          }
0002d3e7          
0002d40a          (uint8_t)rdx_2 =
0002d40a              pTrackStateData->stabilityOfPreTouch == PRETOUCHPOINT_UNSTABLE_LIFT;
0002d411          uint64_t rcx_25 = (uint64_t)pTrackStateData->touchLatestIndex * 6;
0002d411          
0002d425          if (pTrackStateData->numConsecutiveUnstableTouches >= 5
0002d425              && pTrackStateData->lastStateWasSingleTouch)
0002d425          {
0002d42a              if ((uint8_t)rdx_2)
0002d42a              {
0002d43b                  if ((uint8_t)rdx_2 == 1)
0002d43b                  {
0002d43d                      (&pTrackStateData->touchHistory[0].touches[0].touchState)[rcx_25
0002d43d                          * 2] = 0;
0002d442                      (&pTrackStateData->touchHistory[0].touchCount)[rcx_25 << 3] = 0;
0002d43b                  }
0002d42a              }
0002d42a              else if (pTrackStateData->timeSinceLastNoEdges > 0x186a0
0002d42a                  || (uint8_t)rdx_2 == 1)
0002d43b              {
0002d43d                  (&pTrackStateData->touchHistory[0].touches[0].touchState)[rcx_25 * 2] = 0;
0002d442                  (&pTrackStateData->touchHistory[0].touchCount)[rcx_25 << 3] = 0;
0002d43b              }
0002d425          }
0002d3ab      }
0002d3ab      
0002d44f      uint64_t r12_1 = (uint64_t)(uint8_t)rbp * 6;
0002d452      uint32_t r9 = (uint32_t)(&pTrackStateData->touchHistory[0].touchCount)[r12_1 << 3];
0002d45e      char var_b8[0x80];
0002d45e      
0002d45e      if (!r9)
0002d45e      {
0002d5ea          pTrackStateData->prevTouchDistance[0] = 0;
0002d5f1          pTrackStateData->prevTouchDistance[1] = 0f;
0002d5f8          pTrackStateData->lastDeltaTime = 0f;
0002d5ff          pTrackStateData->lastTimeStamp = 0;
0002d45e      }
0002d45e      else
0002d45e      {
0002d466          uint64_t rsi_2;
0002d466          uint8_t touchLatestIndex;
0002d466          int32_t line;
0002d466          
0002d466          if (r9 == 1)
0002d466          {
0002d548              touchLatestIndex = pTrackStateData->touchLatestIndex;
0002d54f              uint8_t touchLatestIndex_1 = touchLatestIndex;
0002d54f              touchLatestIndex -= 2;
0002d54f              
0002d553              if (touchLatestIndex_1 - 2 < 0)
0002d555                  touchLatestIndex += 5;
0002d555              
0002d561              rsi_2 = (uint64_t)touchLatestIndex * 6;
0002d564              uint32_t r9_2 =
0002d564                  (uint32_t)(&pTrackStateData->touchHistory[0].touchCount)[rsi_2 << 3];
0002d564              
0002d570              if (r9_2)
0002d570              {
0002d578                  if (r9_2 == 1)
0002d578                  {
0002d5ba                      (uint8_t)rdx_2 = (uint8_t)rbp;
0002d5ba                      
0002d5c8                      if (!ProcessOneToOneTransition(pTrackStateData, (uint8_t)rdx_2, 
0002d5c8                          touchLatestIndex))
0002d5c8                      {
0002d5ca                          line = 0x240;
0002d5d0                      label_2d5d0:
0002d5de                          onError__("Expected 1 touch but found none!", 
0002d5de                              "c:\development_work\csf_release_hp\driver\foureyes\f"
0002d5de                          "e_track_state.c", 
0002d5de                              line);
0002d5e3                          (&pTrackStateData->touchHistory[0].touchCount)[rsi_2 << 3] = 0;
0002d5c8                      }
0002d578                  }
0002d578                  else if (r9_2 == 2)
0002d57c                  {
0002d59f                      (uint8_t)rdx_2 = (uint8_t)rbp;
0002d59f                      
0002d5ad                      if (!ProcessTwoToOneTransition(pTrackStateData, (uint8_t)rdx_2, 
0002d5ad                          touchLatestIndex))
0002d5ad                      {
0002d5af                          line = 0x24f;
0002d51d                      label_2d51d:
0002d5de                          onError__("Expected 2 touches but found none!", 
0002d5de                              "c:\development_work\csf_release_hp\driver\foureyes\f"
0002d5de                          "e_track_state.c", 
0002d5de                              line);
0002d5e3                          (&pTrackStateData->touchHistory[0].touchCount)[rsi_2 << 3] = 0;
0002d5ad                      }
0002d57c                  }
0002d57c                  else
0002d57c                  {
0002d58f                      RtlStringCchPrintfA(&var_b8, 0x80, "Too many old touches: %d!");
0002d594                      line = 0x25d;
0002d4f9                  label_2d4f9:
0002d5de                      onError__(&var_b8, 
0002d5de                          "c:\development_work\csf_release_hp\driver\foureyes\fe_track_state.c", 
0002d5de                          line);
0002d5e3                      (&pTrackStateData->touchHistory[0].touchCount)[rsi_2 << 3] = 0;
0002d57c                  }
0002d570              }
0002d466          }
0002d466          else if (r9 == 2)
0002d46e          {
0002d4a7              touchLatestIndex = pTrackStateData->touchLatestIndex;
0002d4ae              uint8_t touchLatestIndex_2 = touchLatestIndex;
0002d4ae              touchLatestIndex -= 2;
0002d4ae              
0002d4b2              if (touchLatestIndex_2 - 2 < 0)
0002d4b4                  touchLatestIndex += 5;
0002d4b4              
0002d4c0              rsi_2 = (uint64_t)touchLatestIndex * 6;
0002d4c3              uint32_t r9_1 =
0002d4c3                  (uint32_t)(&pTrackStateData->touchHistory[0].touchCount)[rsi_2 << 3];
0002d4c3              
0002d4cf              if (r9_1)
0002d4cf              {
0002d4d7                  if (r9_1 == 1)
0002d4d7                  {
0002d529                      (uint8_t)rdx_2 = (uint8_t)rbp;
0002d529                      
0002d537                      if (!ProcessOneToTwoTransition(pTrackStateData, (uint8_t)rdx_2, 
0002d537                          touchLatestIndex))
0002d537                      {
0002d53d                          line = 0x350;
0002d543                          goto label_2d5d0;
0002d537                      }
0002d4d7                  }
0002d4d7                  else
0002d4d7                  {
0002d4db                      if (r9_1 != 2)
0002d4db                      {
0002d4ee                          RtlStringCchPrintfA(&var_b8, 0x80, "Too many old touches: %d!");
0002d4f3                          line = 0x36d;
0002d4f3                          goto label_2d4f9;
0002d4db                      }
0002d4db                      
0002d503                      (uint8_t)rdx_2 = (uint8_t)rbp;
0002d503                      
0002d511                      if (!ProcessTwoToTwoTransition(pTrackStateData, (uint8_t)rdx_2, 
0002d511                          touchLatestIndex))
0002d511                      {
0002d517                          line = 0x35f;
0002d517                          goto label_2d51d;
0002d511                      }
0002d4d7                  }
0002d4cf              }
0002d46e          }
0002d46e          else
0002d46e          {
0002d481              RtlStringCchPrintfA(&var_b8, 0x80, "Too many touches: %d!");
0002d498              onError__(&var_b8, 
0002d498                  "c:\development_work\csf_release_hp\driver\foureyes\fe_track_state.c", 
0002d498                  0x222);
0002d49d              (&pTrackStateData->touchHistory[0].touchCount)[r12_1 << 3] = 0;
0002d46e          }
0002d45e      }
0002d45e      
0002d606      uint64_t rax_20;
0002d606      (uint8_t)rax_20 = pTrackStateData->touchLatestIndex;
0002d60c      char temp2 = (uint8_t)rax_20;
0002d60c      (uint8_t)rax_20 -= 2;
0002d60c      
0002d60e      if (temp2 - 2 < 0)
0002d610          (uint8_t)rax_20 += 5;
0002d610      
0002d619      uint64_t rcx_42 = (uint64_t)(uint8_t)rax_20 * 6;
0002d619      
0002d628      if ((&pTrackStateData->touchHistory[0].touchCount)[rcx_42 << 3] > 0
0002d628          || (&pTrackStateData->touchHistory[0].touchCount)[r12_1 << 3] > 0)
0002d628      {
0002d62e          void* rsi_4 =
0002d62e              &(&pTrackStateData->touchHistory[0].touches[0].touchState)[r12_1 * 2];
0002d633          void* rbp_1 =
0002d633              &(&pTrackStateData->touchHistory[0].touches[0].touchState)[rcx_42 * 2];
0002d638          i_3 = 2;
0002d6c2          int64_t i_1;
0002d6c2          
0002d6c2          do
0002d6c2          {
0002d63e              int32_t r9_3 = *(uint32_t*)rbp_1;
0002d645              int32_t rax_23;
0002d645              
0002d645              if (!r9_3)
0002d645              {
0002d6b2                  (uint8_t)rax_23 = *(uint32_t*)rsi_4 == 6;
0002d6b5                  *(uint32_t*)rsi_4 = rax_23;
0002d645              }
0002d645              else if (r9_3 <= 0)
0002d647              {
0002d666              label_2d666:
0002d666                  RtlStringCchPrintfA(&var_b8, 0x80, 
0002d666                      "Unknown or unexpected old touch state %d!");
0002d67d                  onError__(&var_b8, 
0002d67d                      "c:\development_work\csf_release_hp\driver\foureyes\fe_track_state.c", 
0002d67d                      0x1ea);
0002d682                  *(uint32_t*)rbp_1 = 0;
0002d686                  *(uint32_t*)rsi_4 = 0;
0002d647              }
0002d647              else if (r9_3 > 2)
0002d64d              {
0002d653                  if (r9_3 != 3)
0002d653                      goto label_2d666;
0002d653                  
0002d6b2                  (uint8_t)rax_23 = *(uint32_t*)rsi_4 == 6;
0002d6b5                  *(uint32_t*)rsi_4 = rax_23;
0002d64d              }
0002d64d              else if (*(uint32_t*)rsi_4 != 6)
0002d68e              {
0002d698                  *(uint32_t*)rsi_4 = 3;
0002d6a2                  *(uint64_t*)((char*)rsi_4 - 8) = *(uint64_t*)((char*)rbp_1 - 8);
0002d6a6                  (&pTrackStateData->touchHistory[0].touchCount)[r12_1 << 3] += 1;
0002d68e              }
0002d68e              else
0002d690                  *(uint32_t*)rsi_4 = 2;
0002d6b7              rbp_1 += 0x14;
0002d6bb              rsi_4 += 0x14;
0002d6bf              i_1 = i_3;
0002d6bf              i_3 -= 1;
0002d6c2          } while (i_1 != 1);
0002d628      }
0002d628      
0002d6d0      if (pretouchUnlink == 1)
0002d6d0      {
0002d6dd          uint64_t rcx_46 = (uint64_t)pTrackStateData->touchLatestIndex * 6;
0002d6dd          
0002d6e3          if ((uint8_t)r14 == 1)
0002d6e3          {
0002d6ea              uint64_t rax_24;
0002d6ea              (uint8_t)rax_24 =
0002d6ea                  (&pTrackStateData->touchHistory[0].touches[0].touchState)[rcx_46 * 2]
0002d6ea                  != (uint32_t)i_3;
0002d6ea              
0002d6f0              if ((uint8_t)rax_24 != (uint8_t)i_3)
0002d6f0              {
0002d6f2                  struct fpoint_t rax_25;
0002d6f2                  rax_25.x = *(uint32_t*)((char*)pTrackStateData + (rcx_46 << 3));
0002d6f2                  rax_25.y =
0002d6f2                      (&pTrackStateData->touchHistory[0].touches[0].position.y)[rcx_46 * 2];
0002d6f6                  pTrackStateData->lastStableTouchPos.x = rax_25.x;
0002d6f6                  pTrackStateData->lastStableTouchPos.y = rax_25.y;
0002d6f0              }
0002d6f0              
0002d702              if ((uint8_t)rax_24 == (uint8_t)i_3
0002d702                      || (&pTrackStateData->touchHistory[0].touchCount)[rcx_46 << 3] != 1)
0002d704                  rdi = (uint8_t)i_3;
0002d704              
0002d707              pTrackStateData->lastStateWasSingleTouch = rdi;
0002d6e3          }
0002d6d0      }
0002d6d0      
0002d719      __security_check_cookie(rax_1 ^ &var_d8);
0002d230  }

0002d73a                                                                                cc cc cc cc cc cc                            ......

0002d740    uint8_t ProcessOneToOneTransition(struct track_state_data_t* pTrackStateData, uint8_t currentSlotIndex, uint8_t previousSlotIndex)

0002d740  {
0002d75c      void var_108;
0002d75c      uint64_t var_48 = __security_cookie ^ &var_108;
0002d764      void* rbx;
0002d764      (uint8_t)rbx = 0;
0002d766      int64_t r12;
0002d766      (uint8_t)r12 = previousSlotIndex;
0002d769      int64_t r13;
0002d769      (uint8_t)r13 = currentSlotIndex;
0002d76c      int64_t rsi;
0002d76c      (uint8_t)rsi = 0;
0002d76c      
0002d77a      while (!(uint8_t)rbx)
0002d77a      {
0002d788          uint64_t rcx_1 = (uint64_t)(uint8_t)rsi * 0x14;
0002d794          uint64_t rdi_3 = (uint64_t)(uint8_t)r12 * 0x30 + rcx_1;
0002d797          int32_t r9_1 =
0002d797              *(uint32_t*)(&pTrackStateData->touchHistory[0].touches[0].touchState + rdi_3);
0002d797          
0002d79f          if (r9_1)
0002d79f          {
0002d7a1              if (r9_1 <= 0)
0002d7a1              {
0002d7c4              label_2d7c4:
0002d7c4                  char var_c8[0x80];
0002d7c4                  RtlStringCchPrintfA(&var_c8, 0x80, 
0002d7c4                      "Unknown or unexpected old touch state %d!");
0002d7db                  onError__(&var_c8, 
0002d7db                      "c:\development_work\csf_release_hp\driver\foureyes\fe_track_state.c", 
0002d7db                      0x2a5);
0002d7e0                  *(uint32_t*)(
0002d7e0                      &pTrackStateData->touchHistory[0].touches[0].touchState + rdi_3) = 0;
0002d7a1              }
0002d7a1              else if (r9_1 <= 2)
0002d7a7              {
0002d815                  if ((uint8_t)rsi)
0002d815                  {
0002d822                      uint64_t rdx_1 = (uint64_t)(uint8_t)r13 * 6;
0002d829                      void* rdi_4 = (char*)pTrackStateData + (rdx_1 << 3);
0002d833                      rbx = rcx_1 + (rdx_1 << 3) + pTrackStateData;
0002d839                      char var_e8[0x20];
0002d839                      memmove(&var_e8, rbx, 0x14);
0002d847                      memmove(rbx, rdi_4, 0x14);
0002d857                      memmove(rdi_4, &var_e8, 0x14);
0002d815                  }
0002d815                  
0002d85c                  (uint8_t)r9_1 = (uint8_t)rsi;
0002d868                  FixConnectingLines(pTrackStateData, (uint8_t)r13, (uint8_t)r12, 
0002d868                      (uint8_t)r9_1);
0002d86d                  (uint8_t)rbx = 1;
0002d7a7              }
0002d7a7              else
0002d7a7              {
0002d7ad                  if (r9_1 != 3)
0002d7ad                      goto label_2d7c4;
0002d7ad                  
0002d86d                  (uint8_t)rbx = 1;
0002d7a7              }
0002d79f          }
0002d79f          
0002d7e5          (uint8_t)rsi += 1;
0002d7e5          
0002d7ec          if ((uint8_t)rsi >= 2)
0002d7ec              break;
0002d77a      }
0002d77a      
0002d7ee      uint64_t rax_1;
0002d7ee      (uint8_t)rax_1 = (uint8_t)rbx;
0002d7fb      __security_check_cookie(var_48 ^ &var_108);
0002d811      return (uint8_t)rax_1;
0002d740  }

0002d874                                                              cc cc cc cc cc cc cc cc                                  ........

0002d87c    uint8_t ProcessTwoToOneTransition(struct track_state_data_t* pTrackStateData, uint8_t currentSlotIndex, uint8_t previousSlotIndex)

0002d87c  {
0002d887      int64_t rsi;
0002d887      int64_t arg_18 = rsi;
0002d8a0      uint8_t touchLatestIndex = pTrackStateData->touchLatestIndex;
0002d8a6      int64_t r14;
0002d8a6      (uint8_t)r14 = previousSlotIndex;
0002d8a9      int64_t r15;
0002d8a9      (uint8_t)r15 = currentSlotIndex;
0002d8a9      
0002d8b1      if (touchLatestIndex < 0)
0002d8b3          touchLatestIndex += 5;
0002d8b3      
0002d8c0      int64_t rbx;
0002d8c0      (uint8_t)rbx = 0;
0002d8c6      int64_t r13;
0002d8c6      (uint8_t)r13 = 0;
0002d8c9      int64_t r12;
0002d8c9      (uint8_t)r12 = 0;
0002d8d0      int128_t zmm6 = 0x4b18967f;
0002d8d7      uint64_t rax;
0002d8d7      
0002d8d7      if (pTrackStateData->touchHistory[(uint64_t)touchLatestIndex].touchCount <= 0)
0002d8d7      {
0002d97d      label_2d97d:
0002d97d          (uint8_t)rax = pTrackStateData->touchLatestIndex;
0002d983          char temp0_1 = (uint8_t)rax;
0002d983          (uint8_t)rax -= 3;
0002d983          
0002d985          if (temp0_1 - 3 < 0)
0002d987              (uint8_t)rax += 5;
0002d987          
0002d98c          (uint8_t)rbx = 0;
0002d98e          int64_t rbp_2 = 0;
0002d997          void* rsi_1 = &(&pTrackStateData->touchHistory[0].touches[0].touchState)[
0002d997              (uint64_t)(uint8_t)rax * 0xc];
0002d997          
0002d9ee          do
0002d9ee          {
0002d9a4              if (*(uint32_t*)rsi_1 == 1 || *(uint32_t*)rsi_1 == 2)
0002d9a4              {
0002d9b5                  struct fpoint_t* lineStart_1 =
0002d9b5                      (uint64_t)(uint8_t)r14 * 0x30 + rbp_2 + pTrackStateData;
0002d9b5                  
0002d9bc                  if (*(int64_t*)((char*)lineStart_1 + 8) == 2)
0002d9bc                  {
0002d9d1                      int128_t zmm0_2;
0002d9d1                      zmm0_2 = DistanceSquareToCentreLinePoint(
0002d9d1                          &pTrackStateData->touchHistory[(uint64_t)(uint8_t)r15], 
0002d9d1                          lineStart_1, (char*)rsi_1 - 8);
0002d9d1                      
0002d9d9                      if (!((uint32_t)zmm6 <= (uint32_t)zmm0_2))
0002d9d9                      {
0002d9db                          zmm6 = zmm0_2;
0002d9de                          (uint8_t)r13 = (uint8_t)rbx;
0002d9d9                      }
0002d9bc                  }
0002d9a4              }
0002d9a4              
0002d9e1              (uint8_t)rbx += 1;
0002d9e3              rbp_2 += 0x14;
0002d9e7              rsi_1 += 0x14;
0002d9ee          } while ((uint8_t)rbx < 2);
0002d9ee          
0002d9f0          9999999f - (uint32_t)zmm6;
0002d9f0          
0002d9f5          if (FCMP_UO(9999999f, (uint32_t)zmm6) || 9999999f != (uint32_t)zmm6)
0002d9f3              goto label_2da48;
0002d9f3          
0002d9fb          (uint8_t)rbx = 0;
0002da04          void* rsi_2 = &(&pTrackStateData->touchHistory[0].touches[0].touchState)[
0002da04              (uint64_t)(uint8_t)r14 * 0xc];
0002da04          
0002da3f          do
0002da3f          {
0002da11              if (*(uint32_t*)rsi_2 == 1 || *(uint32_t*)rsi_2 == 2)
0002da11              {
0002da26                  int128_t zmm0_3;
0002da26                  zmm0_3 = DistanceSquare(
0002da26                      &pTrackStateData->touchHistory[(uint64_t)(uint8_t)r15], 
0002da26                      (char*)rsi_2 - 8);
0002da26                  
0002da2e                  if (!((uint32_t)zmm6 <= (uint32_t)zmm0_3))
0002da2e                  {
0002da30                      zmm6 = zmm0_3;
0002da33                      (uint8_t)r13 = (uint8_t)rbx;
0002da2e                  }
0002da11              }
0002da11              
0002da36              (uint8_t)rbx += 1;
0002da38              rsi_2 += 0x14;
0002da3f          } while ((uint8_t)rbx < 2);
0002da3f          
0002da41          9999999f - (uint32_t)zmm6;
0002da41          
0002da46          if (FCMP_UO(9999999f, (uint32_t)zmm6) || !(9999999f == (uint32_t)zmm6))
0002da44              goto label_2da48;
0002d8d7      }
0002d8d7      else
0002d8d7      {
0002d95f          do
0002d95f          {
0002d8e0              if ((uint8_t)rbx >= 2)
0002d8e0                  goto label_2dab1;
0002d8e0              
0002d8e6              (uint8_t)rsi = 0;
0002d8e6              
0002d8ec              while ((uint8_t)rbx < 2)
0002d8ec              {
0002d905                  struct fpoint_t* lineStart = &pTrackStateData->touchHistory[(uint64_t)(
0002d905                      uint8_t)r14].touches[(uint64_t)(uint8_t)rsi];
0002d905                  
0002d913                  if (*(int64_t*)((char*)lineStart + 8) == 1
0002d913                      || *(int64_t*)((char*)lineStart + 8) == 2)
0002d913                  {
0002d93e                      int128_t zmm0_1;
0002d93e                      zmm0_1 = DistanceSquareToCentreLinePoint(
0002d93e                          &pTrackStateData->touchHistory[(uint64_t)(uint8_t)r15], 
0002d93e                          lineStart, 
0002d93e                          (uint64_t)touchLatestIndex * 0x30 + (uint64_t)(uint8_t)r12 * 0x14
0002d93e                              + pTrackStateData);
0002d93e                      
0002d946                      if (!((uint32_t)zmm6 <= (uint32_t)zmm0_1))
0002d946                      {
0002d948                          zmm6 = zmm0_1;
0002d94b                          (uint8_t)r13 = (uint8_t)rsi;
0002d946                      }
0002d913                  }
0002d913                  else if (*(int64_t*)((char*)lineStart + 8) == 3)
0002d91b                      (uint8_t)rbx += 1;
0002d91b                  
0002d94e                  (uint8_t)rsi += 1;
0002d94e                  
0002d955                  if ((uint8_t)rsi >= 2)
0002d955                      break;
0002d8ec              }
0002d8ec              
0002d957              (uint8_t)r12 += 1;
0002d95f          } while ((uint8_t)r12
0002d95f              < pTrackStateData->touchHistory[(uint64_t)touchLatestIndex].touchCount);
0002d95f          
0002d968          if ((uint8_t)rbx < 2)
0002d968          {
0002d96e              9999999f - (uint32_t)zmm6;
0002d96e              
0002d977              if (!FCMP_UO(9999999f, (uint32_t)zmm6) && !(9999999f != (uint32_t)zmm6))
0002d971                  goto label_2d97d;
0002d971              
0002da48          label_2da48:
0002da48              
0002da4b              if ((uint8_t)r13)
0002da4b              {
0002da70                  char* rbx_2 = (uint64_t)(uint8_t)r15 * 0x30
0002da70                      + (uint64_t)(uint8_t)r13 * 0x14 + pTrackStateData;
0002da73                  void* rdi_1 = &pTrackStateData->touchHistory[(uint64_t)r15];
0002da79                  char var_68[0x20];
0002da79                  memmove(&var_68, rbx_2, 0x14);
0002da8a                  memmove(rbx_2, rdi_1, 0x14);
0002da9d                  memmove(rdi_1, &var_68, 0x14);
0002da4b              }
0002d968          }
0002d8d7      }
0002d8d7      
0002dab1  label_2dab1:
0002dab1      (uint8_t)rax = 1;
0002dacb      return 1;
0002d87c  }

0002dacc                                      cc cc cc cc cc cc cc cc                                                  ........

0002dad4    uint8_t ProcessOneToTwoTransition(struct track_state_data_t* pTrackStateData, uint8_t currentSlotIndex, uint8_t previousSlotIndex)

0002dad4  {
0002dad7      int64_t rbx;
0002dad7      int64_t arg_20 = rbx;
0002dadb      uint8_t previousSlotIndex_1 = previousSlotIndex;
0002daf1      uint8_t touchLatestIndex = pTrackStateData->touchLatestIndex;
0002daf8      char rbp = 0;
0002db05      uint8_t previousSlotIndex_2 = previousSlotIndex;
0002db08      struct fpoint_t* r13;
0002db08      (uint8_t)r13 = currentSlotIndex;
0002db0b      struct track_state_data_t* pTrackStateData_1 = pTrackStateData;
0002db0b      
0002db0e      if (touchLatestIndex < 0)
0002db10          touchLatestIndex += 5;
0002db10      
0002db1c      int64_t r14;
0002db1c      (uint8_t)r14 = 5;
0002db1f      char i = 0;
0002db22      previousSlotIndex = 0;
0002db25      int128_t zmm6 = 0x4b18967f;
0002db25      
0002db2b      while (!i)
0002db2b      {
0002db44          pTrackStateData = (uint64_t)pTrackStateData_1->touchHistory[(uint64_t)
0002db44              previousSlotIndex_2].touches[(uint64_t)previousSlotIndex].touchState;
0002db44          
0002db50          if ((uint32_t)pTrackStateData == 1 || (uint32_t)pTrackStateData == 2)
0002db50          {
0002db5c              (uint8_t)r14 = previousSlotIndex;
0002db5f              i = 1;
0002db50          }
0002db50          else if ((uint32_t)pTrackStateData == 3)
0002db55          {
0002db57              zmm6 = {0};
0002db5f              i = 1;
0002db55          }
0002db55          
0002db62          previousSlotIndex += 1;
0002db62          
0002db69          if (previousSlotIndex >= 2)
0002db69              break;
0002db2b      }
0002db2b      
0002db6f      void* const* rax;
0002db6f      
0002db6f      if ((uint8_t)r14 != 5)
0002db6f      {
0002db79          int64_t r15;
0002db79          (uint8_t)r15 = 0;
0002db84          (uint8_t)pTrackStateData =
0002db84              pTrackStateData_1->touchHistory[(uint64_t)touchLatestIndex].touchCount;
0002db84          
0002db8b          if ((uint8_t)pTrackStateData > 1)
0002db8b          {
0002db95              (uint8_t)rbx = 0;
0002db9c              int64_t r12_2 = (uint64_t)(uint8_t)r13 * 0x30;
0002dba0              int64_t arg_8 = r12_2;
0002dba0              
0002dbad              if ((&pTrackStateData_1->touchHistory[0].touchCount)[r12_2] > 0)
0002dbad              {
0002dc2e                  do
0002dc2e                  {
0002dbb3                      (uint8_t)r13 = 0;
0002dbb3                      
0002dbb9                      if ((uint8_t)pTrackStateData > 0)
0002dbb9                      {
0002dc13                          do
0002dc13                          {
0002dbf9                              int128_t zmm0_1;
0002dbf9                              zmm0_1 = DistanceSquareToCentreLinePoint(
0002dbf9                                  r12_2 + (uint64_t)(uint8_t)rbx * 0x14
0002dbf9                                      + pTrackStateData_1, 
0002dbf9                                  &pTrackStateData_1->touchHistory[(uint64_t)
0002dbf9                                  previousSlotIndex_2].touches[(uint64_t)(uint8_t)r14], 
0002dbf9                                  (uint64_t)touchLatestIndex * 0x30
0002dbf9                                      + (uint64_t)(uint8_t)r13 * 0x14 + pTrackStateData_1);
0002dbf9                              
0002dc01                              if (!((uint32_t)zmm6 <= (uint32_t)zmm0_1))
0002dc01                              {
0002dc03                                  zmm6 = zmm0_1;
0002dc06                                  (uint8_t)r15 = (uint8_t)rbx;
0002dc01                              }
0002dc01                              
0002dc09                              (uint8_t)pTrackStateData = pTrackStateData_1->touchHistory[(
0002dc09                                  uint64_t)touchLatestIndex].touchCount;
0002dc0d                              (uint8_t)r13 += 1;
0002dc13                          } while ((uint8_t)r13 < (uint8_t)pTrackStateData);
0002dc13                          
0002dc15                          r12_2 = arg_8;
0002dc1d                          previousSlotIndex_2 = previousSlotIndex_1;
0002dc25                          rbp = 0;
0002dbb9                      }
0002dbb9                      
0002dc27                      (uint8_t)rbx += 1;
0002dc2e                  } while ((uint8_t)rbx
0002dc2e                      < (&pTrackStateData_1->touchHistory[0].touchCount)[r12_2]);
0002dc2e                  
0002dc30                  (uint8_t)r13 = currentSlotIndex;
0002dbad              }
0002db8b          }
0002db8b          
0002dc38          9999999f - (uint32_t)zmm6;
0002dc38          
0002dc41          if (FCMP_UO(9999999f, (uint32_t)zmm6) || 9999999f != (uint32_t)zmm6)
0002dc41          {
0002dd54          label_2dd54:
0002dd54              
0002dd57              if ((uint8_t)r14 != (uint8_t)r15)
0002dd57              {
0002dd69                  uint64_t r8_6 = (uint64_t)(uint8_t)r13 * 0x30;
0002dd82                  char* rdi_8 = r8_6 + (uint64_t)(uint8_t)r15 * 0x14 + pTrackStateData_1;
0002dd85                  void* rbx_2 = r8_6 + (uint64_t)(uint8_t)r14 * 0x14 + pTrackStateData_1;
0002dd93                  char var_78[0x20];
0002dd93                  memmove(&var_78, rdi_8, 0x14);
0002dda1                  memmove(rdi_8, rbx_2, 0x14);
0002ddb1                  memmove(rbx_2, &var_78, 0x14);
0002dd57              }
0002dc41          }
0002dc41          else
0002dc41          {
0002dc47              (uint8_t)rax = pTrackStateData_1->touchLatestIndex;
0002dc4d              char temp0_1 = (uint8_t)rax;
0002dc4d              (uint8_t)rax -= 3;
0002dc4d              
0002dc4f              if (temp0_1 - 3 < 0)
0002dc51                  (uint8_t)rax += 5;
0002dc51              
0002dc5a              uint64_t r8_3 = (uint64_t)(uint8_t)rax * 6;
0002dc5a              
0002dc63              if ((&pTrackStateData_1->touchHistory[0].touchCount)[r8_3 << 3] == 2)
0002dc63              {
0002dc69                  (uint8_t)rbx = 0;
0002dc69                  
0002dc79                  if (pTrackStateData_1->touchHistory[(uint64_t)r13].touchCount > 0)
0002dc79                  {
0002dc87                      uint64_t rdx_4 = (uint64_t)(uint8_t)r14 * 0x14;
0002dc87                      
0002dcc7                      do
0002dcc7                      {
0002dcbc                          if (!((uint32_t)zmm6 <= DistanceSquareToCentreLinePoint(
0002dcbc                                  (uint64_t)(uint8_t)r13 * 0x30
0002dcbc                                      + (uint64_t)(uint8_t)rbx * 0x14 + pTrackStateData_1, 
0002dcbc                                  (uint64_t)previousSlotIndex_2 * 0x30 + rdx_4
0002dcbc                                  + pTrackStateData_1, 
0002dcbc                                  rdx_4 + (r8_3 << 3) + pTrackStateData_1)))
0002dcbe                              (uint8_t)r15 = (uint8_t)rbx;
0002dcbe                          
0002dcc1                          (uint8_t)rbx += 1;
0002dcc7                      } while ((uint8_t)rbx
0002dcc7                          < pTrackStateData_1->touchHistory[(uint64_t)r13].touchCount);
0002dcc7                      
0002dcc9                      (uint8_t)r13 = currentSlotIndex;
0002dc79                  }
0002dc63              }
0002dc63              
0002dcd5              (uint8_t)rbx = 0;
0002dcd5              
0002dce5              if (pTrackStateData_1->touchHistory[(uint64_t)r13].touchCount > 0)
0002dce5              {
0002dd2d                  do
0002dd2d                  {
0002dd17                      int128_t zmm0_3;
0002dd17                      zmm0_3 = DistanceSquare(
0002dd17                          (uint64_t)(uint8_t)r13 * 0x30 + (uint64_t)(uint8_t)rbx * 0x14
0002dd17                              + pTrackStateData_1, 
0002dd17                          &pTrackStateData_1->touchHistory[(uint64_t)previousSlotIndex_1].
0002dd17                          touches[(uint64_t)(uint8_t)r14]);
0002dd17                      
0002dd1f                      if (!((uint32_t)zmm6 <= (uint32_t)zmm0_3))
0002dd1f                      {
0002dd21                          zmm6 = zmm0_3;
0002dd24                          (uint8_t)r15 = (uint8_t)rbx;
0002dd1f                      }
0002dd1f                      
0002dd27                      (uint8_t)rbx += 1;
0002dd2d                  } while ((uint8_t)rbx
0002dd2d                      < pTrackStateData_1->touchHistory[(uint64_t)r13].touchCount);
0002dce5              }
0002dce5              
0002dd2f              9999999f - (uint32_t)zmm6;
0002dd2f              
0002dd34              if (FCMP_UO(9999999f, (uint32_t)zmm6) || 9999999f != (uint32_t)zmm6)
0002dd32                  goto label_2dd54;
0002dd32              
0002dd4a              onError__("ProcessOneToTwoTransition(): Invalid input data?", 
0002dd4a                  "c:\development_work\csf_release_hp\driver\foureyes\fe_track_state.c", 
0002dd4a                  0x3ef);
0002dd4f              zmm6 = {0};
0002dc41          }
0002db6f      }
0002db6f      
0002ddb6      9999999f - (uint32_t)zmm6;
0002ddb6      
0002ddbb      if (FCMP_UO(9999999f, (uint32_t)zmm6) || !(9999999f == (uint32_t)zmm6))
0002ddbd          rbp = 1;
0002ddbd      
0002ddd4      (uint8_t)rax = rbp;
0002dde6      return (uint8_t)rax;
0002dad4  }

0002dde7                       cc cc cc cc cc cc cc cc cc                                                         .........

0002ddf0    uint8_t ProcessTwoToTwoTransition(struct track_state_data_t* pTrackStateData, uint8_t currentSlotIndex, uint8_t previousSlotIndex)

0002ddf0  {
0002de00      int64_t r15;
0002de00      int64_t var_38 = r15;
0002de32      void var_1b8;
0002de32      int64_t rax_1 = __security_cookie ^ &var_1b8;
0002de40      struct track_state_data_t* pTrackStateData_1 = pTrackStateData;
0002de4c      uint64_t rax_4 = (uint64_t)currentSlotIndex * 0x30;
0002de55      void* rbp = &pTrackStateData->touchHistory[(uint64_t)currentSlotIndex];
0002de5d      struct fpoint_t p2;
0002de5d      p2.x = *(uint32_t*)rbp;
0002de5d      p2.y = *(uint32_t*)((char*)rbp + 4);
0002de65      void* r12 = (char*)rbp + 0x14;
0002de69      struct fpoint_t p4;
0002de69      p4.x = *(uint32_t*)r12;
0002de69      p4.y = *(uint32_t*)((char*)r12 + 4);
0002de71      void* var_178 = rbp;
0002de76      void* lineStart_2 = &pTrackStateData->touchHistory[(uint64_t)previousSlotIndex];
0002de79      void* lineStart_3 = lineStart_2;
0002de7e      struct fpoint_t p3;
0002de7e      p3.x = *(uint32_t*)((char*)lineStart_2 + 0x14);
0002de7e      p3.y = *(uint32_t*)((char*)lineStart_2 + 0x18);
0002de82      struct fpoint_t p1;
0002de82      p1.x = *(uint32_t*)lineStart_2;
0002de82      p1.y = *(uint32_t*)((char*)lineStart_2 + 4);
0002de8a      char rdi = 1;
0002de92      char* rax_7;
0002de92      char var_168[0x18];
0002de92      uint64_t rsi_1;
0002de92      
0002de92      if (TestIntersect(p1, p2, p3, p4) != 1)
0002de92      {
0002deaf          struct fpoint_t p4_1;
0002deaf          p4_1.x = p2.x;
0002deaf          p4_1.y = p2.y;
0002deb2          struct fpoint_t p2_1;
0002deb2          p2_1.x = *(uint32_t*)r12;
0002deb2          p2_1.y = *(uint32_t*)((char*)r12 + 4);
0002deb2          
0002debe          if (TestIntersect(p1, p2_1, p3, p4_1) != 1)
0002debe          {
0002dec4              p1.x = pTrackStateData_1->touchLatestIndex;
0002dec4              
0002decd              if (p1.x < 0)
0002decf                  p1.x += 5;
0002decf              
0002dedb              p3.x = 0;
0002dede              void* r14;
0002dede              (uint8_t)r14 = 0;
0002dee1              void var_127;
0002dee1              void* rax_8 = &var_127;
0002dee9              int32_t* i_3 = 8;
0002deee              char var_198_1 = 0;
0002def3              float zmm6_1 = 9999999f;
0002df10              int32_t* i;
0002df10              
0002df10              do
0002df10              {
0002def7                  *(uint8_t*)((char*)rax_8 - 1) = 0;
0002defb                  *(uint8_t*)rax_8 = 0;
0002defe                  *(uint8_t*)((char*)rax_8 + 1) = 0;
0002df02                  *(uint32_t*)((char*)rax_8 + 3) = 0x60ad78ec;
0002df09                  rax_8 += 8;
0002df0d                  i = i_3;
0002df0d                  i_3 -= 1;
0002df10              } while (i != 1);
0002df1b              p4_1.x = 0;
0002df25              char var_197_1 = (uint8_t)i_3;
0002df29              rsi_1 = (uint64_t)(uint32_t)&i_3[5];
0002df30              char var_196_1 = 0;
0002df3a              char var_128;
0002df3a              char var_126[0x2];
0002df3a              int32_t var_124[0x1f];
0002df3a              float zmm0_1;
0002df3a              
0002df3a              if (pTrackStateData_1->touchHistory[(uint64_t)p1].touchCount > (uint8_t)i_3)
0002df3a              {
0002dffd                  do
0002dffd                  {
0002df49                      (uint8_t)r15 = 0;
0002df49                      
0002df50                      if (*(uint8_t*)((char*)rbp + 0x28) > 0)
0002df50                      {
0002dfe6                          do
0002dfe6                          {
0002df5b                              (uint8_t)r14 = 0;
0002df5e                              void* lineStart = lineStart_2;
0002df5e                              
0002dfd3                              do
0002dfd3                              {
0002df61                                  rax_7 = (uint64_t)*(uint32_t*)((char*)lineStart + 8);
0002df65                                  uint64_t r12_1 = (uint64_t)p4_1.x;
0002df69                                  (&var_128)[r12_1 << 3] = (uint8_t)r14;
0002df71                                  *(uint8_t*)(&var_127 + (r12_1 << 3)) = (uint8_t)r15;
0002df79                                  (&var_126)[r12_1 * 4][0] = (uint8_t)i_3;
0002df79                                  
0002df83                                  if ((uint32_t)rax_7 <= 0)
0002df83                                  {
0002dfa7                                  label_2dfa7:
0002dfa7                                      rax_7 = onError__(
0002dfa7                                          "ProcessTwoToTwoTransition(): invalid past touch state!", 
0002dfa7                                          "c:\development_work\csf_release_hp\driver\foureyes\f"
0002dfa7                                      "e_track_state.c", 0x477);
0002dfac                                      (uint8_t)i_3 = var_197_1;
0002dfb0                                      p4_1.x = var_196_1;
0002dfb5                                      var_124[r12_1 * 2] = 0;
0002df83                                  }
0002df83                                  else if ((uint32_t)rax_7 <= 2)
0002df88                                  {
0002e081                                      struct fpoint_t* lineEnd = (char*)pTrackStateData
0002e081                                          + (uint64_t)(uint8_t)i_3 * 0x14
0002e081                                          + (uint64_t)p1.x * 0x30;
0002e08c                                      int64_t rax_11;
0002e08c                                      (uint32_t)rax_11 = lineEnd->x;
0002e08c                                      *(uint32_t*)((char*)rax_11)[4] = lineEnd->y;
0002e08f                                      struct fpoint_t B;
0002e08f                                      B.x = (uint32_t)rax_11;
0002e08f                                      B.y = *(uint32_t*)((char*)rax_11)[4];
0002e094                                      int64_t rax_12 = *(uint64_t*)lineStart;
0002e098                                      struct fpoint_t var_150;
0002e098                                      var_150.x = (uint32_t)rax_12;
0002e098                                      var_150.y = *(uint32_t*)((char*)rax_12)[4];
0002e0b3                                      void* point_1 = rax_4 + (uint64_t)(uint8_t)r15 * 0x14
0002e0b3                                          + pTrackStateData;
0002e0b6                                      struct fpoint_t* point = point_1;
0002e0bb                                      int64_t rax_16 = *(uint64_t*)point_1;
0002e0be                                      struct fpoint_t A;
0002e0be                                      A.x = (uint32_t)rax_16;
0002e0be                                      A.y = *(uint32_t*)((char*)rax_16)[4];
0002e0c3                                      float zmm0_2 = DistanceSquare(&A, &B);
0002e0c3                                      
0002e0d2                                      if (zmm0_2 <= 9.99999997e-07f)
0002e126                                          zmm0_1 = DistanceSquareToCentreLinePoint(point, 
0002e126                                              lineStart, lineEnd);
0002e0d2                                      else
0002e0d2                                      {
0002e0de                                          float zmm0_3 = DistanceSquare(&A, &var_150);
0002e0de                                          
0002e0eb                                          if (zmm0_3 <= zmm0_2)
0002e126                                              zmm0_1 = DistanceSquareToCentreLinePoint(
0002e126                                                  point, lineStart, lineEnd);
0002e0eb                                          else
0002e0eb                                          {
0002e0f7                                              zmm0_1 = DistanceSquare(&var_150, &B);
0002e0f7                                              
0002e10e                                              if (zmm0_1 <= zmm0_2
0002e10e                                                      || 100f > (zmm0_1 + zmm0_3) / zmm0_2)
0002e126                                                  zmm0_1 = DistanceSquareToCentreLinePoint(
0002e126                                                      point, lineStart, lineEnd);
0002e10e                                              else
0002e110                                                  zmm0_1 = 9999998f;
0002e0eb                                          }
0002e0d2                                      }
0002e0d2                                      
0002e12b                                      (uint8_t)i_3 = var_197_1;
0002e12f                                      p4_1.x = var_196_1;
0002e134                                      var_124[r12_1 * 2] = zmm0_1;
0002df88                                  }
0002df88                                  else
0002df88                                  {
0002df91                                      if ((uint32_t)rax_7 != 3)
0002df91                                          goto label_2dfa7;
0002df91                                      
0002dfb5                                      var_124[r12_1 * 2] = 0;
0002df88                                  }
0002df88                                  
0002dfbe                                  p4_1.x += 1;
0002dfc1                                  (uint8_t)r14 += 1;
0002dfc4                                  lineStart += rsi_1;
0002dfc7                                  var_196_1 = p4_1.x;
0002dfcc                                  p3.x = p4_1.x;
0002dfd3                              } while ((uint8_t)r14 < 2);
0002dfd3                              
0002dfd5                              rbp = var_178;
0002dfda                              lineStart_2 = lineStart_3;
0002dfdf                              (uint8_t)r15 += 1;
0002dfe6                          } while ((uint8_t)r15 < *(uint8_t*)((char*)rbp + 0x28));
0002dfe6                          
0002dfec                          pTrackStateData_1 = pTrackStateData;
0002df50                      }
0002df50                      
0002dff1                      (uint8_t)i_3 += 1;
0002dff4                      var_197_1 = (uint8_t)i_3;
0002dffd                  } while ((uint8_t)i_3
0002dffd                      < pTrackStateData_1->touchHistory[(uint64_t)p1].touchCount);
0002dffd                  
0002e003                  (uint8_t)r14 = var_198_1;
0002e008                  r12 = (char*)rbp + 0x14;
0002df3a              }
0002df3a              
0002e00c              uint32_t touchCount =
0002e00c                  (uint32_t)pTrackStateData_1->touchHistory[(uint64_t)p1].touchCount;
0002e018              float zmm1_1;
0002e018              
0002e018              if (!touchCount)
0002e018              {
0002e25c                  (uint8_t)rax_7 = pTrackStateData_1->touchLatestIndex;
0002e263                  char temp1_1 = (uint8_t)rax_7;
0002e263                  (uint8_t)rax_7 -= 3;
0002e263                  
0002e265                  if (temp1_1 - 3 < 0)
0002e267                      (uint8_t)rax_7 += 5;
0002e267                  
0002e269                  (uint8_t)i_3 = 0;
0002e26b                  (uint8_t)r12 = 0;
0002e26e                  char var_197_2 = 0;
0002e26e                  
0002e275                  if (*(uint8_t*)((char*)rbp + 0x28) > 0)
0002e275                  {
0002e285                      rax_7 = &(&pTrackStateData_1->touchHistory[0].touches[0].touchState)[
0002e285                          (uint64_t)(uint8_t)rax_7 * 0xc];
0002e28a                      char* var_190_1 = rax_7;
0002e28a                      
0002e31e                      do
0002e31e                      {
0002e294                          (uint8_t)r15 = 0;
0002e297                          void* lineStart_1 = lineStart_2;
0002e29a                          r14 = rax_7;
0002e29a                          
0002e306                          do
0002e306                          {
0002e2ad                              if ((*(uint32_t*)r14 == 1 || *(uint32_t*)r14 == 2)
0002e2ad                                  && *(uint32_t*)((char*)lineStart_1 + 8) == 2)
0002e2ad                              {
0002e2af                                  uint64_t rbx_4 = (uint64_t)(uint8_t)i_3;
0002e2ca                                  (&var_128)[rbx_4 << 3] = (uint8_t)r15;
0002e2d2                                  *(uint8_t*)(&var_127 + (rbx_4 << 3)) = (uint8_t)r12;
0002e2dd                                  zmm0_1 = DistanceSquareToCentreLinePoint(
0002e2dd                                      rax_4 + (uint64_t)(uint8_t)r12 * 0x14
0002e2dd                                          + pTrackStateData, 
0002e2dd                                      lineStart_1, (char*)r14 - 8);
0002e2e2                                  (uint8_t)i_3 = var_197_2;
0002e2e6                                  (uint8_t)i_3 += 1;
0002e2e9                                  var_197_2 = (uint8_t)i_3;
0002e2ed                                  p3.x = (uint8_t)i_3;
0002e2f0                                  var_124[rbx_4 * 2] = zmm0_1;
0002e2ad                              }
0002e2ad                              
0002e2f9                              (uint8_t)r15 += 1;
0002e2fc                              r14 += rsi_1;
0002e2ff                              lineStart_1 += rsi_1;
0002e306                          } while ((uint8_t)r15 < 2);
0002e306                          
0002e308                          rbp = var_178;
0002e30d                          rax_7 = var_190_1;
0002e312                          lineStart_2 = lineStart_3;
0002e317                          (uint8_t)r12 += 1;
0002e31e                      } while ((uint8_t)r12 < *(uint8_t*)((char*)rbp + 0x28));
0002e275                  }
0002e275                  
0002e32c                  (uint8_t)touchCount = 0;
0002e32c                  
0002e332                  if (p3.x)
0002e332                  {
0002e33c                      int64_t rcx_20 = 0;
0002e33c                      
0002e3ba                      do
0002e3ba                      {
0002e346                          i_3 = &var_124;
0002e34e                          uint64_t i_5 = (uint64_t)p3.x;
0002e3ae                          uint64_t i_1;
0002e3ae                          
0002e3ae                          do
0002e3ae                          {
0002e355                              if ((&var_128)[rcx_20] == i_3[-1])
0002e3a3                                  (uint8_t)rax_7 = var_198_1;
0002e355                              else
0002e355                              {
0002e357                                  (uint8_t)rax_7 = *(uint8_t*)((char*)i_3 - 3);
0002e357                                  
0002e361                                  if (*(uint8_t*)(&var_127 + rcx_20) == (uint8_t)rax_7)
0002e3a3                                      (uint8_t)rax_7 = var_198_1;
0002e361                                  else
0002e361                                  {
0002e363                                      (uint8_t)rax_7 = *(uint8_t*)((char*)i_3 - 2);
0002e363                                      
0002e36d                                      if (var_126[rcx_20] == (uint8_t)rax_7)
0002e3a3                                          (uint8_t)rax_7 = var_198_1;
0002e36d                                      else
0002e36d                                      {
0002e36f                                          zmm0_1 = *(uint32_t*)(&var_124 + rcx_20);
0002e378                                          1.00000002e+20f - zmm0_1;
0002e378                                          
0002e37d                                          if (FCMP_UO(1.00000002e+20f, zmm0_1)
0002e37d                                              || !(1.00000002e+20f == zmm0_1))
0002e37d                                          {
0002e37f                                              zmm1_1 = *(uint32_t*)i_3;
0002e383                                              1.00000002e+20f - zmm1_1;
0002e383                                              
0002e388                                              if (FCMP_UO(1.00000002e+20f, zmm1_1)
0002e388                                                  || !(1.00000002e+20f == zmm1_1))
0002e388                                              {
0002e38d                                                  if (!(zmm1_1 > zmm0_1))
0002e38f                                                      zmm0_1 = zmm1_1;
0002e38f                                                  
0002e395                                                  if (zmm6_1 <= zmm0_1)
0002e3a3                                                      (uint8_t)rax_7 = var_198_1;
0002e395                                                  else
0002e395                                                  {
0002e397                                                      (uint8_t)rax_7 = (uint8_t)touchCount;
0002e39a                                                      zmm6_1 = zmm0_1;
0002e39d                                                      var_198_1 = (uint8_t)rax_7;
0002e395                                                  }
0002e388                                              }
0002e388                                              else
0002e3a3                                                  (uint8_t)rax_7 = var_198_1;
0002e37d                                          }
0002e37d                                          else
0002e3a3                                              (uint8_t)rax_7 = var_198_1;
0002e36d                                      }
0002e361                                  }
0002e355                              }
0002e355                              
0002e3a7                              i_3 = &i_3[2];
0002e3ab                              i_1 = i_5;
0002e3ab                              i_5 -= 1;
0002e3ae                          } while (i_1 != 1);
0002e3b0                          (uint8_t)touchCount += 1;
0002e3b3                          rcx_20 += 8;
0002e3ba                      } while ((uint8_t)touchCount < p3.x);
0002e3ba                      
0002e3bc                      9999999f - zmm6_1;
0002e332                  }
0002e332                  
0002e3c2                  bool cond:7_1;
0002e3c2                  
0002e3c2                  if (p3.x && (FCMP_UO(9999999f, zmm6_1) || !(9999999f == zmm6_1)))
0002e3c2                  {
0002e3c4                      uint64_t rcx_21 = (uint64_t)(uint8_t)rax_7;
0002e3c7                      (uint8_t)rax_7 = *(uint8_t*)(&var_127 + (rcx_21 << 3));
0002e3ce                      cond:7_1 = (&var_128)[rcx_21 << 3] == (uint8_t)rax_7;
0002e3d5                      goto label_2e4be;
0002e3c2                  }
0002e3c2                  
0002e3da                  (uint8_t)r12 = 0;
0002e3dd                  (uint8_t)r15 = 0;
0002e3dd                  
0002e3e4                  if (*(uint8_t*)((char*)rbp + 0x28) > 0)
0002e3e4                  {
0002e3ef                      rax_7 = (char*)lineStart_3 + 8;
0002e3f3                      char* var_190_2 = rax_7;
0002e3f3                      
0002e46d                      do
0002e46d                      {
0002e3fd                          (uint8_t)r14 = 0;
0002e400                          char* r13 = rax_7;
0002e400                          
0002e45a                          do
0002e45a                          {
0002e40e                              if (*(uint32_t*)r13 == 1 || *(uint32_t*)r13 == 2)
0002e40e                              {
0002e414                                  uint64_t rbx_6 = (uint64_t)(uint8_t)r15;
0002e425                                  (&var_128)[rbx_6 << 3] = (uint8_t)r14;
0002e431                                  *(uint8_t*)(&var_127 + (rbx_6 << 3)) = (uint8_t)r12;
0002e43c                                  float zmm0_4;
0002e43c                                  zmm0_4 = DistanceSquare(
0002e43c                                      rax_4 + (uint64_t)(uint8_t)r12 * 0x14
0002e43c                                          + pTrackStateData, 
0002e43c                                      &r13[-8]);
0002e441                                  (uint8_t)r15 += 1;
0002e444                                  p3.x = (uint8_t)r15;
0002e447                                  var_124[rbx_6 * 2] = zmm0_4;
0002e40e                              }
0002e40e                              
0002e450                              (uint8_t)r14 += 1;
0002e453                              r13 = &r13[rsi_1];
0002e45a                          } while ((uint8_t)r14 < 2);
0002e45a                          
0002e45c                          rbp = var_178;
0002e461                          rax_7 = var_190_2;
0002e466                          (uint8_t)r12 += 1;
0002e46d                      } while ((uint8_t)r12 < *(uint8_t*)((char*)rbp + 0x28));
0002e3e4                  }
0002e3e4                  
0002e46f                  (uint8_t)i_3 = var_198_1;
0002e473                  (uint8_t)rax_7 = 0;
0002e473                  
0002e478                  if (p3.x)
0002e478                  {
0002e47a                      int32_t* rcx_25 = &var_124;
0002e47a                      
0002e49e                      do
0002e49e                      {
0002e482                          float temp4_1 = *(uint32_t*)rcx_25;
0002e482                          1.00000002e+20f - temp4_1;
0002e482                          
0002e48c                          if ((FCMP_UO(1.00000002e+20f, temp4_1)
0002e48c                              || !(1.00000002e+20f == temp4_1))
0002e48c                              && !(zmm6_1 <= *(uint32_t*)rcx_25))
0002e48c                          {
0002e48e                              *(uint32_t*)rcx_25;
0002e48e                              *(uint32_t*)rcx_25;
0002e48e                              *(uint32_t*)rcx_25;
0002e48e                              zmm6_1 = *(uint32_t*)rcx_25;
0002e492                              (uint8_t)i_3 = (uint8_t)rax_7;
0002e48c                          }
0002e48c                          
0002e494                          (uint8_t)rax_7 += 1;
0002e497                          rcx_25 = &rcx_25[2];
0002e49e                      } while ((uint8_t)rax_7 < p3.x);
0002e478                  }
0002e478                  
0002e4a0                  9999999f - zmm6_1;
0002e4a0                  
0002e4a6                  if (FCMP_UO(9999999f, zmm6_1) || 9999999f != zmm6_1)
0002e4a6                  {
0002e4ad                      uint64_t rdx_8 = (uint64_t)(uint8_t)i_3;
0002e4b0                      (uint8_t)rax_7 = *(uint8_t*)(&var_127 + (rdx_8 << 3));
0002e4b7                      cond:7_1 = (&var_128)[rdx_8 << 3] == (uint8_t)rax_7;
0002e4be                  label_2e4be:
0002e4be                      
0002e4be                      if (!cond:7_1)
0002e4be                      {
0002e4cc                          memmove(&var_168, (char*)rbp + 0x14, rsi_1);
0002e4db                          memmove((char*)rbp + 0x14, rbp, rsi_1);
0002e4eb                          memmove(rbp, &var_168, rsi_1);
0002e4be                      }
0002e4a6                  }
0002e4a6                  else
0002e4a8                      rdi = 0;
0002e018              }
0002e018              else if (touchCount == 1)
0002e020              {
0002e220                  (uint8_t)rax_7 = 0;
0002e220                  
0002e225                  if (!p3.x)
0002e4a8                      rdi = 0;
0002e225                  else
0002e225                  {
0002e233                      int32_t* rcx_14 = &var_124;
0002e233                      
0002e258                      do
0002e258                      {
0002e23b                          float temp3_1 = *(uint32_t*)rcx_14;
0002e23b                          1.00000002e+20f - temp3_1;
0002e23b                          
0002e245                          if ((FCMP_UO(1.00000002e+20f, temp3_1)
0002e245                              || !(1.00000002e+20f == temp3_1))
0002e245                              && !(zmm6_1 <= *(uint32_t*)rcx_14))
0002e245                          {
0002e247                              *(uint32_t*)rcx_14;
0002e247                              *(uint32_t*)rcx_14;
0002e247                              *(uint32_t*)rcx_14;
0002e247                              zmm6_1 = *(uint32_t*)rcx_14;
0002e24b                              (uint8_t)r14 = (uint8_t)rax_7;
0002e245                          }
0002e245                          
0002e24e                          (uint8_t)rax_7 += 1;
0002e251                          rcx_14 = &rcx_14[2];
0002e258                      } while ((uint8_t)rax_7 < p3.x);
0002e258                      
0002e1eb                  label_2e1eb:
0002e1eb                      9999999f - zmm6_1;
0002e1eb                      
0002e1f1                      if (FCMP_UO(9999999f, zmm6_1) || !(9999999f == zmm6_1))
0002e1f1                      {
0002e1f7                          9999998f - zmm6_1;
0002e1f7                          
0002e1fd                          if (FCMP_UO(9999998f, zmm6_1) || !(9999998f == zmm6_1))
0002e1fd                          {
0002e203                              uint64_t rcx_13 = (uint64_t)(uint8_t)r14;
0002e207                              (uint8_t)rax_7 = *(uint8_t*)(&var_127 + (rcx_13 << 3));
0002e207                              
0002e215                              if ((&var_128)[rcx_13 << 3] != (uint8_t)rax_7)
0002e215                                  goto label_2dea2;
0002e1fd                          }
0002e1f1                      }
0002e1f1                      else
0002e4a8                          rdi = 0;
0002e225                  }
0002e020              }
0002e020              else if (touchCount == 2)
0002e028              {
0002e143                  (uint8_t)touchCount = 0;
0002e143                  
0002e149                  if (p3.x)
0002e149                  {
0002e15b                      int64_t rcx_12 = 0;
0002e15b                      
0002e1e5                      do
0002e1e5                      {
0002e165                          int32_t* rdx_5 = &var_124;
0002e16d                          uint64_t i_4 = (uint64_t)p3.x;
0002e1d9                          uint64_t i_2;
0002e1d9                          
0002e1d9                          do
0002e1d9                          {
0002e174                              if ((&var_128)[rcx_12] != rdx_5[-1])
0002e174                              {
0002e176                                  (uint8_t)rax_7 = *(uint8_t*)((char*)rdx_5 - 3);
0002e176                                  
0002e180                                  if (*(uint8_t*)(&var_127 + rcx_12) != (uint8_t)rax_7)
0002e180                                  {
0002e182                                      (uint8_t)rax_7 = *(uint8_t*)((char*)rdx_5 - 2);
0002e182                                      
0002e18c                                      if (var_126[rcx_12] != (uint8_t)rax_7)
0002e18c                                      {
0002e18e                                          zmm0_1 = *(uint32_t*)(&var_124 + rcx_12);
0002e197                                          1.00000002e+20f - zmm0_1;
0002e197                                          
0002e19c                                          if (FCMP_UO(1.00000002e+20f, zmm0_1)
0002e19c                                              || !(1.00000002e+20f == zmm0_1))
0002e19c                                          {
0002e19e                                              zmm1_1 = *(uint32_t*)rdx_5;
0002e1a2                                              1.00000002e+20f - zmm1_1;
0002e1a2                                              
0002e1a7                                              if (FCMP_UO(1.00000002e+20f, zmm1_1)
0002e1a7                                                  || !(1.00000002e+20f == zmm1_1))
0002e1a7                                              {
0002e1a9                                                  9999998f - zmm0_1;
0002e1a9                                                  
0002e1af                                                  if (FCMP_UO(9999998f, zmm0_1)
0002e1af                                                          || !(9999998f == zmm0_1))
0002e1b1                                                      9999998f - zmm1_1;
0002e1b1                                                  
0002e1b7                                                  if ((!FCMP_UO(9999998f, zmm0_1)
0002e1b7                                                          && 9999998f == zmm0_1) || (
0002e1b7                                                          !FCMP_UO(9999998f, zmm1_1)
0002e1b7                                                          && !(9999998f != zmm1_1)))
0002e1b9                                                      zmm0_1 = 9999998f;
0002e1b7                                                  else if (!(zmm1_1 > zmm0_1))
0002e1c4                                                      zmm0_1 = zmm1_1;
0002e1c4                                                  
0002e1ca                                                  if (!(zmm6_1 <= zmm0_1))
0002e1ca                                                  {
0002e1cc                                                      zmm6_1 = zmm0_1;
0002e1cf                                                      (uint8_t)r14 = (uint8_t)touchCount;
0002e1ca                                                  }
0002e1a7                                              }
0002e19c                                          }
0002e18c                                      }
0002e180                                  }
0002e174                              }
0002e174                              
0002e1d2                              rdx_5 = &rdx_5[2];
0002e1d6                              i_2 = i_4;
0002e1d6                              i_4 -= 1;
0002e1d9                          } while (i_2 != 1);
0002e1db                          (uint8_t)touchCount += 1;
0002e1de                          rcx_12 += 8;
0002e1e5                      } while ((uint8_t)touchCount < p3.x);
0002e1e5                      
0002e1e5                      goto label_2e1eb;
0002e149                  }
0002e149                  
0002e4a8                  rdi = 0;
0002e028              }
0002e028              else
0002e028              {
0002e042                  RtlStringCchPrintfA(&var_128, 0x80, "Too many future touches: %d!");
0002e05c                  onError__(&var_128, 
0002e05c                      "c:\development_work\csf_release_hp\driver\foureyes\fe_track_state.c", 
0002e05c                      0x57c);
0002e061                  pTrackStateData_1->touchHistory[(uint64_t)p1].touchCount = 0;
0002e067                  *(uint8_t*)((char*)rbp + 0x28) = 0;
0002e4a8                  rdi = 0;
0002e028              }
0002debe          }
0002de92      }
0002de92      else
0002de92      {
0002de94          rsi_1 = 0x14;
0002dea2      label_2dea2:
0002dea2          memmove(&var_168, r12, rsi_1);
0002e4db          memmove(r12, rbp, rsi_1);
0002e4eb          memmove(rbp, &var_168, rsi_1);
0002de92      }
0002e4f0      (uint8_t)rax_7 = rdi;
0002e4fe      __security_check_cookie(rax_1 ^ &var_1b8);
0002e53b      return (uint8_t)rax_7;
0002ddf0  }

0002e53c                                                                                      cc cc cc cc                              ....
0002e540  cc cc cc cc                                                                                      ....

0002e544    float DistanceSquareToCentreLinePoint(struct fpoint_t const* point, struct fpoint_t const* lineStart, struct fpoint_t const* lineEnd)

0002e544  {
0002e548      lineStart->x
0002e55d      struct fpoint_t A;
0002e55d      A.x = (lineStart->x + lineEnd->x) * 0.5f;
0002e57a      A.y = (lineStart->y + lineEnd->y) * 0.5f;
0002e589      return DistanceSquare(&A, point);
0002e544  }

0002e58a                                cc cc cc cc cc cc                                                            ......

0002e590    void FixConnectingLines(struct track_state_data_t* pTrackStateData, uint8_t currentSlotIndex, uint8_t previousSlotIndex, uint8_t touchIndex)

0002e590  {
0002e5a9      int64_t rsi;
0002e5a9      (uint8_t)rsi = pTrackStateData->touchLatestIndex;
0002e5b3      char temp0 = (uint8_t)rsi;
0002e5b3      (uint8_t)rsi -= 3;
0002e5b3      
0002e5b7      if (temp0 - 3 < 0)
0002e5b9          (uint8_t)rsi += 5;
0002e5b9      
0002e5bd      uint64_t touchIndex_1 = (uint64_t)touchIndex;
0002e5d0      uint64_t r12_1 = touchIndex_1 * 0x14;
0002e5d7      void* A = (uint64_t)currentSlotIndex * 0x30 + r12_1 + pTrackStateData;
0002e5d7      
0002e5df      if (!*(uint32_t*)((char*)A + 8))
0002e5df          return;
0002e5df      
0002e5f4      void* B = (uint64_t)previousSlotIndex * 0x30 + r12_1 + pTrackStateData;
0002e5f4      
0002e5fb      if (!*(uint32_t*)((char*)B + 8))
0002e5fb          return;
0002e5fb      
0002e601      uint32_t lastTimeStamp = pTrackStateData->lastTimeStamp;
0002e601      
0002e609      if (!lastTimeStamp)
0002e609      {
0002e71d          pTrackStateData->lastTimeStamp = pTrackStateData->timeStamp;
0002e71d          return;
0002e609      }
0002e609      
0002e60f      uint32_t timeStamp = pTrackStateData->timeStamp;
0002e615      float zmm0[0x4] = {0};
0002e61b      pTrackStateData->lastTimeStamp = timeStamp;
0002e623      zmm0[0] = (float)(uint64_t)(timeStamp - lastTimeStamp);
0002e628      zmm0[0] = zmm0[0] / 1000f;
0002e630      pTrackStateData->timeDeltaIn_ms = zmm0[0];
0002e638      zmm0[0] = pTrackStateData->lastDeltaTime;
0002e638      zmm0[1] = pTrackStateData->lastDeltaTime;
0002e638      zmm0[2] = pTrackStateData->lastDeltaTime;
0002e638      zmm0[3] = pTrackStateData->lastDeltaTime;
0002e640      zmm0[0] - 0f;
0002e649      float zmm1;
0002e649      
0002e649      if (FCMP_UO(zmm0[0], 0f) || zmm0[0] != 0f)
0002e649      {
0002e65a          zmm0 = DistanceSquare(A, B);
0002e65a          
0002e666          if (zmm0[0] <= 0f)
0002e679              zmm1 = (int32_t){0};
0002e666          else
0002e666          {
0002e66e              zmm0 = sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, *(uint64_t*)&zmm0[0])[0])[0]);
0002e673              zmm1 = (float)*(uint64_t*)&zmm0[0];
0002e666          }
0002e666          
0002e684          pTrackStateData->distMovedPer_ms = zmm1 / pTrackStateData->lastDeltaTime;
0002e649      }
0002e649      else
0002e64b          pTrackStateData->distMovedPer_ms = 0f;
0002e64b      
0002e68c      zmm1 = pTrackStateData->prevTouchDistance[touchIndex_1];
0002e695      zmm1 - 0f;
0002e69e      bool cond:2_1;
0002e69e      
0002e69e      if (FCMP_UO(zmm1, 0f) || zmm1 != 0f)
0002e69e      {
0002e6b1          zmm0[0] = pTrackStateData->distMovedPer_ms;
0002e6b1          zmm0[1] = pTrackStateData->distMovedPer_ms;
0002e6b1          zmm0[2] = pTrackStateData->numConsecutiveUnstableTouches;
0002e6b1          *(uint8_t*)((char*)zmm0[2])[2] = pTrackStateData->lastStateWasSingleTouch;
0002e6b1          *(uint8_t*)((char*)zmm0[2])[3] = pTrackStateData->touchLatestIndex;
0002e6b1          zmm0[3] = pTrackStateData->distMovedPer_ms;
0002e6b1          
0002e6c0          if (zmm0[0] <= 2f)
0002e700              pTrackStateData->prevTouchDistance[touchIndex_1] = zmm0[0];
0002e6c0          else
0002e6c0          {
0002e6cd              if (!(zmm0[0] > zmm1 * 10f))
0002e6cd              {
0002e6cf                  cond:2_1 = zmm0[0] <= 20f;
0002e6cf                  goto label_2e6d6;
0002e6cd              }
0002e6cd              
0002e6d8          label_2e6d8:
0002e6d8              *(uint32_t*)((char*)B + 8) = 3;
0002e6f2              *(uint64_t*)B =
0002e6f2                  *(uint64_t*)((uint64_t)(uint8_t)rsi * 0x30 + r12_1 + pTrackStateData);
0002e6f6              pTrackStateData->prevTouchDistance[touchIndex_1] = 0;
0002e6c0          }
0002e69e      }
0002e69e      else
0002e69e      {
0002e6a0          zmm0[0] = pTrackStateData->distMovedPer_ms;
0002e6a0          zmm0[1] = pTrackStateData->distMovedPer_ms;
0002e6a0          zmm0[2] = pTrackStateData->numConsecutiveUnstableTouches;
0002e6a0          *(uint8_t*)((char*)zmm0[2])[2] = pTrackStateData->lastStateWasSingleTouch;
0002e6a0          *(uint8_t*)((char*)zmm0[2])[3] = pTrackStateData->touchLatestIndex;
0002e6a0          zmm0[3] = pTrackStateData->distMovedPer_ms;
0002e6a8          cond:2_1 = zmm0[0] <= 40f;
0002e6d6      label_2e6d6:
0002e6d6          
0002e6d6          if (!cond:2_1)
0002e6d6              goto label_2e6d8;
0002e6d6          
0002e700          pTrackStateData->prevTouchDistance[touchIndex_1] = zmm0[0];
0002e69e      }
0002e70f      pTrackStateData->lastDeltaTime = pTrackStateData->timeDeltaIn_ms;
0002e590  }

0002e73e                                                                                            cc cc                                ..
0002e740  cc cc cc cc                                                                                      ....

0002e744    void SmoothOutputTouchJitter(struct track_state_data_t* pTrackStateData, struct touches_t* touches)

0002e744  {
0002e749      int64_t rbp;
0002e749      int64_t arg_10 = rbp;
0002e75c      uint8_t touchLatestIndex = pTrackStateData->touchLatestIndex;
0002e76b      uint8_t r10 = touchLatestIndex - 4;
0002e76b      
0002e76f      if (touchLatestIndex - 4 < 0)
0002e771          r10 += 5;
0002e771      
0002e777      uint8_t r11 = touchLatestIndex - 3;
0002e777      
0002e77b      if (touchLatestIndex - 3 < 0)
0002e77d          r11 += 5;
0002e77d      
0002e783      uint8_t rax = touchLatestIndex - 2;
0002e783      
0002e785      if (touchLatestIndex - 2 < 0)
0002e787          rax += 5;
0002e787      
0002e789      uint8_t touchLatestIndex_1 = touchLatestIndex;
0002e789      touchLatestIndex -= 1;
0002e789      
0002e78d      if (touchLatestIndex_1 - 1 < 0)
0002e78f          touchLatestIndex += 5;
0002e78f      
0002e792      int64_t r13 = 0;
0002e798      void var_28;
0002e798      void* rdx = &var_28;
0002e7a0      float* r9 = &touches->touches[0].width;
0002e7a4      int64_t i_1 = 2;
0002e7a8      uint64_t rbx_1 = (uint64_t)rax * 6;
0002e7ab      void* rdi = &(&pTrackStateData->touchHistory[0].touches[0].width)[rbx_1 * 2];
0002e8e5      float rax_18;
0002e8e5      int64_t i;
0002e8e5      
0002e8e5      do
0002e8e5      {
0002e7b0          rax_18 = *(uint32_t*)((char*)rdi - 4);
0002e7b3          ADJ(r9)->touches[0].touchState = rax_18;
0002e7b3          
0002e7b9          if (!rax_18)
0002e7b9          {
0002e8be              ADJ(r9)->touches[0].position.x = 0;
0002e8c3              ADJ(r9)->touches[0].position.y = 0f;
0002e8c8              ADJ(r9)->touches[0].width = 0f;
0002e8cc              ADJ(r9)->touches[0].height = 0f;
0002e7b9          }
0002e7b9          else
0002e7b9          {
0002e7bf              int64_t rax_2 = *(uint64_t*)((char*)rdi - 0xc);
0002e7c3              (uint8_t)rbp = 1;
0002e7c6              *(uint32_t*)rdx = (uint32_t)rax_2;
0002e7c6              *(uint32_t*)((char*)rdx + 4) = *(uint32_t*)((char*)rax_2)[4];
0002e7d5              float* rax_6 = (uint64_t)r11 * 0x30 + r13;
0002e7e4              float zmm0;
0002e7e4              float zmm1;
0002e7e4              
0002e7e4              if (*(uint32_t*)(
0002e7e4                  &pTrackStateData->touchHistory[0].touches[0].touchState + rax_6) == 1 || *(
0002e7e4                  uint32_t*)(&pTrackStateData->touchHistory[0].touches[0].touchState + rax_6)
0002e7e4                  == 2)
0002e7e4              {
0002e7e6                  bool cond:0_1 = *(uint32_t*)(
0002e7e6                      &pTrackStateData->touchHistory[0].touches[0].touchState + rax_6) != 2;
0002e7eb                  *(uint32_t*)rdx;
0002e7eb                  *(uint32_t*)rdx;
0002e7eb                  *(uint32_t*)rdx;
0002e7f5                  (uint8_t)rbp = 2;
0002e7f8                  zmm0 = *(uint32_t*)rdx + *(uint32_t*)((char*)rax_6 + pTrackStateData);
0002e7fd                  zmm1 = *(uint32_t*)(
0002e7fd                      &pTrackStateData->touchHistory[0].touches[0].position.y + rax_6)
0002e7fd                      + *(uint32_t*)((char*)rdx + 4);
0002e802                  *(uint32_t*)rdx = zmm0;
0002e806                  *(uint32_t*)((char*)rdx + 4) = zmm1;
0002e806                  
0002e80b                  if (!cond:0_1)
0002e80b                  {
0002e819                      float* rax_10 = (uint64_t)r10 * 0x30 + r13;
0002e819                      
0002e828                      if (*(uint32_t*)(
0002e828                          &pTrackStateData->touchHistory[0].touches[0].touchState + rax_10) == 1
0002e828                          || *(uint32_t*)(
0002e828                          &pTrackStateData->touchHistory[0].touches[0].touchState + rax_10)
0002e828                          == 2)
0002e828                      {
0002e82f                          zmm1 = zmm1 + *(uint32_t*)(
0002e82f                              &pTrackStateData->touchHistory[0].touches[0].position.y
0002e82f                              + rax_10);
0002e835                          (uint8_t)rbp = 3;
0002e838                          *(uint32_t*)rdx =
0002e838                              zmm0 + *(uint32_t*)((char*)rax_10 + pTrackStateData);
0002e83c                          *(uint32_t*)((char*)rdx + 4) = zmm1;
0002e828                      }
0002e80b                  }
0002e7e4              }
0002e7e4              
0002e84d              float* rax_14 = (uint64_t)touchLatestIndex * 0x30 + r13;
0002e84d              
0002e85c              if (*(uint32_t*)(
0002e85c                  &pTrackStateData->touchHistory[0].touches[0].touchState + rax_14) == 2 || *(
0002e85c                  uint32_t*)(&pTrackStateData->touchHistory[0].touches[0].touchState + rax_14)
0002e85c                  == 3)
0002e85c              {
0002e85e                  *(uint32_t*)rdx;
0002e85e                  *(uint32_t*)rdx;
0002e85e                  *(uint32_t*)rdx;
0002e868                  (uint8_t)rbp += 1;
0002e870                  zmm1 = *(uint32_t*)(
0002e870                      &pTrackStateData->touchHistory[0].touches[0].position.y + rax_14)
0002e870                      + *(uint32_t*)((char*)rdx + 4);
0002e875                  *(uint32_t*)rdx =
0002e875                      *(uint32_t*)rdx + *(uint32_t*)((char*)rax_14 + pTrackStateData);
0002e879                  *(uint32_t*)((char*)rdx + 4) = zmm1;
0002e85c              }
0002e85c              
0002e882              if ((uint8_t)rbp > 1)
0002e882              {
0002e884                  *(uint32_t*)rdx;
0002e884                  *(uint32_t*)rdx;
0002e884                  *(uint32_t*)rdx;
0002e884                  zmm0 = *(uint32_t*)rdx;
0002e888                  zmm1 = *(uint32_t*)((char*)rdx + 4);
0002e895                  uint128_t zmm2 = _mm_cvtepi32_ps((uint128_t)(uint8_t)rbp);
0002e8a0                  *(uint32_t*)rdx = zmm0 / (uint32_t)zmm2;
0002e8a4                  *(uint32_t*)((char*)rdx + 4) = zmm1 / (uint32_t)zmm2;
0002e882              }
0002e882              
0002e8a9              int64_t rax_16;
0002e8a9              (uint32_t)rax_16 = *(uint32_t*)rdx;
0002e8a9              *(uint32_t*)((char*)rax_16)[4] = *(uint32_t*)((char*)rdx + 4);
0002e8ac              ADJ(r9)->touches[0].position.x = (uint32_t)rax_16;
0002e8ac              ADJ(r9)->touches[0].position.y = *(uint32_t*)((char*)rax_16)[4];
0002e8b2              ADJ(r9)->touches[0].width = *(uint32_t*)rdi;
0002e8b8              ADJ(r9)->touches[0].height = *(uint32_t*)((char*)rdi + 4);
0002e7b9          }
0002e7b9          
0002e8d1          rdx += 8;
0002e8d5          r13 += 0x14;
0002e8d9          rdi += 0x14;
0002e8dd          r9 = &r9[5];
0002e8e1          i = i_1;
0002e8e1          i_1 -= 1;
0002e8e5      } while (i != 1);
0002e8eb      (uint8_t)rax_18 = (&pTrackStateData->touchHistory[0].touchCount)[rbx_1 << 3];
0002e8f4      touches->touchCount = (uint8_t)rax_18;
0002e8f7      struct frame_id_t rax_19;
0002e8f7      rax_19.id = (&pTrackStateData->touchHistory[0].id)[rbx_1 * 2].id;
0002e8f7      rax_19.deltaTimeStamp =
0002e8f7          (&pTrackStateData->touchHistory[0].id.deltaTimeStamp)[rbx_1 * 4];
0002e900      touches->id.id = rax_19.id;
0002e900      touches->id.deltaTimeStamp = rax_19.deltaTimeStamp;
0002e744  }

0002e912                                                        cc cc cc cc cc cc                                            ......

0002e918    uint8_t FourSensorPath(struct _ctl_context_t* pContext)

0002e918  {
0002e938      void var_138;
0002e938      int64_t rax_1 = __security_cookie ^ &var_138;
0002e94a      struct _ctl_context_t* pContext_1 = pContext;
0002e94d      char rdi = 0;
0002e94f      uint8_t edgeCount = pContext_1->ssInput.edgeCount;
0002e959      bool cond:0 = pContext_1->ssOutput.floop != 1;
0002e960      (uint8_t)pContext = pContext->ssOutput.sensor[(uint64_t)pContext->ssOutput.trueSensor]
0002e960          .edgeSet[0].touchCount;
0002e967      uint32_t rax_4;
0002e967      
0002e967      if (cond:0 && edgeCount > 0)
0002e977          rax_4 = (uint32_t)(uint8_t)pContext;
0002e977      
0002e97e      uint64_t rax_7;
0002e97e      
0002e97e      if (!cond:0 || (edgeCount > 0 && rax_4 * 2 > 0))
0002e97e      {
0002e969          pContext_1->frameCount = 0;
0002e9d6      label_2e9d6:
0002e9d6          pContext_1->triangError[0] = 0;
0002e9dc          pContext_1->triangError[1] = 0f;
0002e9e2          memmove(&pContext_1->triangulateStatics.sampleHistory[1], 
0002e9e2              &pContext_1->triangulateStatics.sampleHistory, 0xac8);
0002e9f7          memmove(&pContext_1->triangulateStatics.sampleHistory, &pContext_1->ssOutput, 
0002e9f7              0x1cc);
0002e9fc          pContext_1->triangulateStatics.sampleHistory[1];
0002ea0e          int32_t specialCases = pContext_1->triangulateStatics.sampleHistory[1].sensor[(
0002ea0e              uint64_t)*(uint8_t*)((char*)
0002ea0e              *(uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[0x4d8][1])[
0002ea0e              0x1c4]].edgeSet[0].specialCases;
0002ea0e          
0002ea2d          if ((uint8_t)specialCases & 0x40 && pContext_1->triangulateStatics.sampleHistory[
0002ea2d              2].sensor[(uint64_t)*(uint8_t*)((char*)
0002ea2d              *(uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[0x4d8][1])[
0002ea2d              0x1c4]].edgeSet[0].touchCount != 2 && pContext_1->triangulateStatics.
0002ea2d              sampleHistory[0].sensor[(uint64_t)*(uint8_t*)((char*)
0002ea2d              *(uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[0x4d8][1])[
0002ea2d              0x1c4]].edgeSet[0].touchCount != 2)
0002ea2d          {
0002ea3a              pContext_1->triangulateStatics.sampleHistory[1].sensor[(uint64_t)*(uint8_t*)((
0002ea3a                  char*)*(uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[
0002ea3a                  0x4d8][1])[0x1c4]].edgeSet[0].touchCount = 1;
0002ea43              pContext_1->triangulateStatics.sampleHistory[1].sensor[(uint64_t)*(uint8_t*)((
0002ea43                  char*)*(uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[
0002ea43                  0x4d8][1])[0x1c4]].edgeSet[0].edgePair[0].edge[1] = pContext_1->
0002ea43                  triangulateStatics.sampleHistory[1].sensor[(uint64_t)*(uint8_t*)((char*)*(
0002ea43                  uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[0x4d8][
0002ea43                  1])[0x1c4]].edgeSet[0].edgePair[1].edge[1];
0002ea4b              pContext_1->triangulateStatics.sampleHistory[1].sensor[(uint64_t)*(uint8_t*)((
0002ea4b                  char*)*(uint4096_t*)((char*)(*(int4096_t*)((char*)pContext_1 + 0x56f8)))[
0002ea4b                  0x4d8][1])[0x1c4]].edgeSet[0].specialCases = specialCases & 0xffffffbf;
0002ea2d          }
0002ea2d          
0002ea5d          GetActualTouchCount(&pContext_1->triangulateStatics.sampleHistory, 
0002ea5d              &pContext_1->triangulateStatics.actualTouchCount);
0002ea62          uint32_t rcx_6 = (uint32_t)pContext_1->triangulateStatics.actualTouchCount[6];
0002ea62          
0002ea6b          if (!rcx_6)
0002ea6b          {
0002ec48          label_2ec48:
0002ec48              pContext_1->touches.touchCount = 0;
0002ec4f              rax_7 = (uint64_t)pContext_1->triangulateStatics.sampleHistory[6].id.id;
0002ec55              rdi = 1;
0002ec58              pContext_1->touches.id.id = (uint16_t)rax_7;
0002ec58              pContext_1->touches.id.deltaTimeStamp = *(uint16_t*)((char*)rax_7)[2];
0002ea6b          }
0002ea6b          else
0002ea6b          {
0002ea74              enum trans_state_t tchTrans;
0002ea74              
0002ea74              if (rcx_6 == 1)
0002ea74              {
0002eaa4                  if (pContext_1->triangulateStatics.actualTouchCount[3] != 2)
0002eaa6                      tchTrans = TT_ONE;
0002eaa6                  
0002eab0                  if (pContext_1->triangulateStatics.actualTouchCount[3] == 2
0002eab0                          || pContext_1->triangulateStatics.actualTouchCount[9] == 2)
0002eab2                      tchTrans = TT_ONE_TRANS;
0002ea74              }
0002ea74              else
0002ea74              {
0002ea79                  if (rcx_6 != 2)
0002ea79                      goto label_2ec48;
0002ea79                  
0002ea8f                  if (pContext_1->triangulateStatics.actualTouchCount[3] != 2
0002ea8f                          || pContext_1->triangulateStatics.actualTouchCount[9] != 2)
0002ea96                      tchTrans = TT_TWO_TRANS;
0002ea8f                  else
0002ea91                      tchTrans = rcx_6 + 2;
0002ea74              }
0002ea74              
0002ead6              uint8_t numKites_1;
0002ead6              struct triangulation_input_t trigData[0x4];
0002ead6              rax_7 = PopulateDataToTriangulate(
0002ead6                  &pContext_1->triangulateStatics.sampleHistory[6], &numKites_1, &trigData, 
0002ead6                  pContext_1->triangulateStatics.numSensors, tchTrans);
0002ead6              
0002eadd              if ((uint8_t)rax_7 >= 2)
0002eadd              {
0002eae3                  struct sub_sample_t (* r12_1)[0x7];
0002eae3                  (uint8_t)r12_1 = numKites_1;
0002eaf9                  enum trans_state_t tStatics;
0002eaf9                  tStatics = &pContext_1->triangulateStatics;
0002eafe                  rax_7 = TriangulateSample((uint8_t)rax_7, (uint8_t)r12_1, &trigData, 
0002eafe                      &pContext_1->triangulated, tStatics);
0002eb03                  uint8_t numKites = (uint8_t)rax_7;
0002eb06                  numKites_1 = (uint8_t)rax_7;
0002eb06                  
0002eb0c                  if ((uint8_t)rax_7 <= 1)
0002eb0c                  {
0002ebdd                      rax_7 = (uint64_t)pContext_1->triangulated[0].state;
0002ebdd                      
0002ebeb                      if ((uint32_t)rax_7 == 4 || (uint32_t)rax_7 == 5)
0002ebeb                      {
0002ec15                          int64_t rax_12 = *(uint64_t*)(&pContext_1->triangulated
0002ec15                              + (int64_t)pContext_1->triangulated[0].solvedIdx[0] * 0x2c);
0002ec1d                          pContext_1->touches.touches[0].position.x = (uint32_t)rax_12;
0002ec1d                          pContext_1->touches.touches[0].position.y =
0002ec1d                              *(uint32_t*)((char*)rax_12)[4];
0002ec30                          rax_7 = *(uint64_t*)(&pContext_1->triangulated
0002ec30                              + (int64_t)pContext_1->triangulated[0].solvedIdx[1] * 0x2c);
0002ec38                          pContext_1->touches.touchCount = 2;
0002ec3f                          pContext_1->touches.touches[1].position.x = (uint32_t)rax_7;
0002ec3f                          pContext_1->touches.touches[1].position.y =
0002ec3f                              *(uint32_t*)((char*)rax_7)[4];
0002ebeb                      }
0002ebeb                      else if ((uint32_t)rax_7 == 2)
0002ebf0                      {
0002ebf2                          (uint32_t)rax_7 = pContext_1->triangulated[0].kPt[0].pt.x;
0002ebf2                          *(uint32_t*)((char*)rax_7)[4] =
0002ebf2                              pContext_1->triangulated[0].kPt[0].pt.y;
0002ebf9                          pContext_1->touches.touchCount = 1;
0002ec00                          pContext_1->touches.touches[0].position.x = (uint32_t)rax_7;
0002ec00                          pContext_1->touches.touches[0].position.y =
0002ec00                              *(uint32_t*)((char*)rax_7)[4];
0002ebf0                      }
0002eb0c                  }
0002eb0c                  else
0002eb0c                  {
0002eb16                      if ((uint8_t)r12_1 != 2)
0002eb30                          (uint8_t)rax_7 = 1;
0002eb16                      else
0002eb16                      {
0002eb24                          rax_7 = ResolveTouches(&numKites_1, &pContext_1->triangulated);
0002eb29                          numKites = numKites_1;
0002eb16                      }
0002eb16                      
0002eb34                      if ((uint8_t)rax_7 != 1)
0002ebd1                          pContext_1->touches.touchCount = 0;
0002eb34                      else
0002eb34                      {
0002eb3f                          struct touches_t* retTouches = &pContext_1->touches;
0002eb5c                          (uint8_t)tStatics = (uint8_t)r12_1;
0002eb5c                          
0002eb69                          if (!FinalTriangulation(
0002eb69                                  &pContext_1->triangulateStatics.sampleHistory[6], 
0002eb69                                  &pContext_1->trueEdges, &pContext_1->triangulated, 
0002eb69                                  numKites, (uint8_t)tStatics, retTouches, 
0002eb69                                  &pContext_1->triangError))
0002ebd1                              pContext_1->touches.touchCount = 0;
0002eb69                          else
0002eb69                          {
0002eb6b                              int64_t rax_9;
0002eb6b                              (uint32_t)rax_9 = pContext_1->settings.camMax.x;
0002eb6b                              *(uint32_t*)((char*)rax_9)[4] = pContext_1->settings.camMax.y;
0002eb77                              (uint32_t)rax_7 = pContext_1->settings.camMin.x;
0002eb77                              *(uint32_t*)((char*)rax_7)[4] = pContext_1->settings.camMin.y;
0002eb7e                              uint64_t var_f0_1 = rax_7;
0002eb83                              (uint8_t)rax_7 = 1;
0002eb83                              
0002eb89                              if (retTouches->touchCount > 0)
0002eb89                              {
0002eb8b                                  uint64_t touchCount = (uint64_t)retTouches->touchCount;
0002ebc7                                  uint64_t i;
0002ebc7                                  
0002ebc7                                  do
0002ebc7                                  {
0002eb9b                                      float zmm0_1 = retTouches->touches[0].position.x;
0002eb9b                                      
0002eba9                                      if ((uint32_t)var_f0_1 > zmm0_1
0002eba9                                              || zmm0_1 > (uint32_t)rax_9)
0002ebbc                                          (uint8_t)rax_7 = 0;
0002eba9                                      else
0002eba9                                      {
0002ebab                                          zmm0_1 = retTouches->touches[0].position.y;
0002ebab                                          
0002ebba                                          if (*(uint32_t*)((char*)var_f0_1)[4] > zmm0_1 || !
0002ebba                                                  (zmm0_1 <= *(uint32_t*)((char*)rax_9)[4]))
0002ebbc                                              (uint8_t)rax_7 = 0;
0002eba9                                      }
0002eba9                                      
0002ebbf                                      retTouches = &retTouches->touches[1];
0002ebc3                                      i = touchCount;
0002ebc3                                      touchCount -= 1;
0002ebc7                                  } while (i != 1);
0002eb89                              }
0002eb89                              
0002ebc9                              rdi = (uint8_t)rax_7;
0002eb69                          }
0002eb34                      }
0002eb0c                  }
0002eadd              }
0002ea6b          }
0002e97e      }
0002e97e      else
0002e97e      {
0002e98a          if ((uint32_t)edgeCount > (uint32_t)(uint8_t)pContext * 2)
0002e98a          {
0002e98c              pContext_1->frameCount += 1;
0002e992              goto label_2e9d6;
0002e98a          }
0002e98a          
0002e994          rax_7 = (uint64_t)pContext_1->frameCount;
0002e99b          char rcx_2 = 0;
0002e99f          pContext_1->frameCount = 0;
0002e99f          
0002e9a8          if ((uint8_t)rax_7 >= 3)
0002e9a8              rcx_2 = (uint8_t)rax_7;
0002e9a8          
0002e9ae          if (rcx_2 <= 0)
0002e9ae              goto label_2e9d6;
0002e97e      }
0002e97e      
0002ec5e      (uint8_t)rax_7 = rdi;
0002ec6c      __security_check_cookie(rax_1 ^ &var_138);
0002ec8c      return (uint8_t)rax_7;
0002e918  }

0002ec8d                                         cc cc cc cc cc cc cc                                                   .......

0002ec94    void FC_StraightLineFilter(struct strt_line_flt_t* strLineFilter, float dt, struct touches_t* touches)

0002ec94  {
0002ecbb      struct touches_t* touches_1 = touches;
0002ecbe      float* rdi = &strLineFilter->avgAngle;
0002ecc2      int64_t i_1 = 2;
0002ee3d      int64_t i;
0002ee3d      
0002ee3d      do
0002ee3d      {
0002ecdd          if (touches_1->touches[0].touchState != TS_TOUCH)
0002ecdd          {
0002ee17              memset(&rdi[-5], 0, 0x1c);
0002ee1c              ADJ(rdi)->avgAngle = 3.14159274f;
0002ecdd          }
0002ecdd          else
0002ecdd          {
0002ece3              struct fpoint_t pt2;
0002ece3              pt2.x = ADJ(rdi)->prevPos.x;
0002ece3              pt2.y = ADJ(rdi)->prevPos.y;
0002ece7              struct fpoint_t pt1;
0002ece7              pt1.x = touches_1->touches[0].position.x;
0002ece7              pt1.y = touches_1->touches[0].position.y;
0002ecea              uint128_t avgAngle;
0002ecea              int32_t zmm8_1;
0002ecea              float zmm9_1;
0002ecea              uint64_t zmm10_1[0x2];
0002ecea              avgAngle = CalculateAngleBetweenPoints(pt1, pt2);
0002ecf3              float avgAngle_1[0x4] = avgAngle;
0002ecf9              uint128_t zmm1;
0002ecf9              (uint64_t)zmm1 =
0002ecf9                  _mm_cvtps_pd((uint64_t)ADJ(rdi)->avgAngle) + 3.1415926535897931;
0002ed01              avgAngle_1 = _mm_unpacklo_ps(avgAngle_1, *(uint64_t*)&avgAngle_1[0]);
0002ed0b              uint64_t j;
0002ed0b              
0002ed0b              if (!(_mm_cvtps_pd(*(uint64_t*)&avgAngle_1[0]) <= (uint64_t)zmm1))
0002ed0b              {
0002ed14                  j = _mm_cvtps_pd((uint64_t)ADJ(rdi)->avgAngle) + 3.1415926535897931;
0002ed14                  
0002ed35                  do
0002ed35                  {
0002ed1f                      (uint32_t)zmm1 = 0f - 6.28318548f;
0002ed27                      avgAngle_1[0] = avgAngle_1[0] + (uint32_t)zmm1;
0002ed2b                      avgAngle_1 = _mm_unpacklo_ps(avgAngle_1, *(uint64_t*)&avgAngle_1[0]);
0002ed2e                      avgAngle = _mm_cvtps_pd(*(uint64_t*)&avgAngle_1[0]);
0002ed35                  } while ((uint64_t)avgAngle > j);
0002ed0b              }
0002ed0b              
0002ed37              avgAngle = (uint128_t)ADJ(rdi)->avgAngle;
0002ed3b              avgAngle_1 = _mm_unpacklo_ps(avgAngle_1, *(uint64_t*)&avgAngle_1[0]);
0002ed3e              zmm1 = _mm_cvtps_pd(*(uint64_t*)&avgAngle_1[0]);
0002ed44              (uint64_t)avgAngle = _mm_cvtps_pd((uint64_t)avgAngle) - 3.1415926535897931;
0002ed44              
0002ed50              if (!((uint64_t)avgAngle <= (uint64_t)zmm1))
0002ed50              {
0002ed59                  (uint64_t)zmm1 =
0002ed59                      _mm_cvtps_pd((uint64_t)ADJ(rdi)->avgAngle) - 3.1415926535897931;
0002ed59                  
0002ed73                  do
0002ed73                  {
0002ed61                      avgAngle_1[0] = avgAngle_1[0] + 6.28318548f;
0002ed69                      avgAngle_1 = _mm_unpacklo_ps(avgAngle_1, *(uint64_t*)&avgAngle_1[0]);
0002ed6c                      avgAngle = _mm_cvtps_pd(*(uint64_t*)&avgAngle_1[0]);
0002ed73                  } while ((uint64_t)zmm1 > (uint64_t)avgAngle);
0002ed50              }
0002ed50              
0002ed78              (uint32_t)avgAngle = (uint32_t)avgAngle_1 - ADJ(rdi)->avgAngle;
0002ed87              (uint32_t)j = (float)_mm_and_pd(
0002ed87                  _mm_cvtps_pd(_mm_unpacklo_ps(avgAngle, (uint64_t)avgAngle)), zmm10_1);
0002ed87              
0002ed8f              if (zmm8_1 <= (uint32_t)j)
0002ed8f              {
0002eda1                  if (ADJ(rdi)->straightLineCnt == 0x64)
0002eda1                  {
0002eda3                      (uint32_t)avgAngle = ADJ(rdi)->prevPrevPos.x;
0002eda3                      *(uint32_t*)((char*)avgAngle)[4] = ADJ(rdi)->prevPrevPos.x;
0002eda3                      *(uint32_t*)((char*)avgAngle)[8] = ADJ(rdi)->prevPrevPos.x;
0002eda3                      *(uint32_t*)((char*)avgAngle)[0xc] = ADJ(rdi)->prevPrevPos.x;
0002eda8                      (uint32_t)avgAngle = (uint32_t)avgAngle - ADJ(rdi)->prevPos.x;
0002edad                      (uint32_t)avgAngle = (uint32_t)avgAngle / ADJ(rdi)->prevDt;
0002edb2                      (uint32_t)avgAngle = (uint32_t)avgAngle * zmm9_1;
0002edb7                      (uint32_t)avgAngle = (uint32_t)avgAngle + ADJ(rdi)->prevPos.x;
0002edbc                      touches_1->touches[0].position.x = (uint32_t)avgAngle;
0002edc0                      (uint32_t)zmm1 = ADJ(rdi)->prevPrevPos.y;
0002edc0                      *(uint32_t*)((char*)zmm1)[4] = ADJ(rdi)->prevPrevPos.y;
0002edc0                      *(uint32_t*)((char*)zmm1)[8] = ADJ(rdi)->prevPrevPos.y;
0002edc5                      (uint32_t)zmm1 = (uint32_t)zmm1 - ADJ(rdi)->prevPos.y;
0002edca                      (uint32_t)zmm1 = (uint32_t)zmm1 / ADJ(rdi)->prevDt;
0002edcf                      (uint32_t)zmm1 = (uint32_t)zmm1 * zmm9_1;
0002edd4                      (uint32_t)zmm1 = (uint32_t)zmm1 + ADJ(rdi)->prevPos.y;
0002edd9                      touches_1->touches[0].position.y = (uint32_t)zmm1;
0002eda1                  }
0002eda1                  
0002edde                  uint32_t straightLineCnt_1 = ADJ(rdi)->straightLineCnt;
0002edde                  
0002ede4                  if (straightLineCnt_1 >= 2)
0002ede9                      ADJ(rdi)->straightLineCnt = straightLineCnt_1 - 2;
0002ed8f              }
0002ed8f              else
0002ed8f              {
0002ed91                  uint32_t straightLineCnt = ADJ(rdi)->straightLineCnt;
0002ed91                  
0002ed97                  if (straightLineCnt < 0x64)
0002ede9                      ADJ(rdi)->straightLineCnt = straightLineCnt + 1;
0002ed8f              }
0002ed8f              
0002edec              (uint32_t)avgAngle = ADJ(rdi)->avgAngle;
0002edec              *(uint32_t*)((char*)avgAngle)[4] = ADJ(rdi)->avgAngle;
0002edf0              avgAngle_1[0] = avgAngle_1[0] * zmm8_1;
0002edf5              ADJ(rdi)->prevDt = zmm9_1;
0002edfb              (uint32_t)avgAngle = (uint32_t)avgAngle * 0.899999976f;
0002ee03              avgAngle_1[0] = avgAngle_1[0] + (uint32_t)avgAngle;
0002ee07              ADJ(rdi)->avgAngle = avgAngle_1[0];
0002ecdd          }
0002ecdd          
0002ee22          int64_t rax_2;
0002ee22          (uint32_t)rax_2 = ADJ(rdi)->prevPos.x;
0002ee22          *(uint32_t*)((char*)rax_2)[4] = ADJ(rdi)->prevPos.y;
0002ee26          rdi = &rdi[7];
0002ee2a          *(int64_t*)((char*)ADJ(rdi) + -0x10) = rax_2;
0002ee2e          int64_t rax_3;
0002ee2e          (uint32_t)rax_3 = touches_1->touches[0].position.x;
0002ee2e          *(uint32_t*)((char*)rax_3)[4] = touches_1->touches[0].position.y;
0002ee31          touches_1 = &touches_1->touches[1];
0002ee35          i = i_1;
0002ee35          i_1 -= 1;
0002ee39          *(int64_t*)((char*)ADJ(rdi) + -0x18) = rax_3;
0002ee3d      } while (i != 1);
0002ec94  }

0002ee68                          cc cc cc cc cc cc cc cc                                                          ........

0002ee70    void FindTouchIntegrals(uint16_t* litWaveform, uint16_t* trigWaveform, struct edgeStruct_t* edges, struct integralStruct_t* integralData)

0002ee70  {
0002ee89      uint128_t zmm6;
0002ee89      uint128_t var_48 = zmm6;
0002ee8d      uint64_t zmm7[0x2];
0002ee8d      uint64_t var_58[0x2] = zmm7;
0002ee91      int128_t zmm8;
0002ee91      int128_t var_68 = zmm8;
0002ee99      struct integralStruct_t* integralData_1 = integralData;
0002ee9e      struct edgeStruct_t* edges_1 = edges;
0002eea6      uint16_t* litWaveform_1 = litWaveform;
0002eeae      int128_t zmm9;
0002eeae      int128_t var_78 = zmm9;
0002eeb3      uint128_t zmm10;
0002eeb3      uint128_t var_88 = zmm10;
0002eeb9      uint8_t* rax = &edges->Num_Edges;
0002eebd      int32_t i_1 = 0;
0002eebd      
0002eecf      if (((uint32_t)ADJ(rax)->Num_Edges & 0xfffffffe) <= 0)
0002eecf          return;
0002eecf      
0002eed5      zmm10 = 0x7fffffffffffffff;
0002eeeb      uint16_t (* rsi_1)[0x2] = &edges->touchIntegral;
0002f506      int32_t i;
0002f506      
0002f506      do
0002f506      {
0002eef4          uint32_t rcx = edges->Raw_Edges[0];
0002eef7          uint32_t rax_2 = edges->Raw_Edges[1];
0002eefb          uint32_t r14_1 = 0x20c;
0002ef01          zmm6 = {0};
0002ef05          zmm7 = {0};
0002ef0b          uint32_t rbp_1 = rax_2;
0002ef0d          int16_t rdi_1 = 0;
0002ef0d          
0002ef11          if (rcx < rax_2)
0002ef11              rbp_1 = rcx;
0002ef11          
0002ef16          uint64_t r9 = 0;
0002ef16          
0002ef1a          if (rax_2 > rcx)
0002ef1a              rcx = rax_2;
0002ef1a          
0002ef1d          int16_t r10_1 = 0;
0002ef21          int16_t rbx_1 = -1;
0002ef27          uint32_t var_ac_1 = rbp_1;
0002ef2b          int16_t j = (uint16_t)rbp_1;
0002ef2b          
0002ef2f          if (rcx < 0x20c)
0002ef2f              r14_1 = rcx;
0002ef2f          
0002ef39          int32_t j_13 = r14_1 - rbp_1 + 1;
0002ef39          
0002ef40          if ((uint16_t)rbp_1 < (uint16_t)r14_1)
0002ef40          {
0002ef4b              void* r8 = &trigWaveform[(uint64_t)(uint16_t)rbp_1];
0002ef4b              
0002ef77              do
0002ef77              {
0002ef5a                  int16_t temp3_1;
0002ef5a                  int16_t temp4_1;
0002ef5a                  temp3_1 = HIGHD((int64_t)((uint32_t)*(uint16_t*)r8
0002ef5a                      - (uint32_t)*(uint16_t*)((char*)r8 + 2)));
0002ef5a                  temp4_1 = LOWD((int64_t)((uint32_t)*(uint16_t*)r8
0002ef5a                      - (uint32_t)*(uint16_t*)((char*)r8 + 2)));
0002ef5d                  int16_t rax_8 = (temp4_1 ^ temp3_1) - temp3_1;
0002ef5d                  
0002ef62                  if (rax_8 >= rdi_1)
0002ef62                  {
0002ef64                      rdi_1 = rax_8;
0002ef67                      (uint16_t)r9 = j;
0002ef62                  }
0002ef62                  
0002ef6b                  j += 1;
0002ef6f                  r8 += 2;
0002ef77              } while (j < (uint16_t)r14_1);
0002ef77              
0002ef79              litWaveform_1 = litWaveform;
0002ef40          }
0002ef40          
0002ef7e          uint64_t rdx_1 = (uint64_t)(uint16_t)r9;
0002ef82          uint64_t r8_1 = (uint64_t)(uint32_t)(r9 + 6);
0002ef82          
0002ef95          if ((uint32_t)(uint16_t)r14_1 < (int32_t)(rdx_1 + 6))
0002ef95              (uint16_t)r8_1 = (uint16_t)r14_1;
0002ef95          
0002ef9a          (uint16_t)r9 -= 6;
0002ef9a          
0002efa1          if ((uint32_t)(uint16_t)rbp_1 > (int32_t)(rdx_1 - 6))
0002efa1              (uint16_t)r9 = (uint16_t)rbp_1;
0002efa1          
0002efaa          uint64_t j_6;
0002efaa          
0002efaa          if ((uint16_t)r9 > (uint16_t)r8_1)
0002f00c              (uint8_t)j_6 = 0;
0002efaa          else
0002efaa          {
0002efb0              (uint16_t)r8_1 -= (uint16_t)r9;
0002efb9              (uint16_t)r8_1 += 1;
0002efbd              void* rcx_4 = &trigWaveform[(uint64_t)(uint16_t)r9];
0002efc1              j_6 = (uint64_t)(uint16_t)r8_1;
0002efdc              uint64_t j_1;
0002efdc              
0002efdc              do
0002efdc              {
0002efc9                  if (*(uint16_t*)rcx_4 > r10_1)
0002efc9                      r10_1 = *(uint16_t*)rcx_4;
0002efc9                  
0002efd1                  if (*(uint16_t*)rcx_4 < rbx_1)
0002efd1                      rbx_1 = *(uint16_t*)rcx_4;
0002efd1                  
0002efd5                  rcx_4 += 2;
0002efd9                  j_1 = j_6;
0002efd9                  j_6 -= 1;
0002efdc              } while (j_1 != 1);
0002efdc              
0002efeb              if (rbx_1 > r10_1 || !r10_1)
0002f00c                  (uint8_t)j_6 = 0;
0002efeb              else
0002f004                  (uint8_t)j_6 =
0002f004                      0x64 - COMBINE(0, (uint32_t)rbx_1 * 0x64) / (uint32_t)r10_1 > 0x28;
0002efaa          }
0002efaa          
0002f012          uint16_t rax_14;
0002f012          uint64_t zmm0[0x2];
0002f012          uint128_t zmm1;
0002f012          
0002f012          if (!(uint8_t)j_6)
0002f012          {
0002f025              uint128_t zmm2;
0002f025              
0002f025              if (j_13 < 0x14)
0002f025              {
0002f030                  uint64_t rcx_7 = (uint64_t)(uint16_t)rbp_1;
0002f033                  int32_t zmm5 = (int32_t){0};
0002f03b                  int32_t r13 = 0;
0002f03e                  int32_t rdi_2 = 0;
0002f041                  int16_t j_2 = (uint16_t)rbp_1;
0002f045                  r9 = (uint64_t)(uint16_t)r14_1;
0002f045                  
0002f04e                  if (trigWaveform[rcx_7] > litWaveform[rcx_7])
0002f04e                  {
0002f059                      while (j_2 > 0)
0002f059                      {
0002f05b                          j_2 -= 1;
0002f05f                          uint64_t j_7 = (uint64_t)j_2;
0002f05f                          
0002f06c                          if (trigWaveform[j_7] <= litWaveform[j_7])
0002f06c                              break;
0002f059                      }
0002f059                      
0002f06e                      rbp_1 = var_ac_1;
0002f04e                  }
0002f04e                  
0002f072                  uint64_t rcx_8 = (uint64_t)(uint16_t)r14_1;
0002f072                  
0002f07f                  if (trigWaveform[rcx_8] > litWaveform[rcx_8])
0002f07f                  {
0002f08f                      while ((uint16_t)r9 < 0x20b)
0002f08f                      {
0002f091                          (uint16_t)r9 += 1;
0002f095                          uint64_t rcx_9 = (uint64_t)(uint16_t)r9;
0002f095                          
0002f0a2                          if (trigWaveform[rcx_9] <= litWaveform[rcx_9])
0002f0a2                              break;
0002f08f                      }
0002f08f                      
0002f0a4                      rbp_1 = var_ac_1;
0002f07f                  }
0002f07f                  
0002f0a8                  uint64_t j_9 = (uint64_t)j_2;
0002f0ac                  uint32_t rbx_2 = (uint32_t)litWaveform[j_9 + 1];
0002f0b2                  uint32_t r11_2 = (uint32_t)trigWaveform[j_9];
0002f0bd                  uint32_t rdx_3 = (uint32_t)litWaveform[j_9];
0002f0c4                  uint32_t rax_20 = (uint32_t)trigWaveform[j_9 + 1] - r11_2;
0002f0c7                  uint32_t rcx_11 = rbx_2 - rdx_3;
0002f0cb                  float zmm4;
0002f0cb                  
0002f0cb                  if (rax_20 != rcx_11)
0002f0cb                  {
0002f0da                      zmm1 = _mm_cvtepi32_ps((uint128_t)(rax_20 - rcx_11));
0002f0e5                      zmm4 = _divide(_mm_cvtepi32_ps((uint128_t)(rdx_3 - r11_2))[0], 
0002f0e5                          (uint32_t)zmm1)[0];
0002f0e5                      
0002f0f2                      if (!(1f < zmm4) && !(zmm4 < 0f))
0002f0f2                      {
0002f0f4                          uint32_t rcx_12 = (uint32_t)trigWaveform[j_9 + 1];
0002f105                          rdi_2 = 1;
0002f10c                          zmm5 = 1f - zmm4;
0002f118                          zmm0 = _mm_cvtepi32_ps((uint128_t)r11_2);
0002f11b                          zmm0[0] = zmm0[0] * zmm4;
0002f125                          (uint32_t)zmm6 =
0002f125                              _mm_cvtepi32_ps((uint128_t)(rcx_12 - rbx_2)) * 0.5f;
0002f12d                          (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)rcx_12) * zmm5;
0002f131                          (uint32_t)zmm1 = (uint32_t)zmm1 + zmm0[0];
0002f135                          r13 = (int32_t)(int64_t)(uint32_t)zmm1;
0002f13a                          (uint32_t)zmm6 = (uint32_t)zmm6 * zmm5;
0002f13e                          (uint32_t)zmm6 = (uint32_t)zmm6 + 0f;
0002f143                          zmm5 = zmm5 + 0f;
0002f0f2                      }
0002f0cb                  }
0002f0cb                  
0002f14d                  uint64_t rdx_5 = (uint64_t)(uint16_t)r9;
0002f151                  uint32_t r11_3 = (uint32_t)litWaveform[rdx_5 - 1];
0002f157                  uint32_t rbx_3 = (uint32_t)trigWaveform[rdx_5];
0002f160                  r8_1 = (uint64_t)trigWaveform[rdx_5 - 1];
0002f168                  uint32_t rcx_15 = (uint32_t)litWaveform[rdx_5] - r11_3;
0002f16b                  int32_t rax_25 = rbx_3 - (uint32_t)r8_1;
0002f16b                  
0002f170                  if (rax_25 != rcx_15)
0002f170                  {
0002f186                      zmm1 = _mm_cvtepi32_ps((uint128_t)(rax_25 - rcx_15));
0002f191                      zmm4 = _divide(
0002f191                          _mm_cvtepi32_ps((uint128_t)(r11_3 - (uint32_t)r8_1))[0], 
0002f191                          (uint32_t)zmm1)[0];
0002f191                      
0002f19e                      if (!(1f < zmm4) && !(zmm4 < 0f))
0002f19e                      {
0002f1a0                          uint32_t rcx_16 = (uint32_t)trigWaveform[rdx_5 - 1];
0002f1aa                          zmm5 = zmm5 + zmm4;
0002f1b0                          (uint32_t)zmm2 = 1f - zmm4;
0002f1c2                          (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)rcx_16) * zmm4;
0002f1c6                          zmm0 = _mm_cvtepi32_ps((uint128_t)(rcx_16 - r11_3));
0002f1c9                          zmm0[0] = zmm0[0] * 0.5f;
0002f1d1                          zmm0[0] = zmm0[0] * zmm4;
0002f1d5                          (uint32_t)zmm6 = (uint32_t)zmm6 + zmm0[0];
0002f1e5                          (uint32_t)zmm2 =
0002f1e5                              (uint32_t)zmm2 * _mm_cvtepi32_ps((uint128_t)rbx_3)[0];
0002f1e9                          (uint32_t)zmm2 = (uint32_t)zmm2 + (uint32_t)zmm1;
0002f1f2                          r13 += (int32_t)(int64_t)(uint32_t)zmm2;
0002f1f5                          rdi_2 += 1;
0002f19e                      }
0002f170                  }
0002f170                  
0002f20f                  if ((uint32_t)j_2 + 1 < (uint32_t)(uint16_t)r9 - 1)
0002f20f                  {
0002f216                      int32_t j_12 = (uint32_t)(uint16_t)r9 - 1 - ((uint32_t)j_2 + 1);
0002f218                      void* r11_4 = &trigWaveform[(int64_t)((uint32_t)j_2 + 1)];
0002f21c                      r9 = (char*)litWaveform - trigWaveform;
0002f21f                      rdi_2 += j_12;
0002f221                      uint64_t j_10 = (uint64_t)j_12;
0002f261                      uint64_t j_3;
0002f261                      
0002f261                      do
0002f261                      {
0002f224                          rdx_1 = (uint64_t)*(uint16_t*)r11_4;
0002f22c                          zmm5 = zmm5 + 1f;
0002f23a                          r13 += (uint32_t)rdx_1;
0002f23d                          uint32_t rcx_20 = (uint32_t)*(uint16_t*)((char*)r11_4 + 2)
0002f23d                              - (uint32_t)*(uint16_t*)((char*)r11_4 + 2 + r9);
0002f23f                          uint32_t rax_35 = (uint32_t)*(uint16_t*)(r9 + r11_4);
0002f244                          r11_4 += 2;
0002f24b                          j_3 = j_10;
0002f24b                          j_10 -= 1;
0002f252                          zmm0 = _mm_cvtepi32_ps((uint128_t)(rcx_20 - rax_35
0002f252                              + (uint32_t)rdx_1));
0002f255                          zmm0[0] = zmm0[0] * 0.5f;
0002f25d                          (uint32_t)zmm6 = (uint32_t)zmm6 + zmm0[0];
0002f261                      } while (j_3 != 1);
0002f20f                  }
0002f20f                  
0002f272                  if (zmm5 > 1.00000001e-07f || rdi_2)
0002f272                  {
0002f27f                      (uint32_t)zmm6 = (uint32_t)zmm6 / zmm5;
0002f283                      zmm0 = {0};
0002f290                      zmm0[0] = (float)(uint64_t)(COMBINE(0, r13) / rdi_2);
0002f295                      (uint32_t)zmm6 = (uint32_t)zmm6 / zmm0[0];
0002f299                      (uint32_t)zmm6 = (uint32_t)zmm6 * 1000f;
0002f2ac                      (uint32_t)zmm6 = (float)_mm_and_pd(
0002f2ac                          _mm_cvtps_pd(_mm_unpacklo_ps(zmm6, (uint64_t)zmm6)), zmm10)[0];
0002f272                  }
0002f272                  else
0002f274                      zmm6 = {0};
0002f274                  
0002f278                  litWaveform_1 = litWaveform;
0002f025              }
0002f025              
0002f2bb              if (j_13 <= 0xa)
0002f2bb              {
0002f41b                  ADJ(rsi_1)->lowestPtInTch[0] = 0xffff;
0002f41b                  
0002f425                  if (rbp_1 <= r14_1)
0002f425                  {
0002f427                      uint16_t* rax_52 = &litWaveform_1[(int64_t)rbp_1];
0002f42c                      uint64_t j_8 = (uint64_t)j_13;
0002f443                      uint64_t j_4;
0002f443                      
0002f443                      do
0002f443                      {
0002f42f                          uint16_t rcx_35 = *(uint16_t*)rax_52;
0002f42f                          
0002f436                          if (rcx_35 < ADJ(rsi_1)->lowestPtInTch[0])
0002f438                              ADJ(rsi_1)->lowestPtInTch[0] = rcx_35;
0002f438                          
0002f43c                          rax_52 = &rax_52[1];
0002f440                          j_4 = j_8;
0002f440                          j_8 -= 1;
0002f443                      } while (j_4 != 1);
0002f425                  }
0002f2bb              }
0002f2bb              else
0002f2bb              {
0002f2c6                  uint64_t rax_38 = 0;
0002f2c9                  int64_t r10_2 = (int64_t)rbp_1;
0002f2cc                  ADJ(rsi_1)->lowestPtInTch[0] = 0xffff;
0002f2d0                  uint32_t rcx_24 = rbp_1;
0002f2d0                  
0002f2d5                  if (rbp_1 <= r14_1)
0002f2d5                  {
0002f2d7                      rdx_1 = &litWaveform_1[r10_2];
0002f2d7                      
0002f2f7                      do
0002f2f7                      {
0002f2dc                          r8_1 = (uint64_t)*(uint16_t*)rdx_1;
0002f2dc                          
0002f2e5                          if ((uint16_t)r8_1 < ADJ(rsi_1)->lowestPtInTch[0])
0002f2e5                          {
0002f2e7                              ADJ(rsi_1)->lowestPtInTch[0] = (uint16_t)r8_1;
0002f2ec                              rax_38 = (uint64_t)rcx_24;
0002f2e5                          }
0002f2e5                          
0002f2ee                          rcx_24 += 1;
0002f2f0                          rdx_1 += 2;
0002f2f7                      } while (rcx_24 <= r14_1);
0002f2d5                  }
0002f2d5                  
0002f2fd                  uint16_t rdx_8;
0002f2fd                  
0002f2fd                  if (j_13 <= 3)
0002f2fd                  {
0002f39b                      int32_t rax_46 = 0;
0002f39e                      int32_t r9_2 = 0;
0002f39e                      
0002f3a4                      if (rbp_1 <= r14_1)
0002f3a4                      {
0002f3a9                          void* rdx_9 = &trigWaveform[r10_2];
0002f3ad                          uint64_t j_11 = (uint64_t)j_13;
0002f3c7                          uint64_t j_5;
0002f3c7                          
0002f3c7                          do
0002f3c7                          {
0002f3b8                              rax_46 += (uint32_t)*(uint16_t*)((char*)rdx_9
0002f3b8                                  + (char*)litWaveform_1 - trigWaveform);
0002f3ba                              uint32_t rcx_33 = (uint32_t)*(uint16_t*)rdx_9;
0002f3bd                              rdx_9 += 2;
0002f3c1                              r9_2 += rcx_33;
0002f3c4                              j_5 = j_11;
0002f3c4                              j_11 -= 1;
0002f3c7                          } while (j_5 != 1);
0002f3a4                      }
0002f3a4                      
0002f3dc                      (uint32_t)zmm2 = (float)(uint64_t)(COMBINE(0, rax_46) / j_13);
0002f3e1                      rdx_8 = (int16_t)(COMBINE(0, r9_2) / j_13);
0002f2fd                  }
0002f2fd                  else
0002f2fd                  {
0002f303                      uint64_t rcx_25 = (uint64_t)(uint32_t)(rax_38 - 1);
0002f315                      int16_t rbx_4;
0002f315                      int16_t r11_1;
0002f315                      
0002f315                      if ((uint32_t)rcx_25 > 0x209 || (uint32_t)rax_38 == rbp_1
0002f315                          || (uint32_t)rax_38 == r14_1)
0002f315                      {
0002f341                          (uint16_t)r9 = litWaveform_1[rax_38];
0002f347                          (uint16_t)rdx_1 = trigWaveform[rax_38];
0002f34c                          r11_1 = (uint16_t)r9;
0002f350                          (uint16_t)r10_2 = (uint16_t)r9;
0002f354                          rbx_4 = (uint16_t)rdx_1;
0002f357                          (uint16_t)r8_1 = (uint16_t)rdx_1;
0002f315                      }
0002f315                      else
0002f315                      {
0002f317                          r11_1 = litWaveform_1[rax_38];
0002f31d                          r10_2 = (uint64_t)litWaveform_1[rcx_25];
0002f325                          rbx_4 = trigWaveform[(uint64_t)(uint32_t)rax_38];
0002f32a                          uint64_t rax_39 = (uint64_t)((uint32_t)rax_38 + 1);
0002f32f                          r9 = (uint64_t)litWaveform_1[rax_39];
0002f335                          rdx_1 = (uint64_t)trigWaveform[rax_39];
0002f33a                          r8_1 = (uint64_t)trigWaveform[rcx_25];
0002f315                      }
0002f315                      
0002f38c                      (uint32_t)zmm2 = _mm_cvtepi32_ps((uint128_t)((uint32_t)(uint16_t)r9
0002f38c                          + (uint32_t)r11_1 + (uint32_t)(uint16_t)r10_2)) / 3f;
0002f394                      rdx_8 = (int16_t)(((uint32_t)(uint16_t)rdx_1 + (uint32_t)rbx_4
0002f394                          + (uint32_t)(uint16_t)r8_1) / 3);
0002f2fd                  }
0002f2fd                  
0002f3eb                  zmm1 = _mm_cvtepi32_ps((uint128_t)rdx_8);
0002f3ee                  zmm0 = zmm1;
0002f3f1                  zmm0[0] = zmm0[0] - (uint32_t)zmm2;
0002f3f5                  zmm0 = _mm_unpacklo_ps(zmm0, zmm0[0]);
0002f400                  zmm0[0] = (float)_mm_and_pd(_mm_cvtps_pd(zmm0[0]), zmm10);
0002f409                  zmm7 = _divide(zmm0[0], (uint32_t)zmm1);
0002f40c                  zmm7[0] = zmm7[0] * 1000f;
0002f2bb              }
0002f2bb              
0002f449              if (j_13 >= 0x14)
0002f449              {
0002f483                  if (j_13 > 0xa)
0002f48c                      rax_14 = (int16_t)(int64_t)zmm7[0];
0002f483                  else
0002f485                      rax_14 = (int16_t)(int64_t)(uint32_t)zmm6;
0002f449              }
0002f449              else if (j_13 <= 0xa)
0002f485                  rax_14 = (int16_t)(int64_t)(uint32_t)zmm6;
0002f44f              else
0002f44f              {
0002f455                  zmm0 = 0x3f800000;
0002f460                  (uint32_t)zmm1 = _mm_cvtepi32_ps((uint128_t)(j_13 - 0xa)) / 20f;
0002f468                  zmm0[0] = 1f - (uint32_t)zmm1;
0002f46c                  (uint32_t)zmm1 = (uint32_t)zmm1 * zmm7[0];
0002f470                  zmm0[0] = zmm0[0] * (uint32_t)zmm6;
0002f474                  zmm0[0] = zmm0[0] + (uint32_t)zmm1;
0002f478                  rax_14 = (int16_t)(int64_t)zmm0[0];
0002f44f              }
0002f012          }
0002f012          else
0002f019              rax_14 = integralData_1->runningLowPassIntegral[0];
0002f019          
0002f49a          ADJ(rsi_1)->touchIntegral[0] = rax_14;
0002f49d          ADJ(rsi_1)->rawTouchWidth[0] = (uint16_t)j_13;
0002f4a7          i = i_1 + 1;
0002f4ad          edges = &edges_1->Raw_Edges[2];
0002f4b1          i_1 = i;
0002f4b5          edges_1 = edges;
0002f4be          uint32_t rax_55 = (uint32_t)ADJ(rsi_1)->touchIntegral[0];
0002f4c1          rsi_1 = &(*(uint32_t*)rsi_1)[1];
0002f4cc          (uint32_t)zmm1 =
0002f4cc              _mm_cvtepi32_ps((uint128_t)integralData_1->runningLowPassIntegral[0]) * 0.75f;
0002f4d4          zmm0 = _mm_cvtepi32_ps((uint128_t)rax_55);
0002f4d7          zmm0[0] = zmm0[0] * 0.25f;
0002f4df          (uint32_t)zmm1 = (uint32_t)zmm1 + zmm0[0];
0002f4e8          integralData_1->runningLowPassIntegral[0] = (int16_t)(int64_t)(uint32_t)zmm1;
0002f4f8          integralData_1 = &integralData_1->runningLowPassIntegral[1];
0002f506      } while (i < (uint32_t)ADJ(rax)->Num_Edges >> 1);
0002ee70  }

0002f540  cc cc cc cc cc cc cc cc                                                                          ........

0002f548    uint8_t TouchesStable(struct _ctl_context_t* pContext, enum touch_trans_t ssFlags0, enum touch_trans_t ssFlags1, struct pretouchHandler_t* pretouchData)

0002f548  {
0002f560      uint8_t touchCount = pContext->ssOutput.sensor[1].edgeSet[0].touchCount;
0002f567      struct _ctl_context_t* pContext_1 = pContext;
0002f56a      uint8_t touchCount_1 = touchCount;
0002f56a      touchCount += pContext->ssOutput.sensor[0].edgeSet[0].touchCount;
0002f56a      
0002f576      if (touchCount_1 == -(pContext->ssOutput.sensor[0].edgeSet[0].touchCount))
0002f57e          pretouchData->timeOfLastNoEdges = pContext->ssOutput.timestamp;
0002f57e      
0002f584      pretouchData->touchesStable = 0;
0002f58f      uint32_t rax;
0002f58f      
0002f58f      if (ssFlags0 && ssFlags0 != ONE_TO_ONE)
0002f58f      {
0002f5a9          if (ssFlags0 == TWO_TO_TWO
0002f5a9                  && (!ssFlags1 || ssFlags1 == ONE_TO_ONE || ssFlags1 == TWO_TO_TWO))
0002f594              goto label_2f5af;
0002f594          
0002f753          pretouchData->touchesStable = 0;
0002f58f      }
0002f58f      else if (!ssFlags1 || ssFlags1 == ONE_TO_ONE || ssFlags1 == TWO_TO_TWO)
0002f5a9      {
0002f5af      label_2f5af:
0002f5af          uint32_t r8 = 1;
0002f5af          
0002f5b8          if (touchCount)
0002f5b8          {
0002f612              int64_t i_1 = 4;
0002f618              struct pretouchHandler_t* pretouchData_1 = pretouchData;
0002f61b              uint16_t (* rbx_1)[0x2] =
0002f61b                  &pContext->ssOutput.sensor[0].edgeSet[0].touchIntegral;
0002f705              int64_t i;
0002f705              
0002f705              do
0002f705              {
0002f634                  if (!pContext_1->twoSensorTriangulation.occlusionState
0002f634                      || *((char*)ADJ(rbx_1) + 0x3338) != 1)
0002f634                  {
0002f63a                      int16_t* pretouchData_2 = pretouchData_1;
0002f63d                      uint16_t (* r13_1)[0x2] = rbx_1;
0002f640                      int16_t* rbp_1 = &pretouchData_1->cam[0].smoothedIntegral;
0002f644                      int64_t j_1 = 2;
0002f6f2                      int64_t j;
0002f6f2                      
0002f6f2                      do
0002f6f2                      {
0002f647                          pContext = (uint64_t)(int32_t)*(uint16_t*)rbp_1;
0002f64b                          rbp_1[1] = (uint16_t)pContext;
0002f662                          uint128_t zmm1;
0002f662                          (uint64_t)zmm1 = _mm_cvtepi32_pd((uint64_t)
0002f662                              ADJ(r13_1)->ssOutput.sensor[0].edgeSet[0].touchIntegral[0])
0002f662                              * 0.40000000000000002;
0002f66e                          uint128_t zmm0;
0002f66e                          (uint64_t)zmm0 = _mm_cvtepi32_pd((uint64_t)(uint32_t)pContext)
0002f66e                              * 0.59999999999999998;
0002f676                          (uint64_t)zmm1 = (uint64_t)zmm1 + (uint64_t)zmm0;
0002f67a                          int16_t r15_1 = (int16_t)(int32_t)(uint64_t)zmm1;
0002f67f                          *(uint16_t*)rbp_1 = r15_1;
0002f684                          r15_1 -= (uint16_t)pContext;
0002f688                          *(uint16_t*)pretouchData_2 = r15_1;
0002f688                          
0002f69c                          if (pContext_1->ssOutput.timestamp
0002f69c                              - pretouchData->timeOfLastNoEdges > 0x186a0)
0002f69c                          {
0002f69e                              pContext = (uint64_t)(int32_t)pretouchData_2[2];
0002f6a6                              pretouchData_2[2] = r15_1;
0002f6ad                              int32_t temp4_1;
0002f6ad                              int32_t temp5_1;
0002f6ad                              temp4_1 =
0002f6ad                                  HIGHD((int64_t)((int32_t)r15_1 + (uint32_t)pContext));
0002f6ad                              temp5_1 =
0002f6ad                                  LOWD((int64_t)((int32_t)r15_1 + (uint32_t)pContext));
0002f6b2                              *(uint16_t*)pretouchData_2 =
0002f6b2                                  (int16_t)((temp5_1 - temp4_1) >> 1);
0002f69c                          }
0002f69c                          
0002f6b8                          r13_1 = &(*(uint32_t*)r13_1)[1];
0002f6bf                          int32_t rax_11 = (int32_t)*(uint16_t*)rbp_1;
0002f6c3                          rbp_1 = &rbp_1[2];
0002f6cb                          zmm1 = _mm_cvtepi32_ps((uint128_t)(int32_t)
0002f6cb                              *(uint16_t*)pretouchData_2);
0002f6d1                          (uint32_t)zmm0 = _mm_cvtepi32_ps((uint128_t)rax_11) + 200f;
0002f6d9                          (uint32_t)zmm1 = (uint32_t)zmm1 / (uint32_t)zmm0;
0002f6dd                          (uint32_t)zmm1 = (uint32_t)zmm1 * 1000f;
0002f6e9                          *(uint16_t*)pretouchData_2 = ((int32_t)(uint32_t)zmm1);
0002f6ec                          pretouchData_2 = &pretouchData_2[1];
0002f6ef                          j = j_1;
0002f6ef                          j_1 -= 1;
0002f6f2                      } while (j != 1);
0002f634                  }
0002f634                  
0002f6fa                  rbx_1 = &rbx_1[0x1c];
0002f6fe                  pretouchData_1 = &pretouchData_1->cam[1];
0002f702                  i = i_1;
0002f702                  i_1 -= 1;
0002f705              } while (i != 1);
0002f710              uint32_t rdi_1 = (int32_t)(i_1 + 2);
0002f710              
0002f718              if (touchCount == (uint8_t)rdi_1)
0002f718              {
0002f71f                  int16_t rcx = pretouchData->cam[1].touchZVelocity[0]
0002f71f                      + pretouchData->cam[0].touchZVelocity[0];
0002f71f                  
0002f727                  if (rcx >= 0xffce)
0002f727                  {
0002f729                      r8 = 0;
0002f729                      
0002f730                      if (rcx > 0x64)
0002f730                          r8 = rdi_1;
0002f727                  }
0002f727                  
0002f734                  pretouchData->touchStabilities = r8;
0002f734                  
0002f751                  if (!r8 || (pContext_1->edges[0].lowestPtInTch[0] < 0x1e
0002f751                          && pContext_1->edges[1].lowestPtInTch[0] < 0x1e))
0002f75c                      pretouchData->touchesStable = (uint8_t)rdi_1;
0002f751                  else
0002f753                      pretouchData->touchesStable = 0;
0002f718              }
0002f718              else if (touchCount == 3)
0002f769              {
0002f772                  if (pContext_1->ssOutput.sensor[0].edgeSet[0].touchCount
0002f772                      != (uint8_t)rdi_1)
0002f772                  {
0002f779                      (uint8_t)pContext = 1;
0002f77c                      (uint8_t)r8 = 0;
0002f772                  }
0002f772                  else
0002f774                      (uint8_t)pContext = 0;
0002f774                  
0002f78a                  uint64_t rcx_2 = (uint64_t)(uint8_t)pContext * 2;
0002f78d                  pretouchData->cam[(uint64_t)r8].touchZVelocity[0] = 0;
0002f792                  pretouchData->cam[(uint64_t)r8].touchZVelocity[1] = 0;
0002f79d                  (uint16_t)rax = *(uint16_t*)((char*)pretouchData + (rcx_2 << 3)) * 2;
0002f79d                  
0002f7ae                  if ((uint16_t)rax >= 0xffce && (uint16_t)rax <= 0x64)
0002f7ae                  {
0002f7ba                      (uint16_t)rax =
0002f7ba                          pretouchData->cam[0].touchZVelocity[1 + rcx_2 * 4] * 2;
0002f7ba                      
0002f7cb                      if ((uint16_t)rax >= 0xffce && (uint16_t)rax <= 0x64)
0002f7d1                          pretouchData->touchesStable = 4;
0002f7ae                  }
0002f769              }
0002f769              else if (touchCount > 3)
0002f7db              {
0002f7e5                  int16_t rax_14 = pretouchData->cam[0].touchZVelocity[0]
0002f7e5                      + pretouchData->cam[1].touchZVelocity[0];
0002f7ee                  uint32_t rcx_3;
0002f7ee                  
0002f7ee                  if (rax_14 >= 0xffce)
0002f7ee                  {
0002f7f5                      rcx_3 = 0;
0002f7f5                      
0002f7fb                      if (rax_14 > 0x64)
0002f7fb                          rcx_3 = rdi_1;
0002f7ee                  }
0002f7ee                  else
0002f7f0                      rcx_3 = 1;
0002f7f0                  
0002f7fe                  int16_t r11_1 = pretouchData->cam[1].touchZVelocity[1];
0002f803                  int16_t rdx_1 = pretouchData->cam[0].touchZVelocity[1];
0002f80a                  (uint8_t)rcx_3 = !rcx_3;
0002f80d                  int16_t rbx_2 = r11_1 + rdx_1;
0002f811                  (uint8_t)rcx_3 &= 1;
0002f818                  uint32_t rax_15;
0002f818                  
0002f818                  if (rbx_2 >= 0xffce)
0002f818                  {
0002f81f                      rax_15 = 0;
0002f81f                      
0002f825                      if (rbx_2 > 0x64)
0002f825                          rax_15 = rdi_1;
0002f818                  }
0002f818                  else
0002f81a                      rax_15 = 1;
0002f81a                  
0002f82a                  (uint8_t)rax_15 = !rax_15;
0002f82d                  r11_1 += pretouchData->cam[0].touchZVelocity[0];
0002f831                  (uint8_t)rcx_3 &= (uint8_t)rax_15;
0002f831                  
0002f838                  if (r11_1 >= 0xffce)
0002f838                  {
0002f83f                      rax = 0;
0002f83f                      
0002f846                      if (r11_1 > 0x64)
0002f846                          rax = rdi_1;
0002f838                  }
0002f838                  else
0002f83a                      rax = 1;
0002f83a                  
0002f84b                  (uint8_t)rax = !rax;
0002f84e                  rdx_1 += pretouchData->cam[1].touchZVelocity[0];
0002f853                  (uint8_t)rcx_3 &= (uint8_t)rax;
0002f853                  
0002f859                  if (rdx_1 >= 0xffce)
0002f859                  {
0002f85b                      r8 = 0;
0002f85b                      
0002f862                      if (rdx_1 > 0x64)
0002f862                          r8 = rdi_1;
0002f859                  }
0002f859                  
0002f869                  (uint8_t)rax = !r8;
0002f869                  
0002f86e                  if ((uint8_t)rcx_3 & (uint8_t)rax)
0002f89c                      pretouchData->touchesStable = 3;
0002f86e                  else if (pContext_1->edges[0].lowestPtInTch[0] < 0x1e
0002f86e                          && pContext_1->edges[0].lowestPtInTch[1] < 0x1e
0002f86e                          && pContext_1->edges[1].lowestPtInTch[0] < 0x1e
0002f86e                          && pContext_1->edges[1].lowestPtInTch[1] < 0x1e)
0002f89c                      pretouchData->touchesStable = 3;
0002f7db              }
0002f5b8          }
0002f5b8          else
0002f5b8          {
0002f5ba              __builtin_memset(pretouchData, 0, 2);
0002f5be              pretouchData->cam[0].touchZVelocity[1] = 0;
0002f5c3              pretouchData->cam[1].touchZVelocity[0] = 0;
0002f5c8              pretouchData->cam[1].touchZVelocity[1] = 0;
0002f5cd              pretouchData->cam[0].touchZVelocityPrev[0] = 0;
0002f5d2              pretouchData->cam[0].touchZVelocityPrev[1] = 0;
0002f5d7              pretouchData->cam[1].touchZVelocityPrev[0] = 0;
0002f5dc              pretouchData->cam[1].touchZVelocityPrev[1] = 0;
0002f5e1              pretouchData->cam[0].smoothedIntegral[0][0] = 0;
0002f5e6              pretouchData->cam[0].smoothedIntegral[1][0] = 0;
0002f5eb              pretouchData->cam[1].smoothedIntegral[0][0] = 0;
0002f5f0              pretouchData->cam[1].smoothedIntegral[1][0] = 0;
0002f5f5              pretouchData->cam[0].smoothedIntegral[0][1] = 0;
0002f5fa              pretouchData->cam[0].smoothedIntegral[1][1] = 0;
0002f5ff              pretouchData->cam[1].smoothedIntegral[0][1] = 0;
0002f604              pretouchData->cam[1].smoothedIntegral[1][1] = 0;
0002f609              pretouchData->touchesStable = 1;
0002f5b8          }
0002f5a9      }
0002f5a9      else
0002f753          pretouchData->touchesStable = 0;
0002f753      
0002f8a1      (uint8_t)rax = pretouchData->touchesStable;
0002f8bd      return (uint8_t)rax;
0002f548  }

0002f8be                                                                                            cc cc                                ..
0002f8c0  cc cc cc cc                                                                                      ....

0002f8c4    uint8_t GaussElimDbl(double (* a)[0x9], int16_t const n)

0002f8c4  {
0002f8ef      int64_t i_7 = 8;
0002f8f7      void* r8 = nullptr;
0002f8fb      double* rax_6;
0002f8fb      
0002f8fb      while (true)
0002f8fb      {
0002f8fb          int16_t i_8 = (int16_t)(1 + r8);
0002f8ff          int16_t i_6 = (uint16_t)r8;
0002f907          int16_t i = i_8;
0002f907          
0002f90b          if (i_8 < 8)
0002f90b          {
0002f911              int64_t rsi_1 = (int64_t)(uint16_t)r8;
0002f91c              void* rbx_1 = &(*(uint576_t*)a)[(int64_t)i_8 * 9 + rsi_1];
0002f91c              
0002f946              do
0002f946              {
0002f935                  if (!(*(uint64_t*)rbx_1 <= (*(uint576_t*)a)[(int64_t)i_6 * 9 + rsi_1]))
0002f937                      i_6 = i;
0002f937                  
0002f93a                  i += 1;
0002f93e                  rbx_1 += 0x48;
0002f946              } while (i < 8);
0002f90b          }
0002f90b          
0002f94c          int64_t rbx_2 = (int64_t)(uint16_t)r8;
0002f984          double zmm0;
0002f984          
0002f984          for (int16_t i_1 = 0; i_1 < 9; )
0002f984          {
0002f95c              int64_t i_4 = (int64_t)i_1;
0002f960              i_1 += 1;
0002f968              int64_t rdx = (int64_t)i_6 * 9 + i_4;
0002f96c              int64_t rcx_4 = i_4 + rbx_2 * 9;
0002f974              zmm0 = (*(uint576_t*)a)[rdx];
0002f97a              (*(uint576_t*)a)[rdx] = (*(uint576_t*)a)[rcx_4];
0002f97e              (*(uint576_t*)a)[rcx_4] = zmm0;
0002f984          }
0002f984          
0002f98e          zmm0 = *(uint64_t*)(rbx_2 * 0x50 + a);
0002f98e          
0002f9a2          if (!(0x3d719799812dea11 <= zmm0) && zmm0 > -9.9999999999999998e-13)
0002f9a2          {
0002fae7              (uint8_t)rax_6 = 0;
0002fae9              break;
0002f9a2          }
0002f9a2          
0002f9b4          double zmm2 = -1.0 / zmm0;
0002f9b4          
0002f9b8          if (8 >= (uint16_t)r8)
0002f9b8          {
0002f9be              int64_t rdi_2 = 8;
0002f9c1              void* rdx_1 = &a[rbx_2][8];
0002f9cd              uint64_t i_5 = (uint64_t)(9 - (uint16_t)r8);
0002fa28              uint64_t i_2;
0002fa28              
0002fa28              do
0002fa28              {
0002f9d8                  double zmm1 = zmm2 * *(uint64_t*)rdx_1;
0002f9d8                  
0002f9dc                  if (i_8 < 8)
0002f9dc                  {
0002f9e2                      int64_t rcx_5 = (int64_t)i_8 * 9;
0002f9ea                      r8 = &(*(uint576_t*)a)[rdi_2 + rcx_5];
0002f9f2                      void* rcx_6 = &(*(uint576_t*)a)[rcx_5 + rbx_2];
0002f9fd                      uint64_t j_2 = (uint64_t)(8 - i_8);
0002fa1d                      uint64_t j;
0002fa1d                      
0002fa1d                      do
0002fa1d                      {
0002fa04                          zmm0 = zmm1 * *(uint64_t*)rcx_6;
0002fa08                          rcx_6 += 0x48;
0002fa11                          *(uint64_t*)r8 = zmm0 + *(uint64_t*)r8;
0002fa16                          r8 += 0x48;
0002fa1a                          j = j_2;
0002fa1a                          j_2 -= 1;
0002fa1d                      } while (j != 1);
0002f9dc                  }
0002f9dc                  
0002fa1f                  rdi_2 -= 1;
0002fa22                  rdx_1 -= 8;
0002fa25                  i_2 = i_5;
0002fa25                  i_5 -= 1;
0002fa28              } while (i_2 != 1);
0002f9b8          }
0002f9b8          
0002fa2e          (uint16_t)r8 = i_8;
0002fa2e          
0002fa32          if (i_8 >= 8)
0002fa32          {
0002fa38              int64_t rbx_3 = 7;
0002fa3d              double* r8_1 = &(*(uint576_t*)a)[0x46];
0002fa44              double* rsi_2 = &(*(uint576_t*)a)[0x3e];
0002fa4b              int16_t j_3 = 6;
0002fa4e              int64_t rdi_3 = 0x36;
0002fa51              double* rcx_7 = &(*(uint576_t*)a)[0x47];
0002fac7              int64_t i_3;
0002fac7              
0002fac7              do
0002fac7              {
0002fa6a                  int16_t j_1 = j_3;
0002fa72                  *(uint64_t*)rcx_7 = *(uint64_t*)rcx_7 / *(uint64_t*)r8_1;
0002fa76                  *(uint64_t*)r8_1 = 1.0;
0002fa76                  
0002fa79                  if (j_3 >= 0)
0002fa79                  {
0002fa7f                      void* r11_1 = &(*(uint576_t*)a)[rdi_3 + rbx_3];
0002fa83                      rax_6 = rsi_2;
0002fa83                      
0002faad                      do
0002faad                      {
0002fa8e                          j_1 -= 1;
0002fa9a                          *(uint64_t*)rax_6 =
0002fa9a                              *(uint64_t*)rax_6 - *(uint64_t*)rcx_7 * *(uint64_t*)r11_1;
0002fa9e                          *(uint64_t*)r11_1 = 0;
0002faa1                          rax_6 -= 0x48;
0002faa5                          r11_1 -= 0x48;
0002faad                      } while (j_1 >= 0);
0002fa79                  }
0002fa79                  
0002faaf                  j_3 -= 1;
0002fab2                  rdi_3 -= 9;
0002fab5                  rsi_2 -= 0x48;
0002fab9                  rbx_3 -= 1;
0002fabc                  r8_1 -= 0x50;
0002fac0                  rcx_7 -= 0x48;
0002fac4                  i_3 = i_7;
0002fac4                  i_7 -= 1;
0002fac7              } while (i_3 != 1);
0002fac9              (uint8_t)rax_6 = 1;
0002fac9              break;
0002fa32          }
0002f8fb      }
0002f8fb      
0002fae6      return (uint8_t)rax_6;
0002f8c4  }

0002faeb                                   cc cc cc cc cc cc cc cc cc                                                 .........

0002faf4    void CurveFit(struct fpoint_t* ptsArr, uint8_t numPts, uint8_t numCoefficients, float* retCoefficients)

0002faf4  {
0002fb09      struct fpoint_t* ptsArr_1 = ptsArr;
0002fb0c      int64_t rbx;
0002fb0c      (uint8_t)rbx = numPts;
0002fb0e      int64_t var_60 = 0;
0002fb1f      int64_t var_50;
0002fb1f      __builtin_memset(&var_50, 0, 0x18);
0002fb2b      int32_t var_58 = 0;
0002fb2f      void matrix;
0002fb2f      memset(&matrix, 0, 0x30);
0002fb34      int64_t r9 = 0;
0002fb3a      int64_t var_68;
0002fb3a      int64_t j_1;
0002fb3a      
0002fb3a      if ((uint8_t)rbx > 0)
0002fb3a      {
0002fb48          uint64_t i_2 = (uint64_t)(uint8_t)rbx;
0002fbde          uint64_t i;
0002fbde          
0002fbde          do
0002fbde          {
0002fb4b              int64_t rax_1;
0002fb4b              (uint32_t)rax_1 = ptsArr_1->x;
0002fb4b              *(uint32_t*)((char*)rax_1)[4] = ptsArr_1->y;
0002fb4e              float zmm1 = (uint32_t)var_60;
0002fb54              float zmm0 = (uint32_t)var_50;
0002fb5a              var_68 = rax_1;
0002fb5f              float zmm2 = 1f;
0002fb62              j_1 = 2;
0002fb67              int64_t rax_2 = 0;
0002fb74              float var_64;
0002fb74              (uint32_t)var_60 = zmm1 + var_64;
0002fb7a              (uint32_t)var_50 = zmm0 + 1f;
0002fbb3              int64_t j;
0002fbb3              
0002fbb3              do
0002fbb3              {
0002fb80                  zmm2 = zmm2 * (uint32_t)var_68;
0002fb8c                  rax_2 += 4;
0002fb90                  j = j_1;
0002fb90                  j_1 -= 1;
0002fba1                  zmm1 = var_64 * zmm2 + *(uint32_t*)(&var_60 + rax_2);
0002fba7                  *(uint32_t*)(&var_50 + rax_2) = zmm2 + *(uint32_t*)(&var_50 + rax_2);
0002fbad                  *(uint32_t*)(&var_60 + rax_2) = zmm1;
0002fbb3              } while (j != 1);
0002fbb5              (uint8_t)j_1 = 3;
0002fbb5              
0002fbd4              do
0002fbd4              {
0002fbb7                  zmm2 = zmm2 * (uint32_t)var_68;
0002fbbd                  uint64_t rax_3 = (uint64_t)(uint8_t)j_1;
0002fbc0                  (uint8_t)j_1 += 1;
0002fbcb                  *(uint32_t*)(&var_50 + (rax_3 << 2)) =
0002fbcb                      zmm2 + *(uint32_t*)(&var_50 + (rax_3 << 2));
0002fbd4              } while ((uint8_t)j_1 <= 4);
0002fbd4              
0002fbd6              ptsArr_1 = &ptsArr_1[1];
0002fbda              i = i_2;
0002fbda              i_2 -= 1;
0002fbde          } while (i != 1);
0002fb3a      }
0002fb3a      
0002fbe4      void* rdx = &matrix;
0002fbe9      void var_2c;
0002fbe9      void* r8 = &var_2c;
0002fbee      int64_t i_3 = 3;
0002fc1c      int64_t i_1;
0002fc1c      
0002fc1c      do
0002fc1c      {
0002fbf4          int64_t rax_4 = *(uint64_t*)(&var_50 + r9);
0002fbf9          r9 += 4;
0002fbfd          *(uint64_t*)rdx = rax_4;
0002fc05          rdx += 0x10;
0002fc09          *(uint32_t*)((char*)rdx - 8) = *(uint32_t*)(&*(uint64_t*)((char*)var_50)[4] + r9);
0002fc11          *(uint32_t*)r8 = *(uint32_t*)(&*(uint64_t*)((char*)var_68)[4] + r9);
0002fc14          r8 += 0x10;
0002fc18          i_1 = i_3;
0002fc18          i_3 -= 1;
0002fc1c      } while (i_1 != 1);
0002fc26      (uint8_t)j_1 = 3;
0002fc28      GaussSolve((uint8_t)j_1, &matrix, retCoefficients);
0002faf4  }

0002fc42        cc cc cc cc cc cc                                                                            ......

0002fc48    float __convention("sysv") CalcPolynomialY(float x, uint8_t numCoefficients @ rdx, float* coefficientsArr @ r8)

0002fc48  {
0002fc57      uint64_t zmm6[0x2] = {0};
0002fc5f      float* coefficientsArr_1 = coefficientsArr;
0002fc62      int64_t rbx;
0002fc62      (uint8_t)rbx = 0;
0002fc64      float zmm7[0x4] = x;
0002fc64      
0002fc92      do
0002fc92      {
0002fc78          uint128_t zmm1;
0002fc78          uint64_t entry_zmm2[0x2];
0002fc78          double entry_zmm3;
0002fc78          double zmm4;
0002fc78          uint64_t zmm5[0x2];
0002fc78          uint64_t zmm8[0x2];
0002fc78          uint64_t zmm9[0x2];
0002fc78          x = pow(_mm_cvtps_pd(_mm_unpacklo_ps(zmm7, *(uint64_t*)&zmm7[0])[0]), 
0002fc78              _mm_cvtepi32_pd((uint64_t)(uint8_t)rbx), entry_zmm2, entry_zmm3, zmm4, zmm5, 
0002fc78              zmm6, zmm8, zmm9);
0002fc7d          (uint8_t)rbx += 1;
0002fc7f          (uint32_t)zmm1 = (float)x;
0002fc83          (uint32_t)zmm1 = (uint32_t)zmm1 * *(uint32_t*)coefficientsArr_1;
0002fc87          coefficientsArr_1 = &coefficientsArr_1[1];
0002fc8b          zmm6[0] = zmm6[0] + (uint32_t)zmm1;
0002fc92      } while ((uint8_t)rbx < 3);
0002fc92      
0002fcab      return zmm6[0];
0002fc48  }

0002fcac                                      cc cc cc cc cc cc cc cc                                                  ........

0002fcb4    void GaussSolve(uint8_t numOfCoeffs, float (* matrix)[0x4], float* retCoefficients)

0002fcb4  {
0002fcb4      uint64_t rbx;
0002fcb4      uint64_t arg_8 = rbx;
0002fcc3      uint128_t zmm3 = 0x7fffffffffffffff;
0002fcce      float (* matrix_1)[0x4] = matrix;
0002fcd1      uint64_t j_3;
0002fcd1      (uint8_t)j_3 = 0;
0002fe02      uint64_t zmm0[0x2];
0002fe02      float zmm1;
0002fe02      float zmm2;
0002fe02      char i;
0002fe02      
0002fe02      do
0002fe02      {
0002fcd4          i = (char)(j_3 + 1);
0002fcd8          uint64_t r10_1 = (uint64_t)(uint8_t)j_3;
0002fcdc          (uint8_t)rbx = (uint8_t)j_3;
0002fce3          int32_t i_4 = (int32_t)i;
0002fce7          (uint8_t)matrix = i;
0002fcfa          zmm1 = (float)_mm_and_pd(
0002fcfa              _mm_cvtps_pd(((uint128_t)(*(uint128_t*)matrix_1)[r10_1 * 5])[0]), zmm3)[0];
0002fcfa          
0002fcfe          if (i_4 < 3)
0002fcfe          {
0002fd41              do
0002fd41              {
0002fd15                  zmm0 = _mm_and_pd(
0002fd15                      _mm_cvtps_pd(((uint128_t)(*(uint128_t*)matrix_1)[(uint8_t)r10_1
0002fd15                          + ((uint8_t)matrix << 2)])[0]), 
0002fd15                      zmm3);
0002fd19                  zmm0[0] = (float)zmm0[0];
0002fd19                  
0002fd20                  if (!(zmm0[0] <= zmm1))
0002fd20                  {
0002fd25                      (uint8_t)rbx = (uint8_t)matrix;
0002fd38                      zmm1 = (float)_mm_and_pd(
0002fd38                          _mm_cvtps_pd(((uint128_t)(*(uint128_t*)matrix_1)[(uint8_t)r10_1
0002fd38                              + ((uint8_t)matrix << 2)])[0]), 
0002fd38                          zmm3)[0];
0002fd20                  }
0002fd20                  
0002fd3c                  (uint8_t)matrix += 1;
0002fd41              } while ((uint8_t)matrix < 3);
0002fd41              
0002fd4c              if ((uint8_t)j_3 < (uint8_t)rbx && (uint8_t)j_3 <= 3)
0002fd4c              {
0002fd59                  matrix = &(*(uint128_t*)matrix_1)[r10_1 + ((uint64_t)(uint8_t)rbx << 2)];
0002fd5d                  numOfCoeffs = (uint8_t)matrix_1 + (char)(r10_1 * 0x14);
0002fd69                  j_3 = (uint64_t)(4 - (uint8_t)j_3);
0002fd85                  uint64_t j;
0002fd85                  
0002fd85                  do
0002fd85                  {
0002fd6f                      zmm0 = *(uint32_t*)numOfCoeffs;
0002fd73                      *(uint32_t*)numOfCoeffs = *(uint32_t*)matrix;
0002fd75                      numOfCoeffs += 4;
0002fd79                      *(uint32_t*)matrix = zmm0[0];
0002fd7d                      matrix = &(*(uint128_t*)matrix)[1];
0002fd81                      j = j_3;
0002fd81                      j_3 -= 1;
0002fd85                  } while (j != 1);
0002fd4c              }
0002fcfe          }
0002fcfe          
0002fd8a          (uint8_t)matrix = i;
0002fd8a          
0002fd8d          if (i_4 < 3)
0002fd8d          {
0002fdf9              do
0002fdf9              {
0002fd93                  j_3 = (int64_t)(uint8_t)matrix;
0002fd97                  int64_t rax_8 = r10_1 + (j_3 << 2);
0002fda1                  zmm2 =
0002fda1                      (*(uint128_t*)matrix_1)[rax_8] / (*(uint128_t*)matrix_1)[r10_1 * 5];
0002fda7                  (*(uint128_t*)matrix_1)[rax_8] = 0;
0002fda7                  
0002fdb0                  if (i <= 3)
0002fdb0                  {
0002fdb2                      uint64_t i_2 = (uint64_t)i;
0002fdba                      j_3 = &(*(uint128_t*)matrix_1)[i_2 + (j_3 << 2)];
0002fdc2                      numOfCoeffs = (uint8_t)matrix_1 + (char)((i_2 + (r10_1 << 2)) << 2);
0002fdce                      uint64_t j_2 = (uint64_t)(4 - i);
0002fdf2                      uint64_t j_1;
0002fdf2                      
0002fdf2                      do
0002fdf2                      {
0002fdd1                          zmm0 = *(uint32_t*)j_3;
0002fdd9                          zmm1 = zmm2 * *(uint32_t*)numOfCoeffs;
0002fddd                          numOfCoeffs += 4;
0002fde1                          zmm0[0] = zmm0[0] - zmm1;
0002fde5                          *(uint32_t*)j_3 = zmm0[0];
0002fdea                          j_3 += 4;
0002fdee                          j_1 = j_2;
0002fdee                          j_2 -= 1;
0002fdf2                      } while (j_1 != 1);
0002fdb0                  }
0002fdb0                  
0002fdf4                  (uint8_t)matrix += 1;
0002fdf9              } while ((uint8_t)matrix < 3);
0002fd8d          }
0002fd8d          
0002fdfb          (uint8_t)j_3 = i;
0002fe02      } while (i < 3);
0002fe0b      numOfCoeffs = 2;
0002fe86      uint8_t numOfCoeffs_2;
0002fe86      
0002fe86      do
0002fe86      {
0002fe0d          int64_t numOfCoeffs_1 = (int64_t)numOfCoeffs;
0002fe17          int32_t* r8_1 = numOfCoeffs_1 << 2;
0002fe1b          zmm2 = (*(uint128_t*)matrix_1)[(char*)r8_1 + 3];
0002fe1b          
0002fe25          if (numOfCoeffs + 1 < 3)
0002fe25          {
0002fe27              uint64_t rax_12 = (uint64_t)(numOfCoeffs + 1);
0002fe2a              void* r10_2 = &retCoefficients[rax_12];
0002fe31              void* rbx_1 = &(*(uint128_t*)matrix_1)[rax_12 + r8_1];
0002fe3c              uint64_t i_3 = (uint64_t)(3 - (numOfCoeffs + 1));
0002fe5f              uint64_t i_1;
0002fe5f              
0002fe5f              do
0002fe5f              {
0002fe3f                  zmm1 = *(uint32_t*)r10_2;
0002fe44                  zmm0 = {0};
0002fe47                  r10_2 += 4;
0002fe4b                  zmm1 = zmm1 * *(uint32_t*)rbx_1;
0002fe4f                  rbx_1 += 4;
0002fe53                  i_1 = i_3;
0002fe53                  i_3 -= 1;
0002fe57                  zmm0[0] = 0f - zmm1;
0002fe5b                  zmm2 = zmm2 + zmm0[0];
0002fe5f              } while (i_1 != 1);
0002fe25          }
0002fe25          
0002fe65          zmm0 = (*(uint128_t*)matrix_1)[numOfCoeffs_1 * 5];
0002fe6b          zmm0[0] - 0f;
0002fe6b          
0002fe70          if (FCMP_UO(zmm0[0], 0f) || zmm0[0] != 0f)
0002fe7d              *(uint32_t*)((char*)r8_1 + retCoefficients) = zmm2 / zmm0[0];
0002fe70          else
0002fe72              *(uint32_t*)((char*)r8_1 + retCoefficients) = 0;
0002fe72          
0002fe83          numOfCoeffs_2 = numOfCoeffs;
0002fe83          numOfCoeffs -= 1;
0002fe86      } while (numOfCoeffs_2 - 1 >= 0);
0002fcb4  }

0002fe98                                                                          cc cc cc cc cc cc cc cc                          ........

0002fea0    uint8_t CTL_SensorAngleToLine(float sensorAngle, struct sensor_info_t const* sensorInfo, struct line_def_t* line)

0002fea0  {
0002febb      if (!sensorInfo)
0002fec7          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_math.c", 
0002fec7              (int32_t)((char*)sensorInfo + 0xd));
0002fec7      
0002fecf      if (!line)
0002fedb          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_math.c", 
0002fedb              (int32_t)((char*)line + 0xe));
0002fedb      
0002fee0      int128_t zmm6;
0002fee0      (uint32_t)zmm6 = sensorAngle + sensorInfo->rotation_offset;
0002fee8      int64_t rax;
0002fee8      float zmm0;
0002fee8      zmm0 = _safeTan((uint32_t)zmm6);
0002fef2      (uint8_t)rax = 1;
0002fef4      line->m = zmm0;
0002fef8      zmm0 = zmm0 * sensorInfo->position.x;
0002fefc      float y = sensorInfo->position.y;
0002ff01      line->weight = 1f;
0002ff0c      line->c = y - zmm0;
0002ff1b      return 1;
0002fea0  }

0002ff1c                                                                                      cc cc cc cc                              ....
0002ff20  cc cc cc cc                                                                                      ....

0002ff24    uint8_t CTL_EdgesToCentreLine(struct edge_pair_t edgePair, struct sensor_info_t const* sensorInfo, struct line_def_t* line)

0002ff24  {
0002ff29      int64_t arg_8;
0002ff29      (uint32_t)arg_8 = edgePair.edge[0];
0002ff29      *(uint32_t*)((char*)arg_8)[4] = edgePair.edge[1];
0002ff29      
0002ff3c      if (!sensorInfo)
0002ff48          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_math.c", 
0002ff48              (int32_t)((char*)sensorInfo + 0x1d));
0002ff48      
0002ff50      if (!line)
0002ff5c          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_math.c", 
0002ff5c              (int32_t)((char*)line + 0x1e));
0002ff5c      
0002ff7a      int64_t rax;
0002ff7a      float zmm0_1;
0002ff7a      zmm0_1 = _safeTan((*(uint32_t*)((char*)arg_8)[4] + (uint32_t)arg_8) * 0.5f
0002ff7a          + sensorInfo->rotation_offset);
0002ff7f      (uint8_t)rax = 1;
0002ff81      line->m = zmm0_1;
0002ff85      zmm0_1 = zmm0_1 * sensorInfo->position.x;
0002ff89      float y = sensorInfo->position.y;
0002ff8e      line->weight = 1f;
0002ff99      line->c = y - zmm0_1;
0002ffa8      return 1;
0002ff24  }

0002ffa9                             cc cc cc cc cc cc cc                                                           .......

0002ffb0    uint8_t CTL_EdgesetsToCentreLines(struct edge_set_t* edgeSet, struct sensor_info_t const* sensorInfo, struct line_def_t* lines)

0002ffb0  {
0002ffcb      if (!sensorInfo)
0002ffd7          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_math.c", 
0002ffd7              (int32_t)((char*)sensorInfo + 0x2d));
0002ffd7      
0002ffdf      if (!lines)
0002ffeb          onVerify__("c:\development_work\csf_release_hp\driver\foureyes\ctl_math.c", 
0002ffeb              (int32_t)((char*)lines + 0x2e));
0002ffeb      
0002fff0      float edgePair[0x2];
0002fff0      edgePair[0] = edgeSet->edgePair[0].edge[0];
0002fff0      edgePair[1] = edgeSet->edgePair[0].edge[1];
0002fff9      CTL_EdgesToCentreLine(edgePair, sensorInfo, lines);
0002fffe      float edgePair_1[0x2];
0002fffe      edgePair_1[0] = edgeSet->edgePair[1].edge[0];
0002fffe      edgePair_1[1] = edgeSet->edgePair[1].edge[1];
00030009      CTL_EdgesToCentreLine(edgePair_1, sensorInfo, &lines[1]);
00030009      
00030012      if (edgeSet->specialCases & 0x40)
00030012      {
00030025          lines->weight = lines->weight * 0.150000006f;
00030033          *(int64_t*)((char*)lines + 0x14) =
00030033              *(int64_t*)((char*)lines + 0x14) * 0.150000006f;
00030012      }
00030012      
00030042      int64_t rax;
00030042      (uint8_t)rax = 1;
00030049      return 1;
0002ffb0  }

0003004a                                cc cc cc cc cc cc                                                            ......

00030050    struct fpoint_t CTL_Triangulate(float sensorAAngle, float sensorBAngle, struct sensor_info_t const* sensorAInfo, struct sensor_info_t const* sensorBInfo)

00030050  {
00030069      struct line_def_t line;
00030069      uint8_t rax;
00030069      float sensorAngle;
00030069      rax = CTL_SensorAngleToLine(sensorAAngle, sensorAInfo, &line);
00030070      struct line_def_t lineB;
00030070      struct line_def_t line_1;
00030070      
00030070      if (rax == 1 && CTL_SensorAngleToLine(sensorAngle, sensorBInfo, &line_1) == 1)
00030070      {
00030092          lineB.m = line_1.m;
00030097          lineB.c = line_1.c;
000300a2          lineB.weight = line_1.weight;
000300a5          int64_t rax_5;
000300a5          (uint32_t)rax_5 = line.m;
000300a5          *(uint32_t*)((char*)rax_5)[4] = line.c;
000300ad          struct line_def_t lineA;
000300ad          lineA.m = (uint32_t)rax_5;
000300ad          lineA.c = *(uint32_t*)((char*)rax_5)[4];
000300b8          lineA.weight = line.weight;
000300c0          return SFP_LineIntersect(&lineA, &lineB);
00030070      }
00030070      
000300cf      lineB.m = 0x4b18967f;
000300d5      lineB.c = 0x4b18967f;
000300db      struct fpoint_t result;
000300db      result.x = lineB.m;
000300db      result.y = lineB.c;
000300ea      return result;
00030050  }

000300eb                                   cc cc cc cc cc cc cc cc cc                                                 .........

000300f4    void UpdateUnstableFirstTouchFilter(struct triangulate_statics_t* statics, struct unstable_first_filter_t* unstableFirstTouchData, struct sub_sample_in_t* ssInput, uint8_t numTouchesFromEdges)

000300f4  {
0003010d      void var_228;
0003010d      int64_t var_18 = __security_cookie ^ &var_228;
00030115      int64_t rax_1;
00030115      (uint8_t)rax_1 = ssInput->edgeCount;
00030115      
0003012a      if ((uint8_t)rax_1 && !numTouchesFromEdges)
0003012a      {
00030130          bool cond:0_1 = unstableFirstTouchData->patternMatched != 1;
00030134          char var_28 = 4;
00030139          char var_27_1 = 2;
0003013e          char var_26_1 = 2;
00030143          uint8_t numTouchesFromEdges_1 = numTouchesFromEdges;
00030147          uint8_t numTouchesFromEdges_2 = numTouchesFromEdges;
0003014b          char var_20 = 4;
00030150          char var_1f_1 = 2;
00030155          char var_1e_1 = 2;
0003015a          char var_1d_1 = 2;
0003015f          uint8_t numTouchesFromEdges_3 = numTouchesFromEdges;
00030163          uint8_t numTouchesFromEdges_4 = numTouchesFromEdges;
00030163          
0003016b          if (cond:0_1 || (uint8_t)rax_1 != 4)
0003016b          {
00030181              unstableFirstTouchData->savedInputHistory[(uint64_t)unstableFirstTouchData->
00030181                  curHistoryIndex].firstEdges[0] = ssInput->edges[0];
00030192              *(uint32_t*)((char*)unstableFirstTouchData
00030192                  + (((uint64_t)unstableFirstTouchData->curHistoryIndex * 3 + 3) << 2)) =
00030192                  ssInput->edges[1];
0003019d              uint64_t rax_6;
0003019d              (uint8_t)rax_6 = ssInput->edgeCount;
000301a1              (&unstableFirstTouchData->savedInputHistory[0].edgeCount)[
000301a1                  (uint64_t)unstableFirstTouchData->curHistoryIndex * 0xc] = (uint8_t)rax_6;
000301ad              uint64_t rax_7;
000301ad              (uint8_t)rax_7 = ssInput->sensor;
000301b1              (uint8_t)ssInput = 0;
000301b4              (&unstableFirstTouchData->savedInputHistory[0].sensorNum)[
000301b4                  (uint64_t)unstableFirstTouchData->curHistoryIndex * 0xc] = (uint8_t)rax_7;
000301b8              uint32_t curHistoryIndex = (uint32_t)unstableFirstTouchData->curHistoryIndex;
000301bd              unstableFirstTouchData->historyReset = 0;
000301bd              
000301cf              while (true)
000301cf              {
000301f5                  if (unstableFirstTouchData->savedInputHistory[(uint64_t)((curHistoryIndex
000301f5                      - (uint32_t)(uint8_t)ssInput + 6) - (char)(
000301f5                      (uint64_t)((curHistoryIndex - (uint32_t)(uint8_t)ssInput + 6) / 6)
000301f5                      * 3) * 2)].edgeCount != (&var_28)[(uint64_t)(uint8_t)ssInput])
000301f5                  {
00030202                      (uint8_t)ssInput = 0;
00030202                      
00030213                      while (unstableFirstTouchData->savedInputHistory[(uint64_t)((
00030213                          curHistoryIndex - (uint32_t)(uint8_t)ssInput + 6) - (char)(
00030213                          (uint64_t)((curHistoryIndex - (uint32_t)(uint8_t)ssInput + 6) / 6)
00030213                          * 3) * 2)].edgeCount == (&var_20)[(uint64_t)(uint8_t)ssInput])
00030213                      {
0003023f                          (uint8_t)ssInput += 1;
0003023f                          
00030246                          if ((uint8_t)ssInput >= 6)
00030246                              goto label_30252;
00030213                      }
00030213                      
00030239                      break;
000301f5                  }
000301f5                  
000301f7                  (uint8_t)ssInput += 1;
000301f7                  
000301fe                  if ((uint8_t)ssInput >= 5)
000301fe                  {
00030252                  label_30252:
00030252                      unstableFirstTouchData->patternMatched = 1;
0003027e                      uint64_t rdx_10 = (uint64_t)((curHistoryIndex + 5)
0003027e                          - (char)((uint64_t)((curHistoryIndex + 5) / 6) * 3) * 2) * 3;
00030282                      uint64_t rax_31 = (uint64_t)((curHistoryIndex + 4)
00030282                          - (char)((uint64_t)((curHistoryIndex + 4) / 6) * 3) * 2);
00030285                      (uint8_t)curHistoryIndex = (
00030285                          &unstableFirstTouchData->savedInputHistory[0].sensorNum)[rdx_10 << 2];
0003028a                      uint64_t rcx_14 = rax_31 * 3;
0003028e                      (uint8_t)rax_31 = (
0003028e                          &unstableFirstTouchData->savedInputHistory[0].sensorNum)[rcx_14 << 2];
0003028e                      
00030295                      if ((uint8_t)curHistoryIndex == (uint8_t)rax_31)
0003031e                          unstableFirstTouchData->patternMatched = 0;
00030295                      else
00030295                      {
000302a1                          int32_t zmm1 = unstableFirstTouchData->savedInputHistory[0].
000302a1                              firstEdges[1 + rdx_10];
000302bc                          uint8_t sensorB = (uint8_t)rax_31;
000302c0                          struct edge_set_t sensorASet;
000302c0                          sensorASet.edgePair[0].edge[0] = *(uint32_t*)(
000302c0                              &unstableFirstTouchData->savedInputHistory + (rdx_10 << 2));
000302c9                          int32_t zmm0 = *(uint32_t*)(
000302c9                              &unstableFirstTouchData->savedInputHistory + (rcx_14 << 2));
000302cf                          sensorASet.edgePair[0].edge[1] = zmm1;
000302d8                          zmm1 = unstableFirstTouchData->savedInputHistory[0].firstEdges[1
000302d8                              + rcx_14];
000302de                          struct edge_set_t sensorBSet;
000302de                          sensorBSet.edgePair[0].edge[0] = zmm0;
000302ec                          sensorBSet.edgePair[0].edge[1] = zmm1;
0003030b                          struct kite_t __return;
0003030b                          struct fpoint_t var_e8;
0003030b                          memmove(&var_e8, 
0003030b                              Triangulate1Touch(&__return, &sensorASet, &sensorBSet, 
0003030b                                  (uint8_t)curHistoryIndex, sensorB, statics), 
0003030b                              0xbc);
00030310                          struct fpoint_t r11;
00030310                          r11.x = var_e8.x;
00030310                          r11.y = var_e8.y;
00030318                          unstableFirstTouchData->unstableTouchPoint.x = r11.x;
00030318                          unstableFirstTouchData->unstableTouchPoint.y = r11.y;
00030295                      }
00030295                      
00030295                      break;
000301fe                  }
000301cf              }
000301cf              
00030328              int32_t rcx_18 = (uint32_t)unstableFirstTouchData->curHistoryIndex + 1;
0003033a              unstableFirstTouchData->curHistoryIndex =
0003033a                  (uint8_t)rcx_18 - (char)((uint64_t)(rcx_18 / 6) * 3) * 2;
0003016b          }
0003012a      }
0003012a      else if (!unstableFirstTouchData->historyReset)
00030343      {
0003034f          memset(&unstableFirstTouchData->savedInputHistory, 0, 0x48);
00030354          unstableFirstTouchData->curHistoryIndex = 0;
00030358          unstableFirstTouchData->patternMatched = 0;
0003035c          unstableFirstTouchData->historyReset = 1;
00030343      }
00030343      
0003036b      __security_check_cookie(var_18 ^ &var_228);
000300f4  }

00030381     cc cc cc cc cc cc cc                                                                           .......

00030388    enum orientation_t DetermineOrientationFromResidualErrors(struct quadratic_filter_t* quadraticFilterData, uint8_t predictionDecisionMade, uint8_t occludedSensor, enum orientation_t prevOrientation, float* confidence)

00030388  {
0003039c      int32_t result = 0;
0003039e      int64_t rsi;
0003039e      (uint8_t)rsi = occludedSensor;
000303a7      *(uint32_t*)confidence = 0f;
000303aa      int64_t rax;
000303aa      (uint8_t)rax = 0;
000303aa      
000303f1      for (char i = 0; i < 4; i += 1)
000303f1      {
000303b1          if ((uint8_t)rax)
000303e8              (uint8_t)rax = 1;
000303b1          else
000303b1          {
000303bb              int64_t rdx = (uint64_t)i + ((uint64_t)(uint8_t)rsi << 2);
000303e1              (uint8_t)rax = 0;
000303e1              
000303e6              if (!(*(uint32_t*)((char*)quadraticFilterData + ((rdx * 3 + 0xe1) << 2))
000303e6                      <= quadraticFilterData->residualError[0][rdx].resError[1]
000303e6                      * 1.10000002f))
000303e8                  (uint8_t)rax = 1;
000303b1          }
000303f1      }
000303f1      
0003040b      if ((uint8_t)rax && !predictionDecisionMade
0003040b          && !quadraticFilterData->hasSwitchedDuringThisOcclusion
0003040b          && quadraticFilterData->entryOrientation == prevOrientation)
0003040b      {
00030411          if (prevOrientation == O_VERTICAL)
00030411          {
00030413              result = prevOrientation - 1;
00030417              *(uint32_t*)confidence = -0.899999976f;
00030411          }
00030411          else if (prevOrientation == O_HORIZONTAL)
00030424          {
00030426              result = prevOrientation + 1;
0003042a              __builtin_strncpy(confidence, "fff?", 4);
00030424          }
00030424          
0003043c          memset(quadraticFilterData, 0, 0x380);
00030441          quadraticFilterData->hasSwitchedDuringThisOcclusion = 1;
00030448          quadraticFilterData->switchDecisionOccludedSensorNum = (uint8_t)rsi;
0003040b      }
0003040b      
00030460      return result;
00030388  }

00030461     cc cc cc cc cc cc cc                                                                           .......

00030468    void ProcessQuadraticTouchTrackingFilter(struct quadratic_filter_t* quadraticFilterData, struct kite_t* kite, uint8_t predictionDecisionMade, uint8_t numSensors, uint8_t occludedSensor, struct sub_sample_t* ssOutput, float* diamondWidths, float* occludedCentreAngles, struct twoSensorTriangulationMngr_t* twoSensorTriangulation, struct fpoint_t panelSize)

00030468  {
00030496      uint64_t zmm6[0x2];
00030496      uint64_t var_38[0x2] = zmm6;
0003049a      int64_t rdi;
0003049a      (uint8_t)rdi = ssOutput->sensor[1].edgeSet[0].touchCount;
000304a1      uint16_t deltaTimeStamp = ssOutput->id.deltaTimeStamp;
000304a9      uint128_t zmm7;
000304a9      uint128_t var_48 = zmm7;
000304ad      (uint8_t)rdi += ssOutput->sensor[0].edgeSet[0].touchCount;
000304b1      uint8_t hasSeenUnoccludedTouchesSinceTouchDown =
000304b1          quadraticFilterData->hasSeenUnoccludedTouchesSinceTouchDown;
000304ba      quadraticFilterData->orientation = O_UNKNOWN;
000304c1      quadraticFilterData->confidence = 0f;
000304c8      quadraticFilterData->angleDeviationFromVertical = 0f;
000304cf      quadraticFilterData->angleDeviationFromHorizontal = 0f;
000304d6      quadraticFilterData->quadraticFilterOn = hasSeenUnoccludedTouchesSinceTouchDown;
000304ee      int64_t r12;
000304ee      (uint8_t)r12 = numSensors;
000304f1      memset(&quadraticFilterData->residualError, 0, 0xc0);
000304f1      
000304fa      if ((uint8_t)rdi != 3)
000304fc          quadraticFilterData->hasSwitchedDuringThisOcclusion = 0;
000304fc      
00030506      if (!(uint8_t)rdi)
00030508          quadraticFilterData->hasSeenAtLeastOccludedTouches = 0;
00030508      
00030513      if ((uint8_t)rdi > 2)
00030515          quadraticFilterData->hasSeenAtLeastOccludedTouches = 1;
00030515      
00030524      enum occlusionState_t occlusionState = twoSensorTriangulation->occlusionState;
00030524      
0003052b      if (occlusionState == OCCLUSION_ENTRY)
00030531          quadraticFilterData->entryOrientation = twoSensorTriangulation->orientation;
0003052b      else if (!occlusionState || occlusionState == OCCLUSION_EXIT)
00030543          quadraticFilterData->entryOrientation = O_UNKNOWN;
00030543      
00030564      int32_t rdx;
00030564      
00030564      if (quadraticFilterData->hasSwitchedDuringThisOcclusion == 1
00030564          && occludedSensor != quadraticFilterData->switchDecisionOccludedSensorNum)
00030564      {
00030566          (uint8_t)occlusionState = quadraticFilterData->occlusionSwitchResetDelay;
0003056c          (uint8_t)occlusionState += 1;
00030571          int32_t temp2_1;
00030571          int32_t temp3_1;
00030571          temp2_1 = HIGHD((int64_t)(uint32_t)(uint8_t)occlusionState);
00030571          temp3_1 = LOWD((int64_t)(uint32_t)(uint8_t)occlusionState);
00030572          rdx = temp2_1 & 0x7f;
0003057a          occlusionState = ((temp3_1 + rdx) & 0x7f) - rdx;
0003057c          quadraticFilterData->occlusionSwitchResetDelay = (uint8_t)occlusionState;
0003057c          
00030584          if ((uint8_t)occlusionState > 4)
00030584          {
00030586              quadraticFilterData->hasSwitchedDuringThisOcclusion = 0;
0003058d              quadraticFilterData->occlusionSwitchResetDelay = 0;
00030584          }
00030564      }
00030564      
00030598      uint8_t rax_8;
00030598      bool cond:1_1;
00030598      
00030598      if ((uint8_t)rdi < 3)
00030598      {
0003059a          (uint8_t)occlusionState = quadraticFilterData->lessThanTwoTouchDelay;
000305a0          (uint8_t)occlusionState += 1;
000305a5          int32_t temp0_1;
000305a5          char temp1_1;
000305a5          temp0_1 = HIGHD((int64_t)(uint32_t)(uint8_t)occlusionState);
000305a5          temp1_1 = LOWD((int64_t)(uint32_t)(uint8_t)occlusionState);
000305a6          rdx = temp0_1 & 0x7f;
000305ae          rax_8 = ((temp1_1 + (uint8_t)rdx) & 0x7f) - (uint8_t)rdx;
000305b0          cond:1_1 = !quadraticFilterData->hasSeenAtLeastOccludedTouches;
000305b7          quadraticFilterData->lessThanTwoTouchDelay = rax_8;
00030598      }
00030598      
000305c1      if ((uint8_t)rdi < 3 && (cond:1_1 || rax_8 > 4))
000305c1      {
000305ce          memset(quadraticFilterData, 0, 0x380);
000305d6          quadraticFilterData->quadraticFilterOn = 0;
000305dd          quadraticFilterData->hasSeenUnoccludedTouchesSinceTouchDown = 0;
000305e4          quadraticFilterData->lessThanTwoTouchDelay = 0;
000305e4          return;
000305c1      }
000305c1      
000305fa      if ((uint8_t)rdi == 4 && twoSensorTriangulation->triangulationType)
000305fa      {
000305fc          quadraticFilterData->quadraticFilterOn = 1;
00030603          quadraticFilterData->hasSeenUnoccludedTouchesSinceTouchDown = 1;
0003060a          quadraticFilterData->lessThanTwoTouchDelay = 0;
000305fa      }
000305fa      
0003061f      (uint8_t)rdx = (uint8_t)r12;
00030630      UpdateHistoryBuffers(quadraticFilterData, (uint8_t)rdx, occludedSensor, ssOutput, 
00030630          occludedCentreAngles, deltaTimeStamp);
00030638      zmm7 = 0x7fffffffffffffff;
0003064b      uint64_t zmm0[0x2];
0003064b      
0003064b      if (twoSensorTriangulation->triangulationType
0003064b          && twoSensorTriangulation->orientation == O_VERTICAL)
0003064b      {
0003064d          zmm0[0] = kite->kPt[0].pt.x;
0003064d          *(uint32_t*)((char*)zmm0[0])[4] = kite->kPt[0].pt.x;
0003064d          zmm0[1] = kite->kPt[0].sourceST[0];
0003064d          *(uint8_t*)((char*)zmm0[1])[1] = kite->kPt[0].sourceST[1];
0003064d          *(uint16_t*)((char*)zmm0[1])[2] = *(uint16_t*)((char*)kite->kPt[0] + 0xa);
0003064d          *(uint32_t*)((char*)zmm0[1])[4] = kite->kPt[0].pt.x;
00030659          zmm0[0] = zmm0[0] - panelSize.x;
00030668          zmm0 = _mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0]), zmm7);
0003066c          uint64_t zmm1[0x2];
0003066c          zmm1[0] = (float)zmm0[0];
0003066c          
00030673          if (!(30f <= zmm1[0]))
00030673          {
00030675              zmm0[0] = kite->kPt[2].pt.x;
00030675              *(uint32_t*)((char*)zmm0[0])[4] = kite->kPt[2].pt.x;
00030675              zmm0[1] = kite->kPt[2].sourceST[0];
00030675              *(uint8_t*)((char*)zmm0[1])[1] = kite->kPt[2].sourceST[1];
00030675              *(uint16_t*)((char*)zmm0[1])[2] = *(uint16_t*)((char*)kite->kPt[2] + 0xa);
00030675              *(uint32_t*)((char*)zmm0[1])[4] = kite->kPt[2].pt.x;
0003067a              zmm0[0] = zmm0[0] - panelSize.x;
0003067a              
00030694              if (!(30f <= (float)_mm_and_pd(
00030694                  _mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0]), zmm7)[0]))
00030694              {
00030696                  quadraticFilterData->quadraticFilterOn = 0;
0003069d                  quadraticFilterData->hasSeenUnoccludedTouchesSinceTouchDown = 0;
00030694              }
00030673          }
00030673          
000306ad          if (!(30f <= kite->kPt[0].pt.x) && !(30f <= kite->kPt[2].pt.x))
000306ad          {
000306af              quadraticFilterData->quadraticFilterOn = 0;
000306b6              quadraticFilterData->hasSeenUnoccludedTouchesSinceTouchDown = 0;
000306ad          }
0003064b      }
0003064b      
000306de      if (!((*(uint32_t*)diamondWidths)[0] <= 50f) && !(diamondWidths[1][0] <= 50f))
000306e0          quadraticFilterData->quadraticFilterOn = 0;
000306e0      
00030701      if ((uint32_t)ssOutput->sensor[1].edgeSet[0].touchCount
00030701              + (uint32_t)ssOutput->sensor[0].edgeSet[0].touchCount != 3 || occludedSensor >= 4)
00030701          return;
00030701      
00030707      zmm6 = {0};
0003070e      struct sub_sample_t* rbp;
0003070e      (uint8_t)rbp = 0;
00030711      uint64_t r15_2 = (uint64_t)occludedSensor << 2;
0003071d      int32_t* rsi_1 = (char*)quadraticFilterData + ((r15_2 * 3 + 0xe1) << 2);
00030728      void* r12_1 = &quadraticFilterData->dataHistory.elements[0][r15_2].numHistoryEntries;
00030886      void* rdx_3;
00030886      
00030886      do
00030886      {
0003072d          (uint8_t)rdi = *(uint8_t*)r12_1;
0003072d          
00030735          if ((uint8_t)rdi < 5)
00030735          {
00030870              rsi_1[1] = 0;
00030874              *(uint32_t*)rsi_1 = 0;
00030735          }
00030735          else
00030735          {
00030746              int32_t modPtHistory;
00030746              memset(&modPtHistory, 0, 0x28);
0003075d              memmove(&modPtHistory, (char*)r12_1 - 0x28, (uint64_t)(uint8_t)rdi << 3);
00030762              modPtHistory = zmm6[0];
00030762              
0003076c              if ((uint8_t)rdi > 1)
0003076c              {
0003076e                  (uint8_t)rdi -= 1;
00030771                  void var_70;
00030771                  int32_t* rax_15 = &var_70;
00030776                  uint64_t i_1 = (uint64_t)(uint8_t)rdi;
00030797                  uint64_t i;
00030797                  
00030797                  do
00030797                  {
0003077a                      zmm0 = *(uint32_t*)rax_15;
0003077e                      zmm0[0] = zmm0[0] * 9.99999997e-07f;
00030786                      zmm0[0] = zmm0[0] + rax_15[-2];
0003078b                      *(uint32_t*)rax_15 = zmm0[0];
0003078f                      rax_15 = &rax_15[2];
00030793                      i = i_1;
00030793                      i_1 -= 1;
00030797                  } while (i != 1);
0003076c              }
0003076c              
000307a0              if (quadraticFilterData->quadraticFilterOn != 1)
000307a0              {
00030870                  rsi_1[1] = 0;
00030874                  *(uint32_t*)rsi_1 = 0;
000307a0              }
000307a0              else
000307a0              {
000307b1                  struct residualElement_t* rdx_5;
000307b1                  
000307b1                  if (*(uint8_t*)((char*)rsi_1[-0x31])[8] < 1)
000307c4                      zmm0 = zmm6;
000307b1                  else
000307bd                      zmm0 = CalculateResidualErrorForPermutation((char*)r12_1 - 0x28, 
000307bd                          &rsi_1[-0x31], &modPtHistory);
000307bd                  
000307cd                  (uint8_t)rdx_5 = (uint8_t)rbp;
000307d3                  zmm0 = _mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0]), zmm7);
000307d7                  zmm0[0] = (float)zmm0[0];
000307db                  *(uint32_t*)rsi_1 = zmm0[0];
000307db                  
000307e2                  if (!occludedSensor)
000307e2                  {
000307e4                      uint32_t rcx_8 = (uint32_t)(uint8_t)rbp;
000307e4                      
000307eb                      if (!rcx_8)
00030823                          (uint8_t)rdx_5 = 3;
000307eb                      else if (rcx_8 == 1)
0003081f                          (uint8_t)rdx_5 = 2;
000307f0                      else if (rcx_8 == 2)
00030827                          (uint8_t)rdx_5 = 1;
000307f5                      else if (rcx_8 == 3)
000307fc                          (uint8_t)rdx_5 = 0;
000307e2                  }
000307e2                  else if (occludedSensor == 1)
00030805                  {
00030807                      uint32_t rcx_11 = (uint32_t)(uint8_t)rbp;
00030807                      
0003080e                      if (!rcx_11)
00030827                          (uint8_t)rdx_5 = 1;
0003080e                      else if (rcx_11 == 1)
000307fc                          (uint8_t)rdx_5 = 0;
00030813                      else if (rcx_11 == 2)
00030823                          (uint8_t)rdx_5 = 3;
00030818                      else if (rcx_11 == 3)
0003081f                          (uint8_t)rdx_5 = 2;
00030805                  }
00030805                  
0003082c                  uint64_t rax_17 = (uint64_t)(uint8_t)rdx_5 + r15_2;
0003082c                  
0003083f                  if (quadraticFilterData->dataHistory.residualElements[0][rax_17].
0003083f                          numResiduals < 1)
00030855                      zmm0 = zmm6;
0003083f                  else
0003084b                      zmm0 = CalculateResidualErrorForPermutation((char*)r12_1 - 0x28, 
0003084b                          &quadraticFilterData->dataHistory.residualElements[0][rax_17], 
0003084b                          &modPtHistory);
0003084b                  
0003085e                  zmm0 = _mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, zmm0[0])[0]), zmm7);
00030862                  zmm0[0] = (float)zmm0[0];
00030866                  rsi_1[1] = zmm0[0];
000307a0              }
00030735          }
00030735          
00030877          (uint8_t)rbp += 1;
0003087a          r12_1 += 0x2c;
0003087e          rsi_1 = &rsi_1[3];
00030886      } while ((uint8_t)rbp < 4);
00030886      
00030893      if (quadraticFilterData->quadraticFilterOn == 1)
00030893      {
00030895          (uint8_t)rdx_3 = predictionDecisionMade;
000308bf          quadraticFilterData->orientation = DetermineOrientationFromResidualErrors(
000308bf              quadraticFilterData, (uint8_t)rdx_3, occludedSensor, 
000308bf              twoSensorTriangulation->orientation, &quadraticFilterData->confidence);
00030893      }
00030468  }

000308f0                                                  cc cc cc cc cc cc cc cc                                          ........

000308f8    float CalculateResidualErrorForPermutation(struct historyElement_t* hElemPtr, struct residualElement_t* hResidElemPtr, struct fpoint_t* modPtHistory)

000308f8  {
00030908      uint64_t numResiduals = (uint64_t)hResidElemPtr->numResiduals;
0003091f      int64_t arg_8 = 0;
00030923      int64_t* rdx;
00030923      uint64_t r8_2;
00030923      rdx = memmove(&arg_8, hResidElemPtr, numResiduals << 3);
00030923      
0003092a      if ((uint8_t)numResiduals)
0003092a      {
00030930          rdx = &arg_8;
00030935          r8_2 = numResiduals;
0003093b          void* rcx_1 = &modPtHistory[(uint64_t)hElemPtr->numHistoryEntries - numResiduals];
0003094f          uint64_t i;
0003094f          
0003094f          do
0003094f          {
0003093f              int32_t rax_3 = *(uint32_t*)rcx_1;
00030941              rcx_1 += 8;
00030945              *(uint32_t*)rdx = rax_3;
00030947              rdx = &rdx[1];
0003094b              i = r8_2;
0003094b              r8_2 -= 1;
0003094f          } while (i != 1);
0003092a      }
0003092a      
00030951      (uint8_t)rdx = hElemPtr->numHistoryEntries;
00030959      (uint8_t)r8_2 = 3;
0003095c      (uint8_t)rdx -= 2;
00030962      float var_18[0x4];
00030962      CurveFit(modPtHistory, (uint8_t)rdx, (uint8_t)r8_2, &var_18);
00030971      arg_8 = (&__return_addr)[numResiduals];
0003097e      float zmm0_1 = CalcPolynomialY((uint32_t)arg_8, 3, &var_18);
0003099f      return *(uint32_t*)((char*)arg_8)[4] - zmm0_1;
000308f8  }

000309a0  cc cc cc cc cc cc cc cc                                                                          ........

000309a8    void UpdateHistoryBuffers(struct quadratic_filter_t* quadraticFilterData, uint8_t numSensors, uint8_t occludedSensor, struct sub_sample_t* ssOutput, float* occludedCentreAngles, uint16_t deltaTimestamp)

000309a8  {
000309ab      if (numSensors > 2)
000309ab          return;
000309ab      
000309b4      int64_t rbx;
000309b4      int64_t arg_8 = rbx;
000309ce      int128_t zmm6;
000309ce      int128_t var_48_1 = zmm6;
000309d9      struct sub_sample_t* ssOutput_1 = ssOutput;
000309dc      uint8_t rax_1 = ssOutput->sensor[1].edgeSet[0].touchCount
000309dc          + ssOutput->sensor[0].edgeSet[0].touchCount;
000309e0      int64_t r14;
000309e0      (uint8_t)r14 = occludedSensor;
000309e3      int64_t r12;
000309e3      (uint8_t)r12 = numSensors;
000309e3      
00030a05      if (rax_1 < 3 || (rax_1 == 3 && (uint8_t)r14 == 4))
00030a05      {
000309f5          memset(quadraticFilterData, 0, 0x380);
000309f5          return;
00030a05      }
00030a05      
00030a07      int64_t rdi;
00030a07      (uint8_t)rdi = 0;
00030a07      
00030a0d      if (!(uint8_t)r12)
00030a0d          return;
00030a0d      
00030a13      occludedSensor = 1;
00030b16      uint16_t r12_1;
00030b16      
00030b16      do
00030b16      {
00030a16          float* occludedCentreAngles_1 = occludedCentreAngles;
00030a27          uint64_t rax_2 = (uint64_t)(uint8_t)rdi;
00030a35          (uint8_t)rbx = 0;
00030a37          float* occludedCentreAngles_2 = occludedCentreAngles_1;
00030a47          void* rsi_3 = rax_2 * 0x70 + ssOutput_1;
00030a4a          void* ptBuffer_1 = rax_2 * 0xb0 + quadraticFilterData;
00030a50          void* ptBuffer = &quadraticFilterData->dataHistory.residualElements[rax_2];
00030a50          
00030afa          do
00030afa          {
00030a58              zmm6 = {0};
00030a58              
00030a5e              if ((uint8_t)r14 == (uint8_t)rdi)
00030a5e              {
00030a60                  (uint32_t)zmm6 = *(uint32_t*)occludedCentreAngles_1;
00030a60                  *(uint32_t*)((char*)zmm6)[4] = *(uint32_t*)occludedCentreAngles_1;
00030a60                  *(uint32_t*)((char*)zmm6)[8] = *(uint32_t*)occludedCentreAngles_1;
00030a60                  *(uint32_t*)((char*)zmm6)[0xc] = *(uint32_t*)occludedCentreAngles_1;
00030a5e              }
00030a5e              else
00030a5e              {
00030a69                  bool cond:1_1;
00030a69                  
00030a69                  if ((uint8_t)rdi)
00030a69                  {
00030a8d                      if ((uint8_t)rdi == occludedSensor)
00030a8d                      {
00030a97                          if ((uint8_t)rbx != 2 && (uint8_t)rbx != occludedSensor)
00030a97                          {
00030a99                              cond:1_1 = !(uint8_t)rbx;
00030a9b                              goto label_30a77;
00030a97                          }
00030a97                          
00030aa2                          (uint32_t)zmm6 =
00030aa2                              (*(uint32_t*)((char*)rsi_3 + 4)) + *(uint32_t*)rsi_3;
00030aa6                          (uint32_t)zmm6 = (uint32_t)zmm6 * 0.5f;
00030a8d                      }
00030a69                  }
00030a69                  else if (!(uint8_t)rbx || (uint8_t)rbx == occludedSensor)
00030a72                  {
00030aa2                      (uint32_t)zmm6 = (*(uint32_t*)((char*)rsi_3 + 4)) + *(uint32_t*)rsi_3;
00030aa6                      (uint32_t)zmm6 = (uint32_t)zmm6 * 0.5f;
00030a72                  }
00030a72                  else
00030a72                  {
00030a74                      cond:1_1 = (uint8_t)rbx == 2;
00030a77                  label_30a77:
00030a77                      
00030a7c                      if (cond:1_1 || (uint8_t)rbx == 3)
00030a7c                      {
00030a83                          (uint32_t)zmm6 = (*(uint32_t*)((char*)rsi_3 + 0xc))
00030a83                              + *(uint32_t*)((char*)rsi_3 + 8);
00030aa6                          (uint32_t)zmm6 = (uint32_t)zmm6 * 0.5f;
00030a7c                      }
00030a72                  }
00030a5e              }
00030a5e              
00030abe              AddNewDataToBuffer(ptBuffer, (char*)ptBuffer + 8, occludedSensor, 
00030abe                  (uint32_t)zmm6, deltaTimestamp);
00030ad6              AddNewDataToBuffer(ptBuffer_1, (char*)ptBuffer_1 + 0x28, 5, (uint32_t)zmm6, 
00030ad6                  deltaTimestamp);
00030ae0              occludedSensor = 1;
00030ae3              occludedCentreAngles_1 = &occludedCentreAngles_2[1];
00030ae7              (uint8_t)rbx += 1;
00030aea              ptBuffer_1 += 0x2c;
00030aee              ptBuffer += 0xc;
00030af2              occludedCentreAngles_2 = occludedCentreAngles_1;
00030afa          } while ((uint8_t)rbx < 4);
00030afa          
00030b00          (uint8_t)r12_1 = numSensors;
00030b08          ssOutput_1 = ssOutput;
00030b10          (uint8_t)rdi += 1;
00030b16      } while ((uint8_t)rdi < (uint8_t)r12_1);
000309a8  }

00030b39                                                                             cc cc cc cc cc cc cc                           .......

00030b40    void SwapBufferContents(struct fpoint_t* ptBufferA, uint8_t* numPtsA, struct fpoint_t* ptBufferB, uint8_t* numPtsB)

00030b40  {
00030b5c      uint64_t rsi = (uint64_t)*(uint8_t*)numPtsA;
00030b77      char* numPtsB_1 = numPtsB;
00030b7a      char var_a8[0xa0];
00030b7a      memmove(&var_a8, ptBufferA, rsi << 3);
00030b8e      memmove(ptBufferA, ptBufferB, (uint64_t)*(uint8_t*)numPtsB_1 << 3);
00030ba6      *(uint8_t*)numPtsA = *(uint8_t*)numPtsB_1;
00030ba9      memmove(ptBufferB, &var_a8, rsi << 3);
00030bc2      *(uint8_t*)numPtsB_1 = (uint8_t)rsi;
00030b40  }

00030bd0                                                  cc cc cc cc cc cc cc cc                                          ........

00030bd8    void AddNewDataToBuffer(struct fpoint_t* ptBuffer, uint8_t* numPts, uint8_t maxBufferSize, float centreAngle, uint16_t timestamp)

00030bd8  {
00030be7      float centreAngle_1 = centreAngle;
00030bf7      uint32_t rax;
00030bf7      (uint8_t)rax = *(uint8_t*)numPts;
00030bfc      int32_t arg_10 = _mm_cvtepi32_ps((uint128_t)timestamp);
00030bfc      
00030c05      if ((uint8_t)rax != maxBufferSize)
00030c05      {
00030c32          ptBuffer[(uint64_t)(uint8_t)rax].x = arg_10;
00030c36          *(uint8_t*)numPts += 1;
00030c05      }
00030c05      else
00030c05      {
00030c07          (uint8_t)rax -= 1;
00030c15          memmove(ptBuffer, &ptBuffer[1], (uint64_t)(uint8_t)rax << 3);
00030c23          ptBuffer[(uint64_t)*(uint8_t*)numPts - 1].x = arg_10;
00030c05      }
00030bd8  }

00030c43           cc cc cc cc cc cc cc cc cc                                                                 .........

00030c4c    void ProcessDoubleOcclusionFilter(struct double_occlusion_filter_t* doubleOcclusionFilterData, struct kite_t* kite, uint8_t* hasEdgesBetween, struct twoSensorTriangulationMngr_t* twoSensorTriangulation, struct sub_sample_t* ssOut, struct triangulate_statics_t* triangulateStatics, struct generalTouchData_t* generalTouchData, uint8_t isNearfield, uint8_t isLargeFormatScreen)

00030c4c  {
00030c77      doubleOcclusionFilterData->confidence = 0f;
00030c7b      doubleOcclusionFilterData->orientation = 0;
00030c8b      int128_t zmm7;
00030c8b      (uint32_t)zmm7 = generalTouchData->tonyTangents[0].width[0];
00030c8b      *(uint32_t*)((char*)zmm7)[4] = generalTouchData->tonyTangents[0].width[0];
00030c8b      *(uint32_t*)((char*)zmm7)[8] = generalTouchData->tonyTangents[0].width[0];
00030c8b      *(uint32_t*)((char*)zmm7)[0xc] = generalTouchData->tonyTangents[0].width[0];
00030c93      int128_t zmm6;
00030c93      (uint32_t)zmm6 = generalTouchData->tonyTangents[0].width[1];
00030c93      *(uint32_t*)((char*)zmm6)[4] = generalTouchData->tonyTangents[0].width[1];
00030c93      *(uint32_t*)((char*)zmm6)[8] = generalTouchData->tonyTangents[0].width[1];
00030c93      *(uint32_t*)((char*)zmm6)[0xc] = generalTouchData->tonyTangents[0].width[1];
00030c9e      int64_t r14;
00030c9e      (uint8_t)r14 = 0;
00030c9e      
00030ca9      if (!twoSensorTriangulation->prevNumTouchesFromEdges)
00030ca9      {
00030caf          doubleOcclusionFilterData->bothStraightLineTouches = 0;
00030cc1          memset(&doubleOcclusionFilterData->pointsHistory, 0, 0x140);
00030cd3          doubleOcclusionFilterData->numHistoryPts[0] = 0;
00030cda          doubleOcclusionFilterData->numHistoryPts[1] = 0;
00030ce1          memset(&doubleOcclusionFilterData->lineFit, 0, 0x18);
00030cf2          doubleOcclusionFilterData->doubleOcclusionState = DOUBLE_OCCLUSION_INIT;
00030cf6          doubleOcclusionFilterData->doubleOcclusionReason = DOCC_NONE;
00030cfa          memset(&doubleOcclusionFilterData->prevTchSizes, 0, 0x10);
00030d0b          memset(&doubleOcclusionFilterData->stableTchSizes, 0, 0x10);
00030d1c          memset(&doubleOcclusionFilterData->lastKnownTchWidths, 0, 0x10);
00030d23          doubleOcclusionFilterData->lastKnownSingleTouchPt.x = 0;
00030d29          doubleOcclusionFilterData->lastKnownSingleTouchPt.y = 0f;
00030ca9      }
00030ca9      
00030d2f      uint8_t rax = twoSensorTriangulation->numTouchesFromEdges;
00030d2f      
00030d35      if (!rax)
00030d35      {
00030d37          doubleOcclusionFilterData->doubleOcclusionState = DOUBLE_OCCLUSION_INIT;
00030d3b          doubleOcclusionFilterData->doubleOcclusionReason = DOCC_NONE;
00030d35      }
00030d35      else
00030d35      {
00030d46          float zmm1;
00030d46          float zmm2;
00030d46          
00030d46          if (rax != 2)
00030d46          {
00030e39              if ((*(uint8_t*)hasEdgesBetween || hasEdgesBetween[1])
00030e39                  && !((uint32_t)zmm7 <= 14f) && !((uint32_t)zmm6 <= 14f))
00030e39              {
00030e3b                  rax = twoSensorTriangulation->prevNumTouchesFromEdges;
00030e3b                  
00030e51                  if ((!rax || rax == 2) && (
00030e51                      doubleOcclusionFilterData->doubleOcclusionState == NO_DOUBLE_OCCLUSION
00030e51                      || doubleOcclusionFilterData->doubleOcclusionState
00030e51                      == NO_DOUBLE_OCCLUSION_UNSTABLE_WIDTHS))
00030e51                  {
00030e5b                      if (!rax && !isLargeFormatScreen)
00030e5b                      {
00030e5d                          doubleOcclusionFilterData->doubleOcclusionReason =
00030e5d                              DOCC_EDGES_BETWEEN_0TO1;
00030e70                      label_30e70:
00030e70                          doubleOcclusionFilterData->doubleOcclusionState =
00030e70                              IN_DOUBLE_OCCLUSION;
00030e73                          uint8_t rax_1;
00030e73                          rax_1 = AreDoubleOccPointsMovingInStraightLine(
00030e73                              doubleOcclusionFilterData);
00030e7d                          (uint8_t)r14 = 1;
00030e80                          doubleOcclusionFilterData->bothStraightLineTouches = rax_1;
00030e5b                      }
00030e5b                      else if (rax == 2)
00030e68                      {
00030e6a                          doubleOcclusionFilterData->doubleOcclusionReason =
00030e6a                              DOCC_EDGES_BETWEEN_2TO1;
00030e6a                          goto label_30e70;
00030e68                      }
00030e51                  }
00030e39              }
00030e39              
00030e86              enum double_occlusion_state_t doubleOcclusionState =
00030e86                  doubleOcclusionFilterData->doubleOcclusionState;
00030e86              
00030e8c              if (!doubleOcclusionState)
00030e8c              {
000311fe                  if (AreWidthsStable(doubleOcclusionFilterData, (uint32_t)zmm7, 
000311fe                      (uint32_t)zmm6) == 1)
000311fe                  {
00031200                      doubleOcclusionFilterData->stableTchSizes[0] = (uint32_t)zmm7;
00031208                      doubleOcclusionFilterData->stableTchSizes[1] = (uint32_t)zmm6;
00031210                      doubleOcclusionFilterData->doubleOcclusionState = NO_DOUBLE_OCCLUSION;
00031221                      SaveTonyTangentInformation(doubleOcclusionFilterData, 
00031221                          twoSensorTriangulation->numTouchesFromEdges, 
00031221                          &generalTouchData->tonyTangents);
000311fe                  }
00030e8c              }
00030e8c              else
00030e8c              {
00030e95                  if (doubleOcclusionState == NO_DOUBLE_OCCLUSION_UNSTABLE_WIDTHS)
00030e95                  {
000311ab                      if (AreWidthsStable(doubleOcclusionFilterData, (uint32_t)zmm7, 
000311ab                              (uint32_t)zmm6) == 1)
000311ad                          doubleOcclusionFilterData->doubleOcclusionState =
000311ad                              NO_DOUBLE_OCCLUSION;
000311ad                      
000311ab                      goto label_311b4;
00030e95                  }
00030e95                  
00030e9e                  if (doubleOcclusionState == 2)
00030e9e                  {
00030f98                      struct double_occlusion_filter_t* doubleOcclusionFilterData_1;
00030f98                      
00030f98                      if ((*(uint8_t*)hasEdgesBetween || hasEdgesBetween[1])
00030f98                          && !((uint32_t)zmm7 <= 14f) && !((uint32_t)zmm6 <= 14f)
00030f98                          && !isLargeFormatScreen)
00030f98                      {
00030f9e                          if (twoSensorTriangulation->prevNumTouchesFromEdges != 1)
00030f9e                              goto label_31183;
00030f9e                          
00030fa4                          doubleOcclusionFilterData->doubleOcclusionState =
00030fa4                              IN_DOUBLE_OCCLUSION;
00030fa7                          doubleOcclusionFilterData->doubleOcclusionReason =
00030fa7                              DOCC_EDGES_BETWEEN_1TO1;
00030fae                          doubleOcclusionFilterData_1 = doubleOcclusionFilterData;
0003115c                      label_3115c:
0003115c                          uint8_t rax_7;
0003115c                          rax_7 = AreDoubleOccPointsMovingInStraightLine(
0003115c                              doubleOcclusionFilterData_1);
00031161                          doubleOcclusionFilterData->bothStraightLineTouches = rax_7;
00031183                      label_31183:
00031183                          doubleOcclusionFilterData->stableTchSizes[0] = (uint32_t)zmm7;
0003118b                          doubleOcclusionFilterData->stableTchSizes[1] = (uint32_t)zmm6;
00031193                          (uint8_t)r14 = 1;
00030f98                      }
00030f98                      else
00030f98                      {
00030fba                          if (twoSensorTriangulation->prevNumTouchesFromEdges == 2)
00030fba                          {
00030fc4                              zmm2 = doubleOcclusionFilterData->stableTchSizes[1];
00030fcc                              float zmm3 = doubleOcclusionFilterData->stableTchSizes[0];
00030fd7                              int64_t rax_4;
00030fd7                              (uint8_t)rax_4 =
00030fd7                                  twoSensorTriangulation->orientation != O_HORIZONTAL;
00030fd7                              
00031001                              if (!(10f <=
00031001                                  doubleOcclusionFilterData->distanceBetweenTouches[rax_4]
00031001                                  - (zmm2 + zmm3) * 0.5f))
00031001                              {
00031015                                  if ((uint32_t)zmm7 <= zmm3 * 1.29999995f)
00031015                                  {
0003103b                                      if ((uint32_t)zmm7 > zmm3 * 1.60000002f
0003103b                                              || !((uint32_t)zmm6 <= zmm2 * 1.60000002f))
00031032                                          goto label_31040;
00031015                                  }
00031015                                  else if ((uint32_t)zmm6 > zmm2 * 1.29999995f
00031015                                      || (uint32_t)zmm7 > zmm3 * 1.60000002f
00031015                                      || !((uint32_t)zmm6 <= zmm2 * 1.60000002f))
0003103b                                  {
00031040                                  label_31040:
00031040                                      doubleOcclusionFilterData->doubleOcclusionState =
00031040                                          IN_DOUBLE_OCCLUSION;
00031043                                      doubleOcclusionFilterData->doubleOcclusionReason =
00031043                                          DOCC_2_TO_1;
0003104a                                      uint8_t rax_5;
0003104a                                      rax_5 = AreDoubleOccPointsMovingInStraightLine(
0003104a                                          doubleOcclusionFilterData);
0003104f                                      doubleOcclusionFilterData->bothStraightLineTouches =
0003104f                                          rax_5;
0003103b                                  }
00031001                              }
00031001                              
00031059                              if (doubleOcclusionFilterData->doubleOcclusionState
00031059                                      == NO_DOUBLE_OCCLUSION)
0003106c                                  SaveTonyTangentInformation(doubleOcclusionFilterData, 
0003106c                                      twoSensorTriangulation->numTouchesFromEdges, 
0003106c                                      &generalTouchData->tonyTangents);
0003106c                              
00031059                              goto label_31183;
00030fba                          }
00030fba                          
0003107c                          doubleOcclusionFilterData_1 = doubleOcclusionFilterData;
0003107c                          
00031087                          if (AreWidthsStable(doubleOcclusionFilterData_1, (uint32_t)zmm7, 
00031087                              (uint32_t)zmm6))
00031087                          {
000310b0                              if (twoSensorTriangulation->prevNumTouchesFromEdges != 1
000310b0                                      || isNearfield || isLargeFormatScreen)
00031099                                  goto label_31183;
00031099                              
000310ca                              if (!((uint32_t)zmm7 <= 8f) && !((uint32_t)zmm6 <= 8f))
000310ca                              {
000310d0                                  zmm2 = doubleOcclusionFilterData->stableTchSizes[0];
000310d0                                  
000310e3                                  if (!(zmm2 <= 1.00000001e-07f))
000310e3                                  {
000310e9                                      zmm1 = doubleOcclusionFilterData->stableTchSizes[1];
000310e9                                      
000310f4                                      if (!(zmm1 <= 1.00000001e-07f))
000310f4                                      {
00031108                                          if ((uint32_t)zmm7 <= zmm2 * 1.29999995f)
00031108                                          {
0003112e                                              if ((uint32_t)zmm7 > zmm2 * 1.60000002f ||
0003112e                                                      !((uint32_t)zmm6 <= zmm1 * 1.60000002f))
00031125                                                  goto label_3113a;
00031108                                          }
00031108                                          else if ((uint32_t)zmm6 > zmm1 * 1.29999995f
00031108                                              || (uint32_t)zmm7 > zmm2 * 1.60000002f
00031108                                              || !((uint32_t)zmm6 <= zmm1 * 1.60000002f))
0003112e                                          {
0003113a                                          label_3113a:
0003113f                                              doubleOcclusionFilterData_1 =
0003113f                                                  doubleOcclusionFilterData;
0003113f                                              
0003114c                                              if (!((uint32_t)zmm6 * (uint32_t)zmm7 <=
0003114c                                                  DistanceSquare(kite, 
0003114c                                                  &doubleOcclusionFilterData->
0003114c                                                      lastKnownSingleTouchPt)))
0003114c                                              {
0003114e                                                  doubleOcclusionFilterData->
0003114e                                                      doubleOcclusionState =
0003114e                                                      IN_DOUBLE_OCCLUSION;
00031155                                                  doubleOcclusionFilterData->
00031155                                                      doubleOcclusionReason = DOCC_1_TO_1;
00031155                                                  goto label_3115c;
0003114c                                              }
0003112e                                          }
000310f4                                      }
000310e3                                  }
000310ca                              }
000310ca                              
00031173                              SaveTonyTangentInformation(doubleOcclusionFilterData_1, 
00031173                                  twoSensorTriangulation->numTouchesFromEdges, 
00031173                                  &generalTouchData->tonyTangents);
00031178                              struct fpoint_t r11;
00031178                              r11.x = kite->kPt[0].pt.x;
00031178                              r11.y = kite->kPt[0].pt.y;
0003117c                              doubleOcclusionFilterData->lastKnownSingleTouchPt.x = r11.x;
0003117c                              doubleOcclusionFilterData->lastKnownSingleTouchPt.y = r11.y;
0003117c                              goto label_31183;
00031087                          }
00031087                          
00031089                          doubleOcclusionFilterData->doubleOcclusionState =
00031089                              NO_DOUBLE_OCCLUSION_UNSTABLE_WIDTHS;
000311b4                      label_311b4:
000311b4                          
000311c4                          if (!generalTouchData->touchDownCircle[0].TouchLeftTouchDownCircle
000311c4                              && generalTouchData->touchDownCircle[0].TouchAge > 0 && !(
000311c4                              (uint32_t)zmm6 * (uint32_t)zmm7
000311c4                              <= DistanceSquare(kite, &generalTouchData->touchDownCircle)))
000311c4                          {
000311e1                              int64_t rax_9;
000311e1                              (uint32_t)rax_9 =
000311e1                                  generalTouchData->touchDownCircle[0].TouchDownLocation.x;
000311e1                              *(uint32_t*)((char*)rax_9)[4] =
000311e1                                  generalTouchData->touchDownCircle[0].TouchDownLocation.y;
000311e8                              kite->kPt[0].pt.x = (uint32_t)rax_9;
000311e8                              kite->kPt[0].pt.y = *(uint32_t*)((char*)rax_9)[4];
000311c4                          }
00030f98                      }
00030e9e                  }
00030e9e                  else if (doubleOcclusionState == 3)
00030ea7                  {
00030ee1                      if (AreWidthsStable(doubleOcclusionFilterData, (uint32_t)zmm7, 
00030ee1                          (uint32_t)zmm6))
00030ee1                      {
00030f1d                          if (!twoSensorTriangulation->prevNumTouchesFromEdges
00030f1d                              || doubleOcclusionFilterData->stableTchSizes[0]
00030f1d                              * 0.800000012f > (uint32_t)zmm7 || !(
00030f1d                              doubleOcclusionFilterData->stableTchSizes[1] * 0.800000012f
00030f1d                              <= (uint32_t)zmm6))
00030f1d                          {
00030f2b                              doubleOcclusionFilterData->doubleOcclusionState =
00030f2b                                  NO_DOUBLE_OCCLUSION;
00030f32                              doubleOcclusionFilterData->doubleOcclusionReason = DOCC_NONE;
00030f36                              doubleOcclusionFilterData->bothStraightLineTouches = 0;
00030f3d                              memset(&doubleOcclusionFilterData->pointsHistory, 0, 0x140);
00030f4f                              doubleOcclusionFilterData->numHistoryPts[0] = 0;
00030f56                              doubleOcclusionFilterData->numHistoryPts[1] = 0;
00030f5d                              memset(&doubleOcclusionFilterData->lineFit, 0, 0x18);
00030f1d                          }
00030f1d                          
00030f62                          doubleOcclusionFilterData->stableTchSizes[0] = (uint32_t)zmm7;
00030f6a                          doubleOcclusionFilterData->stableTchSizes[1] = (uint32_t)zmm6;
00030ee1                      }
00030ee1                      else
00030ee3                          doubleOcclusionFilterData->doubleOcclusionState =
00030ee3                              IN_DOUBLE_OCCLUSION_UNSTABLE_WIDTHS;
00030ea7                  }
00030ea7                  else if (doubleOcclusionState == 4 && AreWidthsStable(
00030ea7                          doubleOcclusionFilterData, (uint32_t)zmm7, (uint32_t)zmm6) == 1)
00030ec8                      doubleOcclusionFilterData->doubleOcclusionState = IN_DOUBLE_OCCLUSION;
00030e8c              }
00030e8c              
00031226              bool cond:0_1 =
00031226                  doubleOcclusionFilterData->doubleOcclusionState == IN_DOUBLE_OCCLUSION;
0003122a              doubleOcclusionFilterData->prevTchSizes[0] = (uint32_t)zmm7;
00031232              doubleOcclusionFilterData->prevTchSizes[1] = (uint32_t)zmm6;
00031232              
00031240              if (cond:0_1 || doubleOcclusionFilterData->doubleOcclusionState
00031240                  == IN_DOUBLE_OCCLUSION_UNSTABLE_WIDTHS)
00031240              {
00031246                  enum orientation_t orientation = twoSensorTriangulation->orientation;
00031246                  
0003124c                  if ((uint8_t)r14)
00031268                      orientation = CalculateSplitTouchPositions(doubleOcclusionFilterData, 
00031268                          orientation, ssOut, triangulateStatics);
0003124c                  else if (doubleOcclusionFilterData->doubleOcclusionState
0003124c                      != IN_DOUBLE_OCCLUSION_UNSTABLE_WIDTHS
0003124c                      || generalTouchData->touchDownCircle[0].TouchLeftTouchDownCircle
0003124c                      == 1)
00031279                  {
00031288                      float* rax_12 = &doubleOcclusionFilterData->adjustedPts[0].y;
0003128f                      int64_t i_1 = 2;
000312c4                      int64_t i;
000312c4                      
000312c4                      do
000312c4                      {
000312b3                          ADJ(rax_12)->adjustedPts[0].x = kite->kPt[0].pt.x
000312b3                              - doubleOcclusionFilterData->lastCentroid.x
000312b3                              + ADJ(rax_12)->adjustedPts[0].x;
000312b8                          ADJ(rax_12)->adjustedPts[0].y = kite->kPt[0].pt.y
000312b8                              - doubleOcclusionFilterData->lastCentroid.y
000312b8                              + ADJ(rax_12)->adjustedPts[0].y;
000312bc                          rax_12 = &rax_12[2];
000312c0                          i = i_1;
000312c0                          i_1 -= 1;
000312c4                      } while (i != 1);
00031279                  }
00031279                  
000312d0                  if (doubleOcclusionFilterData->doubleOcclusionReason
000312d0                          == DOCC_EDGES_BETWEEN_2TO1
000312d0                          || doubleOcclusionFilterData->doubleOcclusionReason
000312d0                          == DOCC_2_TO_1)
000312d2                      orientation = twoSensorTriangulation->orientation;
000312d2                  
000312d5                  struct fpoint_t rax_13;
000312d5                  rax_13.x = kite->kPt[0].pt.x;
000312d5                  rax_13.y = kite->kPt[0].pt.y;
000312d9                  doubleOcclusionFilterData->lastCentroid.x = rax_13.x;
000312d9                  doubleOcclusionFilterData->lastCentroid.y = rax_13.y;
000312d9                  
000312e3                  if (orientation != O_HORIZONTAL)
000312e3                  {
000312f0                      doubleOcclusionFilterData->confidence = 0.800000012f;
000312f7                      doubleOcclusionFilterData->orientation = 2;
000312e3                  }
000312e3                  else
000312e3                  {
000312e5                      doubleOcclusionFilterData->confidence = -0.800000012f;
000312ec                      doubleOcclusionFilterData->orientation = orientation;
000312e3                  }
00031240              }
00030d46          }
00030d46          else
00030d46          {
00030d58              doubleOcclusionFilterData->doubleOcclusionState = NO_DOUBLE_OCCLUSION;
00030d5f              doubleOcclusionFilterData->doubleOcclusionReason = DOCC_NONE;
00030d63              memset(&doubleOcclusionFilterData->prevTchSizes, 0, 0x10);
00030d74              memset(&doubleOcclusionFilterData->stableTchSizes, 0, 0x10);
00030d86              SaveTonyTangentInformation(doubleOcclusionFilterData, 
00030d86                  twoSensorTriangulation->numTouchesFromEdges, 
00030d86                  &generalTouchData->tonyTangents);
00030d8f              float zmm0_1;
00030d8f              
00030d8f              if (twoSensorTriangulation->orientation != O_VERTICAL)
00030d8f              {
00030dbb                  zmm1 = generalTouchData->tonyTangents[3].width[0];
00030dc3                  zmm0_1 = generalTouchData->tonyTangents[1].width[0];
00030dc3                  
00030dce                  if (!(zmm1 > zmm0_1))
00030dd0                      zmm1 = zmm0_1;
00030dd0                  
00030dd3                  zmm0_1 = generalTouchData->tonyTangents[3].width[1];
00030ddb                  zmm2 = generalTouchData->tonyTangents[1].width[1];
00030d8f              }
00030d8f              else
00030d8f              {
00030d91                  zmm1 = generalTouchData->tonyTangents[0].width[0];
00030d99                  zmm0_1 = generalTouchData->tonyTangents[2].width[0];
00030d99                  
00030da4                  if (!(zmm1 > zmm0_1))
00030da6                      zmm1 = zmm0_1;
00030da6                  
00030da9                  zmm0_1 = generalTouchData->tonyTangents[0].width[1];
00030db1                  zmm2 = generalTouchData->tonyTangents[2].width[1];
00030d8f              }
00030d8f              
00030de6              if (!(zmm0_1 > zmm2))
00030de8                  zmm0_1 = zmm2;
00030de8              
00030deb              doubleOcclusionFilterData->stableTchSizes[0] = zmm1;
00030df3              doubleOcclusionFilterData->stableTchSizes[1] = zmm0_1;
00030dfb              doubleOcclusionFilterData->prevTchSizes[0] = zmm1;
00030e03              doubleOcclusionFilterData->prevTchSizes[1] = zmm0_1;
00030d46          }
00030d35      }
00030c4c  }

00031325                 cc cc cc cc cc cc cc                                                                   .......

0003132c    uint8_t AreWidthsStable(struct double_occlusion_filter_t* doubleOcclusionFilterData, float cam0Width, float cam1Width)

0003132c  {
0003132c      cam0Width = cam0Width - doubleOcclusionFilterData->prevTchSizes[0];
00031334      uint128_t zmm3 = 0x7fffffffffffffff;
00031355      int64_t rax;
00031355      
00031355      if (!(1f <=
00031355          (float)_mm_and_pd(_mm_cvtps_pd(_mm_unpacklo_ps(cam0Width, cam0Width)), zmm3)[0]))
00031355      {
00031357          cam1Width = cam1Width - doubleOcclusionFilterData->prevTchSizes[1];
00031357          
00031370          if (!(1f <= (float)_mm_and_pd(
00031370              _mm_cvtps_pd(_mm_unpacklo_ps(cam1Width, cam1Width)), zmm3)[0]))
00031370          {
00031372              (uint8_t)rax = 1;
00031374              return 1;
00031370          }
00031355      }
00031355      
00031375      (uint8_t)rax = 0;
00031377      return 0;
0003132c  }

00031378                                                                          cc cc cc cc cc cc cc cc                          ........

00031380    void SwapDoubleOcclusionHistoryBuffers(struct double_occlusion_filter_t* doubleOcclusionFilterData, uint8_t occludedSensor)

00031380  {
00031383      if (occludedSensor != 1)
00031383          return;
00031383      
000313d4      doubleOcclusionFilterData->lineFit[0].m = doubleOcclusionFilterData->lineFit[1].m;
000313e0      doubleOcclusionFilterData->lineFit[0].c = doubleOcclusionFilterData->lineFit[1].c;
000313ec      doubleOcclusionFilterData->lineFit[0].weight =
000313ec          doubleOcclusionFilterData->lineFit[1].weight;
000313f4      doubleOcclusionFilterData->lineFit[1].m = doubleOcclusionFilterData->lineFit[0].m;
000313fd      doubleOcclusionFilterData->lineFit[1].c = doubleOcclusionFilterData->lineFit[0].c;
0003140b      doubleOcclusionFilterData->lineFit[1].weight =
0003140b          doubleOcclusionFilterData->lineFit[0].weight;
00031411      char var_a8[0xa0];
00031411      memmove(&var_a8, &doubleOcclusionFilterData->pointsHistory, 0xa0);
00031424      memmove(&doubleOcclusionFilterData->pointsHistory, 
00031424          &doubleOcclusionFilterData->pointsHistory[1], 0xa0);
00031438      memmove(&doubleOcclusionFilterData->pointsHistory[1], &var_a8, 0xa0);
00031380  }

00031452                                                        cc cc cc cc cc cc                                            ......

00031458    uint8_t AreDoubleOccPointsMovingInStraightLine(struct double_occlusion_filter_t* doubleOcclusionFilterData)

00031458  {
00031471      int64_t rdi;
00031471      (uint8_t)rdi = 1;
00031474      uint8_t (* rsi)[0x2] = &doubleOcclusionFilterData->numHistoryPts;
0003147b      struct line_def_t (* lineDef)[0x2] = &doubleOcclusionFilterData->lineFit;
00031482      struct fpoint_t (* rbx)[0x2][0x14] = &doubleOcclusionFilterData->pointsHistory;
00031486      int64_t i_1 = 2;
000314cf      int64_t i;
000314cf      
000314cf      do
000314cf      {
00031497          struct line_fit_t lineFitData;
00031497          GenerateLineFitData(&lineFitData, rbx, *((char*)ADJ(rsi) + 0x150));
00031497          
0003149f          if ((uint8_t)rdi)
000314ba              (uint8_t)rdi = CalculateBestFitLineEquation(lineDef, &lineFitData, rbx, 
000314ba                  *((char*)ADJ(rsi) + 0x150), nullptr);
000314ba          
000314bd          rsi = &(*(uint16_t*)rsi)[1];
000314c0          rbx = &(*(uint2560_t*)rbx)[1];
000314c7          lineDef = &(*(uint192_t*)lineDef)[1];
000314cb          i = i_1;
000314cb          i_1 -= 1;
000314cf      } while (i != 1);
000314ee      return (uint8_t)rdi;
00031458  }

000314ef                                               cc cc cc cc cc cc cc cc cc                                         .........

000314f8    void SaveTonyTangentInformation(struct double_occlusion_filter_t* doubleOcclusionFilterData, uint8_t numTouches, struct tonyTangents_t* tonyTangentData)

000314f8  {
0003150a      int64_t rbx;
0003150a      (uint8_t)rbx = numTouches;
0003150a      
00031511      if (!numTouches)
0003151f          onVerify__(
0003151f              "c:\development_work\csf_release_hp\driver\foureyes\filter_doubleocclusion.c", 
0003151f              0x2f5);
0003151f      
00031561      for (char i = 0; i < 4; )
00031561      {
00031527          char i_2 = 0;
00031527          
00031530          if ((uint8_t)rbx > 1)
00031530              i_2 = i;
00031530          
0003153a          int32_t zmm0 = tonyTangentData[(uint64_t)i_2].width[0];
0003153a          
00031545          if (!(zmm0 > tonyTangentData[(uint64_t)i_2].width[1]))
00031547              zmm0 = tonyTangentData[(uint64_t)i_2].width[1];
00031547          
0003154d          uint64_t i_1 = (uint64_t)i;
00031551          i += 1;
00031554          doubleOcclusionFilterData->lastKnownTchWidths[i_1] = zmm0;
00031561      }
000314f8  }

00031573                                                           cc cc cc cc cc cc cc cc cc                                 .........

0003157c    enum orientation_t CalculateSplitTouchPositions(struct double_occlusion_filter_t* doubleOcclusionFilterData, enum orientation_t orientation, struct sub_sample_t* ssOut, struct triangulate_statics_t* triangulateStatics)

0003157c  {
0003159b      int128_t zmm6;
0003159b      int128_t var_38 = zmm6;
000315a3      int128_t zmm8;
000315a3      int128_t var_58 = zmm8;
000315a8      float zmm9[0x4];
000315a8      float var_68[0x4] = zmm9;
000315c1      void var_1a8;
000315c1      int64_t rax_1 = __security_cookie ^ &var_1a8;
000315e4      int64_t var_178;
000315e4      memset(&var_178, 0, 0x20);
00031602      int64_t r15;
00031602      (uint8_t)r15 = 0;
00031605      void* rsi = &*(uint64_t*)((char*)var_178)[4];
0003160a      struct <unnamed-tag> const (* const rbp)[0x4] = &tchCentreCalcData[1];
00031611      float (* r12)[0x4] = &doubleOcclusionFilterData->lastKnownTchWidths;
00031611      
0003176d      do
0003176d      {
00031618          struct sensor_info_t* snsInfo_1 = triangulateStatics->snsInfo;
00031631          zmm8 = *(uint32_t*)((char*)ssOut + ((uint64_t)*(uint8_t*)rbp << 2));
0003163b          struct fpoint_t rax_4;
0003163b          float zmm6_1;
0003163b          rax_4 = CTL_Triangulate((*(uint32_t*)(&ssOut->sensor[1] + (&rbp[2] << 2))), 
0003163b              (uint32_t)zmm8, &snsInfo_1[1], snsInfo_1);
00031644          struct fpoint_t var_180_1;
00031644          var_180_1.x = rax_4.x;
00031644          var_180_1.y = rax_4.y;
00031644          
0003164f          if (doubleOcclusionFilterData->doubleOcclusionReason == DOCC_2_TO_1
0003164f              || doubleOcclusionFilterData->doubleOcclusionReason
0003164f              == DOCC_EDGES_BETWEEN_2TO1)
0003164f          {
00031658              zmm9[0] = ADJ(r12)->lastKnownTchWidths[0];
00031658              zmm9[1] = ADJ(r12)->lastKnownTchWidths[0];
00031658              zmm9[2] = ADJ(r12)->lastKnownTchWidths[0];
00031658              zmm9[3] = ADJ(r12)->lastKnownTchWidths[0];
0003164f          }
0003164f          else
0003164f          {
00031651              zmm9[0] = doubleOcclusionFilterData->lastKnownTchWidths[0];
00031651              zmm9[1] = doubleOcclusionFilterData->lastKnownTchWidths[0];
00031651              zmm9[2] = doubleOcclusionFilterData->lastKnownTchWidths[0];
00031651              zmm9[3] = doubleOcclusionFilterData->lastKnownTchWidths[0];
0003164f          }
0003164f          
0003165e          struct sensor_info_t* snsInfo = triangulateStatics->snsInfo;
00031665          zmm9[0] = zmm9[0] * 0.5f;
0003166a          uint32_t rcx_1 = (uint32_t)(uint8_t)r15;
0003166e          (uint32_t)zmm8 = (uint32_t)zmm8 + snsInfo->rotation_offset;
00031679          (uint32_t)zmm8 = (uint32_t)zmm8 * 57.2957802f;
00031682          zmm6_1 = (zmm6_1 + *(int64_t*)((char*)snsInfo + 0x14)) * 57.2957802f;
0003168d          float zmm0_1;
0003168d          
0003168d          if (!(uint8_t)r15)
000316fd              zmm0_1 = ((uint32_t)zmm8 + zmm6_1) * 0.5f - (uint32_t)zmm8;
0003168d          else if (rcx_1 == 1)
00031692          {
000316e4              (uint32_t)zmm8 = (uint32_t)zmm8 + 180f;
000316fd              zmm0_1 = ((uint32_t)zmm8 + zmm6_1) * 0.5f - (uint32_t)zmm8;
00031692          }
00031692          else if (rcx_1 == 2)
00031697          {
000316be              zmm6_1 = zmm6_1 + 180f;
000316de              zmm0_1 = ((uint32_t)zmm8 + 180f + zmm6_1) * 0.5f - zmm6_1;
00031697          }
00031697          else if (rcx_1 == 3)
0003169c          {
000316ac              zmm6_1 = zmm6_1 - 180f;
000316de              zmm0_1 = (zmm6_1 + (uint32_t)zmm8) * 0.5f - zmm6_1;
0003169c          }
0003169c          else
000316a6              zmm0_1 = 90f;
000316a6          
0003170a          float zmm0_2;
0003170a          int512_t zmm6_2;
0003170a          float zmm7_2;
0003170a          zmm0_2 = sinf(zmm0_1 * 0.0174532924f);
00031717          zmm9[0] = zmm9[0] / zmm0_2;
0003171f          zmm9 = _mm_unpacklo_ps(zmm9, *(uint64_t*)&zmm9[0]);
0003172c          (uint32_t)zmm6_2 =
0003172c              (float)_mm_and_pd(_mm_cvtps_pd(*(uint64_t*)&zmm9[0]), 0x7fffffffffffffff)[0];
00031730          float zmm0_3;
00031730          float zmm6_3;
00031730          float x;
00031730          zmm0_3 = cosf(zmm7_2 * 0.0174532924f);
0003173f          *(uint32_t*)((char*)rsi - 4) = zmm0_3 * zmm6_3 + var_180_1.x;
00031747          float zmm0;
00031747          zmm0 = sinf(x);
0003174c          (uint8_t)r15 += 1;
0003174f          rbp = &rbp[8];
00031753          r12 = &(*(uint128_t*)r12)[1];
00031761          *(uint32_t*)rsi = zmm0 * (uint32_t)zmm6 + var_180_1.y;
00031765          rsi += 8;
0003176d      } while ((uint8_t)r15 < 4);
0003176d      
00031777      enum orientation_t result = orientation;
00031777      
00031781      if (doubleOcclusionFilterData->doubleOcclusionReason == DOCC_1_TO_1
00031781          || doubleOcclusionFilterData->doubleOcclusionReason == DOCC_EDGES_BETWEEN_1TO1)
00031781      {
00031787          struct kite_pt_t kite[0x4];
00031787          struct kite_pt_t (* rcx_4)[0x4] = &kite;
0003178c          int64_t* rdx = &var_178;
00031791          int64_t i_1 = 4;
000317a9          int64_t i;
000317a9          
000317a9          do
000317a9          {
00031797              int64_t rax_5 = *(uint64_t*)rdx;
0003179a              rdx = &rdx[1];
0003179e              *(uint32_t*)rcx_4 = (uint32_t)rax_5;
0003179e              *(uint32_t*)((char*)rcx_4 + 4) = *(uint32_t*)((char*)rax_5)[4];
000317a1              rcx_4 = &(*(uint1408_t*)rcx_4)[1];
000317a5              i = i_1;
000317a5              i_1 -= 1;
000317a9          } while (i != 1);
000317b0          enum orientation_t result_1 = UseAwesomeLogicToFigureOutOrientation(&kite);
000317b5          result = result_1;
000317b5          
000317b9          if (!result_1)
000317b9          {
000317bb              zmm6 = 0x4b18967f;
000317c3              float (* rbx)[0x4];
000317c3              (uint8_t)rbx = 0;
000317c5              int64_t* B = &var_178;
000317ca              (uint8_t)rbp = 0;
000317ca              
000317f2              do
000317f2              {
000317d7                  int128_t zmm0_4 =
000317d7                      DistanceSquare(&doubleOcclusionFilterData->lastKnownSingleTouchPt, B);
000317d7                  
000317df                  if (!((uint32_t)zmm6 <= (uint32_t)zmm0_4))
000317df                  {
000317e1                      zmm6 = zmm0_4;
000317e4                      (uint8_t)rbx = (uint8_t)rbp;
000317df                  }
000317df                  
000317e7                  (uint8_t)rbp += 1;
000317ea                  B = &B[1];
000317f2              } while ((uint8_t)rbp < 4);
000317f2              
000317fb              if (!(uint8_t)rbx || (uint8_t)rbx == 2)
0003180e                  result = O_VERTICAL;
000317fb              else if ((uint8_t)rbx == 3 || (uint8_t)rbx == 1)
00031807                  result = O_HORIZONTAL;
00031807              
00031813              int64_t rax_6;
00031813              (uint32_t)rax_6 = doubleOcclusionFilterData->lastKnownSingleTouchPt.x;
00031813              *(uint32_t*)((char*)rax_6)[4] =
00031813                  doubleOcclusionFilterData->lastKnownSingleTouchPt.y;
0003181d              (&var_178)[(uint64_t)(uint8_t)rbx] = rax_6;
000317b9          }
00031781      }
00031781      
00031825      struct fpoint_t rax_8;
00031825      
00031825      if (result != O_HORIZONTAL)
00031825      {
0003183a          int64_t rax_9 = var_178;
0003183f          doubleOcclusionFilterData->adjustedPts[0].x = (uint32_t)rax_9;
0003183f          doubleOcclusionFilterData->adjustedPts[0].y = *(uint32_t*)((char*)rax_9)[4];
00031846          struct fpoint_t var_168;
00031846          rax_8.x = var_168.x;
00031846          rax_8.y = var_168.y;
00031825      }
00031825      else
00031825      {
0003182c          int64_t var_170;
0003182c          doubleOcclusionFilterData->adjustedPts[0].x = (uint32_t)var_170;
0003182c          doubleOcclusionFilterData->adjustedPts[0].y = *(uint32_t*)((char*)var_170)[4];
00031833          struct fpoint_t var_160;
00031833          rax_8.x = var_160.x;
00031833          rax_8.y = var_160.y;
00031825      }
00031825      
0003184b      doubleOcclusionFilterData->adjustedPts[1].x = rax_8.x;
0003184b      doubleOcclusionFilterData->adjustedPts[1].y = rax_8.y;
0003185f      __security_check_cookie(rax_1 ^ &var_1a8);
000318a2      return result;
0003157c  }

000318a3           cc cc cc cc cc cc cc cc cc                                                                 .........

000318ac    void AddTouchPointsToLinearRegressionBuffer(struct generalTouchData_t* generalTouchData, struct touches_t* touches, enum filterTypeFlag_t decisionFilter, struct sub_sample_t* ssOutput, struct twoSensorTriangulationMngr_t* twoSensorTriangulation, uint8_t occludedSensor)

000318ac  {
000318cb      struct sub_sample_t* ssOutput_1 = ssOutput;
000318ce      (uint8_t)ssOutput = occludedSensor;
000318d8      generalTouchData->pointsHistoryData.occludedSensor = (uint8_t)ssOutput;
000318f1      struct touches_t* A = touches;
000318fb      int64_t rbp;
000318fb      (uint8_t)rbp = 0;
000318fe      int64_t r12;
000318fe      (uint8_t)r12 = 0;
000318fe      
0003190b      if ((uint32_t)ssOutput_1->sensor[1].edgeSet[0].touchCount
0003190b          + (uint32_t)ssOutput_1->sensor[0].edgeSet[0].touchCount < 3
0003190b          && decisionFilter != DOUBLE_OCCLUSION_FILTER)
0003190b      {
00031915          memset(generalTouchData, 0, 0x140);
0003192e          generalTouchData->pointsHistoryData.numHistoryPts[0] = 0;
00031934          generalTouchData->pointsHistoryData.numHistoryPts[1] = 0;
0003193a          generalTouchData->pointsHistoryData.sampleGap[0] = 0x3eb851ec;
00031940          generalTouchData->pointsHistoryData.sampleGap[1] = 0.360000014f;
00031946          generalTouchData->pointsHistoryData.numSamplesAtGapSize[0] = 0;
0003194c          generalTouchData->pointsHistoryData.numSamplesAtGapSize[1] = 0;
00031952          memset(&generalTouchData->pointsHistoryData.centroidHistory, 0, 0xa0);
00031957          generalTouchData->pointsHistoryData.numCentroidPts = 0;
0003196e          memset(&generalTouchData->pointsHistoryData.lineFit, 0, 0x18);
0003197f          memset(&generalTouchData->pointsHistoryData.centroidLineFit, 0, 0x18);
0003197f          return;
0003190b      }
0003190b      
000319a6      if (twoSensorTriangulation->orientation != twoSensorTriangulation->prevOrientation
000319a6          && !(uint8_t)ssOutput)
000319a6      {
000319dc          generalTouchData->pointsHistoryData.lineFit[0].m =
000319dc              generalTouchData->pointsHistoryData.lineFit[1].m;
000319e8          generalTouchData->pointsHistoryData.lineFit[0].c =
000319e8              generalTouchData->pointsHistoryData.lineFit[1].c;
000319f4          generalTouchData->pointsHistoryData.lineFit[0].weight =
000319f4              generalTouchData->pointsHistoryData.lineFit[1].weight;
000319fc          generalTouchData->pointsHistoryData.lineFit[1].m =
000319fc              generalTouchData->pointsHistoryData.lineFit[0].m;
00031a05          generalTouchData->pointsHistoryData.lineFit[1].c =
00031a05              generalTouchData->pointsHistoryData.lineFit[0].c;
00031a14          generalTouchData->pointsHistoryData.lineFit[1].weight =
00031a14              generalTouchData->pointsHistoryData.lineFit[0].weight;
00031a1a          float rax_10;
00031a1a          (uint8_t)rax_10 = generalTouchData->pointsHistoryData.numHistoryPts[1];
00031a20          generalTouchData->pointsHistoryData.numHistoryPts[1] =
00031a20              generalTouchData->pointsHistoryData.numHistoryPts[0];
00031a2b          generalTouchData->pointsHistoryData.numHistoryPts[0] = (uint8_t)rax_10;
00031a31          char var_c8[0xa0];
00031a31          memmove(&var_c8, generalTouchData, 0xa0);
00031a43          memmove(generalTouchData, &generalTouchData->pointsHistoryData.pointsHistory[1], 
00031a43              0xa0);
00031a57          memmove(&generalTouchData->pointsHistoryData.pointsHistory[1], &var_c8, 0xa0);
000319a6      }
000319a6      
00031a6c      if ((uint32_t)ssOutput_1->sensor[1].edgeSet[0].touchCount
00031a6c          + (uint32_t)ssOutput_1->sensor[0].edgeSet[0].touchCount == 4)
00031a6c      {
00031a7a          (uint8_t)rbp = 1;
00031a7d          memset(&generalTouchData->pointsHistoryData.centroidHistory, 0, 0xa0);
00031a82          generalTouchData->pointsHistoryData.numCentroidPts = 0;
00031a6c      }
00031a6c      
00031aaa      if ((uint32_t)ssOutput_1->sensor[1].edgeSet[0].touchCount
00031aaa          + (uint32_t)ssOutput_1->sensor[0].edgeSet[0].touchCount == 3 && (
00031aaa          generalTouchData->pointsHistoryData.numHistoryPts[0] < 8
00031aaa          || generalTouchData->pointsHistoryData.numHistoryPts[1] < 8))
00031aaa      {
00031aac          (uint8_t)rbp = 1;
00031aaf          (uint8_t)r12 = 1;
00031aaa      }
00031aaa      
00031ab6      if (decisionFilter == DOUBLE_OCCLUSION_FILTER)
00031ab6      {
00031ab8          (uint8_t)rbp = 1;
00031abb          (uint8_t)r12 = 1;
00031ab6      }
00031ab6      
00031ac2      if ((uint8_t)rbp != 1)
00031ac2          return;
00031ac2      
00031ac8      int64_t r14_1 = 0;
00031acb      uint8_t (* rax_13)[0x2] = &generalTouchData->pointsHistoryData.numHistoryPts;
00031ad2      struct generalTouchData_t* buffer = generalTouchData;
00031ad5      char* rbx_1 = &generalTouchData->pointsHistoryData.numSamplesAtGapSize;
00031adc      float (* rsi)[0x2] = &generalTouchData->pointsHistoryData.sampleGap;
00031ae3      int64_t i_1 = 2;
00031b81      int64_t i;
00031b81      
00031b81      do
00031b81      {
00031af2          float zmm0;
00031af2          
00031af2          if (!rax_13)
00031af2          {
00031b27          label_31b27:
00031b27              struct fpoint_t ptToAdd;
00031b27              ptToAdd.x = A->touches[0].position.x;
00031b27              ptToAdd.y = A->touches[0].position.y;
00031b31              AddPointDataToStraightLineBuffer(buffer, &rbx_1[2], ptToAdd);
00031b36              *(uint8_t*)rbx_1 += 1;
00031b36              
00031b3b              if (*(uint8_t*)rbx_1 >= 8)
00031b3b              {
00031b41                  zmm0 = ADJ(rsi)->pointsHistoryData.sampleGap[0] * 2f;
00031b50                  ADJ(rsi)->pointsHistoryData.sampleGap[0] = zmm0;
00031b50                  
00031b54                  if (!(zmm0 <= 15f))
00031b56                      ADJ(rsi)->pointsHistoryData.sampleGap[0] = 0x41700000;
00031b56                  
00031b5c                  *(uint8_t*)rbx_1 = 0;
00031b3b              }
00031af2          }
00031af2          else
00031af2          {
00031af4              (uint8_t)rax_13 = rbx_1[2];
00031afa              (uint8_t)rax_13 -= 1;
00031b06              zmm0 = DistanceSquare(A, 
00031b06                  (char*)generalTouchData + (((uint64_t)(uint8_t)rax_13 + r14_1) << 3));
00031b0e              float zmm1_1;
00031b0e              
00031b0e              if (!(uint8_t)r12)
00031b1a                  zmm1_1 = ADJ(rsi)->pointsHistoryData.sampleGap[0];
00031b0e              else
00031b10                  zmm1_1 = 0.360000014f;
00031b10              
00031b25              if (!(zmm0 < zmm1_1 * zmm1_1))
00031b25                  goto label_31b27;
00031af2          }
00031b5f          rsi = &(*(uint64_t*)rsi)[1];
00031b63          r14_1 += 0x14;
00031b67          A = &A->touches[1];
00031b6b          buffer = &buffer->pointsHistoryData.pointsHistory[1];
00031b6e          rbx_1 = &rbx_1[1];
00031b71          i = i_1;
00031b71          i_1 -= 1;
00031b7a          rax_13 = &generalTouchData->pointsHistoryData.numHistoryPts;
00031b81      } while (i != 1);
00031b81      
00031b8b      if ((uint8_t)r12 != 1)
00031b8b          return;
00031b8b      
00031b8d      (uint8_t)rax_13 = generalTouchData->pointsHistoryData.numCentroidPts;
00031b8d      
00031b95      if (!(uint8_t)rax_13)
00031b95      {
00031bb9      label_31bb9:
00031bb9          struct fpoint_t ptToAdd_1;
00031bb9          ptToAdd_1.x = generalTouchData->centroid.x;
00031bb9          ptToAdd_1.y = generalTouchData->centroid.y;
00031bce          AddPointDataToStraightLineBuffer(
00031bce              &generalTouchData->pointsHistoryData.centroidHistory, 
00031bce              &generalTouchData->pointsHistoryData.numCentroidPts, ptToAdd_1);
00031b95      }
00031b95      else
00031b95      {
00031b97          (uint8_t)rax_13 -= 1;
00031b97          
00031bb7          if (!(DistanceSquare(&generalTouchData->centroid, 
00031bb7                  &generalTouchData->pointsHistoryData.centroidHistory[(uint64_t)(uint8_t)
00031bb7                      rax_13]) < 0.129600003f))
00031bb7              goto label_31bb9;
00031b95      }
000318ac  }

00031bf4                                                              cc cc cc cc cc cc cc cc                                  ........

00031bfc    void ProcessStraightLineFilter(struct straight_line_filter_t* straightLineFilterData, struct generalTouchData_t* generalTouchData, struct kite_t* kite, uint8_t occludedSensor, enum orientation_t orientation, struct sub_sample_t* ssOutput)

00031bfc  {
00031c23      straightLineFilterData->orientation = 0;
00031c25      straightLineFilterData->confidence = 0f;
00031c28      int128_t zmm6;
00031c28      int128_t var_48 = zmm6;
00031c3d      int64_t rbp;
00031c3d      (uint8_t)rbp = occludedSensor;
00031c40      straightLineFilterData->ptInBounds[0] = 0;
00031c40      straightLineFilterData->ptInBounds[1] = 0;
00031c40      straightLineFilterData->ptInBounds[2] = 0;
00031c40      straightLineFilterData->ptInBounds[3] = 0;
00031c43      memset(&straightLineFilterData->distances, 0, 0x10);
00031c43      
00031c62      if ((uint32_t)ssOutput->sensor[1].edgeSet[0].touchCount
00031c62          + (uint32_t)ssOutput->sensor[0].edgeSet[0].touchCount != 3)
00031c62      {
00031f30          straightLineFilterData->straightLineFilterOn = 0;
00031f30          return;
00031c62      }
00031c62      
00031c6f      if ((uint8_t)rbp != generalTouchData->pointsHistoryData.occludedSensor)
00031c6f      {
00031c74          straightLineFilterData->straightLineFilterOn = 1;
00031c7d          straightLineFilterData->bothStraightLineTouches =
00031c7d              ArePointsMovingInStraightLine(generalTouchData);
00031c6f      }
00031c6f      
00031c8c      if (!straightLineFilterData->bothStraightLineTouches
00031c8c              || !straightLineFilterData->straightLineFilterOn)
00031c8c          return;
00031c8c      
00031c9d      int64_t var_68;
00031c9d      memset(&var_68, 0, 0x20);
00031ca8      struct line_def_t lineA;
00031ca8      
00031ca8      if (generalTouchData->pointsHistoryData.numCentroidPts > 0)
00031ca8      {
00031cb2          struct line_def_t* __return = &lineA;
00031cb2          
00031cbe          if (generalTouchData->pointsHistoryData.lineFitError[0]
00031cbe              <= generalTouchData->pointsHistoryData.lineFitError[1])
00031cbe          {
00031d09              int32_t* rax_4 = RecalculateLineEquationWithNewSlope(__return, 
00031d09                  &generalTouchData->pointsHistoryData.pointsHistory[1], 
00031d09                  generalTouchData->pointsHistoryData.numHistoryPts[1], 
00031d09                  generalTouchData->pointsHistoryData.lineFit[0].m);
00031d10              generalTouchData->pointsHistoryData.lineFit[1].m = *(uint32_t*)rax_4;
00031d19              generalTouchData->pointsHistoryData.lineFit[1].c = rax_4[1];
00031d22              generalTouchData->pointsHistoryData.lineFit[1].weight = rax_4[2];
00031cbe          }
00031cbe          else
00031cbe          {
00031cd2              struct line_def_t* rax_2 = RecalculateLineEquationWithNewSlope(__return, 
00031cd2                  generalTouchData, generalTouchData->pointsHistoryData.numHistoryPts[0], 
00031cd2                  generalTouchData->pointsHistoryData.lineFit[1].m);
00031cd9              generalTouchData->pointsHistoryData.lineFit[0].m = rax_2->m;
00031ce2              generalTouchData->pointsHistoryData.lineFit[0].c = rax_2->c;
00031ceb              generalTouchData->pointsHistoryData.lineFit[0].weight = rax_2->weight;
00031cbe          }
00031ca8      }
00031ca8      
00031d30      zmm6 = 0x80000000;
00031d3f      uint8_t (* var_a8_1)[0x4] = &straightLineFilterData->ptInBounds;
00031d44      ssOutput = &straightLineFilterData->distances;
00031d4c      struct kite_t* B = kite;
00031d54      struct boundaryPoints_t (* polygon)[0x4] = &generalTouchData->boundaryPts;
00031d5c      int64_t r15;
00031d5c      (uint8_t)r15 = 0;
00031d5f      int64_t* A = &var_68;
00031e96      int128_t zmm1;
00031e96      
00031e96      do
00031e96      {
00031d64          uint32_t rdx_2 = (uint32_t)(uint8_t)r15;
00031d68          float rcx_5;
00031d68          (uint8_t)rcx_5 = 0;
00031d6c          bool cond:0_1;
00031d6c          
00031d6c          if (!rdx_2)
00031d6c          {
00031d98              cond:0_1 = orientation != O_HORIZONTAL;
00031d9c          label_31d9c:
00031d9c              
00031d9c              if (cond:0_1)
00031da5                  (uint8_t)rcx_5 = 0;
00031d9c              else
00031d9c              {
00031d9e                  (uint8_t)rcx_5 = 1;
00031d9e                  
00031da3                  if ((uint8_t)rbp)
00031da5                      (uint8_t)rcx_5 = 0;
00031d9c              }
00031d6c          }
00031d6c          else
00031d6c          {
00031d71              if (rdx_2 == 1)
00031d71              {
00031d92                  cond:0_1 = orientation != O_VERTICAL;
00031d96                  goto label_31d9c;
00031d71              }
00031d71              
00031d76              bool cond:1_1;
00031d76              
00031d76              if (rdx_2 == 2)
00031d76              {
00031d83                  cond:1_1 = orientation != O_HORIZONTAL;
00031d87              label_31d87:
00031d87                  
00031d8c                  if (cond:1_1 || (uint8_t)rbp)
00031d8e                      (uint8_t)rcx_5 = 1;
00031d8c                  else
00031da5                      (uint8_t)rcx_5 = 0;
00031d76              }
00031d76              else if (rdx_2 == 3)
00031d7b              {
00031d7d                  cond:1_1 = orientation != O_VERTICAL;
00031d81                  goto label_31d87;
00031d7b              }
00031d6c          }
00031dc2          uint64_t rcx_8 = (uint64_t)(uint8_t)rcx_5 * 3;
00031dc6          (uint32_t)zmm1 = 1f /
00031dc6              *(uint32_t*)(&generalTouchData->pointsHistoryData.lineFit + (rcx_8 << 2));
00031dcf          zmm1 ^= zmm6;
00031dd2          int32_t var_a0_1 = (uint32_t)zmm1;
00031dd8          (uint32_t)zmm1 = (uint32_t)zmm1 * B->kPt[0].pt.x;
00031de2          float var_9c_1 = B->kPt[0].pt.y - (uint32_t)zmm1;
00031de8          int64_t rax_8 = var_a0_1;
00031deb          struct line_def_t lineB;
00031deb          lineB.m = (uint32_t)rax_8;
00031deb          lineB.c = *(uint32_t*)((char*)rax_8)[4];
00031df6          int32_t var_98;
00031df6          lineB.weight = var_98;
00031e01          lineA.m =
00031e01              *(uint32_t*)(&generalTouchData->pointsHistoryData.lineFit + (rcx_8 << 2));
00031e0a          lineA.c = (&generalTouchData->pointsHistoryData.lineFit[0].c)[rcx_8];
00031e19          lineA.weight = (&generalTouchData->pointsHistoryData.lineFit[0].weight)[rcx_8];
00031e21          struct fpoint_t rax_13 = SFP_LineIntersect(&lineA, &lineB);
00031e2c          struct fpoint_t rbx_1;
00031e2c          rbx_1.x = rax_13.x;
00031e2c          rbx_1.y = rax_13.y;
00031e2f          *(uint32_t*)A = rax_13.x;
00031e2f          *(uint32_t*)((char*)A + 4) = rax_13.y;
00031e3f          float* ssOutput_1 = ssOutput;
00031e4d          struct fpoint_t pt;
00031e4d          pt.x = rbx_1.x;
00031e4d          pt.y = rbx_1.y;
00031e50          *(uint32_t*)ssOutput_1 = DistanceSquare(A, B);
00031e55          uint8_t rax_14;
00031e55          rax_14 = IsPointInPolygon(pt, polygon, 4);
00031e5a          uint8_t* r8_2 = var_a8_1;
00031e67          (uint8_t)r15 += 1;
00031e6a          *(uint8_t*)r8_2 = rax_14;
00031e70          B = &B->kPt[1];
00031e74          A = &A[1];
00031e78          ssOutput = &ssOutput_1[1];
00031e80          polygon = &(*(uint1024_t*)polygon)[1];
00031e8d          var_a8_1 = &r8_2[1];
00031e96      } while ((uint8_t)r15 < 4);
00031e96      
00031e9c      (uint32_t)zmm1 = straightLineFilterData->distances[1];
00031e9c      *(uint32_t*)((char*)zmm1)[4] = straightLineFilterData->distances[1];
00031e9c      *(uint32_t*)((char*)zmm1)[8] = straightLineFilterData->distances[1];
00031e9c      *(uint8_t*)((char*)zmm1)[0xc] = straightLineFilterData->ptInBounds[0];
00031e9c      *(uint8_t*)((char*)zmm1)[0xd] = straightLineFilterData->ptInBounds[1];
00031e9c      *(uint8_t*)((char*)zmm1)[0xe] = straightLineFilterData->ptInBounds[2];
00031e9c      *(uint8_t*)((char*)zmm1)[0xf] = straightLineFilterData->ptInBounds[3];
00031eae      (uint32_t)zmm1 = (uint32_t)zmm1 + straightLineFilterData->distances[3];
00031eb3      float zmm2_1 =
00031eb3          straightLineFilterData->distances[0] + straightLineFilterData->distances[2];
00031ed3      struct fpoint_t rax_16;
00031ed3      
00031ed3      if (!(zmm2_1 <= (uint32_t)zmm1) && straightLineFilterData->ptInBounds[1] == 1
00031ed3          && straightLineFilterData->ptInBounds[3] == 1
00031ed3          && !(9f <= straightLineFilterData->distances[1])
00031ed3          && !(9f <= straightLineFilterData->distances[3]))
00031ed3      {
00031eda          straightLineFilterData->orientation = 1;
00031ee0          straightLineFilterData->confidence = -0.800000012f;
00031ee7          int64_t var_60;
00031ee7          straightLineFilterData->adjustedPts[0].x = (uint32_t)var_60;
00031ee7          straightLineFilterData->adjustedPts[0].y = *(uint32_t*)((char*)var_60)[4];
00031eeb          struct fpoint_t var_50;
00031eeb          rax_16.x = var_50.x;
00031eeb          rax_16.y = var_50.y;
00031f2a          straightLineFilterData->adjustedPts[1].x = rax_16.x;
00031f2a          straightLineFilterData->adjustedPts[1].y = rax_16.y;
00031ed3      }
00031ed3      else if ((uint32_t)zmm1 <= zmm2_1 || straightLineFilterData->ptInBounds[0] != 1
00031ed3              || straightLineFilterData->ptInBounds[2] != 1
00031ed3              || 9f <= straightLineFilterData->distances[0]
00031ed3              || 9f <= straightLineFilterData->distances[2])
00031f30          straightLineFilterData->straightLineFilterOn = 0;
00031f0d      else
00031f0d      {
00031f0f          int64_t rax_17 = var_68;
00031f14          straightLineFilterData->orientation = 2;
00031f1a          straightLineFilterData->confidence = 0.800000012f;
00031f21          straightLineFilterData->adjustedPts[0].x = (uint32_t)rax_17;
00031f21          straightLineFilterData->adjustedPts[0].y = *(uint32_t*)((char*)rax_17)[4];
00031f25          struct fpoint_t var_58;
00031f25          rax_16.x = var_58.x;
00031f25          rax_16.y = var_58.y;
00031f2a          straightLineFilterData->adjustedPts[1].x = rax_16.x;
00031f2a          straightLineFilterData->adjustedPts[1].y = rax_16.y;
00031f0d      }
00031bfc  }

00031f53                                                           cc cc cc cc cc cc cc cc cc                                 .........

00031f5c    uint8_t ArePointsMovingInStraightLine(struct generalTouchData_t* generalTouchData)

00031f5c  {
00031f7c      int64_t rsi;
00031f7c      (uint8_t)rsi = 1;
00031f7f      struct generalTouchData_t* generalTouchData_1 = generalTouchData;
00031f82      uint8_t (* rbp)[0x2] = &generalTouchData->pointsHistoryData.numHistoryPts;
00031f89      struct line_def_t (* lineDef)[0x2] = &generalTouchData->pointsHistoryData.lineFit;
00031f90      float (* lineError_1)[0x2] = &generalTouchData->pointsHistoryData.lineFitError;
00031f97      int64_t i_1 = 2;
00031fe5      float (* lineError)[0x2];
00031fe5      struct line_fit_t lineFitData;
00031fe5      int64_t i;
00031fe5      
00031fe5      do
00031fe5      {
00031fa9          GenerateLineFitData(&lineFitData, generalTouchData_1, *((char*)ADJ(rbp) + 0x1ea));
00031fa9          
00031fb1          if ((uint8_t)rsi)
00031fb1          {
00031fc2              lineError = lineError_1;
00031fcc              (uint8_t)rsi = CalculateBestFitLineEquation(lineDef, &lineFitData, 
00031fcc                  generalTouchData_1, *((char*)ADJ(rbp) + 0x1ea), lineError);
00031fb1          }
00031fb1          
00031fcf          lineError_1 = &(*(uint64_t*)lineError_1)[1];
00031fd3          rbp = &(*(uint16_t*)rbp)[1];
00031fd6          generalTouchData_1 = &generalTouchData_1->pointsHistoryData.pointsHistory[1];
00031fdd          lineDef = &(*(uint192_t*)lineDef)[1];
00031fe1          i = i_1;
00031fe1          i_1 -= 1;
00031fe5      } while (i != 1);
00031fe5      
00031fea      if ((uint8_t)rsi)
00031fea      {
00031fec          (uint8_t)rbp = generalTouchData->pointsHistoryData.numCentroidPts;
00031fec          
00031ff7          if ((uint8_t)rbp >= 8)
00031ff7          {
00032008              GenerateLineFitData(&lineFitData, 
00032008                  &generalTouchData->pointsHistoryData.centroidHistory, (uint8_t)rbp);
00032028              CalculateBestFitLineEquation(
00032028                  &generalTouchData->pointsHistoryData.centroidLineFit, &lineFitData, 
00032028                  &generalTouchData->pointsHistoryData.centroidHistory, (uint8_t)rbp, 
00032028                  lineError & i_1);
00031ff7          }
00031fea      }
00031fea      
0003204e      return (uint8_t)rsi;
00031f5c  }

0003204f                                               cc cc cc cc cc cc cc cc cc                                         .........

00032058    float PtWeightedDistanceSquare(struct kite_pt_t const* ptA, struct kite_pt_t const* ptB)

00032058  {
00032068      float zmm0 = DistanceSquare(ptA, ptB);
0003206d      float deltaAngle = ptA->deltaAngle;
00032072      float deltaAngle_1 = ptB->deltaAngle;
00032072      
0003207d      if (!(deltaAngle_1 > deltaAngle))
0003207f          deltaAngle = deltaAngle_1;
0003207f      
00032082      deltaAngle = deltaAngle / 3.14159274f;
000320b0      return (1f - deltaAngle) * deltaAngle * 4f * zmm0;
00032058  }

000320b1                                                     cc cc cc cc cc cc cc                                           .......

000320b8    void KI_TwoSensorSortKite(struct kite_t* kite)

000320b8  {
000320d7      void var_f8;
000320d7      int64_t var_28 = __security_cookie ^ &var_f8;
000320df      float x_1 = 9.99999968e-21f;
000320e7      float x_2 = 1.00000002e+20f;
000320ef      int64_t rbx;
000320ef      (uint8_t)rbx = 0;
000320f1      struct kite_t* kite_1 = kite;
000320f4      int64_t rdi;
000320f4      (uint8_t)rdi = 1;
000320f7      int64_t rsi;
000320f7      (uint8_t)rsi = 2;
000320fa      char rdx = 3;
000320fc      int64_t rax_1;
000320fc      (uint8_t)rax_1 = 0;
00032104      float y_2 = 9.99999968e-21f;
00032107      float y_1 = 1.00000002e+20f;
00032107      
00032144      do
00032144      {
0003210a          kite->kPt[0];
0003210a          kite->kPt[0];
0003210a          float x;
0003210a          *(uint8_t*)((char*)x)[8] = kite->kPt[0].sourceST[0];
0003210a          *(uint8_t*)((char*)x)[9] = kite->kPt[0].sourceST[1];
0003210a          x = kite->kPt[0].pt.x;
0003210a          
00032111          if (!(x <= x_1))
00032111          {
00032113              x_1 = x;
00032116              (uint8_t)rbx = (uint8_t)rax_1;
00032111          }
00032111          
00032118          float y = kite->kPt[0].pt.y;
00032118          
00032120          if (!(y <= y_2))
00032120          {
00032122              y_2 = y;
00032125              (uint8_t)rsi = (uint8_t)rax_1;
00032120          }
00032120          
0003212b          if (!(x_2 <= x))
0003212b          {
0003212d              x_2 = x;
00032130              (uint8_t)rdi = (uint8_t)rax_1;
0003212b          }
0003212b          
00032136          if (!(y_1 <= y))
00032136          {
00032138              y_1 = y;
0003213b              rdx = (uint8_t)rax_1;
00032136          }
00032136          
0003213d          (uint8_t)rax_1 += 1;
0003213f          kite = &kite->kPt[1];
00032144      } while ((uint8_t)rax_1 < 4);
00032144      
00032158      char var_d8[0x2c];
00032158      memmove(&var_d8, (uint64_t)rdx * 0x2c + kite_1, 0x2c);
0003216f      char var_ac[0x2c];
0003216f      memmove(&var_ac, (uint64_t)(uint8_t)rbx * 0x2c + kite_1, 0x2c);
00032187      char var_80[0x2c];
00032187      memmove(&var_80, (uint64_t)(uint8_t)rsi * 0x2c + kite_1, 0x2c);
000321a2      char var_54[0x2c];
000321a2      memmove(&var_54, (uint64_t)(uint8_t)rdi * 0x2c + kite_1, 0x2c);
000321b5      memmove(kite_1, &var_d8, 0xb0);
000321c5      __security_check_cookie(var_28 ^ &var_f8);
000320b8  }

000321e2        cc cc cc cc cc cc                                                                            ......

000321e8    void KI_SortKite(struct kite_t* kite)

000321e8  {
00032217      void var_a8;
00032217      int64_t rax_1 = __security_cookie ^ &var_a8;
0003222b      int64_t rsi;
0003222b      (uint8_t)rsi = 0;
00032231      int64_t rdi;
00032231      (uint8_t)rdi = 0;
00032234      struct kite_t* A = kite;
0003223d      struct fpoint_t B;
0003223d      __builtin_memset(&B, 0, 8);
0003224b      int128_t zmm6 = 0x60ad78ec;
0003224b      
00032270      do
00032270      {
00032256          int128_t zmm0_1 = DistanceSquare(A, &B);
00032256          
0003225e          if (!((uint32_t)zmm6 <= (uint32_t)zmm0_1))
0003225e          {
00032260              zmm6 = zmm0_1;
00032263              (uint8_t)rsi = (uint8_t)rdi;
0003225e          }
0003225e          
00032266          (uint8_t)rdi += 1;
00032269          A = &A->kPt[1];
00032270      } while ((uint8_t)rdi < 4);
00032270      
00032275      if (1.00000002e+20f <= (uint32_t)zmm6)
00032366          onError__("Bad kite point values!", 
00032366              "c:\development_work\csf_release_hp\driver\foureyes\fe_kites.c", 0xab);
00032275      else
00032275      {
0003227e          char var_80[0x30];
0003227e          
0003227e          if ((uint8_t)rsi)
0003227e          {
00032280              uint64_t i_1 = (uint64_t)(uint8_t)rsi;
000322de              uint64_t i;
000322de              
000322de              do
000322de              {
0003228f                  memmove(&var_80, kite, 0x2c);
0003229e                  memmove(kite, &kite->kPt[1], 0x2c);
000322ae                  memmove(&kite->kPt[1].pt.x, &kite->kPt[2], 0x2c);
000322c1                  memmove(&kite->kPt[2].pt.x, &kite->kPt[3], 0x2c);
000322d5                  memmove(&kite->kPt[3], &var_80, 0x2c);
000322da                  i = i_1;
000322da                  i_1 -= 1;
000322de              } while (i != 1);
0003227e          }
0003227e          
000322f4          B.x = 0x3f800000;
000322fa          B.y = 0;
000322fa          
00032320          if (!(DistanceSquare(&kite->kPt[1].pt.x, &B)
00032320              <= DistanceSquare(&kite->kPt[3].pt, &B)))
00032320          {
0003232d              memmove(&var_80, &kite->kPt[1].pt.x, 0x2c);
0003233b              memmove(&kite->kPt[1].pt.x, &kite->kPt[3], 0x2c);
0003234b              memmove(&kite->kPt[3], &var_80, 0x2c);
00032320          }
00032275      }
00032275      
00032373      __security_check_cookie(rax_1 ^ &var_a8);
000321e8  }

000323a4              cc cc cc cc cc cc cc cc                                                                  ........

000323ac    uint8_t KI_KitePairsOnScreen(struct kite_t* kite, struct fpoint_t screenMin, struct fpoint_t screenMax)

000323ac  {
000323b1      int64_t arg_18;
000323b1      (uint32_t)arg_18 = screenMax.x;
000323b1      *(uint32_t*)((char*)arg_18)[4] = screenMax.y;
000323b6      int64_t arg_10;
000323b6      (uint32_t)arg_10 = screenMin.x;
000323b6      *(uint32_t*)((char*)arg_10)[4] = screenMin.y;
000323c2      int64_t zmm5 = 0x3fb999999999999a;
000323ca      int32_t zmm4 = *(uint32_t*)((char*)arg_18)[4];
000323d0      int32_t zmm2 = (uint32_t)arg_18;
000323d6      struct kite_t* kite_1 = kite;
000323d9      (uint8_t)kite = 1;
000323db      int64_t rbp;
000323db      (uint8_t)rbp = 0;
000323de      char rax = 1;
000323e5      int32_t zmm3 = *(uint32_t*)((char*)arg_10)[4];
000323eb      int32_t zmm1 = (uint32_t)arg_10;
000323f8      uint64_t zmm0;
000323f8      
000323f8      if (_mm_cvtps_pd((uint64_t)kite_1->kPt[0].deltaAngle) <= zmm5)
000323f8      {
0003241f      label_3241f:
0003241f          
00032426          if (!(_mm_cvtps_pd((uint64_t)kite_1->kPt[2].deltaAngle) <= zmm5))
00032426          {
00032428              (uint32_t)zmm0 = kite_1->kPt[2].pt.x;
00032428              *(uint32_t*)((char*)zmm0)[4] = kite_1->kPt[2].pt.x;
00032428              
00032435              if (zmm1 > (uint32_t)zmm0 || (uint32_t)zmm0 > zmm2)
00032435              {
00032446                  (uint8_t)rbp = 1;
00032449                  (uint8_t)kite = 0;
00032435              }
00032435              else
00032435              {
00032437                  (uint32_t)zmm0 = kite_1->kPt[2].pt.y;
00032437                  *(uint8_t*)((char*)zmm0)[4] = kite_1->kPt[2].sourceST[0];
00032437                  *(uint8_t*)((char*)zmm0)[5] = kite_1->kPt[2].sourceST[1];
00032437                  
00032444                  if (zmm3 > (uint32_t)zmm0 || !((uint32_t)zmm0 <= zmm4))
00032444                  {
00032446                      (uint8_t)rbp = 1;
00032449                      (uint8_t)kite = 0;
00032444                  }
00032435              }
00032426          }
000323f8      }
000323f8      else
000323f8      {
000323fa          (uint32_t)zmm0 = kite_1->kPt[0].pt.x;
000323fa          *(uint32_t*)((char*)zmm0)[4] = kite_1->kPt[0].pt.x;
000323fa          
00032406          if (zmm1 > (uint32_t)zmm0 || (uint32_t)zmm0 > zmm2)
00032406          {
00032446              (uint8_t)rbp = 1;
00032449              (uint8_t)kite = 0;
00032406          }
00032406          else
00032406          {
00032408              (uint32_t)zmm0 = kite_1->kPt[0].pt.y;
00032408              *(uint8_t*)((char*)zmm0)[4] = kite_1->kPt[0].sourceST[0];
00032408              *(uint8_t*)((char*)zmm0)[5] = kite_1->kPt[0].sourceST[1];
00032408              
00032415              if (!(zmm3 > (uint32_t)zmm0) && !((uint32_t)zmm0 > zmm4))
00032410                  goto label_3241f;
00032410              
00032446              (uint8_t)rbp = 1;
00032449              (uint8_t)kite = 0;
00032406          }
000323f8      }
000323f8      
00032457      if (_mm_cvtps_pd((uint64_t)kite_1->kPt[1].deltaAngle) <= zmm5)
00032457      {
0003247f      label_3247f:
0003247f          
00032486          if (!(_mm_cvtps_pd((uint64_t)kite_1->kPt[3].deltaAngle) <= zmm5))
00032486          {
00032488              (uint32_t)zmm0 = kite_1->kPt[3].pt.x;
00032488              *(uint32_t*)((char*)zmm0)[4] = kite_1->kPt[3].pt.x;
00032488              
00032498              if (zmm1 > (uint32_t)zmm0 || (uint32_t)zmm0 > zmm2)
00032498              {
000324ac                  (uint8_t)rbp += 1;
000324af                  rax = 0;
00032498              }
00032498              else
00032498              {
0003249a                  (uint32_t)zmm0 = kite_1->kPt[3].pt.y;
0003249a                  *(uint8_t*)((char*)zmm0)[4] = kite_1->kPt[3].sourceST[0];
0003249a                  *(uint8_t*)((char*)zmm0)[5] = kite_1->kPt[3].sourceST[1];
0003249a                  
000324aa                  if (zmm3 > (uint32_t)zmm0 || !((uint32_t)zmm0 <= zmm4))
000324aa                  {
000324ac                      (uint8_t)rbp += 1;
000324af                      rax = 0;
000324aa                  }
00032498              }
00032486          }
00032457      }
00032457      else
00032457      {
00032459          (uint32_t)zmm0 = kite_1->kPt[1].pt.x;
00032459          *(uint32_t*)((char*)zmm0)[4] = kite_1->kPt[1].pt.x;
00032459          
00032466          if (zmm1 > (uint32_t)zmm0 || (uint32_t)zmm0 > zmm2)
00032466          {
000324ac              (uint8_t)rbp += 1;
000324af              rax = 0;
00032466          }
00032466          else
00032466          {
00032468              (uint32_t)zmm0 = kite_1->kPt[1].pt.y;
00032468              *(uint8_t*)((char*)zmm0)[4] = kite_1->kPt[1].sourceST[0];
00032468              *(uint8_t*)((char*)zmm0)[5] = kite_1->kPt[1].sourceST[1];
00032468              
00032475              if (!(zmm3 > (uint32_t)zmm0) && !((uint32_t)zmm0 > zmm4))
00032470                  goto label_3247f;
00032470              
000324ac              (uint8_t)rbp += 1;
000324af              rax = 0;
00032466          }
00032457      }
00032457      
000324b8      if ((uint8_t)kite)
000324b8      {
000324cc          if (!rax)
000324cc          {
000324d1              if ((uint8_t)kite != 1)
000324d1                  goto label_32511;
000324d1              
000324dc              int64_t rdx;
000324dc              (uint32_t)rdx = (uint32_t)kite_1;
000324dc              *(uint32_t*)((char*)rdx)[4] = *(uint32_t*)((char*)kite_1)[4];
000324e2              kite_1->solvedIdx[0] = rax;
000324e8              kite_1->solvedIdx[1] = 2;
000324ef              memmove(&kite_1->kPt[1], rdx, 0x2c);
00032531              memmove(&kite_1->kPt[3], &kite_1->kPt[2], 0x2c);
00032536              kite_1->state = K_FORCED;
000324cc          }
000324b8      }
000324b8      else if (rax)
000324bc      {
00032511      label_32511:
00032511          kite_1->solvedIdx[0] = 1;
00032518          kite_1->solvedIdx[1] = 3;
0003251f          memmove(&kite_1->kPt[2].pt.x, &kite_1->kPt[1], 0x2c);
00032531          memmove(kite_1, &kite_1->kPt[3], 0x2c);
00032536          kite_1->state = K_FORCED;
000324bc      }
000324bc      else
000324be          kite_1->state = K_INVALID;
000324be      
00032555      return 2 - (uint8_t)rbp;
000323ac  }

00032556                                                                    cc cc cc cc cc cc                                    ......

0003255c    void KI_Match2Kites(struct kite_t* kiteA, struct kite_t* kiteB, float* retSquareError)

0003255c  {
00032578      float* retSquareError_1 = retSquareError;
00032581      int64_t rdi;
00032581      (uint8_t)rdi = 0;
00032584      float squareError = 1.00000002e+20f;
00032584      
000325a3      do
000325a3      {
0003258e          (uint8_t)retSquareError = (uint8_t)rdi;
00032597          KI_BestPair2(kiteA, kiteB, (uint8_t)retSquareError, &squareError);
0003259c          (uint8_t)rdi += 1;
000325a3      } while ((uint8_t)rdi < 4);
000325a3      
000325b5      *(uint32_t*)retSquareError_1 = squareError;
0003255c  }

000325c4              cc cc cc cc cc cc cc cc                                                                  ........

000325cc    void KI_Match3Kites(struct kite_t* kiteA, struct kite_t* kiteB, struct kite_t* kiteC, float* retSquareError)

000325cc  {
000325db      int64_t rdi;
000325db      int64_t var_8 = rdi;
000325ef      struct kite_t* kiteC_1 = kiteC;
000325f8      int64_t rbx;
000325f8      (uint8_t)rbx = 0;
000325fa      float squareError = 1.00000002e+20f;
000325fa      
00032630      do
00032630      {
000325ff          (uint8_t)rdi = 0;
000325ff          
00032629          do
00032629          {
0003260a              (uint8_t)kiteC = (uint8_t)rbx;
0003261d              KI_BestPair3(kiteA, kiteB, (uint8_t)kiteC, kiteC_1, (uint8_t)rdi, 
0003261d                  &squareError);
00032622              (uint8_t)rdi += 1;
00032629          } while ((uint8_t)rdi < 4);
00032629          
0003262b          (uint8_t)rbx += 1;
00032630      } while ((uint8_t)rbx < 4);
00032630      
00032642      *(uint32_t*)retSquareError = squareError;
000325cc  }

00032655                                                                 cc cc cc cc cc cc cc                                   .......

0003265c    uint8_t KI_BestPair2(struct kite_t* kiteA, struct kite_t* kiteB, uint8_t rotateB, float* squareError)

0003265c  {
00032683      uint32_t rotateB_1 = (uint32_t)rotateB;
00032696      int32_t temp0;
00032696      int32_t temp1;
00032696      temp0 = HIGHD((int64_t)rotateB_1);
00032696      temp1 = LOWD((int64_t)rotateB_1);
00032697      int32_t rdx_1 = temp0 & 3;
000326a1      int64_t rbp = (int64_t)(((temp1 + rdx_1) & 3) - rdx_1);
000326bb      int32_t temp2;
000326bb      int32_t temp3;
000326bb      temp2 = HIGHD((int64_t)(rotateB_1 + 2));
000326bb      temp3 = LOWD((int64_t)(rotateB_1 + 2));
000326bf      int32_t rdx_6 = temp2 & 3;
000326c9      int64_t r12 = (int64_t)(((temp3 + rdx_6) & 3) - rdx_6);
000326e3      int32_t temp4;
000326e3      int32_t temp5;
000326e3      temp4 = HIGHD((int64_t)(rotateB_1 + 1));
000326e3      temp5 = LOWD((int64_t)(rotateB_1 + 1));
000326e4      int128_t zmm6;
000326e4      (uint32_t)zmm6 = PtWeightedDistanceSquare(kiteA, rbp * 0x2c + kiteB)
000326e4          + PtWeightedDistanceSquare(&kiteA->kPt[2], r12 * 0x2c + kiteB);
000326e8      int32_t rdx_11 = temp4 & 3;
000326f2      int64_t r14 = (int64_t)(((temp5 + rdx_11) & 3) - rdx_11);
000326ff      int128_t zmm0_2 = PtWeightedDistanceSquare(&kiteA->kPt[1], r14 * 0x2c + kiteB);
0003270f      int32_t temp6;
0003270f      int32_t temp7;
0003270f      temp6 = HIGHD((int64_t)(rotateB_1 + 3));
0003270f      temp7 = LOWD((int64_t)(rotateB_1 + 3));
00032713      int32_t rdx_16 = temp6 & 3;
0003271d      int64_t r15 = (int64_t)(((temp7 + rdx_16) & 3) - rdx_16);
0003272a      int32_t rax_20;
0003272a      float zmm0_3;
0003272a      zmm0_3 = PtWeightedDistanceSquare(&kiteA->kPt[3], r15 * 0x2c + kiteB);
00032735      int128_t zmm7;
00032735      (uint32_t)zmm7 = (uint32_t)zmm0_2 + zmm0_3;
00032735      
00032748      if (kiteA->state == K_FORCED)
00032748      {
00032751          int32_t temp8_1;
00032751          int32_t temp9_1;
00032751          temp8_1 = HIGHD((int64_t)kiteA->solvedIdx[0]);
00032751          temp9_1 = LOWD((int64_t)kiteA->solvedIdx[0]);
00032751          
00032759          if (((temp9_1 & 1) ^ temp8_1) != temp8_1)
00032760              zmm6 = 0x60ad78ec;
00032759          else
0003275b              zmm7 = 0x60ad78ec;
00032748      }
00032748      
0003276a      if (kiteB->state == K_FORCED)
0003276a      {
00032773          int32_t temp11_1;
00032773          int32_t temp12_1;
00032773          temp11_1 = HIGHD((int64_t)kiteB->solvedIdx[0]);
00032773          temp12_1 = LOWD((int64_t)kiteB->solvedIdx[0]);
00032780          int32_t temp13_1;
00032780          int32_t temp14_1;
00032780          temp13_1 = HIGHD((int64_t)rotateB_1);
00032780          temp14_1 = LOWD((int64_t)rotateB_1);
00032780          
0003278a          if (((temp12_1 & 1) ^ temp11_1) - temp11_1
0003278a                  != ((temp14_1 & 1) ^ temp13_1) - temp13_1)
00032791              zmm6 = 0x60ad78ec;
0003278a          else
0003278c              zmm7 = 0x60ad78ec;
0003276a      }
0003276a      
00032797      zmm0_3 = *(uint32_t*)squareError;
00032797      
0003279b      if ((uint32_t)zmm7 <= (uint32_t)zmm6)
0003279b      {
000327f0          if (zmm0_3 <= (uint32_t)zmm7)
00032837              (uint8_t)rax_20 = 0;
000327f0          else
000327f0          {
000327f2              kiteA->solvedIdx[0] = 1;
000327f9              kiteA->solvedIdx[1] = 3;
00032800              kiteB->solvedIdx[0] = (uint8_t)r14;
00032807              kiteB->solvedIdx[1] = (uint8_t)r15;
00032807              
0003281a              if (kiteA->state != K_FORCED)
0003281c                  kiteA->state = K_SOLVED;
0003281c              
00032829              if (kiteB->state != K_FORCED)
0003282b                  kiteB->state = K_SOLVED;
0003282b              
00032831              *(uint32_t*)squareError = (uint32_t)zmm7;
000327e9              (uint8_t)rax_20 = 1;
000327f0          }
0003279b      }
0003279b      else if (zmm0_3 <= (uint32_t)zmm6)
00032837          (uint8_t)rax_20 = 0;
000327a0      else
000327a0      {
000327a6          kiteA->solvedIdx[0] = 0;
000327ad          kiteA->solvedIdx[1] = 2;
000327b4          kiteB->solvedIdx[0] = (uint8_t)rbp;
000327bb          kiteB->solvedIdx[1] = (uint8_t)r12;
000327bb          
000327ce          if (kiteA->state != K_FORCED)
000327d0              kiteA->state = K_SOLVED;
000327d0          
000327dd          if (kiteB->state != K_FORCED)
000327df              kiteB->state = K_SOLVED;
000327df          
000327e5          *(uint32_t*)squareError = (uint32_t)zmm6;
000327e9          (uint8_t)rax_20 = 1;
000327a0      }
000327a0      
00032860      return (uint8_t)rax_20;
0003265c  }

00032861     cc cc cc cc cc cc cc                                                                           .......

00032868    uint8_t KI_BestPair3(struct kite_t* kiteA, struct kite_t* kiteB, uint8_t rotateB, struct kite_t* kiteC, uint8_t rotateC, float* squareError)

00032868  {
0003287c      uint32_t rotateB_1 = (uint32_t)rotateB;
0003288f      int32_t temp0;
0003288f      int32_t temp1;
0003288f      temp0 = HIGHD((int64_t)rotateB_1);
0003288f      temp1 = LOWD((int64_t)rotateB_1);
00032898      int32_t rdx_1 = temp0 & 3;
000328a5      int32_t rax_4 = ((temp1 + rdx_1) & 3) - rdx_1;
000328b5      void* r12_2 = (int64_t)rax_4 * 0x2c + kiteB;
000328c7      int32_t temp2;
000328c7      int32_t temp3;
000328c7      temp2 = HIGHD((int64_t)(rotateB_1 + 2));
000328c7      temp3 = LOWD((int64_t)(rotateB_1 + 2));
000328cb      int32_t rdx_4 = temp2 & 3;
000328d1      int32_t rax_9 = ((temp3 + rdx_4) & 3) - rdx_4;
000328e1      struct kite_pt_t* rbp_2 = (int64_t)rax_9 * 0x2c + kiteB;
000328ec      uint32_t rotateC_1 = (uint32_t)rotateC;
000328f9      int32_t temp4;
000328f9      int32_t temp5;
000328f9      temp4 = HIGHD((int64_t)rotateC_1);
000328f9      temp5 = LOWD((int64_t)rotateC_1);
000328fa      int128_t zmm6;
000328fa      (uint32_t)zmm6 = PtWeightedDistanceSquare(kiteA, r12_2)
000328fa          + PtWeightedDistanceSquare(&kiteA->kPt[2], rbp_2);
000328fe      int32_t rdx_7 = temp4 & 3;
00032904      int32_t rax_14 = ((temp5 + rdx_7) & 3) - rdx_7;
00032914      struct kite_pt_t* ptB_2 = (int64_t)rax_14 * 0x2c + kiteC;
00032926      int32_t temp6;
00032926      int32_t temp7;
00032926      temp6 = HIGHD((int64_t)(rotateC_1 + 2));
00032926      temp7 = LOWD((int64_t)(rotateC_1 + 2));
00032927      (uint32_t)zmm6 = (uint32_t)zmm6 + PtWeightedDistanceSquare(kiteA, ptB_2);
0003292b      int32_t rdx_10 = temp6 & 3;
00032933      int32_t rax_19 = ((temp7 + rdx_10) & 3) - rdx_10;
00032940      struct kite_pt_t* ptB = (int64_t)rax_19 * 0x2c + kiteC;
00032951      (uint32_t)zmm6 = (uint32_t)zmm6 + PtWeightedDistanceSquare(&kiteA->kPt[2], ptB);
00032960      (uint32_t)zmm6 = (uint32_t)zmm6 + PtWeightedDistanceSquare(r12_2, ptB_2);
00032973      int32_t temp8;
00032973      int32_t temp9;
00032973      temp8 = HIGHD((int64_t)(rotateB_1 + 1));
00032973      temp9 = LOWD((int64_t)(rotateB_1 + 1));
00032974      (uint32_t)zmm6 = (uint32_t)zmm6 + PtWeightedDistanceSquare(rbp_2, ptB);
00032978      int32_t rdx_15 = temp8 & 3;
00032980      int32_t rax_24 = ((temp9 + rdx_15) & 3) - rdx_15;
00032991      void* r12_5 = (int64_t)rax_24 * 0x2c + kiteB;
000329a6      int32_t temp10;
000329a6      int32_t temp11;
000329a6      temp10 = HIGHD((int64_t)(rotateB_1 + 3));
000329a6      temp11 = LOWD((int64_t)(rotateB_1 + 3));
000329aa      int32_t rdx_18 = temp10 & 3;
000329b2      int32_t rax_29 = ((temp11 + rdx_18) & 3) - rdx_18;
000329bf      struct kite_pt_t* rbp_5 = (int64_t)rax_29 * 0x2c + kiteB;
000329d8      int128_t zmm7;
000329d8      (uint32_t)zmm7 = PtWeightedDistanceSquare(&kiteA->kPt[1], r12_5)
000329d8          + PtWeightedDistanceSquare(&kiteA->kPt[3], rbp_5);
000329dc      int32_t temp12;
000329dc      int32_t temp13;
000329dc      temp12 = HIGHD((int64_t)((uint32_t)rotateC + 1));
000329dc      temp13 = LOWD((int64_t)((uint32_t)rotateC + 1));
000329dd      int32_t rdx_21 = temp12 & 3;
000329e5      int32_t rax_35 = ((temp13 + rdx_21) & 3) - rdx_21;
000329f2      struct kite_pt_t* ptB_3 = (int64_t)rax_35 * 0x2c + kiteC;
00032a0f      (uint32_t)zmm7 = (uint32_t)zmm7 + PtWeightedDistanceSquare(&kiteA->kPt[1], ptB_3);
00032a13      int32_t temp14;
00032a13      int32_t temp15;
00032a13      temp14 = HIGHD((int64_t)((uint32_t)rotateC + 3));
00032a13      temp15 = LOWD((int64_t)((uint32_t)rotateC + 3));
00032a14      int32_t rdx_24 = temp14 & 3;
00032a1c      int32_t rax_41 = ((temp15 + rdx_24) & 3) - rdx_24;
00032a28      struct kite_pt_t* ptB_1 = (int64_t)rax_41 * 0x2c + kiteC;
00032a3a      (uint32_t)zmm7 = (uint32_t)zmm7 + PtWeightedDistanceSquare(&kiteA->kPt[3], ptB_1);
00032a49      (uint32_t)zmm7 = (uint32_t)zmm7 + PtWeightedDistanceSquare(r12_5, ptB_3);
00032a4d      uint64_t squareError_1;
00032a4d      float zmm0_11;
00032a4d      zmm0_11 = PtWeightedDistanceSquare(rbp_5, ptB_1);
00032a58      (uint32_t)zmm7 = (uint32_t)zmm7 + zmm0_11;
00032a58      
00032a6b      if (kiteA->state == K_FORCED)
00032a6b      {
00032a75          int32_t temp16_1;
00032a75          int32_t temp17_1;
00032a75          temp16_1 = HIGHD((int64_t)kiteA->solvedIdx[0]);
00032a75          temp17_1 = LOWD((int64_t)kiteA->solvedIdx[0]);
00032a75          
00032a7d          if (((temp17_1 & 1) ^ temp16_1) != temp16_1)
00032a84              zmm6 = 0x60ad78ec;
00032a7d          else
00032a7f              zmm7 = 0x60ad78ec;
00032a6b      }
00032a6b      
00032a8e      if (kiteB->state == K_FORCED)
00032a8e      {
00032a98          int32_t temp19_1;
00032a98          int32_t temp20_1;
00032a98          temp19_1 = HIGHD((int64_t)kiteB->solvedIdx[0]);
00032a98          temp20_1 = LOWD((int64_t)kiteB->solvedIdx[0]);
00032aa9          int32_t temp21_1;
00032aa9          int32_t temp22_1;
00032aa9          temp21_1 = HIGHD((int64_t)rotateB_1);
00032aa9          temp22_1 = LOWD((int64_t)rotateB_1);
00032aa9          
00032ab3          if (((temp20_1 & 1) ^ temp19_1) - temp19_1
00032ab3                  != ((temp22_1 & 1) ^ temp21_1) - temp21_1)
00032aba              zmm6 = 0x60ad78ec;
00032ab3          else
00032ab5              zmm7 = 0x60ad78ec;
00032a8e      }
00032a8e      
00032ac4      if (kiteC->state == K_FORCED)
00032ac4      {
00032ace          int32_t temp23_1;
00032ace          int32_t temp24_1;
00032ace          temp23_1 = HIGHD((int64_t)kiteC->solvedIdx[0]);
00032ace          temp24_1 = LOWD((int64_t)kiteC->solvedIdx[0]);
00032ae0          int32_t temp25_1;
00032ae0          int32_t temp26_1;
00032ae0          temp25_1 = HIGHD((int64_t)(uint32_t)rotateC);
00032ae0          temp26_1 = LOWD((int64_t)(uint32_t)rotateC);
00032ae0          
00032aea          if (((temp24_1 & 1) ^ temp23_1) - temp23_1
00032aea                  != ((temp26_1 & 1) ^ temp25_1) - temp25_1)
00032af1              zmm6 = 0x60ad78ec;
00032aea          else
00032aec              zmm7 = 0x60ad78ec;
00032ac4      }
00032ac4      
00032af7      if ((uint32_t)zmm7 <= (uint32_t)zmm6)
00032af7      {
00032b97          squareError_1 = squareError;
00032b97          
00032ba6          if (*(uint32_t*)squareError_1 <= (uint32_t)zmm7)
00032c22              (uint8_t)squareError_1 = 0;
00032ba6          else
00032ba6          {
00032bac              kiteA->solvedIdx[0] = 1;
00032bb4              kiteA->solvedIdx[1] = 3;
00032bbc              kiteB->solvedIdx[0] = (uint8_t)rax_24;
00032bc7              kiteB->solvedIdx[1] = (uint8_t)rax_29;
00032bd2              kiteC->solvedIdx[0] = (uint8_t)rax_35;
00032bdd              kiteC->solvedIdx[1] = (uint8_t)rax_41;
00032bdd              
00032bf0              if (kiteA->state != K_FORCED)
00032bf2                  kiteA->state = K_SOLVED;
00032bf2              
00032c00              if (kiteB->state != K_FORCED)
00032c02                  kiteB->state = K_SOLVED;
00032c02              
00032c10              if (kiteC->state != K_FORCED)
00032c12                  kiteC->state = K_SOLVED;
00032c12              
00032c19              *(uint32_t*)squareError_1 = (uint32_t)zmm7;
00032b90              (uint8_t)squareError_1 = 1;
00032ba6          }
00032af7      }
00032af7      else
00032af7      {
00032afd          int32_t* squareError_2 = squareError;
00032b05          *(uint32_t*)squareError_2;
00032b05          *(uint32_t*)squareError_2;
00032b05          *(uint8_t*)((char*)zmm0_11)[8] = squareError_2[2];
00032b05          *(uint8_t*)((char*)zmm0_11)[9] = *(uint8_t*)((char*)squareError_2 + 9);
00032b05          
00032b0c          if (*(uint32_t*)squareError_2 <= (uint32_t)zmm6)
00032c22              (uint8_t)squareError_1 = 0;
00032b0c          else
00032b0c          {
00032b19              kiteA->solvedIdx[0] = 0;
00032b21              kiteA->solvedIdx[1] = 2;
00032b29              kiteB->solvedIdx[0] = (uint8_t)rax_4;
00032b3c              kiteB->solvedIdx[1] = (uint8_t)rax_9;
00032b4a              kiteC->solvedIdx[0] = (uint8_t)rax_14;
00032b55              kiteC->solvedIdx[1] = (uint8_t)rax_19;
00032b55              
00032b63              if (kiteA->state != K_FORCED)
00032b65                  kiteA->state = K_SOLVED;
00032b65              
00032b73              if (kiteB->state != K_FORCED)
00032b75                  kiteB->state = K_SOLVED;
00032b75              
00032b83              if (kiteC->state != K_FORCED)
00032b85                  kiteC->state = K_SOLVED;
00032b85              
00032b8c              *(uint32_t*)squareError_2 = (uint32_t)zmm6;
00032b90              (uint8_t)squareError_1 = 1;
00032b0c          }
00032af7      }
00032af7      
00032c3e      return (uint8_t)squareError_1;
00032868  }

00032c3f                                                                                               cc                                 .
00032c40  cc cc cc cc cc cc cc cc                                                                          ........

00032c48    enum orientation_t UseAwesomeLogicToFigureOutOrientation(struct kite_pt_t* kite)

00032c48  {
00032c4e      struct fpoint_t pt2;
00032c4e      pt2.x = *(int64_t*)((char*)kite + 0x58);
00032c4e      pt2.y = *(int64_t*)((char*)kite + 0x5c);
00032c55      struct fpoint_t pt1;
00032c55      pt1.x = kite->pt.x;
00032c55      pt1.y = kite->pt.y;
00032c5d      int128_t zmm0;
00032c5d      int512_t zmm6;
00032c5d      zmm0 = CalculateAngleBetweenPoints(pt1, pt2);
00032c62      struct fpoint_t pt2_1;
00032c62      pt2_1.x = *(int64_t*)((char*)kite + 0x2c);
00032c62      pt2_1.y = *(int64_t*)((char*)kite + 0x30);
00032c66      struct fpoint_t pt1_1;
00032c66      pt1_1.x = *(int64_t*)((char*)kite + 0x84);
00032c66      pt1_1.y = *(int64_t*)((char*)kite + 0x88);
00032c6d      (uint128_t)zmm6 = zmm0;
00032c70      double zmm0_1[0x2];
00032c70      float zmm6_1[0x4];
00032c70      zmm0_1 = CalculateAngleBetweenPoints(pt1_1, pt2_1);
00032c70      
00032c93      if (0.261799395f > zmm6_1[0])
00032c93      {
00032c9f      label_32c9f:
00032c9f          
00032ca2          if (0.261799395f > zmm0_1[0])
00032d1d              return 1;
00032d1d          
00032cac          if (!(zmm0_1[0] <= 2.87979341f) && 3.40339208f > zmm0_1[0])
00032d1d              return 1;
00032c93      }
00032c93      else if (!(zmm6_1[0] <= 2.87979341f) && !(3.40339208f <= zmm6_1[0]))
00032c9d          goto label_32c9f;
00032c9d      
00032cb6      int64_t zmm2_1 = 0x4011cd6761110b46;
00032cbe      int64_t zmm4_1 = 0x4013e591a9110b46;
00032cbe      
00032cd6      if (zmm6_1[0] <= 1.30899692f || !(1.83259583f > zmm6_1[0]))
00032cd6      {
00032cd8          float temp0_1[0x4] = _mm_unpacklo_ps(zmm6_1, *(uint64_t*)&zmm6_1[0]);
00032cd8          
00032ce2          if (!(_mm_cvtps_pd(*(uint64_t*)&temp0_1[0])[0] <= zmm2_1) && !(zmm4_1 <=
00032ce2                  _mm_cvtps_pd(_mm_unpacklo_ps(temp0_1, *(uint64_t*)&temp0_1[0])[0])[0]))
00032cee              goto label_32cf0;
00032cd6      }
00032cd6      else
00032cd6      {
00032cf0      label_32cf0:
00032cf0          
00032cf8          if (!(zmm0_1[0] <= 1.30899692f) && 1.83259583f > zmm0_1[0])
00032d12              return 2;
00032d12          
00032cfa          double zmm5[0x2] = _mm_unpacklo_ps(zmm0_1, zmm0_1[0]);
00032cfa          
00032d04          if (!(_mm_cvtps_pd(zmm5[0])[0] <= zmm2_1)
00032d04                  && !(zmm4_1 <= _mm_cvtps_pd(_mm_unpacklo_ps(zmm5, zmm5[0])[0])[0]))
00032d12              return 2;
00032cd6      }
00032cd6      
00032d19      return 0;
00032c48  }

00032d2d                                         cc cc cc cc cc cc cc                                                   .......

00032d34    void CalculatePivotLocations(struct pivot_filter_t* pivotFilterData, struct kite_pt_t* kite, uint8_t diamondIdx, struct fpoint_t tchDownPosition, struct sub_sample_t* ssOutput)

00032d34  {
00032d34      pivotFilterData->adjustedPts[0].x = tchDownPosition.x;
00032d34      pivotFilterData->adjustedPts[0].y = tchDownPosition.y;
00032d38      char r10 = 0;
00032d3b      uint32_t diamondIdx_1 = (uint32_t)diamondIdx;
00032d3b      
00032d45      if (!diamondIdx_1)
00032d63          r10 = 2;
00032d45      else if (diamondIdx_1 == 1)
00032d5e          r10 = 3;
00032d4b      else if (diamondIdx_1 != 2 && diamondIdx_1 == 3)
00032d59          r10 = (diamondIdx_1 - 2);
00032d59      
00032d6b      ssOutput->sensor[1].edgeSet[0];
00032d72      ssOutput->sensor[0].edgeSet[0];
00032d7c      struct fpoint_t* rax_3 = (uint64_t)r10 * 0x2c;
00032d80      struct fpoint_t rax_4;
00032d80      rax_4.x = *(uint32_t*)((char*)rax_3 + kite);
00032d80      rax_4.y = *(uint32_t*)(&rax_3->y + kite);
00032d84      pivotFilterData->adjustedPts[1].x = rax_4.x;
00032d84      pivotFilterData->adjustedPts[1].y = rax_4.y;
00032d34  }

00032d89                             cc cc cc cc cc cc cc                                                           .......

00032d90    void ProcessPredictionFilter(struct prediction_filter_t* predFilterData, struct kite_t* kite, struct sub_sample_t* ssOut, uint8_t quadraticDecisionMade, float* diamondWidths, uint8_t numTouches, enum orientation_t orientation)

00032d90  {
00032da9      predFilterData->confidence = 0f;
00032dad      predFilterData->orientation = O_UNKNOWN;
00032db1      predFilterData->angleDeviationFromVertical = 0f;
00032db5      predFilterData->requiredDiamondMinWidth = 3.5f;
00032dcc      int64_t rdi;
00032dcc      (uint8_t)rdi = quadraticDecisionMade;
00032dcc      
00032dd9      if ((uint32_t)ssOut->sensor[1].edgeSet[0].touchCount
00032dd9              + (uint32_t)ssOut->sensor[0].edgeSet[0].touchCount != 3)
00032ddb          predFilterData->hasSwitchedDuringThisOcclusion = 0;
00032ddb      
00032de4      if (numTouches < 2)
00032de4      {
00032de6          predFilterData->predState = 0;
00032de9          predFilterData->minWidth = 99999f;
00032de9          return;
00032de4      }
00032de4      
00032df5      struct fpoint_t pt2;
00032df5      pt2.x = kite->kPt[2].pt.x;
00032df5      pt2.y = kite->kPt[2].pt.y;
00032df9      struct fpoint_t pt1;
00032df9      pt1.x = kite->kPt[0].pt.x;
00032df9      pt1.y = kite->kPt[0].pt.y;
00032dfd      float zmm0_1[0x4] = CalculateAngleBetweenPoints(pt1, pt2);
00032e0a      zmm0_1[0] = zmm0_1[0] - 4.71238899f;
00032e20      float zmm2_1 = (float)__andpd_xmmxuq_memxuq(
00032e20          _mm_cvtps_pd(_mm_unpacklo_ps(zmm0_1, *(uint64_t*)&zmm0_1[0])[0]), 
00032e20          __mask@@AbsDouble@)[0];
00032e27      predFilterData->angleDeviationFromVertical = zmm2_1;
00032e27      
00032e45      if (!(0.400000006f <= zmm2_1) || (uint8_t)rdi == 1)
00032e45      {
00032e2e          predFilterData->predState = 0;
00032e31          predFilterData->minWidth = 99999f;
00032e31          return;
00032e45      }
00032e45      
00032e4c      zmm0_1 = diamondWidths[1];
00032e54      int64_t rsi;
00032e54      
00032e54      if (zmm0_1[0] <= *(uint32_t*)diamondWidths)
00032e5b          (uint8_t)rsi = 1;
00032e54      else
00032e56          (uint8_t)rsi = 0;
00032e56      
00032e5e      enum prediction_state_t predState = predFilterData->predState;
00032e5e      
00032e62      if (!predState)
00032e62      {
00032f4f          if (!(diamondWidths[(uint64_t)(uint8_t)rsi][0] <= 30f))
00032f51              predFilterData->predState = 1;
00032e62      }
00032e62      else if (predState == PS_WAIT_FOR_DIAMOND_CLOSE)
00032e6a      {
00032eeb          float zmm0_2[0x4] = DistanceSquare(kite, &kite->kPt[2].pt);
00032ef0          int32_t zmm1_2 = (int32_t){0};
00032ef0          
00032ef6          if (!(zmm0_2[0] <= 0f))
00032ef6          {
00032efe              zmm0_2 =
00032efe                  sqrt(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0_2, *(uint64_t*)&zmm0_2[0])[0])[0]);
00032f03              zmm1_2 = (float)*(uint64_t*)&zmm0_2[0];
00032ef6          }
00032ef6          
00032f0e          if (!(zmm1_2 <= 130f))
00032f0e          {
00032f10              zmm0_2[0] = predFilterData->requiredDiamondMinWidth;
00032f10              zmm0_2[1] = predFilterData->requiredDiamondMinWidth;
00032f10              zmm0_2[2] = predFilterData->hasSwitchedDuringThisOcclusion;
00032f10              *(uint16_t*)((char*)zmm0_2[2])[1] = *(int64_t*)((char*)predFilterData + 0x11);
00032f10              *(uint8_t*)((char*)zmm0_2[2])[3] = *((char*)predFilterData + 0x13);
00032f10              zmm0_2[3] = predFilterData->requiredDiamondMinWidth;
00032f15              zmm0_2[0] = zmm0_2[0] * 2.5f;
00032f1d              predFilterData->requiredDiamondMinWidth = zmm0_2[0];
00032f0e          }
00032f0e          
00032f22          zmm0_2[0] = predFilterData->requiredDiamondMinWidth;
00032f22          zmm0_2[1] = predFilterData->requiredDiamondMinWidth;
00032f22          zmm0_2[2] = predFilterData->hasSwitchedDuringThisOcclusion;
00032f22          *(uint16_t*)((char*)zmm0_2[2])[1] = *(int64_t*)((char*)predFilterData + 0x11);
00032f22          *(uint8_t*)((char*)zmm0_2[2])[3] = *((char*)predFilterData + 0x13);
00032f22          zmm0_2[3] = predFilterData->requiredDiamondMinWidth;
00032f27          uint64_t rax_2 = (uint64_t)(uint8_t)rsi;
00032f27          
00032f2f          if (!(zmm0_2[0] <= diamondWidths[rax_2]))
00032f2f          {
00032f31              predFilterData->predState = 2;
00032f3a              predFilterData->minWidth = diamondWidths[rax_2];
00032f2f          }
00032e6a      }
00032e6a      else if (predState == 2)
00032e6e      {
00032e74          zmm0_1[0] = predFilterData->minWidth;
00032e74          zmm0_1[1] = predFilterData->minWidth;
00032e74          zmm0_1[2] = predFilterData->minWidth;
00032e74          zmm0_1[3] = predFilterData->hasSwitchedDuringThisOcclusion;
00032e74          *(uint16_t*)((char*)zmm0_1[3])[1] = *(int64_t*)((char*)predFilterData + 0x11);
00032e74          *(uint8_t*)((char*)zmm0_1[3])[3] = *((char*)predFilterData + 0x13);
00032e85          double zmm1_1[0x2] = diamondWidths[(uint64_t)(uint8_t)rsi];
00032e85          
00032e99          if (!(zmm0_1[0] <= zmm1_1[0]))
00032e9b              predFilterData->minWidth = zmm1_1[0];
00032e99          else if (!(zmm1_1[0] <= (3.5f - zmm0_1[0]) * 0.400000006f + zmm0_1[0]))
00032ea8          {
00032eb2              if (orientation == O_HORIZONTAL)
00032eb2              {
00032eb4                  predFilterData->confidence = 0.800000012f;
00032ebb                  predFilterData->orientation = O_VERTICAL;
00032eb2              }
00032eb2              else if (orientation == O_VERTICAL)
00032ec9              {
00032ecb                  predFilterData->confidence = -0.800000012f;
00032ed2                  predFilterData->orientation = O_HORIZONTAL;
00032ec9              }
00032ec9              
00032ed5              predFilterData->predState = 0;
00032ed8              predFilterData->minWidth = 99999f;
00032edf              predFilterData->hasSwitchedDuringThisOcclusion = 1;
00032ea8          }
00032e6e      }
00032d90  }

00032f6e                                            cc cc cc cc cc cc                                                    ......

00032f74    void GenerateLineFitData(struct line_fit_t* lineFitData, struct fpoint_t* ptBuffer, uint8_t numPts)

00032f74  {
00032f84      struct fpoint_t* ptBuffer_1 = ptBuffer;
00032f89      int64_t rdi;
00032f89      (uint8_t)rdi = numPts;
00032f8c      int128_t zmm6;
00032f8c      int128_t var_18 = zmm6;
00032f97      int128_t sumXY;
00032f97      int128_t sumXY_1 = sumXY;
00032f9b      memset(lineFitData, 0, 0x18);
00032f9b      
00032fa3      if (!(uint8_t)rdi)
00032fa3          return;
00032fa3      
00032fa7      float sumX = lineFitData->sumX;
00032fac      float sumY = lineFitData->sumY;
00032fb1      uint64_t i_1 = (uint64_t)(uint8_t)rdi;
00032fb5      uint8_t rax_1 = lineFitData->numPts + (uint8_t)i_1;
00032fb7      float sumXSquared = lineFitData->sumXSquared;
00032fbc      (uint32_t)zmm6 = lineFitData->sumYSquared;
00032fbc      *(uint32_t*)((char*)zmm6)[4] = lineFitData->sumYSquared;
00032fc1      sumXY = lineFitData->sumXY;
00032ffa      uint64_t i;
00032ffa      
00032ffa      do
00032ffa      {
00032fc6          float y = ptBuffer_1->y;
00032fcb          float x = ptBuffer_1->x;
00032fcf          sumX = sumX + ptBuffer_1->x;
00032fde          sumY = sumY + y;
00032fe2          sumXSquared = sumXSquared + x * x;
00032fe6          (uint32_t)zmm6 = (uint32_t)zmm6 + y * y;
00032fea          y = y * ptBuffer_1->x;
00032fee          ptBuffer_1 = &ptBuffer_1[1];
00032ff2          i = i_1;
00032ff2          i_1 -= 1;
00032ff6          (uint32_t)sumXY = (uint32_t)sumXY + y;
00032ffa      } while (i != 1);
00032ffc      lineFitData->sumX = sumX;
00033001      lineFitData->sumY = sumY;
00033006      lineFitData->sumXSquared = sumXSquared;
0003300b      lineFitData->numPts = rax_1;
0003300d      lineFitData->sumYSquared = (uint32_t)zmm6;
00033012      lineFitData->sumXY = (uint32_t)sumXY;
00032f74  }

00033031                                                     cc cc cc cc cc cc cc                                           .......

00033038    uint8_t CalculateBestFitLineEquation(struct line_def_t* lineDef, struct line_fit_t* lineFitData, struct fpoint_t* dataPts, uint8_t numDataPts, float* lineError)

00033038  {
00033053      float* lineError_1 = lineError;
0003305b      int128_t zmm6;
0003305b      int128_t var_28 = zmm6;
0003305f      uint128_t zmm7;
0003305f      uint128_t var_38 = zmm7;
00033063      char rbx = 0;
00033065      int64_t rsi;
00033065      (uint8_t)rsi = numDataPts;
00033068      struct fpoint_t* B = dataPts;
0003306e      uint128_t zmm8;
0003306e      uint128_t var_48 = zmm8;
00033073      int128_t zmm9;
00033073      int128_t var_58 = zmm9;
00033073      
0003307b      if (lineError_1)
0003307d          *(uint32_t*)lineError_1 = 9999999f;
0003307d      
00033086      if (lineFitData->numPts >= 8)
00033086      {
0003308c          float sumX = lineFitData->sumX;
0003309c          float zmm4 = sumX * sumX;
000330a0          zmm8 = _mm_cvtepi32_ps((uint128_t)lineFitData->numPts);
000330a8          uint128_t zmm3;
000330a8          (uint32_t)zmm3 = (uint32_t)zmm8 * lineFitData->sumXSquared;
000330b0          uint128_t zmm0;
000330b0          (uint32_t)zmm0 = (uint32_t)zmm3 - zmm4;
000330b0          
000330ca          if (!(__andpd_xmmxuq_memxuq(_mm_cvtps_pd(_mm_unpacklo_ps(zmm0, (uint64_t)zmm0)), 
000330ca              __mask@@AbsDouble@) <= 1.0000000116860974e-07))
000330ca          {
000330d0              uint128_t zmm2;
000330d0              (uint32_t)zmm2 = lineFitData->sumY;
000330d0              *(uint32_t*)((char*)zmm2)[4] = lineFitData->sumY;
000330d0              *(uint32_t*)((char*)zmm2)[8] = lineFitData->sumY;
000330d0              *(uint32_t*)((char*)zmm2)[0xc] = lineFitData->sumY;
000330d5              zmm6 = {0};
000330dc              uint128_t zmm1;
000330dc              (uint32_t)zmm1 = (uint32_t)zmm8 * lineFitData->sumXY;
000330e4              (uint32_t)zmm3 = (uint32_t)zmm3 - zmm4;
000330e8              zmm7 = {0};
000330eb              (uint32_t)zmm0 = (uint32_t)zmm2 * sumX;
000330ef              (uint32_t)zmm1 = (uint32_t)zmm1 - (uint32_t)zmm0;
000330f3              (uint32_t)zmm1 = (uint32_t)zmm1 / (uint32_t)zmm3;
000330f7              lineDef->m = (uint32_t)zmm1;
000330fb              (uint32_t)zmm1 = (uint32_t)zmm1 * sumX;
000330ff              (uint32_t)zmm2 = (uint32_t)zmm2 - (uint32_t)zmm1;
00033103              (uint32_t)zmm2 = (uint32_t)zmm2 / (uint32_t)zmm8;
00033111              lineDef->c = (uint32_t)zmm2;
00033111              
00033119              if ((uint8_t)rsi > 0)
00033119              {
00033128                  uint64_t i_1 = (uint64_t)(uint8_t)rsi;
000331be                  uint64_t i;
000331be                  
000331be                  do
000331be                  {
0003313f                      (uint32_t)zmm1 = 1f / lineDef->m;
00033145                      zmm1 ^= 0x80000000;
00033149                      int32_t var_88_1 = (uint32_t)zmm1;
0003314f                      (uint32_t)zmm1 = (uint32_t)zmm1 * B->x;
00033154                      (uint32_t)zmm0 = B->y - (uint32_t)zmm1;
00033158                      int32_t var_84_1 = (uint32_t)zmm0;
0003315e                      int64_t rax_1 = var_88_1;
00033161                      struct line_def_t lineB;
00033161                      lineB.m = (uint32_t)rax_1;
00033161                      lineB.c = *(uint32_t*)((char*)rax_1)[4];
0003316c                      int32_t var_80;
0003316c                      lineB.weight = var_80;
00033178                      struct line_def_t lineA;
00033178                      lineA.m = lineDef->m;
0003317e                      lineA.c = lineDef->c;
00033185                      lineA.weight = lineDef->weight;
0003318d                      struct fpoint_t rax_6 = SFP_LineIntersect(&lineA, &lineB);
0003319d                      (uint32_t)lineError = rax_6.x;
0003319d                      *(uint32_t*)((char*)lineError)[4] = rax_6.y;
000331a5                      zmm0 = DistanceSquare(&lineError, B);
000331ad                      (uint32_t)zmm6 = (uint32_t)zmm6 + (uint32_t)zmm0;
000331ad                      
000331b1                      if (!((uint32_t)zmm0 <= (uint32_t)zmm7))
000331b3                          zmm7 = zmm0;
000331b3                      
000331b6                      B = &B[1];
000331ba                      i = i_1;
000331ba                      i_1 -= 1;
000331be                  } while (i != 1);
00033119              }
00033119              
000331cf              (uint32_t)zmm6 = (uint32_t)zmm6 / _mm_cvtepi32_ps((uint128_t)(uint8_t)rsi);
000331cf              
000331d6              if (lineError_1)
000331d8                  *(uint32_t*)lineError_1 = (uint32_t)zmm6;
000331d8              
000331ed              if (!(1f <= (uint32_t)zmm6) && !(2.25f <= (uint32_t)zmm7))
000331ef                  rbx = 1;
000330ca          }
00033086      }
00033086      
000331fe      uint32_t rax;
000331fe      (uint8_t)rax = rbx;
00033223      return (uint8_t)rax;
00033038  }

00033224              cc cc cc cc cc cc cc cc                                                                  ........

0003322c    void AddPointDataToStraightLineBuffer(struct fpoint_t* buffer, uint8_t* numPts, struct fpoint_t ptToAdd)

0003322c  {
00033231      int64_t arg_18;
00033231      (uint32_t)arg_18 = ptToAdd.x;
00033231      *(uint32_t*)((char*)arg_18)[4] = ptToAdd.y;
0003323b      uint8_t rax = *(uint8_t*)numPts;
0003323b      
00033245      if (rax >= 0x14)
00033245      {
00033255          memmove(buffer, &buffer[1], (uint64_t)(rax - 1) << 3);
00033263          buffer[(uint64_t)*(uint8_t*)numPts - 1].x = arg_18;
00033263          return;
00033245      }
00033245      
0003326a      uint64_t rax_2 = (uint64_t)rax;
0003326d      buffer[rax_2].x = ptToAdd.x;
0003326d      buffer[rax_2].y = ptToAdd.y;
00033271      *(uint8_t*)numPts += 1;
0003322c  }

0003327e                                                                                            cc cc                                ..
00033280  cc cc cc cc                                                                                      ....

00033284    struct line_def_t* RecalculateLineEquationWithNewSlope(struct line_def_t* __return, struct fpoint_t* ptsBuffer, uint8_t numPts, float newSlope)

00033284  {
00033284      int32_t zmm1 = (int32_t){0};
00033287      int32_t arg_8 = 0;
0003328d      int32_t zmm2 = (int32_t){0};
00033290      int32_t arg_c = zmm2;
0003329e      uint128_t zmm0;
0003329e      
0003329e      if (ptsBuffer && numPts)
0003329e      {
000332a0          uint64_t rax_1 = (uint64_t)numPts;
000332b5          uint64_t i;
000332b5          
000332b5          do
000332b5          {
000332a4              zmm1 = zmm1 + ptsBuffer->x;
000332a8              zmm2 = zmm2 + ptsBuffer->y;
000332ad              ptsBuffer = &ptsBuffer[1];
000332b1              i = rax_1;
000332b1              rax_1 -= 1;
000332b5          } while (i != 1);
000332bf          zmm0 = _mm_cvtepi32_ps((uint128_t)numPts);
000332ca          arg_8 = zmm1 / (uint32_t)zmm0;
000332d0          arg_c = zmm2 / (uint32_t)zmm0;
0003329e      }
0003329e      
000332db      __return->m = newSlope;
000332df      arg_8 = arg_8;
000332ed      (uint32_t)zmm0 = arg_8 * newSlope;
000332f8      (uint32_t)zmm0 = (zmm0 ^ __mask@@NegFloat@) + arg_c;
000332fe      __return->c = (uint32_t)zmm0;
00033303      return __return;
00033284  }

00033304              cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00      ..................ff........

00033320    int64_t __security_check_cookie(int64_t arg1)

00033320  {
00033327      if (arg1 == __security_cookie)
00033327      {
00033329          int64_t rcx = ROLQ(arg1, 0x10);
00033329          
00033332          if (!((uint16_t)rcx & 0xffff))
00033334              return;
00033334          
00033337          arg1 = RORQ(rcx, 0x10);
00033327      }
00033327      
0003333b      /* tailcall */
0003333b      return __report_gsfailure(arg1);
00033320  }

00033340  cc cc cc cc cc cc cc cc                                                                          ........

00033348    void __report_gsfailure(uint64_t StackCookie) __noreturn

00033348  {
00033368      KeBugCheckEx(DRIVER_OVERRAN_STACK_BUFFER, StackCookie, __security_cookie, 
00033368          __security_cookie_complement, 0);
0003336e      breakpoint();
00033348  }

0003336f                                               cc cc cc cc cc cc cc                                               .......

00033376    uint32_t j_DbgPrint(char* Format, ...)

00033376  {
00033376      /* tailcall */
00033376      return DbgPrint(Format);
00033376  }

0003337c                                                                                      cc cc cc cc                              ....
00033380  cc cc                                                                                            ..

00033382    int64_t j__vsnprintf()

00033382  {
00033382      /* tailcall */
00033382      return _vsnprintf();
00033382  }

00033388                          cc cc cc cc cc cc                                                                ......

0003338e    int64_t j_strrchr()

0003338e  {
0003338e      /* tailcall */
0003338e      return strrchr();
0003338e  }

00033394                                                              cc cc cc cc cc cc cc cc cc cc cc cc                      ............
000333a0  cc cc cc cc cc cc 66 66 66 90 66 66 66 90 66 90                                                  ......fff.fff.f.

000333b0    char* memmove(char* arg1, int64_t arg2, int64_t arg3)

000333b0  {
000333b0      char* result = arg1;
000333b3      char* rdx = arg2 - arg1;
000333b6      uint64_t rax;
000333b6      
000333b6      if (arg2 > arg1)
000333b6      {
000333c0          if (arg3 >= 8)
000333c0          {
000333c5              if ((uint8_t)arg1 & 7)
000333c5              {
000333ca                  if ((uint8_t)arg1 & 1)
000333ca                  {
000333cc                      (uint8_t)rax = *(uint8_t*)(rdx + arg1);
000333cf                      arg3 -= 1;
000333d2                      *(uint8_t*)arg1 = (uint8_t)rax;
000333d4                      arg1 = &arg1[1];
000333ca                  }
000333ca                  
000333db                  if ((uint8_t)arg1 & 2)
000333db                  {
000333dd                      (uint16_t)rax = *(uint16_t*)(rdx + arg1);
000333e1                      arg3 -= 2;
000333e5                      *(uint16_t*)arg1 = (uint16_t)rax;
000333e8                      arg1 = &arg1[2];
000333db                  }
000333db                  
000333ef                  if ((uint8_t)arg1 & 4)
000333ef                  {
000333f4                      arg3 -= 4;
000333f8                      *(uint32_t*)arg1 = *(uint32_t*)(rdx + arg1);
000333fa                      arg1 = &arg1[4];
000333ef                  }
000333c5              }
000333c5              
00033401              while (true)
00033401              {
00033401                  uint64_t i_6 = arg3 >> 5;
00033401                  
00033405                  if (!i_6)
00033405                      break;
00033405                  
000334a9                  if (i_6 < 0x800 || rdx < 0x1000)
000334a9                  {
0003348a                      uint64_t i;
0003348a                      
0003348a                      do
0003348a                      {
00033460                          int64_t rax_3 = *(uint64_t*)(rdx + arg1);
00033464                          int64_t r10_1 = *(uint64_t*)(rdx + arg1 + 8);
00033469                          arg1 = &arg1[0x20];
0003346d                          *(uint64_t*)(arg1 - 0x20) = rax_3;
00033471                          *(uint64_t*)(arg1 - 0x18) = r10_1;
0003347a                          int64_t r10_2 = *(uint64_t*)(rdx + arg1 - 8);
0003347f                          i = i_6;
0003347f                          i_6 -= 1;
00033482                          *(uint64_t*)(arg1 - 0x10) = *(uint64_t*)(rdx + arg1 - 0x10);
00033486                          *(uint64_t*)(arg1 - 8) = r10_2;
0003348a                      } while (i != 1);
0003348c                      arg3 &= 0x1f;
00033490                      break;
000334a9                  }
000334a9                  
00033534                  do
00033534                  {
000334ab                      int32_t j_4 = 0x20;
000334c2                      int32_t j;
000334c2                      
000334c2                      do
000334c2                      {
000334b9                          arg1 = &arg1[0x80];
000334c0                          j = j_4;
000334c0                          j_4 -= 1;
000334c2                      } while (j != 1);
000334c4                      arg1 -= 0x1000;
000334cb                      rax = 0x40;
00033524                      int32_t j_1;
00033524                      
00033524                      do
00033524                      {
000334d4                          int64_t r10_3 = *(uint64_t*)(rdx + arg1 + 8);
000334d9                          *(uint64_t*)arg1 = *(uint64_t*)(rdx + arg1);
000334dd                          *(uint64_t*)(arg1 + 8) = r10_3;
000334e7                          int64_t r10_4 = *(uint64_t*)(rdx + arg1 + 0x18);
000334ec                          *(uint64_t*)(arg1 + 0x10) = *(uint64_t*)(rdx + arg1 + 0x10);
000334f1                          *(uint64_t*)(arg1 + 0x18) = r10_4;
000334f6                          int64_t r9_5 = *(uint64_t*)(rdx + arg1 + 0x20);
000334fb                          int64_t r10_5 = *(uint64_t*)(rdx + arg1 + 0x28);
00033500                          arg1 = &arg1[0x40];
00033504                          *(uint64_t*)(arg1 - 0x20) = r9_5;
00033509                          *(uint64_t*)(arg1 - 0x18) = r10_5;
00033513                          int64_t r10_6 = *(uint64_t*)(rdx + arg1 - 8);
00033518                          j_1 = (uint32_t)rax;
00033518                          rax = (uint64_t)((uint32_t)rax - 1);
0003351a                          *(uint64_t*)(arg1 - 0x10) = *(uint64_t*)(rdx + arg1 - 0x10);
0003351f                          *(uint64_t*)(arg1 - 8) = r10_6;
00033524                      } while (j_1 != 1);
00033526                      arg3 -= 0x1000;
00033534                  } while (arg3 >= 0x1000);
00033534                  
0003353a                  (uint8_t)__return_addr = (uint8_t)__return_addr;
0003353f                  continue;
00033401              }
00033401              
0003340a              uint64_t i_7 = arg3 >> 3;
0003340a              
0003340e              if (i_7)
0003340e              {
0003341e                  uint64_t i_1;
0003341e                  
0003341e                  do
0003341e                  {
00033414                      *(uint64_t*)arg1 = *(uint64_t*)(rdx + arg1);
00033417                      arg1 = &arg1[8];
0003341b                      i_1 = i_7;
0003341b                      i_7 -= 1;
0003341e                  } while (i_1 != 1);
00033420                  arg3 &= 7;
0003340e              }
000333c0          }
000333c0          
00033427          if (arg3)
00033427          {
0003343b              int64_t i_2;
0003343b              
0003343b              do
0003343b              {
00033430                  (uint8_t)rax = *(uint8_t*)(rdx + arg1);
00033433                  *(uint8_t*)arg1 = (uint8_t)rax;
00033435                  arg1 = &arg1[1];
00033438                  i_2 = arg3;
00033438                  arg3 -= 1;
0003343b              } while (i_2 != 1);
00033427          }
00033427          
0003342c          return result;
000333b6      }
000333b6      
00033558      if (arg2 != arg1)
00033558      {
0003355a          int32_t* rcx = &arg1[arg3];
0003355a          
00033561          if (arg3 >= 8)
00033561          {
00033566              if ((uint8_t)rcx & 7)
00033566              {
0003356b                  if ((uint8_t)rcx & 1)
0003356b                  {
0003356d                      rcx -= 1;
00033570                      (uint8_t)rax = *(uint8_t*)(rdx + rcx);
00033573                      arg3 -= 1;
00033576                      *(uint8_t*)rcx = (uint8_t)rax;
0003356b                  }
0003356b                  
0003357b                  if ((uint8_t)rcx & 2)
0003357b                  {
0003357d                      rcx -= 2;
00033581                      (uint16_t)rax = *(uint16_t*)(rdx + rcx);
00033585                      arg3 -= 2;
00033589                      *(uint16_t*)rcx = (uint16_t)rax;
0003357b                  }
0003357b                  
0003358f                  if ((uint8_t)rcx & 4)
0003358f                  {
00033591                      rcx -= 4;
00033598                      arg3 -= 4;
0003359c                      *(uint32_t*)rcx = *(uint32_t*)(rdx + rcx);
0003358f                  }
00033566              }
00033566              
000335a1              while (true)
000335a1              {
000335a1                  uint64_t i_8 = arg3 >> 5;
000335a1                  
000335a5                  if (!i_8)
000335a5                      break;
000335a5                  
00033649                  if (i_8 < 0x800 || rdx > -0x1000)
00033649                  {
00033629                      uint64_t i_3;
00033629                      
00033629                      do
00033629                      {
00033600                          int64_t rax_6 = *(uint64_t*)(rdx + rcx - 8);
00033605                          int64_t r10_7 = *(uint64_t*)(rdx + rcx - 0x10);
0003360a                          rcx -= 0x20;
0003360e                          *(uint64_t*)((char*)rcx + 0x18) = rax_6;
00033612                          *(uint64_t*)((char*)rcx + 0x10) = r10_7;
0003361b                          int64_t r10_8 = *(uint64_t*)(rdx + rcx);
0003361f                          i_3 = i_8;
0003361f                          i_8 -= 1;
00033622                          *(uint64_t*)((char*)rcx + 8) = *(uint64_t*)(rdx + rcx + 8);
00033626                          *(uint64_t*)rcx = r10_8;
00033629                      } while (i_3 != 1);
0003362b                      arg3 &= 0x1f;
0003362f                      break;
00033649                  }
00033649                  
000336d4                  do
000336d4                  {
0003364b                      int32_t j_5 = 0x20;
00033662                      int32_t j_2;
00033662                      
00033662                      do
00033662                      {
00033650                          rcx -= 0x80;
00033660                          j_2 = j_5;
00033660                          j_5 -= 1;
00033662                      } while (j_2 != 1);
00033664                      rcx = &rcx[0x400];
0003366b                      rax = 0x40;
000336c4                      int32_t j_3;
000336c4                      
000336c4                      do
000336c4                      {
00033675                          int64_t r10_9 = *(uint64_t*)(rdx + rcx - 0x10);
0003367a                          *(uint64_t*)((char*)rcx - 8) = *(uint64_t*)(rdx + rcx - 8);
0003367f                          *(uint64_t*)((char*)rcx - 0x10) = r10_9;
00033689                          int64_t r10_10 = *(uint64_t*)(rdx + rcx - 0x20);
0003368e                          *(uint64_t*)((char*)rcx - 0x18) = *(uint64_t*)(rdx + rcx - 0x18);
00033693                          *(uint64_t*)((char*)rcx - 0x20) = r10_10;
00033698                          int64_t r9_11 = *(uint64_t*)(rdx + rcx - 0x28);
0003369d                          int64_t r10_11 = *(uint64_t*)(rdx + rcx - 0x30);
000336a2                          rcx -= 0x40;
000336a6                          *(uint64_t*)((char*)rcx + 0x18) = r9_11;
000336ab                          *(uint64_t*)((char*)rcx + 0x10) = r10_11;
000336b5                          int64_t r10_12 = *(uint64_t*)(rdx + rcx);
000336b9                          j_3 = (uint32_t)rax;
000336b9                          rax = (uint64_t)((uint32_t)rax - 1);
000336bb                          *(uint64_t*)((char*)rcx + 8) = *(uint64_t*)(rdx + rcx + 8);
000336c0                          *(uint64_t*)rcx = r10_12;
000336c4                      } while (j_3 != 1);
000336c6                      arg3 -= 0x1000;
000336d4                  } while (arg3 >= 0x1000);
000336d4                  
000336da                  (uint8_t)__return_addr = (uint8_t)__return_addr;
000336df                  continue;
000335a1              }
000335a1              
000335aa              uint64_t i_9 = arg3 >> 3;
000335aa              
000335ae              if (i_9)
000335ae              {
000335be                  uint64_t i_4;
000335be                  
000335be                  do
000335be                  {
000335b0                      rcx -= 8;
000335b8                      i_4 = i_9;
000335b8                      i_9 -= 1;
000335bb                      *(uint64_t*)rcx = *(uint64_t*)(rdx + rcx);
000335be                  } while (i_4 != 1);
000335c0                  arg3 &= 7;
000335ae              }
00033561          }
00033561          
000335c7          if (arg3)
000335c7          {
000335db              int64_t i_5;
000335db              
000335db              do
000335db              {
000335d0                  rcx -= 1;
000335d3                  (uint8_t)rax = *(uint8_t*)(rdx + rcx);
000335d6                  i_5 = arg3;
000335d6                  arg3 -= 1;
000335d9                  *(uint8_t*)rcx = (uint8_t)rax;
000335db              } while (i_5 != 1);
000335c7          }
00033558      }
00033558      
000335cc      return result;
000333b0  }

0003342d                                         66 66 90                                                               ff.
00033441     66 66 66 90 66 66 66 90 66 66 66 90 66 66 90 66 66 66 90 66 66 90                              fff.fff.fff.ff.fff.ff.
00033495                                                                 66 66 66 90 66 66 66 90 66 66 90                       fff.fff.ff.
000334a0  66 90                                                                                            f.
00033544              66 66 66 90 66 66 66 90 66 66 66 90 66 66 66 90 66 66 66 90                              fff.fff.fff.fff.fff.
000335cd                                         66 66 90                                                               ff.
000335e1     66 66 66 90 66 66 66 90 66 66 66 90 66 66 90 66 66 66 90 66 66 90                              fff.fff.fff.ff.fff.ff.
00033634                                                              66 66 66 90 66 66 66 90 66 66 66 90                      fff.fff.fff.
00033640  66 90                                                                                            f.
000336e4              cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 66 66 66 90 66 66 66 90 66 90      ..................fff.fff.f.

00033700    int64_t* memset(void* arg1, int64_t arg2, int64_t arg3)

00033700  {
00033700      int64_t* result = arg1;
00033700      
00033707      if (arg3 >= 8)
00033707      {
00033716          arg2 = (uint64_t)(uint8_t)arg2 * 0x101010101010101;
00033716          
0003371e          if (arg3 >= 0x40)
0003371e          {
00033723              uint64_t rcx_1 = (uint64_t)(uint32_t)-(arg1) & 7;
00033723              
00033726              if ((uint32_t)rcx_1)
00033726              {
00033728                  arg3 -= rcx_1;
0003372b                  *(uint64_t*)result = arg2;
00033726              }
00033726              
0003372e              arg1 = rcx_1 + result;
00033731              int64_t r9_1 = arg3;
00033734              arg3 &= 0x3f;
00033738              uint64_t i_4 = r9_1 >> 6;
00033738              
0003373c              if (i_4)
0003373c              {
0003377e                  if (i_4 >= 0x400)
0003377e                  {
000337de                      uint64_t i;
000337de                      
000337de                      do
000337de                      {
000337b0                          *(uint64_t*)arg1 = arg2;
000337b4                          *(uint64_t*)((char*)arg1 + 8) = arg2;
000337b9                          *(uint64_t*)((char*)arg1 + 0x10) = arg2;
000337be                          arg1 += 0x40;
000337c2                          *(uint64_t*)((char*)arg1 - 0x28) = arg2;
000337c7                          *(uint64_t*)((char*)arg1 - 0x20) = arg2;
000337cc                          i = i_4;
000337cc                          i_4 -= 1;
000337cf                          *(uint64_t*)((char*)arg1 - 0x18) = arg2;
000337d4                          *(uint64_t*)((char*)arg1 - 0x10) = arg2;
000337d9                          *(uint64_t*)((char*)arg1 - 8) = arg2;
000337de                      } while (i != 1);
000337e0                      (uint8_t)__return_addr = (uint8_t)__return_addr;
0003377e                  }
0003377e                  else
0003377e                  {
000337a6                      uint64_t i_1;
000337a6                      
000337a6                      do
000337a6                      {
00033780                          *(uint64_t*)arg1 = arg2;
00033783                          *(uint64_t*)((char*)arg1 + 8) = arg2;
00033787                          *(uint64_t*)((char*)arg1 + 0x10) = arg2;
0003378b                          arg1 += 0x40;
0003378f                          *(uint64_t*)((char*)arg1 - 0x28) = arg2;
00033793                          *(uint64_t*)((char*)arg1 - 0x20) = arg2;
00033797                          i_1 = i_4;
00033797                          i_4 -= 1;
0003379a                          *(uint64_t*)((char*)arg1 - 0x18) = arg2;
0003379e                          *(uint64_t*)((char*)arg1 - 0x10) = arg2;
000337a2                          *(uint64_t*)((char*)arg1 - 8) = arg2;
000337a6                      } while (i_1 != 1);
0003377e                  }
0003373c              }
0003371e          }
0003371e          
0003373e          int64_t r9_2 = arg3;
00033741          arg3 &= 7;
00033745          uint64_t i_5 = r9_2 >> 3;
00033745          
00033749          if (i_5)
00033749          {
0003375a              uint64_t i_2;
0003375a              
0003375a              do
0003375a              {
00033750                  *(uint64_t*)arg1 = arg2;
00033753                  arg1 += 8;
00033757                  i_2 = i_5;
00033757                  i_5 -= 1;
0003375a              } while (i_2 != 1);
00033749          }
00033707      }
00033707      
0003375f      if (arg3)
0003375f      {
00033769          int64_t i_3;
00033769          
00033769          do
00033769          {
00033761              *(uint8_t*)arg1 = (uint8_t)arg2;
00033763              arg1 += 1;
00033766              i_3 = arg3;
00033766              arg3 -= 1;
00033769          } while (i_3 != 1);
0003375f      }
0003375f      
0003376b      return result;
00033700  }

0003376c                                      66 66 66 90 66 66 66 90 66 66 90                                         fff.fff.ff.
000337aa                                66 66 90 66 66 90                                                            ff.ff.
000337ea                                cc cc cc cc cc cc cc cc cc cc cc cc 66 66 66 90 66 66 66 90 66 90            ............fff.fff.f.

00033800    uint64_t memcmp(char* arg1, int64_t arg2, int64_t arg3)

00033800  {
00033800      char* rdx = arg2 - arg1;
00033807      uint64_t rax;
00033807      bool c_1;
00033807      
00033807      if (arg3 >= 8)
00033807      {
0003380c          while ((uint8_t)arg1 & 7)
0003380c          {
00033810              (uint8_t)rax = *(uint8_t*)arg1;
00033812              char temp4_1 = *(uint8_t*)(rdx + arg1);
00033812              c_1 = (uint8_t)rax < temp4_1;
00033812              
00033815              if ((uint8_t)rax != temp4_1)
00033815                  goto label_33843;
00033815              
00033817              arg1 = &arg1[1];
0003381a              arg3 -= 1;
0003380c          }
0003380c          
00033825          uint64_t r9_2 = arg3 >> 3;
00033825          
00033829          if (r9_2)
00033829          {
0003384a              uint64_t i_2 = r9_2 >> 2;
0003384a              
0003384e              if (i_2)
0003384e              {
00033881                  uint64_t i;
00033881                  
00033881                  do
00033881                  {
00033850                      rax = *(uint64_t*)arg1;
00033850                      
00033857                      if (rax != *(uint64_t*)(rdx + arg1))
00033857                          goto label_338b4;
00033857                      
00033859                      rax = *(uint64_t*)(arg1 + 8);
00033859                      
00033862                      if (rax != *(uint64_t*)(rdx + arg1 + 8))
00033862                          goto label_338b0;
00033862                      
00033864                      rax = *(uint64_t*)(arg1 + 0x10);
00033864                      
0003386d                      if (rax != *(uint64_t*)(rdx + arg1 + 0x10))
0003386d                          goto label_338ac;
0003386d                      
0003386f                      rax = *(uint64_t*)(arg1 + 0x18);
0003386f                      
00033878                      if (rax != *(uint64_t*)(rdx + arg1 + 0x18))
00033878                      {
000338a8                          arg1 = &arg1[8];
000338ac                      label_338ac:
000338ac                          arg1 = &arg1[8];
000338b0                      label_338b0:
000338b0                          arg1 = &arg1[8];
000338b4                      label_338b4:
000338b4                          uint64_t rcx = *(uint64_t*)(arg1 + rdx);
000338b8                          uint64_t rax_4 = _bswap(rax);
000338c1                          int32_t rax_5 = (uint32_t)rax_4 - (uint32_t)rax_4;
000338c1                          bool c_4 = /* bool c_4 = unimplemented  {sbb eax, eax} */;
000338c6                          return (uint64_t)(rax_5 + 1);
00033878                      }
00033878                      
0003387a                      arg1 = &arg1[0x20];
0003387e                      i = i_2;
0003387e                      i_2 -= 1;
00033881                  } while (i != 1);
00033883                  arg3 &= 0x1f;
0003384e              }
0003384e              
0003388a              uint64_t i_3 = arg3 >> 3;
0003388a              
0003388e              if (i_3)
0003388e              {
000338a0                  uint64_t i_1;
000338a0                  
000338a0                  do
000338a0                  {
00033890                      rax = *(uint64_t*)arg1;
00033890                      
00033897                      if (rax != *(uint64_t*)(rdx + arg1))
00033897                          goto label_338b4;
00033897                      
00033899                      arg1 = &arg1[8];
0003389d                      i_1 = i_3;
0003389d                      i_3 -= 1;
000338a0                  } while (i_1 != 1);
000338a2                  arg3 &= 7;
0003388e              }
00033829          }
00033807      }
00033807      
0003382e      if (!arg3)
00033842          return 0;
00033842      
00033830      while (true)
00033830      {
00033830          (uint8_t)rax = *(uint8_t*)arg1;
00033832          char temp0_1 = *(uint8_t*)(rdx + arg1);
00033832          c_1 = (uint8_t)rax < temp0_1;
00033832          
00033835          if ((uint8_t)rax != temp0_1)
00033835              break;
00033835          
00033837          arg1 = &arg1[1];
0003383a          int64_t temp3_1 = arg3;
0003383a          arg3 -= 1;
0003383a          
0003383d          if (temp3_1 == 1)
00033842              return 0;
00033830      }
00033830      
00033843  label_33843:
00033843      bool c_2 = /* bool c_2 = unimplemented  {sbb eax, eax} */;
00033848      return (uint64_t)((uint32_t)rax - (uint32_t)rax + 1);
00033800  }

00033849                             90                                                                             .
000338c7                       cc cc cc cc cc cc cc cc cc                                                         .........

000338d0    void __GSHandlerCheckCommon(void* EstablisherFrame, struct _DISPATCHER_CONTEXT* DispatcherContext, struct _GS_HANDLER_DATA* GSHandlerData)

000338d0  {
000338dc      void* EstablisherFrame_1 = EstablisherFrame;
000338e7      void* EstablisherFrame_2 = EstablisherFrame;
000338e7      
000338ea      if (*(uint8_t*)((char*)GSHandlerData->u + 0) & 4)
000338fc          EstablisherFrame_2 = ((int64_t)GSHandlerData->AlignedBaseOffset
000338fc              + EstablisherFrame) & (int64_t)-(GSHandlerData->Alignment);
000338fc      
0003390d      void* rcx_2 = (uint64_t)*(uint32_t*)(*(int64_t*)((char*)DispatcherContext + 0x10) + 8)
0003390d          + *(int64_t*)((char*)DispatcherContext + 8);
0003390d      
00033915      if (*(uint8_t*)((char*)rcx_2 + 3) & 0xf)
00033920          EstablisherFrame_1 +=
00033920              (int64_t)((uint32_t)*(uint8_t*)((char*)rcx_2 + 3) & 0xfffffff0);
00033920      
0003392e      /* tailcall */
0003392e      return __security_check_cookie(EstablisherFrame_1 ^ *(uint64_t*)(
0003392e          (int64_t)(*(uint32_t*)((char*)GSHandlerData->u + 0) & 0xfffffff8)
0003392e          + EstablisherFrame_2));
000338d0  }

00033933                                                           cc cc cc cc cc cc cc cc cc                                 .........

0003393c    enum _EXCEPTION_DISPOSITION __GSHandlerCheck(struct _EXCEPTION_RECORD* ExceptionRecord, void* EstablisherFrame, struct _CONTEXT* ContextRecord, struct _DISPATCHER_CONTEXT* DispatcherContext)

0003393c  {
0003394a      __GSHandlerCheckCommon(EstablisherFrame, DispatcherContext, 
0003394a          *(int64_t*)((char*)DispatcherContext + 0x38));
00033958      return 1;
0003393c  }

00033959                                                                             cc cc cc cc cc cc cc                           .......

00033960    int64_t __convention("sysv") pow(uint128_t arg1 @ zmm0, double arg2[0x2] @ zmm1, uint64_t arg3[0x2] @ zmm2, double arg4, double arg5, uint64_t arg6[0x2] @ zmm5, uint64_t arg7[0x2] @ zmm6, uint64_t arg8[0x2] @ zmm8, uint64_t arg9[0x2] @ zmm9)

00033960  {
00033985      int64_t bitret_1 = (int64_t)arg1;
0003398a      int64_t bitret = (int64_t)arg2;
000339a2      int64_t bitret_5 = 0x7fffffffffffffff & bitret_1;
000339a8      uint64_t bitret_2 = 0x7fffffffffffffff & bitret;
000339ab      int32_t result = 0;
000339ab      
000339b8      if (0x3ff0000000000000 != bitret_1)
000339b8      {
000339c1          if (!bitret_2)
00033a84              (uint64_t)arg1 = 0x3ff0000000000000;
000339c1          else
000339c1          {
000339c7              uint64_t var_38_1[0x2] = arg7;
000339cf              uint128_t zmm7;
000339cf              uint128_t var_48_1 = zmm7;
000339d7              uint64_t var_58_1[0x2] = arg8;
000339ed              int64_t rax = 0x7ff0000000000000 & bitret_5;
000339ed              
00033a05              if (rax != 0x7ff0000000000000 || !(0xfffffffffffff & bitret_5))
00033a05              {
00033a0b                  uint64_t var_68_1[0x2] = arg9;
00033a14                  int128_t zmm10;
00033a14                  int128_t var_78_1 = zmm10;
00033a1d                  int128_t zmm11;
00033a1d                  int128_t var_88_1 = zmm11;
00033a27                  int128_t zmm12;
00033a27                  int128_t var_98_1 = zmm12;
00033a2d                  uint128_t zmm13;
00033a2d                  uint128_t var_a8_1 = zmm13;
00033a36                  int64_t rax_2 = 0x7ff0000000000000 & bitret_2;
00033a36                  
00033a4e                  if (rax_2 != 0x7ff0000000000000 || !(0xfffffffffffff & bitret_2))
00033a4e                  {
00033a54                      result = 0;
00033a54                      
00033a61                      if (0x3ff0000000000000 != bitret)
00033a61                      {
00033a67                          result = 0;
00033a67                          
00033a74                          if (bitret_2 <= 0x43e0000000000000)
00033a74                          {
00033d60                              uint64_t temp0_10[0x2] = _mm_xor_pd(arg7, arg7);
00033d64                              uint64_t temp0_11[0x2] = _mm_xor_pd(arg3, arg3);
00033d77                              int64_t rbx_1 = 1;
00033d77                              
00033d80                              if ((int32_t)(rax_2 >> 0x34) - 0x3fe < 1)
00033d80                                  rbx_1 = 0;
00033d80                              
00033d83                              if ((int32_t)(rax_2 >> 0x34) - 0x3fe >= 1)
00033d83                              {
00033d8e                                  if ((int32_t)(rax_2 >> 0x34) - 0x3fe <= 0x35)
00033d8e                                  {
00033d9c                                      rbx_1 = (rbx_1
00033d9c                                          << (0x35 - ((int32_t)(rax_2 >> 0x34) - 0x3fe))) - 1;
00033da2                                      int64_t rax_12 = bitret & rbx_1;
00033da2                                      
00033da5                                      if (rax_12)
00033da5                                          rbx_1 = 0;
00033da5                                      
00033da8                                      if (!rax_12)
00033da8                                      {
00033db9                                          bool cond:4_1 = (bitret & ~rbx_1) >> (0x35
00033db9                                              - ((int32_t)(rax_2 >> 0x34) - 0x3fe)) & 1;
00033dbc                                          rbx_1 = 1;
00033dbc                                          
00033dbe                                          if (!cond:4_1)
00033dc0                                              rbx_1 = 2;
00033da8                                      }
00033d8e                                  }
00033d8e                                  else
00033d90                                      rbx_1 = 2;
00033d83                              }
00033d83                              
00033dc2                              int32_t result_1 = (uint32_t)rbx_1;
00033dc6                              uint64_t temp0_12[0x2] = _mm_xor_pd(arg8, arg8);
00033dcb                              result = 0;
00033dcb                              
00033dd8                              if (0x7ff0000000000000 == rax)
00033dd8                              {
00033c7d                                  if (bitret_1 != bitret_5)
00033c7d                                  {
00033c8d                                      result = result_1;
00033c8d                                      
00033c94                                      if (result != 1)
00033cab                                          _mm_xor_pd(arg1, arg1);
00033c94                                      else if (bitret != bitret_2)
00033c9b                                          (uint64_t)arg1 = -0x8000000000000000;
00033c7d                                  }
00033c7d                                  else if (bitret != bitret_2)
00033c84                                      _mm_xor_pd(arg1, arg1);
00033dd8                              }
00033dd8                              else if (bitret_5)
00033de1                              {
00033de7                                  uint64_t r11_2 = 0;
00033de7                                  
00033ded                                  if (bitret_1 == bitret_5)
00033ded                                  {
00033e06                                  label_33e06:
00033e06                                      int32_t result_2 = (uint32_t)r11_2;
00033e06                                      
00033e18                                      if (bitret_2 < 0x3c00000000000000)
00033e18                                      {
00033d2f                                          result = 0;
00033d3d                                          _mm_xor_pd(arg6, arg6);
00033d46                                          _mm_xor_pd(arg9, arg9);
00033d4b                                          (uint64_t)arg1 = 0x3ff0000000000000 + arg2[0];
00033e18                                      }
00033e18                                      else
00033e18                                      {
00033e2b                                          int32_t rbx_4;
00033e2b                                          
00033e2b                                          if (bitret_1 >= 0x10000000000000)
00033e2b                                          {
00033e5d                                              (uint64_t)zmm13 = (int64_t)arg1;
00033e62                                              rbx_4 = 0;
00033e2b                                          }
00033e2b                                          else
00033e2b                                          {
00033e47                                              (uint64_t)zmm13 = (0x3d0000000000000
00033e47                                                  | bitret_1) - 2.5653355008114852e-290;
00033e4c                                              rbx_4 = 0x3c;
00033e57                                              bitret_1 = (uint64_t)zmm13;
00033e2b                                          }
00033e2b                                          
00033e64                                          int32_t var_f4_1 = rbx_4;
00033eac                                          temp0_11[0] = 0x3f80000000000000;
00033ec1                                          (uint64_t)zmm13 = (0xfffffffffffff & bitret_1)
00033ec1                                              | 0x3fe0000000000000;
00033ed8                                          (uint64_t)zmm10 = 0x4060000000000000;
00033ee8                                          uint64_t rbx_7 = (uint64_t)(
00033ee8                                              (int32_t)((0x200000000000 & bitret_1) >> 0x2d)
00033ee8                                              + (int32_t)(((0xfc00000000000 & bitret_1)
00033ee8                                              | 0x10000000000000) >> 0x2e));
00033eea                                          arg6[0] = (double)(uint32_t)rbx_7;
00033efc                                          zmm7 = -0x8000000;
00033f04                                          (uint64_t)zmm10 = 128.0 / arg6[0];
00033f09                                          (uint64_t)zmm12 =
00033f09                                              (&__real_4090040000000000)[rbx_7];
00033f13                                          (uint64_t)zmm11 =
00033f13                                              *(uint64_t*)((rbx_7 << 3) + 0x3b510);
00033f1d                                          arg6[0] = arg6[0] * 0.0078125;
00033f21                                          (uint64_t)zmm13 = (uint64_t)zmm13 - arg6[0];
00033f26                                          temp0_10[0] = (int64_t)zmm13;
00033f2b                                          temp0_10[0] = temp0_10[0] * (uint64_t)zmm10;
00033f30                                          temp0_11[0] = 0x3fc0000000000000;
00033f38                                          arg9[0] = 0x3fc2492492492492;
00033f41                                          arg4 = (int64_t)zmm7;
00033f45                                          temp0_12[0] = (int64_t)temp0_10;
00033f4e                                          zmm7 = _mm_and_pd(zmm7, temp0_10);
00033f52                                          arg5 = (int64_t)temp0_10 * arg6[0];
00033f56                                          temp0_12[0] = temp0_12[0] - (uint64_t)zmm7;
00033f5b                                          temp0_11[0] = 0.125 * temp0_10[0];
00033f5f                                          temp0_12[0] = temp0_12[0] * arg6[0];
00033f64                                          arg9[0] = 0.14285714285714285 - temp0_11[0];
00033f69                                          arg9[0] = arg9[0] * temp0_10[0];
00033f6e                                          temp0_11[0] = 0x3fc5555555555555;
00033f76                                          temp0_11[0] = 0.16666666666666666 - arg9[0];
00033f7b                                          temp0_11[0] = temp0_11[0] * temp0_10[0];
00033f7f                                          arg9[0] = 0x3fc999999999999a;
00033f88                                          arg9[0] = 0.20000000000000001 - temp0_11[0];
00033f8d                                          temp0_11[0] = arg4;
00033f95                                          arg4 = (int64_t)zmm7 * arg6[0];
00033f99                                          arg6[0] = (int64_t)temp0_11;
00033fa1                                          arg4 = arg4 - arg5 + temp0_12[0];
00033fa6                                          temp0_11[0] = (int64_t)zmm13;
00033fab                                          temp0_11[0] = temp0_11[0] - arg5;
00033faf                                          temp0_11[0] = temp0_11[0] - arg4;
00033fb3                                          temp0_11[0] = temp0_11[0] * (uint64_t)zmm10;
00033fbc                                          arg5 = (int64_t)temp0_10 + temp0_11[0];
00033fc8                                          uint64_t temp0_14[0x2] =
00033fc8                                              _mm_xor_pd(temp0_12, temp0_12);
00033fcd                                          arg9[0] = arg9[0] * temp0_10[0];
00033fd7                                          arg4 = (0.25 - arg9[0]) * temp0_10[0];
00033fdb                                          arg9[0] = 0x3fd5555555555555;
00033fe4                                          arg9[0] = 0.33333333333333331 - arg4;
00033fe9                                          arg9[0] = arg9[0] * temp0_10[0];
00033fee                                          (uint64_t)zmm7 = (int64_t)temp0_10;
00033ff2                                          (uint64_t)zmm7 = (uint64_t)zmm7 - arg5;
00033ff6                                          (uint64_t)zmm7 = (uint64_t)zmm7 + temp0_11[0];
00033ffa                                          temp0_11[0] = 0x3fe0000000000000;
00034006                                          temp0_11[0] = 0.5 - arg9[0];
0003400b                                          temp0_14[0] = temp0_14[0] - temp0_10[0];
00034010                                          temp0_14[0] = temp0_14[0] * temp0_11[0];
00034015                                          temp0_11[0] = arg5;
00034019                                          temp0_14[0] = temp0_14[0] * temp0_10[0];
0003401e                                          temp0_11[0] = temp0_11[0] + temp0_14[0];
0003402c                                          arg4 = arg5 - temp0_11[0] + temp0_14[0]
0003402c                                              + (uint64_t)zmm7;
00034030                                          (uint64_t)zmm7 = (int64_t)temp0_11;
00034034                                          (uint64_t)zmm7 = (uint64_t)zmm7 + arg4;
00034038                                          temp0_11[0] = temp0_11[0] - (uint64_t)zmm7;
0003403c                                          temp0_11[0] = temp0_11[0] + arg4;
00034040                                          arg4 = 1.4426950408889634;
00034048                                          temp0_14[0] = arg4;
0003404d                                          (uint64_t)zmm13 = arg4;
00034052                                          arg9[0] = 0x3ff7154760000000;
0003405b                                          (uint64_t)zmm10 = (int64_t)zmm7;
00034060                                          temp0_10[0] = (int64_t)arg6;
00034064                                          uint64_t temp0_15[0x2] = _mm_and_pd(arg6, zmm7);
00034068                                          temp0_14[0] = temp0_14[0] - 1.4426950216293335;
00034072                                          arg4 = 1.4426950408889634 * (uint64_t)zmm7;
00034076                                          (uint64_t)zmm10 = (uint64_t)zmm10 - temp0_15[0];
0003407b                                          arg5 = (int64_t)arg9 * temp0_15[0];
0003407f                                          arg9[0] = 1.4426950216293335 * (uint64_t)zmm10;
00034088                                          temp0_15[0] = temp0_15[0] * temp0_14[0];
0003408d                                          arg5 = arg5 - arg4 + arg9[0];
00034092                                          temp0_14[0] = temp0_14[0] * (uint64_t)zmm10;
0003409b                                          arg5 = arg5 + temp0_15[0] + temp0_14[0];
000340a0                                          arg9[0] = 0x3c7777d0ffda0d20;
000340a9                                          (uint64_t)zmm13 = (uint64_t)zmm13 * temp0_11[0];
000340ae                                          (uint64_t)zmm7 =
000340ae                                              (uint64_t)zmm7 * 2.0355273740931021e-17;
000340b8                                          arg5 = arg5 + (uint64_t)zmm13 + (uint64_t)zmm7;
000340bc                                          temp0_11[0] = arg4;
000340c0                                          temp0_11[0] = temp0_11[0] + arg5;
000340c4                                          zmm13 = _mm_xor_pd(zmm13, zmm13);
000340c9                                          arg4 = arg4 - temp0_11[0];
000340cd                                          arg9[0] = (int64_t)temp0_10;
000340d2                                          arg4 = arg4 + arg5;
000340d2                                          
000340db                                          if (!(temp0_11[0] != (uint64_t)zmm13))
000340dd                                              temp0_11[0] = (int64_t)zmm11;
000340db                                          else if (!((uint64_t)zmm11 == (uint64_t)zmm13))
000340e9                                          {
000340ef                                              arg5 = (int64_t)temp0_11 + (uint64_t)zmm11;
000340f4                                              temp0_15[0] = (int64_t)temp0_11;
000340f8                                              temp0_15[0] = temp0_15[0] - arg5;
000340fc                                              temp0_15[0] = temp0_15[0] + (uint64_t)zmm11;
00034101                                              temp0_15[0] = temp0_15[0] + arg4;
00034105                                              temp0_11[0] = arg5;
00034109                                              temp0_11[0] = temp0_11[0] + temp0_15[0];
00034115                                              arg4 = arg5 - temp0_11[0] + temp0_15[0];
000340e9                                          }
000340e9                                          
00034119                                          temp0_10[0] = (int64_t)zmm12;
0003411e                                          temp0_10[0] = temp0_10[0] + temp0_11[0];
00034122                                          temp0_15[0] = (int64_t)zmm12;
00034127                                          temp0_15[0] = temp0_15[0] - temp0_10[0];
0003412b                                          temp0_15[0] = temp0_15[0] + temp0_11[0];
0003412f                                          arg4 = arg4 + temp0_15[0];
00034133                                          temp0_11[0] = (double)((int32_t)((
00034133                                              0x7ff0000000000000 & bitret_1) >> 0x34) - 0x3ff
00034133                                              - rbx_4);
00034139                                          temp0_15[0] = arg4;
0003413d                                          temp0_15[0] = temp0_15[0] + temp0_10[0];
00034141                                          temp0_10[0] = temp0_10[0] - temp0_15[0];
00034145                                          temp0_10[0] = temp0_10[0] + arg4;
0003414d                                          temp0_11[0] = temp0_11[0] + temp0_15[0];
00034159                                          temp0_10[0] = temp0_10[0] + (int64_t)temp0_11
00034159                                              - temp0_11[0] + temp0_15[0];
0003415d                                          temp0_15[0] = (int64_t)temp0_11;
00034161                                          temp0_15[0] = temp0_15[0] + temp0_10[0];
00034165                                          temp0_11[0] = temp0_11[0] - temp0_15[0];
00034169                                          temp0_10[0] = temp0_10[0] + temp0_11[0];
00034175                                          temp0_11[0] = (int64_t)temp0_15;
00034179                                          temp0_11[0] = temp0_11[0] * arg2[0];
00034179                                          
00034181                                          if (1025.0 < temp0_11[0])
00034181                                          {
000341be                                          label_341be:
000341be                                              int32_t index_2 = 0x17;
000341be                                              
000341c5                                              if (!result_2)
000341c5                                                  index_2 = 0x18;
000341c5                                              
000341c9                                              result = __pow_error((uint64_t)arg1, arg2[0], 
000341c9                                                  index_2, bitret_2);
00034181                                          }
00034181                                          else if (temp0_11[0] >= -1074.0)
0003418f                                          {
00034200                                              temp0_11[0] = (int64_t)arg9;
00034205                                              uint64_t temp0_17[0x2] =
00034205                                                  _mm_and_pd(arg9, temp0_15);
0003420a                                              temp0_14[0] = (int64_t)temp0_15;
0003420f                                              temp0_14[0] = temp0_14[0] - temp0_17[0];
0003421d                                              (uint64_t)zmm10 = (int64_t)arg2;
00034222                                              arg4 = (int64_t)temp0_15 * arg2[0];
00034226                                              uint64_t temp0_18[0x2] =
00034226                                                  _mm_and_pd(temp0_11, arg2);
0003422a                                              (uint64_t)zmm10 =
0003422a                                                  (uint64_t)zmm10 - temp0_18[0];
0003422f                                              arg5 = (int64_t)temp0_17 * temp0_18[0];
00034233                                              temp0_17[0] = temp0_17[0] * (uint64_t)zmm10;
0003423c                                              temp0_18[0] = temp0_18[0] * temp0_14[0];
00034241                                              temp0_10[0] = temp0_10[0] * arg2[0];
00034245                                              temp0_14[0] = temp0_14[0] * (uint64_t)zmm10;
00034258                                              temp0_10[0] = temp0_10[0] + arg5 - arg4
00034258                                                  + temp0_17[0] + temp0_18[0]
00034258                                                  + temp0_14[0];
0003425c                                              temp0_18[0] = arg4;
00034260                                              temp0_18[0] = temp0_18[0] + temp0_10[0];
00034268                                              arg4 = arg4 - temp0_18[0] + temp0_10[0];
00034270                                              int32_t rcx_2 = (int32_t)(int64_t)temp0_18;
00034274                                              (uint64_t)zmm7 = (double)rcx_2;
00034278                                              temp0_10[0] = (int64_t)temp0_18;
0003427c                                              temp0_10[0] = temp0_10[0] - (uint64_t)zmm7;
00034280                                              temp0_18[0] = temp0_18[0] - temp0_10[0];
00034284                                              temp0_18[0] = temp0_18[0] - (uint64_t)zmm7;
00034288                                              temp0_18[0] = temp0_18[0] + arg4;
0003428c                                              temp0_15[0] = (int64_t)temp0_10;
00034290                                              temp0_15[0] = temp0_15[0] + temp0_18[0];
00034294                                              temp0_10[0] = temp0_10[0] - temp0_15[0];
00034298                                              temp0_10[0] = temp0_10[0] + temp0_18[0];
0003429c                                              uint64_t var_108_3 = temp0_15[0];
000342af                                              int64_t rax_30 =
000342af                                                  0x7fffffffffffffff & var_108_3;
000342af                                              
000342c2                                              if (rax_30 < 0x3fb7154764ee6c2f)
000342c2                                              {
00034503                                                  if (rax_30 >= 0x3c00000000000000)
00034503                                                  {
00034523                                                      arg9 =
00034523                                                          -0x8000000 & (uint128_t)var_108_3;
00034528                                                      temp0_14[0] = (int64_t)temp0_15;
00034535                                                      temp0_14[0] = temp0_14[0] - arg9[0];
0003453a                                                      temp0_15[0] =
0003453a                                                          temp0_15[0] * 0.69314716756343842;
0003453e                                                      temp0_10[0] = 0.69314716756343842;
0003454a                                                      temp0_18[0] = 0x3f437d98a3a06a02;
00034552                                                      (uint64_t)zmm7 = 1.2996506893889887e-08;
00034556                                                      arg4 = 0.69314716756343842 * arg9[0];
0003455b                                                      (uint64_t)zmm7 =
0003455b                                                          (uint64_t)zmm7 * arg9[0];
00034560                                                      temp0_10[0] = temp0_10[0] * temp0_14[0];
00034565                                                      arg4 = arg4 - temp0_15[0];
00034569                                                      temp0_14[0] =
00034569                                                          temp0_14[0] * 1.2996506893889887e-08;
00034576                                                      arg4 = arg4 + (uint64_t)zmm7;
0003457a                                                      (uint64_t)zmm7 = (int64_t)temp0_15;
00034582                                                      temp0_14[0] =
00034582                                                          temp0_14[0] + arg4 + temp0_10[0];
00034587                                                      temp0_10[0] = 0x3f985eaf935d972d;
0003458f                                                      (uint64_t)zmm7 =
0003458f                                                          (uint64_t)zmm7 + temp0_14[0];
0003459c                                                      temp0_18[0] =
0003459c                                                          0.0005948062237196019 * (uint64_t)zmm7;
000345a4                                                      temp0_18[0] =
000345a4                                                          temp0_18[0] - 0.011897736426815022;
000345ac                                                      temp0_18[0] =
000345ac                                                          temp0_18[0] * (uint64_t)zmm7;
000345b4                                                      temp0_10[0] = 0x3feffc6f012164ad;
000345bc                                                      temp0_18[0] =
000345bc                                                          temp0_18[0] + 0.10708768940985862;
000345cc                                                      temp0_18[0] =
000345cc                                                          temp0_18[0] * (uint64_t)zmm7;
000345d4                                                      temp0_18[0] =
000345d4                                                          temp0_18[0] - 0.4997661997651513;
000345e8                                                      temp0_18[0] =
000345e8                                                          temp0_18[0] * (uint64_t)zmm7;
000345ec                                                      temp0_18[0] =
000345ec                                                          temp0_18[0] + 0.99956464978017368;
000345f0                                                      arg5 = (((
000345f0                                                          2.6872477485611118e-07 * (uint64_t)zmm7
000345f0                                                          + 0.023798697823983851)
000345f0                                                          * (uint64_t)zmm7
000345f0                                                          + 1.6125124935526804e-05)
000345f0                                                          * (uint64_t)zmm7 + 0.99956464978017368)
000345f0                                                          / temp0_18[0];
000345f4                                                      temp0_10[0] = arg5;
000345f8                                                      arg5 = arg5 * temp0_15[0];
000345fc                                                      temp0_10[0] = temp0_10[0] * temp0_14[0];
00034605                                                      arg4 = 1.0 + arg5 + temp0_10[0];
00034503                                                  }
00034503                                                  else
0003450d                                                      arg4 = 1.0 + temp0_15[0];
0003450d                                                  
0003460e                                                  int32_t rcx_11 = 0;
0003460e                                                  
00034612                                                  if (rcx_2)
00034612                                                  {
00034614                                                      if (rcx_2 < 0)
00034614                                                      {
0003464f                                                          int32_t rbx_20 = -(rcx_2);
0003464f                                                          
00034658                                                          if (rbx_20 >= 0x2bc)
00034658                                                          {
0003465c                                                              rcx_11 = rbx_20 >> 1;
0003466e                                                              arg4 = arg4
0003466e                                                                  * ((uint64_t)(0x3ff - rcx_11) << 0x34);
00034658                                                          }
00034658                                                          
00034684                                                          arg4 = arg4 * (
00034684                                                              (uint64_t)(0x3ff - (rbx_20 - rcx_11))
00034684                                                              << 0x34);
00034614                                                      }
00034614                                                      else
00034614                                                      {
0003461d                                                          if (rcx_2 >= 0x200)
0003461d                                                          {
00034621                                                              rcx_11 = rcx_2 >> 1;
00034633                                                              arg4 = arg4
00034633                                                                  * ((uint64_t)(0x3ff + rcx_11) << 0x34);
0003461d                                                          }
0003461d                                                          
00034649                                                          arg4 = arg4 * (
00034649                                                              (uint64_t)(0x3ff + rcx_2 - rcx_11)
00034649                                                              << 0x34);
00034614                                                      }
00034612                                                  }
00034612                                                  
00034612                                                  goto label_34688;
000342c2                                              }
000342c2                                              
000342d4                                              int32_t rbx_8 = (int32_t)(32.0 * temp0_15[0]);
000342e6                                              (uint64_t)zmm7 = (double)rbx_8;
000342ea                                              temp0_18[0] = (int64_t)temp0_15;
000342fa                                              temp0_18[0] =
000342fa                                                  temp0_18[0] - 0.03125 * (uint64_t)zmm7;
00034305                                              uint64_t rax_31 = 0x1f & (uint64_t)rbx_8;
00034307                                              (uint64_t)zmm12 = *(uint64_t*)(
00034307                                                  &__two_to_jby32_lead_table
00034307                                                  + (rax_31 << 3));
0003430d                                              (uint64_t)zmm11 = *(uint64_t*)(
0003430d                                                  &__two_to_jby32_trail_table
0003430d                                                  + (rax_31 << 3));
00034320                                              temp0_18[0] =
00034320                                                  temp0_18[0] * 0.69314718055994529;
00034370                                              arg5 = (0.5 + (0.16666666666526087 + (
00034370                                                  0.041666666666226079 + (
00034370                                                  0.0083333679843421958
00034370                                                  + 0.0013888949086377719 * temp0_18[0])
00034370                                                  * temp0_18[0]) * temp0_18[0]) * temp0_18[0])
00034370                                                  * temp0_18[0] * temp0_18[0];
0003438b                                              int32_t rbx_11 =
0003438b                                                  ((rbx_8 - (uint32_t)rax_31) >> 5) + rcx_2;
0003438d                                              arg4 = ((int64_t)zmm12 + (uint64_t)zmm11)
0003438d                                                  * (arg5 + temp0_18[0]) + (uint64_t)zmm11
0003438d                                                  + (uint64_t)zmm12;
00034399                                              uint64_t bitret_3;
00034399                                              
00034399                                              if (rbx_11 < 0xfffffc02)
00034399                                              {
00034487                                                  uint64_t rdx_3 = arg4 << 1 >> 1;
00034491                                                  uint64_t rcx_8 = (uint64_t)(
00034491                                                      (int32_t)(rdx_3 >> 0x34) + rbx_11);
00034497                                                  uint64_t rdx_9;
00034497                                                  
00034497                                                  if ((uint32_t)rcx_8 > 0)
000344e2                                                      rdx_9 =
000344e2                                                          rdx_3 << 0xc >> 0xc | rcx_8 << 0x34;
00034497                                                  else if (1 - (uint32_t)rcx_8 > 0x36)
000344d1                                                      rdx_9 = 0;
000344b8                                                  else
000344b8                                                  {
000344bf                                                      uint64_t rdx_7 = (rdx_3 << 0xc >> 0xc
000344bf                                                          | 0x10000000000000)
000344bf                                                          >> ((1 - (uint32_t)rcx_8) - 1);
000344cc                                                      rdx_9 = (rdx_7 & 1) + (rdx_7 >> 1);
000344b8                                                  }
000344b8                                                  
000344ee                                                  bitret_3 = RRCQ(rdx_9 << 1, 1, 
000344ee                                                      RRC
000344ee                                                          Q(r11_2, 1, arg4 & 0x8000000000000000)
000344ee                                                          & 0x8000000000000000);
000344f1                                                  goto label_341df;
00034399                                              }
00034399                                              
000343a2                                              int32_t rcx_3 = 0;
000343a4                                              int32_t r11_3 = 0;
000343a4                                              
000343a9                                              if (rbx_11)
000343a9                                              {
000343af                                                  if (rbx_11 < 0)
000343af                                                  {
00034412                                                      int32_t rbx_14 = -(rbx_11);
00034412                                                      
0003441b                                                      if (rbx_14 >= 0x2bc)
0003441b                                                      {
0003441f                                                          rcx_3 = rbx_14 >> 2;
00034432                                                          arg4 = arg4
00034432                                                              * ((uint64_t)(0x3ff - rcx_3) << 0x34);
0003441b                                                      }
0003441b                                                      
0003443d                                                      if (rbx_14 >= 0x15e)
0003443d                                                      {
00034442                                                          r11_3 = rbx_14 >> 1;
00034456                                                          arg4 = arg4
00034456                                                              * ((uint64_t)(0x3ff - r11_3) << 0x34);
0003443d                                                      }
0003443d                                                      
0003446f                                                      arg4 = arg4 * ((uint64_t)(0x3ff
0003446f                                                          - (rbx_14 - rcx_3 - r11_3)) << 0x34);
000343af                                                  }
000343af                                                  else
000343af                                                  {
000343b8                                                      if (rbx_11 >= 0x2bc)
000343b8                                                      {
000343bc                                                          rcx_3 = rbx_11 >> 2;
000343cf                                                          arg4 = arg4
000343cf                                                              * ((uint64_t)(0x3ff + rcx_3) << 0x34);
000343b8                                                      }
000343b8                                                      
000343da                                                      if (rbx_11 >= 0x15e)
000343da                                                      {
000343df                                                          r11_3 = rbx_11 >> 1;
000343f3                                                          arg4 = arg4
000343f3                                                              * ((uint64_t)(0x3ff + r11_3) << 0x34);
000343da                                                      }
000343da                                                      
0003440c                                                      arg4 = arg4 * ((uint64_t)(0x3ff + rbx_11
0003440c                                                          - rcx_3 - r11_3) << 0x34);
000343af                                                  }
000343a9                                              }
000343a9                                              
00034688                                          label_34688:
00034688                                              (uint64_t)arg1 = arg4;
0003469f                                              uint64_t bitret_4 = 0x7fffffffffffffff & arg4;
0003469f                                              
000346b5                                              if ((0x7ff0000000000000 & bitret_4)
000346b5                                                      == 0x7ff0000000000000)
000346b5                                                  goto label_341be;
000346b5                                              
000346be                                              if (!bitret_4)
000346be                                                  goto label_3419d;
000346be                                              
000346ce                                              bitret_3 = bitret_4;
000346ce                                              
000346d4                                              if (bitret_4 < 0x10000000000000)
000346d4                                              {
000341df                                              label_341df:
000341df                                                  int32_t index_3 = 0x1b;
000341df                                                  
000341e6                                                  if (!result_2)
000341e6                                                      index_3 = 0x1c;
000341e6                                                  
000341ea                                                  result = __pow_error((uint64_t)arg1, 
000341ea                                                      arg2[0], index_3, bitret_3);
000346d4                                              }
000346d4                                              else
000346d4                                              {
000346da                                                  result = result_2;
000346da                                                  
000346e1                                                  if (result)
000346eb                                                      (uint64_t)arg1 = (int64_t)_mm_sub_pd(
000346eb                                                          _mm_xor_pd(arg2, arg2), arg1);
000346d4                                              }
0003418f                                          }
0003418f                                          else
0003418f                                          {
0003419d                                          label_3419d:
0003419d                                              int32_t index_1 = 0x19;
0003419d                                              
000341a4                                              if (!result_2)
000341a4                                                  index_1 = 0x1a;
000341a4                                              
000341a8                                              result = __pow_error((uint64_t)arg1, arg2[0], 
000341a8                                                  index_1, bitret_2);
0003418f                                          }
00033e18                                      }
00033ded                                  }
00033ded                                  else
00033ded                                  {
00033df1                                      if ((uint32_t)rbx_1)
00033df1                                      {
00033df7                                          bitret_1 = bitret_5;
00033dfa                                          arg1 = (uint128_t)bitret_1;
00033dfa                                          
00033e02                                          if ((uint32_t)rbx_1 == 1)
00033e02                                              r11_2 = (uint64_t)(uint32_t)rbx_1;
00033e02                                          
00033e02                                          goto label_33e06;
00033df1                                      }
00033df1                                      
00033d25                                      result = __pow_error((uint64_t)arg1, arg2[0], 0x12, 
00033d25                                          bitret_2);
00033ded                                  }
00033de1                              }
00033de1                              else if (bitret_1 == bitret_5)
00033cbe                              {
00033cc3                                  arg1 = _mm_xor_pd(arg1, arg1);
00033cc3                                  
00033cc7                                  if (bitret != bitret_2)
00033cd8                                      result = __pow_error(_mm_xor_pd(arg1, arg1), arg2[0], 
00033cd8                                          0xf, bitret_2);
00033cbe                              }
00033cbe                              else if (bitret != bitret_2)
00033ce5                              {
00033d09                                  int32_t index = 0x11;
00033d09                                  
00033d10                                  if (result_1 == 1)
00033d10                                      index = 0x10;
00033d10                                  
00033d14                                  result =
00033d14                                      __pow_error((uint64_t)arg1, arg2[0], index, bitret_2);
00033ce5                              }
00033ce5                              else
00033ce5                              {
00033ce7                                  result = result_1;
00033ce7                                  
00033cee                                  if (result != 1)
00033cf4                                      _mm_xor_pd(arg1, arg1);
00033ce5                              }
00033a74                          }
00033a74                          else if (bitret != bitret_2)
00033b88                          {
00033c03                              if (bitret_5)
00033c03                              {
00033c16                                  result = 0;
00033c16                                  
00033c23                                  if (bitret_5 < 0x3ff0000000000000)
00033c23                                  {
00033c25                                      result = 0;
00033c25                                      
00033c32                                      if (bitret_2 != 0x7ff0000000000000)
00033c3b                                          result = __pow_error((uint64_t)arg1, arg2[0], 
00033c3b                                              0xc, bitret_2);
00033c23                                  }
00033c23                                  else if (bitret_5 != 0x3ff0000000000000)
00033c45                                  {
00033c51                                      result = 0;
00033c51                                      
00033c5e                                      if (bitret_2 == 0x7ff0000000000000)
00033c71                                          _mm_xor_pd(arg1, arg1);
00033c5e                                      else
00033c67                                          result = __pow_error((uint64_t)arg1, arg2[0], 
00033c67                                              0xe, bitret_2);
00033c45                                  }
00033c03                              }
00033c03                              else
00033c0c                                  result =
00033c0c                                      __pow_error((uint64_t)arg1, arg2[0], 0xb, bitret_2);
00033b88                          }
00033b88                          else if (bitret_5)
00033b8d                          {
00033b98                              result = 0;
00033b98                              
00033ba5                              if (bitret_5 < 0x3ff0000000000000)
00033ba5                              {
00033ba7                                  result = 0;
00033ba7                                  
00033bb4                                  if (bitret_2 == 0x7ff0000000000000)
00033b8f                                      _mm_xor_pd(arg1, arg1);
00033bb4                                  else
00033bbd                                      result =
00033bbd                                          __pow_error((uint64_t)arg1, arg2[0], 8, bitret_2);
00033ba5                              }
00033ba5                              else if (bitret_5 != 0x3ff0000000000000)
00033bc7                              {
00033bd6                                  result = 0;
00033bd6                                  
00033be3                                  if (bitret_2 != 0x7ff0000000000000)
00033bec                                      result = __pow_error((uint64_t)arg1, arg2[0], 0xa, 
00033bec                                          bitret_2);
00033bc7                              }
00033bc7                              else
00033bc9                                  (uint64_t)arg1 = 0x3ff0000000000000;
00033b8d                          }
00033b8d                          else
00033b8f                              _mm_xor_pd(arg1, arg1);
00033a61                      }
00033a4e                  }
00033a4e                  else if (bitret != -0x8000000000000
00033a4e                          || (bitret_5 & 0x7ff0000000000000) != 0x7ff0000000000000
00033a4e                          || !(0xfffffffffffff & bitret_1))
00033b76                      result = __pow_error((uint64_t)arg1, arg2[0], 1, bitret);
00033b56                  else
00033b62                      result = __pow_error((uint64_t)arg1, arg2[0], 1, bitret_1);
00033a05              }
00033a05              else
00033a05              {
00033a9e                  if (bitret_1 == -0x8000000000000)
00033aaa                      bitret_2 &= 0x7ff0000000000000;
00033aaa                  
00033abf                  if (bitret_1 == -0x8000000000000 && bitret_2 == 0x7ff0000000000000
00033abf                          && 0xfffffffffffff & bitret)
00033acb                      result = __pow_error((uint64_t)arg1, arg2[0], 1, bitret);
00033abf                  else if (bitret_1 == bitret_5 || bitret != bitret_2
00033abf                          || (bitret_2 & 0x7ff0000000000000) != 0x7ff0000000000000
00033abf                          || !(0xfffffffffffff & bitret))
00033b1e                      result = __pow_error((uint64_t)arg1, arg2[0], 1, bitret_1);
00033afe                  else
00033b0a                      result = __pow_error((uint64_t)arg1, arg2[0], 1, bitret);
00033a05              }
000339c1          }
000339b8      }
000339b8      
0003475f      return result;
00033960  }

00033a7f                                                                                               e9                                 .
00033a80  bc 0c 00 00                                                                                      ....
00033d54                                                              66 66 66 66 0f 1f 84 00 00 00 00 00                      ffff........
000341f4                                                              66 66 66 66 0f 1f 84 00 00 00 00 00                      ffff........
000346f1                                                     66 66 66 66 66 66 66 0f 1f 84 00 00 00 00 00                   fffffff........

00034760    int64_t __clear_x87_state() __pure

00034760  {
00034760      return;
00034760  }

00034761     cc cc cc cc cc cc cc                                                                           .......

00034768    double sqrt(double x)

00034768  {
0003479a      double arg_8;
0003479a      bool cond:0_1;
0003479a      
0003479a      if ((x & 0x7ff0000000000000) == 0x7ff0000000000000)
0003479a      {
000347ad          if (!(0xfffffffffffff & x))
000347ad          {
000347fd              cond:0_1 = !(-0x8000000000000000 & x);
000347fd              goto label_34800;
000347ad          }
000347ad          
000347bf          int32_t var_18_1 = 1;
000347dd          int32_t var_30_1 = 0x21;
000347f6          return _handle_error("sqrt", 5, 0x8000000000000 | x, 1, 0, 0x21, arg_8, 
000347f6              _mm_xor_pd(x, x), 1);
0003479a      }
0003479a      
00034842      if (-0x8000000000000000 & x)
00034842      {
0003484e          cond:0_1 = !(0x7fffffffffffffff & x);
00034800      label_34800:
00034800          
00034800          if (!cond:0_1)
00034800          {
00034812              int32_t var_18_2 = 1;
0003482d              int32_t var_30_2 = 0x21;
000347f6              return _handle_error("sqrt", 5, -0x8000000000000, 1, 8, 0x21, arg_8, 
000347f6                  _mm_xor_pd(x, x), 1);
00034800          }
00034842      }
00034842      
00034867      uint128_t entry_zmm1;
00034867      return (int64_t)_mm_sqrt_sd(_mm_xor_pd(entry_zmm1, entry_zmm1), x);
00034768  }

00034872                                                        cc cc cc cc cc cc                                            ......

00034878    void __remainder_piby2f_inline(uint64_t ux, double* r, int32_t* region)

00034878  {
00034890      int64_t var_48 = 0;
000348ef      uint64_t r10_3 = ((ux & 0xfffffe0000000) | 0x10000000000000) >> 0x1d;
00034900      uint64_t r9_2 = (uint64_t)((((int32_t)(ux >> 0x34) & 0x7ff) - 0x3ff) / 0x24);
0003490a      int32_t r11_4 = ((int32_t)(ux >> 0x34) & 0x7ff) - 0x3ff - ((int32_t)(r9_2 * 9) << 2);
00034911      int64_t r8 = (int64_t)(int32_t)(r9_2 + 3);
00034914      int64_t rcx_1 = r10_3 * pibits[r8];
0003492c      int64_t rdx_3 = *(uint64_t*)((r8 << 3) + 0x3fa68) * r10_3 + (rcx_1 >> 0x24);
00034934      int64_t var_50 = rcx_1 & 0xfffffffff;
00034944      int64_t rcx_5 = *(uint64_t*)((r8 << 3) + &_fltused) * r10_3 + (rdx_3 >> 0x24);
00034951      int64_t var_58 = rdx_3 & 0xfffffffff;
00034956      int64_t r8_2 = rcx_5 & 0xfffffffff;
0003495c      uint64_t r9_3 = 1;
0003495f      int64_t rdx_5 = pibits[(int64_t)(uint32_t)r9_2];
00034963      int64_t var_60 = r8_2;
00034974      int64_t rdx_8 = (rdx_5 * r10_3 + (rcx_5 >> 0x24)) & 0xfffffffff;
0003497a      int64_t var_68 = rdx_8;
00034988      int32_t rdx_12 = (int32_t)((rdx_8 << 0x24 | r8_2) >> (0x23 - (uint8_t)r11_4)) & 7;
0003498d      int32_t rsi_1 = rdx_12 & 1;
0003498f      int64_t i;
0003498f      int64_t r8_6;
0003498f      
0003498f      if (!rsi_1)
0003498f      {
000349f5          *(uint32_t*)region = rdx_12 >> 1;
00034a0a          i = ((1 << (0x24 - r11_4)) - 1) & r8_2;
00034a0a          
00034a16          if (i < &_iob)
00034a16          {
00034a18              int64_t* rax_13 = &var_60;
00034a18              
00034a2e              do
00034a2e              {
00034a1d                  rax_13 = &rax_13[1];
00034a25                  r9_3 = (uint64_t)((uint32_t)r9_3 + 1);
00034a28                  i = i << 0x24 | *(uint64_t*)rax_13;
00034a2e              } while (i < &_iob);
00034a16          }
00034a16          
00034a33          r8_6 = (&var_60)[(int64_t)(uint32_t)r9_3];
0003498f      }
0003498f      else
0003498f      {
0003499b          *(uint32_t*)region = ((rdx_12 >> 1) + 1) & 3;
000349ae          i = ((1 << (0x24 - r11_4)) - 1) & ~r8_2;
000349ae          
000349ba          if (i < &_iob)
000349ba          {
000349bc              int64_t* r10_4 = &var_60;
000349bc              
000349e1              do
000349e1              {
000349c4                  r10_4 = &r10_4[1];
000349c8                  r9_3 = (uint64_t)((uint32_t)r9_3 + 1);
000349db                  i = (~*(uint64_t*)r10_4 & 0xfffffffff) | i << 0x24;
000349e1              } while (i < &_iob);
000349ba          }
000349ba          
000349ee          r8_6 = ~(&var_60)[(int64_t)(uint32_t)r9_3] & 0xfffffffff;
0003498f      }
0003498f      
00034a38      int32_t r10_5 = 0;
00034a38      
00034a52      for (; i < 0x400000000000; i <<= 6)
00034a47          r10_5 += 6;
00034a47      
00034a5f      for (; i < 0x10000000000000; i *= 2)
00034a56          r10_5 += 1;
00034a56      
00034a6b      uint64_t rcx_8;
00034a6b      (uint8_t)rcx_8 = 0x24 - (uint8_t)r10_5;
00034a96      double rax_21 =
00034a96          ((int64_t)(r11_4 - ((int32_t)(r9_3 * 9) << 2) - r10_5 + 0x34) + 0x3ff) << 0x34
00034a96          | ((r8_6 >> (uint8_t)rcx_8 | i) & 0xfffffffffffff);
00034a96      
00034a9b      if (rsi_1)
00034aa7          rax_21 |= 0x8000000000000000;
00034aa7      
00034ace      *(uint64_t*)r = rax_21 * 1.5707963267948966;
00034878  }

00034adb                                                                                   cc cc cc cc cc                             .....
00034ae0  cc cc cc cc                                                                                      ....

00034ae4    float __convention("sysv") tanf(float x)

00034ae4  {
00034af9      float zmm6[0x4] = x;
00034afc      float temp0[0x4] = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
00034aff      uint64_t entry_zmm7[0x2];
00034aff      uint64_t var_28[0x2] = entry_zmm7;
00034b04      double r_1[0x2] = _mm_cvtps_pd(*(uint64_t*)&temp0[0]);
00034b07      int64_t r_2 = (int64_t)r_1;
00034b1b      uint64_t ux = r_2 & 0x7fffffffffffffff;
00034b2b      double zmm2;
00034b2b      
00034b2b      if (ux > 0x3fe921fb54442d18)
00034b2b      {
00034bfd          if ((r_2 & 0x7ff0000000000000) == 0x7ff0000000000000)
00034bfd          {
00034c3b              int32_t flags;
00034c3b              uint64_t value;
00034c3b              
00034c3b              if (!(0xfffffffffffff & r_2))
00034c3b              {
00034c62                  flags = 8;
00034c6a                  value = 0xffc00000;
00034c3b              }
00034c3b              else
00034c3b              {
00034c4e                  value = (uint64_t)temp0[0] | 0x400000;
00034c53                  flags = 0;
00034c3b              }
00034c3b              
00034c58              return _handle_errorf("tanf", 0x20, value, 1, flags, 0x21, temp0[0], 0f, 1);
00034bfd          }
00034bfd          
00034c72          uint128_t zmm5 = -0x8000000000000000;
00034c7a          uint32_t rbx_1 = (int32_t)(r_2 >> 0x3f);
00034c7a          
00034c80          if (rbx_1)
00034c82              r_1 = _mm_xor_pd(r_1, zmm5);
00034c82          
00034c92          char region_1;
00034c92          double zmm4;
00034c92          
00034c92          if (0f <= r_1[0])
00034c92          {
00034dd0              int32_t region;
00034dd0              double r;
00034dd0              __remainder_piby2f_inline(ux, &r, &region);
00034dd5              region_1 = (char)region;
00034ddc              r_1 = (uint128_t)r;
00034c92          }
00034c92          else
00034c92          {
00034cac              int32_t rdx_2;
00034cac              
00034cac              if (ux <= 0x400f6a7a2955385e)
00034cac              {
00034cbd                  int32_t rdx_1;
00034cbd                  (uint8_t)rdx_1 = ux > 0x4002d97c7f3321d2;
00034cc0                  rdx_2 = rdx_1 + 1;
00034cac              }
00034cac              else if (ux > 0x401c463abeccb2bb)
00034cfe                  rdx_2 =
00034cfe                      (int32_t)((int32_t)(((int32_t)(r_1[0] * 0.63661977236758138)) + 0.5));
00034cd1              else
00034cd1              {
00034ce2                  int32_t rdx_3;
00034ce2                  (uint8_t)rdx_3 = ux > 0x4015fdbbe9bba775;
00034ce5                  rdx_2 = rdx_3 + 3;
00034cd1              }
00034cd1              
00034d06              zmm6 = _mm_cvtepi32_pd(((uint128_t)rdx_2)[0]);
00034d1a              zmm4 = *(uint64_t*)&zmm6[0] * 6.0771005065061922e-11;
00034d22              r_1[0] = r_1[0] - ((int32_t)(*(uint64_t*)&zmm6[0] * 1.5707963267341256));
00034d40              uint64_t r8_4 =
00034d40                  (ux >> 0x34) - ((uint64_t)(uint32_t)((int64_t)r_1 >> 0x34) & 0x7ff);
00034d40              
00034d47              if (r8_4 > 0xf)
00034d47              {
00034d49                  uint64_t temp0_6[0x2] = _mm_xor_pd(entry_zmm7, entry_zmm7);
00034d4d                  zmm2 = r_1[0];
00034d55                  double zmm1 = *(uint64_t*)&zmm6[0] * 6.077100506303966e-11;
00034d69                  zmm4 = *(uint64_t*)&zmm6[0] * 2.0222662487959506e-21;
00034d71                  r_1[0] = r_1[0] + ((int32_t)(temp0_6[0] - zmm1));
00034d7d                  zmm4 = zmm4 - (zmm2 - r_1[0] - zmm1);
00034d7d                  
00034d85                  if (r8_4 > 0x30)
00034d85                  {
00034d87                      zmm1 = r_1[0];
00034d93                      x = (int32_t)(*(uint64_t*)&zmm6[0] * 2.0222662487111665e-21);
00034d9b                      zmm4 = *(uint64_t*)&zmm6[0] * 8.4784276603688996e-32;
00034da3                      temp0_6[0] = temp0_6[0] - x;
00034da7                      r_1[0] = r_1[0] + temp0_6[0];
00034db3                      zmm4 = zmm4 - (zmm1 - r_1[0] - x);
00034d85                  }
00034d47              }
00034d47              
00034db7              r_1[0] = r_1[0] - zmm4;
00034dbb              region_1 = (uint8_t)rdx_2 & 3;
00034c92          }
00034c92          
00034df1          zmm2 = r_1[0] * r_1[0];
00034e31          zmm4 = (0.3852960712639954 - ((int32_t)((uint32_t)zmm2 * 0.017203248047148168)))
00034e31              * zmm2 * r_1[0] / ((int32_t)(((int32_t)(((int32_t)(((int32_t)((uint32_t)zmm2
00034e31              * 0.018442392569016561)) - 0.51396505478854537)) * zmm2))
00034e31              + 1.1558882143468838));
00034e35          zmm4 = zmm4 + r_1[0];
00034e35          
00034e3b          if (rbx_1)
00034e3b          {
00034e40              x = !(region_1 & 1) ? (uint32_t)zmm4 : (int32_t)(0f / zmm4);
00034e40              
00034e54              x = _mm_xor_pd(x, zmm5);
00034e3b          }
00034e3b          else if (!(region_1 & 1))
00034e6d              x = (uint32_t)zmm4;
00034e5d          else
00034e67              x = (int32_t)(0f / zmm4);
00034b2b      }
00034b2b      else
00034b2b      {
00034b3e          if (ux >= 0x3f80000000000000)
00034b3e          {
00034b87              r_1 = 0x3fd8a8b0da56cb17;
00034b92              double temp0_3 =
00034b92                  _mm_cvtps_pd(_mm_unpacklo_ps(temp0, *(uint64_t*)&temp0[0])[0]);
00034b99              zmm2 = temp0_3 * temp0_3;
00034bb1              r_1[0] = r_1[0] - ((int32_t)((uint32_t)zmm2 * 0.017203248047148168));
00034bc1              r_1[0] = r_1[0] * zmm2 * temp0_3;
00034bd9              r_1[0] = r_1[0] / ((int32_t)(((int32_t)(((int32_t)(((int32_t)((uint32_t)zmm2
00034bd9                  * 0.018442392569016561)) - 0.51396505478854537)) * zmm2))
00034bd9                  + 1.1558882143468838));
00034bdd              r_1[0] = r_1[0] + temp0_3;
00034be1              return (float)r_1[0];
00034b3e          }
00034b3e          
00034b4d          if (ux < 0x3f20000000000000)
00034b4d          {
00034b52              if (ux)
00034b63                  _controlfp(0x10, 0x10);
00034b63              
00034b54              return temp0[0];
00034b4d          }
00034b4d          
00034b7e          x = (int32_t)(((int32_t)(((int32_t)(((int32_t)(r_1[0] * r_1[0])) * r_1[0]))
00034b7e              * 0.33333333333333331)) + r_1[0]);
00034b2b      }
00034e71      return (float)x;
00034ae4  }

00034e85                 cc cc cc cc cc cc cc                                                                   .......

00034e8c    double atan2(double y, double x)

00034e8c  {
00034ea1      uint128_t zmm6;
00034ea1      uint128_t var_48 = zmm6;
00034ea5      uint128_t zmm7;
00034ea5      uint128_t var_58 = zmm7;
00034eae      int64_t rbx = 0;
00034edb      uint128_t x_3 = y;
00034ef7      uint64_t entry_zmm9[0x2];
00034ef7      uint64_t var_78[0x2] = entry_zmm9;
00034f02      uint128_t x_4 = x;
00034f17      int64_t rcx_1 = y & 0x7fffffffffffffff;
00034f1a      int64_t rdx_1 = x & 0x7fffffffffffffff;
00034f21      int32_t r15_2 = (int32_t)(x >> 0x34) & 0x7ff;
00034f2e      int64_t r14_1 = x & 0x8000000000000000;
00034f34      uint64_t rax_2 = (uint64_t)(uint32_t)(y >> 0x34) & 0x7ff;
00034f37      int64_t rsi_1 = y & 0x8000000000000000;
00034f3d      int32_t r9;
00034f3d      (uint8_t)r9 = rdx_1 == 0x7ff0000000000000;
00034f47      int32_t r8;
00034f47      (uint8_t)r8 = rcx_1 == 0x7ff0000000000000;
00034f55      int32_t rdi_1 = (uint32_t)rax_2 - r15_2;
00034f58      double arg_8;
00034f58      (uint32_t)arg_8 = r8;
00034f6b      uint64_t value;
00034f6b      
00034f6b      if (rdx_1 <= 0x7ff0000000000000)
00034f6b      {
00034fb8          if (rcx_1 <= 0x7ff0000000000000)
00034fb8          {
00034fcc              if (!rcx_1)
00034fcc              {
00034fd1                  if (!r14_1)
00035688                      return y;
00035688                  
00034fd1                  goto label_34fd7;
00034fcc              }
00034fcc              
00034ff8              if (!rdx_1)
00034ff8              {
00034ffd                  if (rsi_1)
00034ffd                  {
00034fff                  label_34fff:
00034fff                      y = data_3fae0;
0003500f                  label_3500f:
0003500f                      zmm6 = __xorpd_xmmxuq_memxuq(y, (*(uint128_t*)__mask@@NegDouble@));
00035165                      _controlfp(0x10, 0x10);
0003516a                      return (uint64_t)zmm6;
00034ffd                  }
00034ffd                  
0003501f                  _controlfp(0x10, 0x10);
0003502c                  r8 = (uint32_t)arg_8;
00034ff8              }
00034ff8              
0003504c              entry_zmm9 = _mm_xor_pd(entry_zmm9, entry_zmm9);
00035061              double zmm2;
00035061              
00035061              if (r15_2 < 0x3fd && (uint32_t)rax_2 < 0x3fd)
00035061              {
00035067                  zmm2 = 4.0;
00035086                  double x_1;
00035086                  
00035086                  if (0x7ff0000000000000 & x)
000350c7                      x_1 = x + 0x4000000000000000;
00035086                  else
00035086                  {
00035088                      double r12_1 = x | 0x4010000000000000;
00035088                      
0003509f                      if (!r14_1)
000350b0                          x = r12_1 + entry_zmm9[0] - zmm2;
0003509f                      else
000350a1                          x = r12_1 + zmm2;
000350a1                      
000350bd                      x_1 = x;
00035086                  }
00035086                  
000350ce                  double x_2;
000350ce                  
000350ce                  if (0x7ff0000000000000 & y)
0003510f                      x_2 = y + 0x4000000000000000;
000350ce                  else
000350ce                  {
000350d0                      double r13_1 = y | 0x4010000000000000;
000350d0                      
000350e7                      if (!rsi_1)
000350f8                          x = r13_1 + entry_zmm9[0] - zmm2;
000350e7                      else
000350e9                          x = r13_1 + zmm2;
000350e9                      
00035105                      x_2 = x;
000350ce                  }
000350ce                  
00035120                  x_4 = (uint128_t)x_1;
0003513c                  x_3 = (uint128_t)x_2;
00035146                  rdi_1 =
00035146                      ((int32_t)(x_2 >> 0x34) & 0x7ff) - ((int32_t)(x_1 >> 0x34) & 0x7ff);
00035061              }
00035061              
0003514b              if (rdi_1 > 0x38)
0003514b              {
00035150                  if (rsi_1)
00035150                      goto label_34fff;
00035150                  
00035156                  zmm6 = (uint128_t)data_3fae0;
00035165                  _controlfp(0x10, 0x10);
0003516a                  return (uint64_t)zmm6;
0003514b              }
0003514b              
0003517f              if (rdi_1 < 0xffffffe4 && !r14_1)
0003517f              {
0003518b                  if (rdi_1 >= 0xfffffbce)
0003518b                  {
000351b5                      if (rdi_1 >= 0xfffffc02)
000351b5                      {
000352a3                          (uint64_t)x_3 = (uint64_t)x_3 / (uint64_t)x_4;
000352a8                          return (uint64_t)x_3;
000351b5                      }
000351b5                      
000351e5                      y = 1.2676506002282294e+30 * (uint64_t)x_3 / (uint64_t)x_4;
0003520b                      int64_t rax_6 = y & 0x7fffffffffffffff;
0003520b                      
0003521d                      if (((int32_t)(rax_6 >> 0x34) & 0x7ff) - 0x64 > 0)
00035233                          rbx = (int64_t)(((int32_t)(rax_6 >> 0x34) & 0x7ff) - 0x64) << 0x34
00035233                              | (rax_6 & 0x800fffffffffffff);
0003521d                      else if (1 - (((int32_t)(rax_6 >> 0x34) & 0x7ff) - 0x64) <= 0x36)
00035260                      {
00035265                          uint64_t rax_10 = ((rax_6 & 0x801fffffffffffff)
00035265                              | 0x10000000000000)
00035265                              >> ((1 - (((int32_t)(rax_6 >> 0x34) & 0x7ff) - 0x64)) - 1);
00035271                          rbx = (rax_10 >> 1) + (rax_10 & 1);
00035260                      }
00035260                      
00035274                      double rbx_5 = rbx | (y & 0x8000000000000000);
0003527f                      entry_zmm9 = (uint128_t)rbx_5;
0003527f                      
0003528c                      if (!(0x7ff0000000000000 & rbx_5))
00035299                          _controlfp(0x12, 0x12);
0003518b                  }
0003518b                  else
0003518b                  {
00035190                      if (rsi_1)
00035190                      {
0003519d                          _controlfp(0x12, 0x12);
000351a2                          return -0.0;
00035190                      }
00035190                      
00035299                      _controlfp(0x12, 0x12);
0003518b                  }
0003518b                  
00035654                  return entry_zmm9[0];
0003517f              }
0003517f              
000352ba              if (rdi_1 < 0xffffffc8 && r14_1)
000352ba              {
00034fd7              label_34fd7:
00034fd7                  zmm6 = (uint128_t)data_3fad8;
00034fd7                  
00034fe2                  if (rsi_1)
00034fe8                      zmm6 = __xorpd_xmmxuq_memxuq(zmm6, (*(uint128_t*)__mask@@NegDouble@));
00034fe8                  
00035165                  _controlfp(0x10, 0x10);
0003516a                  return (uint64_t)zmm6;
000352ba              }
000352ba              
000352c8              if (r8 && r9)
000352c8              {
000352cd                  if (!r14_1)
000352cd                  {
000352f1                      if (rsi_1)
000352f1                      {
000352f3                          y = data_3fae8;
000352fb                          goto label_3500f;
000352f1                      }
000352f1                      
00035300                      zmm6 = (uint128_t)data_3fae8;
00035165                      _controlfp(0x10, 0x10);
0003516a                      return (uint64_t)zmm6;
000352cd                  }
000352cd                  
000352d2                  if (!rsi_1)
000352d2                  {
000352e1                      zmm6 = (uint128_t)data_3faf0;
00035165                      _controlfp(0x10, 0x10);
0003516a                      return (uint64_t)zmm6;
000352d2                  }
000352d2                  
000352d4                  y = data_3faf0;
000352dc                  goto label_3500f;
000352c8              }
000352c8              
00035310              if (r14_1)
00035312                  x_4 = __xorpd_xmmxuq_memxuq(x_4, (*(uint128_t*)__mask@@NegDouble@));
00035312              
0003531e              if (rsi_1)
00035320                  x_3 = __xorpd_xmmxuq_memxuq(x_3, (*(uint128_t*)__mask@@NegDouble@));
00035320              
0003532e              int32_t r9_1;
0003532e              
0003532e              if ((uint64_t)x_3 <= (uint64_t)x_4)
00035347                  r9_1 = 0;
0003532e              else
0003532e              {
00035330                  y = (uint64_t)x_4;
00035335                  x_4 = x_3;
0003533a                  r9_1 = 1;
00035340                  x_3 = y;
0003532e              }
0003532e              
0003534f              uint128_t x_5;
0003534f              (uint64_t)x_5 = (uint64_t)x_3 / (uint64_t)x_4;
0003535c              uint128_t zmm3;
0003535c              uint128_t zmm4;
0003535c              
0003535c              if (!((uint64_t)x_5 <= 0.0625))
0003535c              {
00035362                  (uint64_t)x_5 = (uint64_t)x_5 * 256.0;
0003537b                  (uint64_t)x_5 = (uint64_t)x_5 + 0.5;
00035383                  int32_t rdx_3 = (int32_t)(int64_t)(uint64_t)x_5;
00035388                  uint64_t rcx_7 = (uint64_t)(rdx_3 - 0x10);
00035394                  entry_zmm9 = (uint128_t)atan_jby256_lead[rcx_7];
000353bc                  int32_t r8_7 = -((((int32_t)((int64_t)x_4 >> 0x34) & 0x7ff) - 0x3ff));
000353bf                  (uint64_t)zmm6 = (double)(uint64_t)rdx_3;
000353c7                  int32_t temp0_6;
000353c7                  int32_t temp1_1;
000353c7                  temp0_6 = HIGHD((int64_t)r8_7);
000353c7                  temp1_1 = LOWD((int64_t)r8_7);
000353ca                  int32_t rax_16 = (temp1_1 - temp0_6) >> 1;
000353e1                  (uint64_t)zmm6 = (uint64_t)zmm6 * 0.00390625;
00035406                  (uint64_t)x_5 = (((int64_t)rax_16 + 0x3ff) << 0x34) * (uint64_t)x_4;
0003540e                  int32_t temp2_1;
0003540e                  int32_t temp3_1;
0003540e                  temp2_1 = HIGHD((int64_t)r8_7);
0003540e                  temp3_1 = LOWD((int64_t)r8_7);
0003541a                  int32_t rax_23 = (temp3_1 - temp2_1) >> 1;
00035422                  (uint64_t)x_5 =
00035422                      (uint64_t)x_5 * (((int64_t)(r8_7 - rax_16) + 0x3ff) << 0x34);
00035454                  (uint64_t)zmm4 = (((int64_t)rax_23 + 0x3ff) << 0x34) * (uint64_t)x_3;
00035473                  double rax_28 = (int64_t)x_5 & 0xfffffffff8000000;
00035481                  (uint64_t)zmm4 =
00035481                      (uint64_t)zmm4 * (((int64_t)(r8_7 - rax_23) + 0x3ff) << 0x34);
0003549e                  x = ((uint64_t)x_5 - rax_28) * (uint64_t)zmm6;
000354a2                  (uint64_t)zmm3 = (uint64_t)zmm4 - rax_28 * (uint64_t)zmm6;
000354a6                  (uint64_t)zmm6 = (uint64_t)zmm6 * (uint64_t)zmm4;
000354aa                  (uint64_t)zmm3 = (uint64_t)zmm3 - x;
000354b6                  (uint64_t)zmm6 = (uint64_t)zmm6 + (uint64_t)x_5;
000354ba                  (uint64_t)zmm3 = (uint64_t)zmm3 / (uint64_t)zmm6;
000354c6                  (uint64_t)x_5 = (uint64_t)zmm3 + atan_jby256_tail[rcx_7];
000354ca                  zmm2 = (uint64_t)zmm3 * (uint64_t)zmm3;
000354e6                  (uint64_t)x_5 = (uint64_t)x_5
000354e6                      - (0.33333333333224097 - zmm2 * 0.19999918038989142) * zmm2
000354e6                      * (uint64_t)zmm3;
0003535c              }
0003535c              else if (!(1e-08 > (uint64_t)x_5))
000354fb              {
00035531                  (uint64_t)zmm4 = (uint64_t)x_5 * (uint64_t)x_5;
00035535                  zmm3 = (uint128_t)(uint64_t)x_4 & -0x100000000;
0003554f                  double rax_32 = (int64_t)x_5 & 0xffffffff00000000;
00035573                  (uint64_t)x_3 = (uint64_t)x_3 - rax_32 * (uint64_t)zmm3;
0003557c                  (uint64_t)x_3 = (uint64_t)x_3 - ((uint64_t)x_4 - (uint64_t)zmm3) * rax_32;
00035592                  (uint64_t)x_3 = (uint64_t)x_3 - ((uint64_t)x_5 - rax_32) * (uint64_t)x_4;
000355a3                  (uint64_t)x_3 = (uint64_t)x_3 / (uint64_t)x_4;
000355d4                  x = (0.19999999999393223 - (0.1428571356180717
000355d4                      - (0.11110736283514526 - (uint64_t)zmm4 * 0.090029810285449791)
000355d4                      * (uint64_t)zmm4) * (uint64_t)zmm4) * (uint64_t)zmm4;
000355d8                  (uint64_t)zmm4 = (uint64_t)zmm4 * (uint64_t)x_5;
000355e4                  (uint64_t)x_3 =
000355e4                      (uint64_t)x_3 - (0.33333333333333171 - x) * (uint64_t)zmm4;
000355e9                  (uint64_t)x_3 = (uint64_t)x_3 + (uint64_t)x_5;
000355ee                  x_5 = x_3;
000354fb              }
000354fb              
000355f6              if (r9_1)
000355f6              {
00035611                  entry_zmm9 = (piby2_head - entry_zmm9[0]);
00035616                  x_5 = (piby2_tail - (uint64_t)x_5);
000355f6              }
000355f6              
0003561d              if (r14_1)
0003561d              {
00035638                  entry_zmm9 = (pi_head - entry_zmm9[0]);
0003563d                  x_5 = (pi_tail - (uint64_t)x_5);
0003561d              }
0003561d              
00035641              entry_zmm9[0] = entry_zmm9[0] + (uint64_t)x_5;
00035641              
00035649              if (rsi_1)
0003564b                  entry_zmm9 =
0003564b                      __xorpd_xmmxuq_memxuq(entry_zmm9, (*(uint128_t*)__mask@@NegDouble@));
0003564b              
00035654              return entry_zmm9[0];
00034fb8          }
00034fb8          
00034fc4          value = 0x8000000000000 | y;
00034f6b      }
00034f6b      else
00034f77          value = 0x8000000000000 | x;
00034f77      
00034fab      return _handle_error("atan2", 0x10, value, 1, 0, 0x21, x, y, 2);
00034e8c  }

00035689                             cc cc cc cc cc cc cc                                                           .......

00035690    float sqrtf(float x)

00035690  {
000356a5      uint64_t x_2 = (uint64_t)x;
000356af      int32_t flags;
000356af      float x_1;
000356af      uint64_t value;
000356af      
000356af      if (((uint32_t)x_2 & 0x7f800000) != 0x7f800000)
000356af      {
0003574f          if (!TEST_BITD((uint32_t)x_2, 0x1f) || !((uint32_t)x_2 & 0x7fffffff))
00035761              return _mm_sqrt_ss(x, x);
00035761          
0003571a      label_3571a:
0003571a          int32_t var_18_2 = 1;
0003571f          value = 0xffc00000;
00035725          int32_t var_20_2 = 0;
0003572b          x_1 = x;
00035731          int32_t var_30_2 = 0x21;
00035739          flags = 8;
000356af      }
000356af      else
000356af      {
000356bb          if (!((uint32_t)x_2 & 0x7fffff))
000356bb          {
0003574f              if (!TEST_BITD((uint32_t)x_2, 0x1f) &&
0003574f                      (!TEST_BITD((uint32_t)x_2, 0x1f) || !((uint32_t)x_2 & 0x7fffffff)))
00035761                  return _mm_sqrt_ss(x, x);
00035761              
00035709              goto label_3571a;
000356bb          }
000356bb          
000356cc          int32_t var_18_1 = 1;
000356d4          value = x_2 | 0x400000;
000356d9          int32_t var_20_1 = 0;
000356df          x_1 = x;
000356e5          int32_t var_30_1 = 0x21;
000356ed          flags = 0;
000356af      }
000356af      
000356fe      return _handle_errorf("sqrtf", 5, value, 1, flags, 0x21, x_1, 0f, 1);
00035690  }

0003576c                                      cc cc cc cc cc cc cc cc                                                  ........

00035774    double sin_piby4(double x, double xx) __pure

00035774  {
00035774      xx - 0.0;
00035784      double zmm5 = x * x;
00035798      double zmm3 = zmm5 * x;
000357c0      double zmm2 = (((zmm5 * 1.5918144304485914e-10 - 2.5051132068021698e-08) * zmm5
000357c0          + 2.7557316103728802e-06) * zmm5 - 0.00019841269836761127) * zmm5
000357c0          + 0.0083333333333309497;
000357c0      
000357ca      if (!FCMP_UO(xx, 0.0) && !(xx != 0.0))
000357e4          return (zmm2 * zmm5 - 0.16666666666666666) * zmm3 + x;
000357e4      
00035815      return x - ((xx * 0.5 - zmm2 * zmm3) * zmm5 - xx - zmm3 * -0.16666666666666666);
00035774  }

00035816                                                                    cc cc cc cc cc cc                                    ......

0003581c    double cos_piby4(double x, double xx) __pure

0003581c  {
00035820      double zmm5 = 1.0;
00035835      double zmm3 = x * x;
00035859      int128_t zmm7;
00035859      (uint64_t)zmm7 = x * xx;
0003586a      double zmm4 = zmm3 * 0.5;
00035876      xx = zmm5 - zmm4;
000358ca      return (((((2.0876146382232963e-09 - zmm3 * 1.1382639806794487e-11) * zmm3
000358ca          - 2.7557317272344188e-07) * zmm3 + 2.4801587298767041e-05) * zmm3
000358ca          - 0.0013888888888887398) * zmm3 + 0.041666666666666664) * zmm3 * zmm3 + zmm5 - xx
000358ca          - zmm4 - (uint64_t)zmm7 + xx;
0003581c  }

000358cb                                   cc cc cc cc cc cc cc cc cc                                                 .........

000358d4    double __convention("sysv") sin(double x)

000358d4  {
000358fa      uint128_t zmm7;
000358fa      uint128_t var_28 = zmm7;
000358ff      uint64_t rr_1[0x2] = x;
00035906      int64_t rdx_1 = x & 0x7fffffffffffffff;
00035916      uint64_t entry_rr[0x2];
00035916      
00035916      if (rdx_1 > 0x3fe921fb54442d18)
00035916      {
0003598b          if ((x & 0x7ff0000000000000) == 0x7ff0000000000000)
0003598b          {
0003598d              double temp0_2 = _mm_xor_pd(x, x);
000359c4              int32_t flags;
000359c4              uint64_t value;
000359c4              
000359c4              if (!(0xfffffffffffff & x))
000359c4              {
000359e9                  flags = 8;
000359f1                  value = -0x8000000000000;
000359c4              }
000359c4              else
000359c4              {
000359d0                  value = 0x8000000000000 | x;
000359d3                  flags = 0;
000359c4              }
000359c4              
000359df              return _handle_error("sin", 0x1e, value, 1, flags, 0x21, (int64_t)rr_1, 
000359df                  temp0_2, 1);
0003598b          }
0003598b          
000359fd          zmm7 = -0x8000000000000000;
00035a0a          int32_t rdi_1;
00035a0a          (uint8_t)rdi_1 = rdx_1 != x;
00035a0a          
00035a10          if (rdi_1)
00035a12              rr_1 = _mm_xor_pd(rr_1, zmm7);
00035a12          
00035a22          int32_t region_1;
00035a22          
00035a22          if (500000.0 <= rr_1[0])
00035a22          {
00035b78              int32_t region;
00035b78              double r;
00035b78              double rr;
00035b78              zmm7 = __remainder_piby2(rr_1[0], &r, &rr, &region);
00035b7d              region_1 = region;
00035b84              x = r;
00035b8d              rr_1 = (uint128_t)rr;
00035a22          }
00035a22          else
00035a22          {
00035a3c              int32_t rcx_2;
00035a3c              
00035a3c              if (rdx_1 <= 0x400f6a7a2955385e)
00035a3c              {
00035a4d                  int32_t rcx_1;
00035a4d                  (uint8_t)rcx_1 = rdx_1 > 0x4002d97c7f3321d2;
00035a50                  rcx_2 = rcx_1 + 1;
00035a3c              }
00035a3c              else if (rdx_1 > 0x401c463abeccb2bb)
00035a8e                  rcx_2 = (int32_t)(rr_1[0] * 0.63661977236758138 + 0.5);
00035a61              else
00035a61              {
00035a72                  int32_t rcx_3;
00035a72                  (uint8_t)rcx_3 = rdx_1 > 0x4015fdbbe9bba775;
00035a75                  rcx_2 = rcx_3 + 3;
00035a61              }
00035a61              
00035a96              uint128_t entry_rr_1 = _mm_cvtepi32_pd((uint64_t)rcx_2);
00035aaa              double zmm3 = (uint64_t)entry_rr_1 * 6.0771005065061922e-11;
00035ab2              rr_1[0] = rr_1[0] - (uint64_t)entry_rr_1 * 1.5707963267341256;
00035ad0              uint64_t r8_3 =
00035ad0                  (rdx_1 >> 0x34) - ((uint64_t)(uint32_t)((int64_t)rr_1 >> 0x34) & 0x7ff);
00035ad0              
00035ad7              if (r8_3 > 0xf)
00035ad7              {
00035ad9                  uint64_t entry_zmm5[0x2];
00035ad9                  uint64_t temp0_5[0x2] = _mm_xor_pd(entry_zmm5, entry_zmm5);
00035add                  double zmm2 = rr_1[0];
00035ae1                  entry_rr = entry_rr_1;
00035ae5                  entry_rr[0] = entry_rr[0] * 6.077100506303966e-11;
00035b01                  rr_1[0] = rr_1[0] + temp0_5[0] - entry_rr[0];
00035b0d                  zmm3 = (uint64_t)entry_rr_1 * 2.0222662487959506e-21
00035b0d                      - (zmm2 - rr_1[0] - entry_rr[0]);
00035b0d                  
00035b15                  if (r8_3 > 0x30)
00035b15                  {
00035b23                      x = (uint64_t)entry_rr_1 * 2.0222662487111665e-21;
00035b33                      temp0_5[0] = temp0_5[0] - x;
00035b37                      rr_1[0] = rr_1[0] + temp0_5[0];
00035b3b                      rr_1[0] = rr_1[0] - rr_1[0];
00035b3f                      rr_1[0] = rr_1[0] - x;
00035b43                      zmm3 = (uint64_t)entry_rr_1 * 8.4784276603688996e-32 - rr_1[0];
00035b15                  }
00035ad7              }
00035ad7              
00035b4b              region_1 = rcx_2 & 3;
00035b4e              x = rr_1[0] - zmm3;
00035b52              rr_1[0] = rr_1[0] - x;
00035b56              rr_1[0] = rr_1[0] - zmm3;
00035a22          }
00035a22          
00035b96          entry_rr = rr_1;
00035b96          
00035b9c          if (!rdi_1)
00035b9c          {
00035bc6              if (region_1 == 1)
00035bd7                  return cos_piby4(x, entry_rr[0]);
00035bd7              
00035bcb              if (region_1 == 2)
00035bb6                  return _mm_xor_pd(sin_piby4(x, entry_rr[0]), zmm7);
00035bb6              
00035bd0              if (region_1 == 3)
00035bd0              {
00035bbc                  x = cos_piby4(x, entry_rr[0]);
00035bb6                  return _mm_xor_pd(x, zmm7);
00035bd0              }
00035b9c          }
00035b9c          else
00035b9c          {
00035ba1              if (region_1 == 1)
00035ba1              {
00035bbc                  x = cos_piby4(x, entry_rr[0]);
00035bb6                  return _mm_xor_pd(x, zmm7);
00035ba1              }
00035ba1              
00035ba6              if (region_1 != 2)
00035ba6              {
00035baf                  if (region_1 == 3)
00035bd7                      return cos_piby4(x, entry_rr[0]);
00035bd7                  
00035bb6                  return _mm_xor_pd(sin_piby4(x, entry_rr[0]), zmm7);
00035ba6              }
00035b9c          }
00035916      }
00035916      else
00035916      {
00035925          if (rdx_1 < 0x3f20000000000000)
00035925          {
00035934              if (rdx_1 >= 0x3e40000000000000)
00035964                  rr_1[0] = rr_1[0] - x * rr_1[0] * rr_1[0] * 0.16666666666666666;
00035934              else
00035934              {
00035939                  if (!rdx_1)
00035beb                      return x;
00035beb                  
00035946                  _controlfp(0x10, 0x10);
00035934              }
00035934              
0003594b              return rr_1[0];
00035925          }
00035925          
0003596a          entry_rr = _mm_xor_pd(entry_rr, entry_rr);
00035916      }
00035916      
0003596e      return sin_piby4(x, entry_rr[0]);
000358d4  }

00035bec                                      cc cc cc cc cc cc cc cc                                                  ........

00035bf4    double __convention("sysv") cos(double x)

00035bf4  {
00035c0b      uint128_t zmm6;
00035c0b      uint128_t var_18 = zmm6;
00035c18      uint64_t entry_zmm7[0x2];
00035c18      uint64_t var_28[0x2] = entry_zmm7;
00035c1d      uint64_t rr_1[0x2] = x;
00035c24      int64_t rdx_1 = x & 0x7fffffffffffffff;
00035c34      uint64_t entry_rr[0x2];
00035c34      
00035c34      if (rdx_1 > 0x3fe921fb54442d18)
00035c34      {
00035cb4          if ((x & 0x7ff0000000000000) == 0x7ff0000000000000)
00035cb4          {
00035cb6              double temp0_2 = _mm_xor_pd(x, x);
00035cec              int32_t flags;
00035cec              uint64_t value;
00035cec              
00035cec              if (!(0xfffffffffffff & x))
00035cec              {
00035d12                  flags = 8;
00035d1a                  value = -0x8000000000000;
00035cec              }
00035cec              else
00035cec              {
00035cf8                  value = x | 0x8000000000000;
00035cfd                  flags = 0;
00035cec              }
00035cec              
00035d08              return _handle_error("cos", 0x12, value, 1, flags, 0x21, (int64_t)rr_1, 
00035d08                  temp0_2, 1);
00035cb4          }
00035cb4          
00035d26          zmm6 = -0x8000000000000000;
00035d26          
00035d31          if (rdx_1 != x)
00035d33              rr_1 = _mm_xor_pd(rr_1, zmm6);
00035d33          
00035d43          int32_t region_1;
00035d43          
00035d43          if (500000.0 <= rr_1[0])
00035d43          {
00035e99              int32_t region;
00035e99              double r;
00035e99              double rr;
00035e99              zmm6 = __remainder_piby2(rr_1[0], &r, &rr, &region);
00035e9e              region_1 = region;
00035ea5              x = r;
00035eae              rr_1 = (uint128_t)rr;
00035d43          }
00035d43          else
00035d43          {
00035d5d              int32_t rcx_2;
00035d5d              
00035d5d              if (rdx_1 <= 0x400f6a7a2955385e)
00035d5d              {
00035d6e                  int32_t rcx_1;
00035d6e                  (uint8_t)rcx_1 = rdx_1 > 0x4002d97c7f3321d2;
00035d71                  rcx_2 = rcx_1 + 1;
00035d5d              }
00035d5d              else if (rdx_1 > 0x401c463abeccb2bb)
00035daf                  rcx_2 = (int32_t)(rr_1[0] * 0.63661977236758138 + 0.5);
00035d82              else
00035d82              {
00035d93                  int32_t rcx_3;
00035d93                  (uint8_t)rcx_3 = rdx_1 > 0x4015fdbbe9bba775;
00035d96                  rcx_2 = rcx_3 + 3;
00035d82              }
00035d82              
00035db7              uint128_t entry_rr_1 = _mm_cvtepi32_pd((uint64_t)rcx_2);
00035dcb              double zmm4 = (uint64_t)entry_rr_1 * 6.0771005065061922e-11;
00035dd3              rr_1[0] = rr_1[0] - (uint64_t)entry_rr_1 * 1.5707963267341256;
00035df1              uint64_t r8_3 =
00035df1                  (rdx_1 >> 0x34) - ((uint64_t)(uint32_t)((int64_t)rr_1 >> 0x34) & 0x7ff);
00035df1              
00035df8              if (r8_3 > 0xf)
00035df8              {
00035dfa                  uint64_t temp0_5[0x2] = _mm_xor_pd(entry_zmm7, entry_zmm7);
00035dfe                  double zmm2 = rr_1[0];
00035e02                  entry_rr = entry_rr_1;
00035e06                  entry_rr[0] = entry_rr[0] * 6.077100506303966e-11;
00035e22                  rr_1[0] = rr_1[0] + temp0_5[0] - entry_rr[0];
00035e2e                  zmm4 = (uint64_t)entry_rr_1 * 2.0222662487959506e-21
00035e2e                      - (zmm2 - rr_1[0] - entry_rr[0]);
00035e2e                  
00035e36                  if (r8_3 > 0x30)
00035e36                  {
00035e44                      x = (uint64_t)entry_rr_1 * 2.0222662487111665e-21;
00035e54                      temp0_5[0] = temp0_5[0] - x;
00035e58                      rr_1[0] = rr_1[0] + temp0_5[0];
00035e5c                      rr_1[0] = rr_1[0] - rr_1[0];
00035e60                      rr_1[0] = rr_1[0] - x;
00035e64                      zmm4 = (uint64_t)entry_rr_1 * 8.4784276603688996e-32 - rr_1[0];
00035e36                  }
00035df8              }
00035df8              
00035e6c              region_1 = rcx_2 & 3;
00035e6f              x = rr_1[0] - zmm4;
00035e73              rr_1[0] = rr_1[0] - x;
00035e77              rr_1[0] = rr_1[0] - zmm4;
00035d43          }
00035d43          
00035eba          entry_rr = rr_1;
00035eba          
00035ebe          if (region_1 == 1)
00035ee1              return _mm_xor_pd(sin_piby4(x, entry_rr[0]), zmm6);
00035ee1          
00035ec3          if (region_1 == 2)
00035ec3          {
00035ed5              x = cos_piby4(x, entry_rr[0]);
00035ee1              return _mm_xor_pd(x, zmm6);
00035ec3          }
00035ec3          
00035ec8          if (region_1 == 3)
00035ece              return sin_piby4(x, entry_rr[0]);
00035c34      }
00035c34      else
00035c34      {
00035c43          if (rdx_1 < 0x3f20000000000000)
00035c43          {
00035c52              if (rdx_1 >= 0x3e40000000000000)
00035c52              {
00035c7e                  rr_1[0] = rr_1[0] * rr_1[0];
00035c82                  rr_1[0] = rr_1[0] * 0.5;
00035c8a                  return 1.0 - rr_1[0];
00035c52              }
00035c52              
00035c59              if (rdx_1)
00035c6f                  _controlfp(0x10, 0x10);
00035c6f              
00035c5b              return 1.0;
00035c43          }
00035c43          
00035c93          entry_rr = _mm_xor_pd(entry_rr, entry_rr);
00035c34      }
00035c34      
00035c97      return cos_piby4(x, entry_rr[0]);
00035bf4  }

00035ef4                                                              cc cc cc cc cc cc cc cc                                  ........

00035efc    float atan2f(float fy, float fx)

00035efc  {
00035f10      int64_t rbx = 0;
00035f35      float temp0 = _mm_unpacklo_ps(fx, fx);
00035f3e      float temp0_1 = _mm_unpacklo_ps(fy, fy);
00035f4c      double zmm7[0x2] = _mm_cvtps_pd(temp0);
00035f58      int64_t rax = (int64_t)zmm7;
00035f60      uint128_t zmm6 = _mm_cvtps_pd(temp0_1);
00035f69      int64_t arg_18 = (int64_t)zmm6;
00035f7a      int64_t rdx_1 = rax & 0x7fffffffffffffff;
00035f7d      int64_t rbp_1 = rax & 0x8000000000000000;
00035f86      int64_t rcx_1 = arg_18 & 0x7fffffffffffffff;
00035f89      int64_t rsi_1 = arg_18 & 0x8000000000000000;
00035f8f      int32_t r13;
00035f8f      (uint8_t)r13 = rdx_1 == 0x7ff0000000000000;
00035f96      int32_t r14;
00035f96      (uint8_t)r14 = rcx_1 == 0x7ff0000000000000;
00035fa8      int32_t r12_3 =
00035fa8          ((int32_t)(arg_18 >> 0x34) & 0x7ff) - ((int32_t)(rax >> 0x34) & 0x7ff);
00035fae      float arg_8;
00035fae      
00035fae      if (rdx_1 <= 0x7ff0000000000000)
00035fae      {
00036003          if (rcx_1 <= 0x7ff0000000000000)
00036003          {
00036013              if (!rcx_1)
00036013              {
00036018                  if (!rbp_1)
000361e9                      return (float)(uint64_t)zmm6;
000361e9                  
00036021                  if (!rsi_1)
00036041                      zmm6 = ((float)(long double)pi);
00036021                  else
00036033                      (uint32_t)zmm6 = (float)__xorpd_xmmxuq_memxuq(((int32_t)pi), 
00036033                          (*(uint128_t*)__mask@@NegDouble@));
00036033                  
0003604d                  _controlfp(0x10, 0x10);
00036052                  return (uint32_t)zmm6;
00036013              }
00036013              
00036062              if (!rdx_1)
00036062              {
00036067                  if (rsi_1)
00036067                  {
00036069                      fy = (int32_t)data_3fb20;
00036079                  label_36079:
00036079                      (uint32_t)zmm6 = (float)__xorpd_xmmxuq_memxuq(fy, 
00036079                          (*(uint128_t*)__mask@@NegDouble@));
0003604d                      _controlfp(0x10, 0x10);
00036052                      return (uint32_t)zmm6;
00036067                  }
00036067                  
00036083                  _controlfp(0x10, 0x10);
00036062              }
00036062              
000360a6              if (r12_3 > 0x1a)
000360a6              {
000360ab                  if (rsi_1)
000360ab                  {
000360ad                      fy = (int32_t)data_3fb20;
000360bd                  label_360bd:
000360bd                      fy = (float)__xorpd_xmmxuq_memxuq(fy, 
000360bd                          (*(uint128_t*)__mask@@NegDouble@));
000360c1                      goto label_360cb;
000360ab                  }
000360ab                  
000360c3                  fy = (float)(long double)data_3fb20;
000360cb              label_360cb:
0003604d                  _controlfp(0x10, 0x10);
00036052                  return fy;
000360a6              }
000360a6              
000360e0              if (r12_3 < 0xfffffff3 && !rbp_1)
000360e0              {
000360ed                  if (r12_3 < 0xffffff6a)
000360ed                  {
000360f6                      _controlfp(0x12, 0x12);
000360f6                      
000360fe                      if (!rsi_1)
0003610d                          return (int32_t){0};
0003610d                      
00036100                      return -0f;
000360ed                  }
000360ed                  
00036119                  if (r12_3 >= 0xffffff82)
000361f2                      (uint64_t)zmm6 = (uint64_t)zmm6 / zmm7[0];
00036119                  else
00036119                  {
00036142                      arg_18 = ((int32_t)(((int32_t)(0f * (uint64_t)zmm6)) / zmm7[0]));
00036156                      int64_t rax_4 = arg_18 & 0x7fffffffffffffff;
00036156                      
0003616b                      if (((int32_t)(rax_4 >> 0x34) & 0x7ff) - 0x64 > 0)
00036181                          rbx = (int64_t)(((int32_t)(rax_4 >> 0x34) & 0x7ff) - 0x64) << 0x34
00036181                              | (rax_4 & 0x800fffffffffffff);
0003616b                      else if (1 - (((int32_t)(rax_4 >> 0x34) & 0x7ff) - 0x64) <= 0x36)
000361af                      {
000361b5                          uint64_t rax_8 = ((rax_4 & 0x801fffffffffffff) | 0x10000000000000)
000361b5                              >> ((1 - (((int32_t)(rax_4 >> 0x34) & 0x7ff) - 0x64)) - 1);
000361c1                          rbx = (rax_8 >> 1) + (rax_8 & 1);
000361af                      }
000361af                      
000361c4                      int64_t rbx_5 = rbx | (arg_18 & 0x8000000000000000);
000361cf                      zmm6 = (uint128_t)rbx_5;
000361cf                      
000361db                      if (!(0x7ff0000000000000 & rbx_5))
000361e4                          _controlfp(0x12, 0x12);
00036119                  }
00036119                  
000361e9                  return (float)(uint64_t)zmm6;
000360e0              }
000360e0              
00036201              if (r12_3 < 0xffffffe6 && rbp_1)
00036201              {
00036206                  if (!rsi_1)
00036206                  {
00036215                      fy = (float)(long double)pi;
0003621d                      goto label_360cb;
00036206                  }
00036206                  
00036208                  fy = (int32_t)pi;
00036210                  goto label_36079;
00036201              }
00036201              
0003622a              if (r14 && r13)
0003622a              {
0003622f                  if (!rbp_1)
0003622f                  {
00036253                      if (!rsi_1)
00036253                      {
00036262                          fy = (float)(long double)piby4;
0003626a                          goto label_360cb;
00036253                      }
00036253                      
00036255                      fy = (int32_t)piby4;
0003625d                      goto label_360bd;
0003622f                  }
0003622f                  
00036234                  if (!rsi_1)
00036234                  {
00036243                      fy = (float)(long double)three_piby4;
0003624b                      goto label_360cb;
00036234                  }
00036234                  
00036236                  fy = (int32_t)three_piby4;
0003623e                  goto label_360bd;
0003622a              }
0003622a              
0003626f              uint64_t zmm5[0x2] = -0x8000000000000000;
0003626f              
0003627a              if (rbp_1)
0003627c                  zmm7 = _mm_xor_pd(zmm7, zmm5);
0003627c              
00036283              if (rsi_1)
00036285                  zmm6 = _mm_xor_pd(zmm6, zmm5);
00036285              
0003628d              int32_t rdx_2;
0003628d              
0003628d              if ((uint64_t)zmm6 <= zmm7[0])
000362a2                  rdx_2 = 0;
0003628d              else
0003628d              {
0003628f                  fy = zmm7[0];
00036293                  zmm7 = zmm6;
00036297                  rdx_2 = 1;
0003629c                  zmm6 = fy;
0003628d              }
0003628d              
000362a8              uint128_t zmm4;
000362a8              (uint64_t)zmm4 = (uint64_t)zmm6 / zmm7[0];
000362b4              double zmm2;
000362b4              
000362b4              if (!((uint64_t)zmm4 <= 0.0625))
000362b4              {
000362b6                  zmm2 = 256.0;
000362c6                  (uint64_t)zmm4 = (uint64_t)zmm4 * zmm2;
000362ca                  uint128_t zmm3;
000362ca                  (uint64_t)zmm3 = (uint64_t)zmm6 * zmm2;
000362ce                  (uint64_t)zmm4 = (uint64_t)zmm4 + 0.5;
000362d6                  int32_t rcx_7 = (int32_t)(int64_t)(uint64_t)zmm4;
000362e0                  fx = (int32_t)(double)(uint64_t)rcx_7;
000362f4                  fy = (int32_t)(fx * zmm7[0]);
000362f8                  zmm7[0] = zmm7[0] * zmm2;
000362fc                  (uint64_t)zmm3 = (uint64_t)zmm3 - fy;
00036304                  (uint64_t)zmm3 = (uint64_t)zmm3
00036304                      / ((int32_t)(((int32_t)(fx * (uint64_t)zmm6)) + zmm7[0]));
00036310                  (uint64_t)zmm4 = (uint64_t)zmm3 + atan_jby256[(uint64_t)(rcx_7 - 0x10)];
0003636d                  (uint64_t)zmm4 = (uint64_t)zmm4 - ((int32_t)(((int32_t)(((int32_t)(
0003636d                      (uint32_t)zmm3 * (uint64_t)zmm3)) * (uint64_t)zmm3))
0003636d                      * 0.33333333333224097));
000362b4              }
000362b4              else if (!(-1.88909657e+26f > (uint64_t)zmm4))
00036333              {
00036341                  zmm2 = (uint64_t)zmm4 * (uint64_t)zmm4;
0003636d                  (uint64_t)zmm4 = (uint64_t)zmm4 - ((int32_t)(((int32_t)(1.46601243e+13f -
0003636d                      ((int32_t)(((int32_t)(-1.55369547e-23f
0003636d                      - ((int32_t)((uint32_t)zmm2 * 0.1428571356180717)))) * zmm2)))) * zmm2
0003636d                      * (uint64_t)zmm4));
00036333              }
00036333              
00036373              if (rdx_2)
00036381                  zmm4 = ((int32_t)(((int32_t)data_3fb20) - (uint64_t)zmm4));
00036381              
00036388              if (rbp_1)
00036396                  zmm4 = ((int32_t)(((int32_t)pi) - (uint64_t)zmm4));
00036396              
0003639d              if (rsi_1)
0003639f                  zmm4 = _mm_xor_pd(zmm4, zmm5);
0003639f              
000363a3              return (float)(uint64_t)zmm4;
00036003          }
00036003          
00036005          arg_8 = temp0_1;
00035fae      }
00035fae      else
00035fb0          arg_8 = temp0;
00035fb0      
00035ff6      return _handle_errorf("atan2f", 0x10, (uint64_t)arg_8 | 0x400000, 1, 0, 0x21, temp0, 
00035ff6          temp0_1, 2);
00035efc  }

000363c9                             cc cc cc cc cc cc cc                                                           .......

000363d0    double sub_363d0(int64_t arg1, double* arg2, int32_t* arg3)

000363d0  {
000363e8      int64_t var_48 = 0;
00036447      uint64_t r10_3 = ((arg1 & 0xfffffe0000000) | 0x10000000000000) >> 0x1d;
00036458      uint64_t r9_2 = (uint64_t)((((int32_t)(arg1 >> 0x34) & 0x7ff) - 0x3ff) / 0x24);
00036462      int32_t r11_4 =
00036462          ((int32_t)(arg1 >> 0x34) & 0x7ff) - 0x3ff - ((int32_t)(r9_2 * 9) << 2);
00036469      int64_t r8 = (int64_t)(int32_t)(r9_2 + 3);
0003646c      int64_t rcx_1 = r10_3 * *(uint64_t*)(&data_3fb40 + (r8 << 3));
00036484      int64_t rdx_3 = *(uint64_t*)((r8 << 3) + 0x3fb38) * r10_3 + (rcx_1 >> 0x24);
0003648c      int64_t var_50 = rcx_1 & 0xfffffffff;
0003649c      int64_t rcx_5 = (&three_piby4)[r8] * r10_3 + (rdx_3 >> 0x24);
000364a9      int64_t var_58 = rdx_3 & 0xfffffffff;
000364ae      int64_t r8_2 = rcx_5 & 0xfffffffff;
000364b4      uint64_t r9_3 = 1;
000364b7      int64_t rdx_5 = *(uint64_t*)(&data_3fb40 + ((int64_t)(uint32_t)r9_2 << 3));
000364bb      int64_t var_60 = r8_2;
000364cc      int64_t rdx_8 = (rdx_5 * r10_3 + (rcx_5 >> 0x24)) & 0xfffffffff;
000364d2      int64_t var_68 = rdx_8;
000364e0      int32_t rdx_12 = (int32_t)((rdx_8 << 0x24 | r8_2) >> (0x23 - (uint8_t)r11_4)) & 7;
000364e5      int32_t rsi_1 = rdx_12 & 1;
000364e7      int64_t i;
000364e7      int64_t r8_6;
000364e7      
000364e7      if (!rsi_1)
000364e7      {
0003654d          *(uint32_t*)arg3 = rdx_12 >> 1;
00036562          i = ((1 << (0x24 - r11_4)) - 1) & r8_2;
00036562          
0003656e          if (i < &_iob)
0003656e          {
00036570              int64_t* rax_13 = &var_60;
00036570              
00036586              do
00036586              {
00036575                  rax_13 = &rax_13[1];
0003657d                  r9_3 = (uint64_t)((uint32_t)r9_3 + 1);
00036580                  i = i << 0x24 | *(uint64_t*)rax_13;
00036586              } while (i < &_iob);
0003656e          }
0003656e          
0003658b          r8_6 = (&var_60)[(int64_t)(uint32_t)r9_3];
000364e7      }
000364e7      else
000364e7      {
000364f3          *(uint32_t*)arg3 = ((rdx_12 >> 1) + 1) & 3;
00036506          i = ((1 << (0x24 - r11_4)) - 1) & ~r8_2;
00036506          
00036512          if (i < &_iob)
00036512          {
00036514              int64_t* r10_4 = &var_60;
00036514              
00036539              do
00036539              {
0003651c                  r10_4 = &r10_4[1];
00036520                  r9_3 = (uint64_t)((uint32_t)r9_3 + 1);
00036533                  i = (~*(uint64_t*)r10_4 & 0xfffffffff) | i << 0x24;
00036539              } while (i < &_iob);
00036512          }
00036512          
00036546          r8_6 = ~(&var_60)[(int64_t)(uint32_t)r9_3] & 0xfffffffff;
000364e7      }
000364e7      
00036590      int32_t r10_5 = 0;
00036590      
000365aa      for (; i < 0x400000000000; i <<= 6)
0003659f          r10_5 += 6;
0003659f      
000365b7      for (; i < 0x10000000000000; i *= 2)
000365ae          r10_5 += 1;
000365ae      
000365c3      uint64_t rcx_8;
000365c3      (uint8_t)rcx_8 = 0x24 - (uint8_t)r10_5;
000365ee      double result =
000365ee          ((int64_t)(r11_4 - ((int32_t)(r9_3 * 9) << 2) - r10_5 + 0x34) + 0x3ff) << 0x34
000365ee          | ((r8_6 >> (uint8_t)rcx_8 | i) & 0xfffffffffffff);
000365ee      
000365f3      if (rsi_1)
000365ff          result |= 0x8000000000000000;
000365ff      
00036626      *(uint64_t*)arg2 = result * 1.5707963267948966;
00036632      return result;
000363d0  }

00036633                                                           cc cc cc cc cc cc cc cc cc                                 .........

0003663c    float sinf(float x)

0003663c  {
00036654      float zmm6[0x4] = x;
00036657      float temp0[0x4] = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
0003665a      uint128_t zmm7;
0003665a      uint128_t var_28 = zmm7;
0003665f      uint64_t entry_zmm8[0x2];
0003665f      uint64_t var_38[0x2] = entry_zmm8;
00036665      double zmm3[0x2] = _mm_cvtps_pd(*(uint64_t*)&temp0[0]);
00036668      int64_t arg_18 = (int64_t)zmm3;
0003667c      int64_t r9_1 = arg_18 & 0x7fffffffffffffff;
0003667c      
0003668c      if (r9_1 <= 0x3fe921fb54442d18)
0003668c      {
0003669b          if (r9_1 >= 0x3f80000000000000)
0003669b              goto label_369ce;
0003669b          
000366ae          if (r9_1 >= 0x3f20000000000000)
000366ae          {
000366df              zmm3[0] = zmm3[0] - ((int32_t)(((int32_t)(((int32_t)(zmm3[0] * zmm3[0]))
000366df                  * zmm3[0])) * 0.16666666666666666));
000366e3              return (float)zmm3[0];
000366ae          }
000366ae          
000366b3          if (r9_1)
000366c4              _controlfp(0x10, 0x10);
000366c4          
000366b5          return temp0[0];
0003668c      }
0003668c      
000366ff      if ((arg_18 & 0x7ff0000000000000) == 0x7ff0000000000000)
000366ff      {
00036746          int32_t flags;
00036746          uint64_t value;
00036746          
00036746          if (!(0xfffffffffffff & arg_18))
00036746          {
0003676b              flags = 8;
00036773              value = 0xffc00000;
00036746          }
00036746          else
00036746          {
00036750              value = (uint64_t)temp0[0] | 0x400000;
00036755              flags = 0;
00036746          }
00036746          
0003675a          return _handle_errorf("sinf", 0x1e, value, 1, flags, 0x21, temp0[0], 0f, 1);
000366ff      }
000366ff      
0003677b      uint64_t zmm5[0x2] = -0x8000000000000000;
00036783      uint32_t rdi_1 = (int32_t)(arg_18 >> 0x3f);
00036783      
00036789      if (rdi_1)
0003678b          zmm3 = _mm_xor_pd(zmm3, zmm5);
0003678b      
00036797      zmm6 = 0x3fe0000000000000;
000367a3      int32_t rcx_4;
000367a3      double zmm1[0x2];
000367a3      
000367a3      if (0f <= zmm3[0])
000367a3      {
000368e4          int32_t arg_10;
000368e4          double arg_20;
000368e4          sub_363d0(r9_1, &arg_20, &arg_10);
000368e9          rcx_4 = arg_10;
000368f0          zmm3 = (uint128_t)arg_20;
000367a3      }
000367a3      else
000367a3      {
000367bd          int32_t rcx_2;
000367bd          
000367bd          if (r9_1 <= 0x400f6a7a2955385e)
000367bd          {
000367ce              int32_t rcx_1;
000367ce              (uint8_t)rcx_1 = r9_1 > 0x4002d97c7f3321d2;
000367d1              rcx_2 = rcx_1 + 1;
000367bd          }
000367bd          else if (r9_1 > 0x401c463abeccb2bb)
0003680b              rcx_2 = (int32_t)((int32_t)(
0003680b                  ((int32_t)(zmm3[0] * 0.63661977236758138)) + *(uint64_t*)&zmm6[0]));
000367e2          else
000367e2          {
000367f3              int32_t rcx_3;
000367f3              (uint8_t)rcx_3 = r9_1 > 0x4015fdbbe9bba775;
000367f6              rcx_2 = rcx_3 + 3;
000367e2          }
000367e2          
00036813          zmm7 = _mm_cvtepi32_pd((uint64_t)rcx_2);
00036827          double zmm4 = (uint64_t)zmm7 * 6.0771005065061922e-11;
0003682f          zmm3[0] = zmm3[0] - ((int32_t)((uint32_t)zmm7 * 1.5707963267341256));
0003684d          uint64_t rdx_3 =
0003684d              (r9_1 >> 0x34) - ((uint64_t)(uint32_t)((int64_t)zmm3 >> 0x34) & 0x7ff);
0003684d          
00036854          if (rdx_3 > 0xf)
00036854          {
00036856              uint64_t temp0_4[0x2] = _mm_xor_pd(entry_zmm8, entry_zmm8);
0003685b              double zmm2 = zmm3[0];
0003685f              zmm1 = zmm7;
00036863              zmm1[0] = zmm1[0] * 6.077100506303966e-11;
00036880              zmm3[0] = zmm3[0] + ((int32_t)(temp0_4[0] - zmm1[0]));
0003688c              zmm4 = (uint64_t)zmm7 * 2.0222662487959506e-21 - (zmm2 - zmm3[0] - zmm1[0]);
0003688c              
00036894              if (rdx_3 > 0x30)
00036894              {
000368a2                  x = (int32_t)((uint32_t)zmm7 * 2.0222662487111665e-21);
000368b2                  temp0_4[0] = temp0_4[0] - x;
000368b7                  zmm3[0] = zmm3[0] + temp0_4[0];
000368bc                  zmm3[0] = zmm3[0] - zmm3[0];
000368c0                  zmm3[0] = zmm3[0] - x;
000368c4                  zmm4 = (uint64_t)zmm7 * 8.4784276603688996e-32 - zmm3[0];
00036894              }
00036854          }
00036854          
000368c8          zmm3[0] = zmm3[0] - zmm4;
000368cc          rcx_4 = rcx_2 & 3;
000367a3      }
000367a3      
000368fb      if (!rdi_1)
000368fb      {
000369ba          if (rcx_4 == 1)
000369ba          {
00036a0c          label_36a0c:
00036a0c              zmm1 = 0x3efa015c50a93b49;
00036a14              zmm3[0] = zmm3[0] * zmm3[0];
00036a24              zmm1[0] = zmm1[0] - ((int32_t)(zmm3[0] * 2.7301013343179833e-07));
00036a2c              x = (int32_t)(zmm3[0] * zmm3[0]);
00036a30              zmm1[0] = zmm1[0] * zmm3[0];
00036a34              zmm1[0] = zmm1[0] - 0.0013888887673175665;
00036a3c              zmm1[0] = zmm1[0] * zmm3[0];
00036a40              zmm3[0] = zmm3[0] * *(uint64_t*)&zmm6[0];
00036a44              zmm1[0] = zmm1[0] + 0.041666666664325176;
00036a4c              zmm1[0] = zmm1[0] * x;
00036a5c              zmm1[0] = zmm1[0] + ((int32_t)(0f - zmm3[0]));
000369ba          }
000369ba          else
000369ba          {
000369bf              if (rcx_4 != 2)
000369bf              {
000369c8                  if (rcx_4 == 3)
000369c8                      goto label_36961;
000369c8                  
000369c8                  goto label_369ce;
000369bf              }
000369bf              
0003691c          label_3691c:
0003691c              x = (int32_t)(zmm3[0] * zmm3[0]);
00036920              zmm1 = x;
00036924              zmm1[0] = zmm1[0] * 2.7250001514558409e-06;
0003692c              zmm1[0] = zmm1[0] - 0.0001984008743595277;
00036934              zmm1[0] = zmm1[0] * x;
00036938              zmm1[0] = zmm1[0] + 0.0083333318763308632;
00036940              zmm1[0] = zmm1[0] * x;
00036944              x = (int32_t)(x * zmm3[0]);
00036948              zmm1[0] = zmm1[0] - 0.16666666663860844;
00036950              zmm1[0] = zmm1[0] * x;
00036954              zmm1[0] = zmm1[0] + zmm3[0];
00036958              zmm1 = _mm_xor_pd(zmm1, zmm5);
000369ba          }
000368fb      }
000368fb      else if (rcx_4 == 1)
00036904      {
00036961      label_36961:
00036961          zmm1 = 0x3efa015c50a93b49;
00036969          zmm3[0] = zmm3[0] * zmm3[0];
00036979          zmm1[0] = zmm1[0] - ((int32_t)(zmm3[0] * 2.7301013343179833e-07));
00036981          x = (int32_t)(zmm3[0] * zmm3[0]);
00036985          zmm1[0] = zmm1[0] * zmm3[0];
00036989          zmm1[0] = zmm1[0] - 0.0013888887673175665;
00036991          zmm1[0] = zmm1[0] * zmm3[0];
00036995          zmm3[0] = zmm3[0] * *(uint64_t*)&zmm6[0];
00036999          zmm1[0] = zmm1[0] + 0.041666666664325176;
000369a1          zmm1[0] = zmm1[0] * x;
000369b1          zmm1[0] = zmm1[0] + ((int32_t)(0f - zmm3[0]));
00036958          zmm1 = _mm_xor_pd(zmm1, zmm5);
00036904      }
00036904      else
00036904      {
00036909          if (rcx_4 != 2)
00036909          {
00036912              if (rcx_4 == 3)
00036912                  goto label_36a0c;
00036912              
00036912              goto label_3691c;
00036909          }
00036909          
000369ce      label_369ce:
000369ce          x = (int32_t)(zmm3[0] * zmm3[0]);
000369d2          zmm1 = x;
000369d6          zmm1[0] = zmm1[0] * 2.7250001514558409e-06;
000369de          zmm1[0] = zmm1[0] - 0.0001984008743595277;
000369e6          zmm1[0] = zmm1[0] * x;
000369ea          zmm1[0] = zmm1[0] + 0.0083333318763308632;
000369f2          zmm1[0] = zmm1[0] * x;
000369f6          x = (int32_t)(x * zmm3[0]);
000369fa          zmm1[0] = zmm1[0] - 0.16666666663860844;
00036a02          zmm1[0] = zmm1[0] * x;
00036a06          zmm1[0] = zmm1[0] + zmm3[0];
00036904      }
00036904      
00036a60      return (float)zmm1[0];
0003663c  }

00036a7d                                                                                         cc cc cc                               ...
00036a80  cc cc cc cc                                                                                      ....

00036a84    float cosf(float x)

00036a84  {
00036a92      float zmm1[0x4] = x;
00036a95      uint128_t zmm7;
00036a95      uint128_t var_18 = zmm7;
00036a9a      float temp0[0x4] = _mm_unpacklo_ps(zmm1, *(uint64_t*)&zmm1[0]);
00036a9d      uint64_t entry_zmm8[0x2];
00036a9d      uint64_t var_28[0x2] = entry_zmm8;
00036aa3      double zmm3[0x2] = _mm_cvtps_pd(*(uint64_t*)&temp0[0]);
00036aa6      int64_t arg_18 = (int64_t)zmm3;
00036aba      int64_t r9_1 = arg_18 & 0x7fffffffffffffff;
00036aba      
00036aca      if (r9_1 <= 0x3fe921fb54442d18)
00036aca      {
00036add          if (r9_1 >= 0x3f80000000000000)
00036add              goto label_36b31;
00036add          
00036aec          if (r9_1 >= 0x3f20000000000000)
00036aec          {
00036b18              zmm3[0] = zmm3[0] * zmm3[0];
00036b1c              zmm3[0] = zmm3[0] * 0.5;
00036b28              return (float)((int32_t)(0f - zmm3[0]));
00036aec          }
00036aec          
00036af3          if (r9_1)
00036b09              _controlfp(0x10, 0x10);
00036b09          
00036af5          return 1f;
00036aca      }
00036aca      
00036ba1      if ((arg_18 & 0x7ff0000000000000) == 0x7ff0000000000000)
00036ba1      {
00036be2          int32_t flags;
00036be2          uint64_t value;
00036be2          
00036be2          if (!(0xfffffffffffff & arg_18))
00036be2          {
00036c0f              flags = 8;
00036c17              value = 0xffc00000;
00036be2          }
00036be2          else
00036be2          {
00036bec              value = (uint64_t)temp0[0] | 0x400000;
00036bf3              flags = 0;
00036be2          }
00036be2          
00036bfe          return _handle_errorf("cosf", 0x12, value, 1, flags, 0x21, temp0[0], 0f, 1);
00036ba1      }
00036ba1      
00036c1f      uint64_t zmm5[0x2] = -0x8000000000000000;
00036c1f      
00036c2f      if ((char)(arg_18 >> 0x3f))
00036c31          zmm3 = _mm_xor_pd(zmm3, zmm5);
00036c31      
00036c41      int32_t rcx_3;
00036c41      
00036c41      if (0f <= zmm3[0])
00036c41      {
00036d82          int32_t arg_10;
00036d82          double arg_20;
00036d82          sub_363d0(r9_1, &arg_20, &arg_10);
00036d87          rcx_3 = arg_10;
00036d8e          zmm3 = (uint128_t)arg_20;
00036c41      }
00036c41      else
00036c41      {
00036c5b          int32_t rcx_2;
00036c5b          int32_t rcx_1;
00036c5b          
00036c5b          if (r9_1 <= 0x400f6a7a2955385e)
00036c5b          {
00036c6a              (uint8_t)rcx_1 = r9_1 > 0x4002d97c7f3321d2;
00036c6d              rcx_2 = rcx_1 + 1;
00036c5b          }
00036c5b          else if (r9_1 > 0x401c463abeccb2bb)
00036ca9              rcx_2 =
00036ca9                  (int32_t)((int32_t)(((int32_t)(zmm3[0] * 0.63661977236758138)) + 0.5));
00036c7e          else
00036c7e          {
00036c8d              (uint8_t)rcx_1 = r9_1 > 0x4015fdbbe9bba775;
00036c90              rcx_2 = rcx_1 + 3;
00036c7e          }
00036cb1          zmm7 = _mm_cvtepi32_pd((uint64_t)rcx_2);
00036cc5          double zmm4 = (uint64_t)zmm7 * 6.0771005065061922e-11;
00036ccd          zmm3[0] = zmm3[0] - ((int32_t)((uint32_t)zmm7 * 1.5707963267341256));
00036ceb          uint64_t rdx_4 =
00036ceb              (r9_1 >> 0x34) - ((uint64_t)(uint32_t)((int64_t)zmm3 >> 0x34) & 0x7ff);
00036ceb          
00036cf2          if (rdx_4 > 0xf)
00036cf2          {
00036cf4              uint64_t temp0_4[0x2] = _mm_xor_pd(entry_zmm8, entry_zmm8);
00036cf9              double zmm2 = zmm3[0];
00036cfd              zmm1 = zmm7;
00036d01              *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * 6.077100506303966e-11;
00036d1e              zmm3[0] = zmm3[0] + ((int32_t)(temp0_4[0] - *(uint64_t*)&zmm1[0]));
00036d2a              zmm4 = (uint64_t)zmm7 * 2.0222662487959506e-21
00036d2a                  - (zmm2 - zmm3[0] - *(uint64_t*)&zmm1[0]);
00036d2a              
00036d32              if (rdx_4 > 0x30)
00036d32              {
00036d34                  zmm1 = zmm3;
00036d40                  x = (int32_t)((uint32_t)zmm7 * 2.0222662487111665e-21);
00036d50                  temp0_4[0] = temp0_4[0] - x;
00036d55                  zmm3[0] = zmm3[0] + temp0_4[0];
00036d5a                  *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - zmm3[0];
00036d5e                  *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - x;
00036d62                  zmm4 = (uint64_t)zmm7 * 8.4784276603688996e-32 - *(uint64_t*)&zmm1[0];
00036d32              }
00036cf2          }
00036cf2          
00036d66          zmm3[0] = zmm3[0] - zmm4;
00036d6a          rcx_3 = rcx_2 & 3;
00036c41      }
00036c41      
00036d9a      if (rcx_3 == 1)
00036d9a      {
00036e51          x = (int32_t)(zmm3[0] * zmm3[0]);
00036e55          zmm1 = x;
00036e59          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * 2.7250001514558409e-06;
00036e61          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - 0.0001984008743595277;
00036e69          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * x;
00036e6d          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + 0.0083333318763308632;
00036e75          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * x;
00036e7d          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - 0.16666666663860844;
00036e85          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * ((int32_t)(x * zmm3[0]));
00036e89          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + zmm3[0];
00036e8d          zmm1 = _mm_xor_pd(zmm1, zmm5);
00036d9a      }
00036d9a      else if (rcx_3 == 2)
00036da3      {
00036df3          zmm1 = 0x3efa015c50a93b49;
00036dfb          zmm3[0] = zmm3[0] * zmm3[0];
00036e0b          *(uint64_t*)&zmm1[0] =
00036e0b              *(uint64_t*)&zmm1[0] - ((int32_t)(zmm3[0] * 2.7301013343179833e-07));
00036e13          x = (int32_t)(zmm3[0] * zmm3[0]);
00036e17          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * zmm3[0];
00036e1b          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - 0.0013888887673175665;
00036e23          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * zmm3[0];
00036e27          zmm3[0] = zmm3[0] * 0.5;
00036e2f          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + 0.041666666664325176;
00036e37          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * x;
00036e47          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + ((int32_t)(0f - zmm3[0]));
00036e8d          zmm1 = _mm_xor_pd(zmm1, zmm5);
00036da3      }
00036da3      else if (rcx_3 != 3)
00036da8      {
00036b31      label_36b31:
00036b31          zmm1 = 0x3efa015c50a93b49;
00036b39          zmm3[0] = zmm3[0] * zmm3[0];
00036b49          *(uint64_t*)&zmm1[0] =
00036b49              *(uint64_t*)&zmm1[0] - ((int32_t)(zmm3[0] * 2.7301013343179833e-07));
00036b51          x = (int32_t)(zmm3[0] * zmm3[0]);
00036b55          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * zmm3[0];
00036b59          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - 0.0013888887673175665;
00036b61          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * zmm3[0];
00036b65          zmm3[0] = zmm3[0] * 0.5;
00036b6d          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + 0.041666666664325176;
00036b75          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * x;
00036b85          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + ((int32_t)(0f - zmm3[0]));
00036da8      }
00036da8      else
00036da8      {
00036db2          x = (int32_t)(zmm3[0] * zmm3[0]);
00036db6          zmm1 = x;
00036dba          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * 2.7250001514558409e-06;
00036dc2          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - 0.0001984008743595277;
00036dca          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * x;
00036dce          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + 0.0083333318763308632;
00036dd6          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * x;
00036dde          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] - 0.16666666663860844;
00036de6          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] * ((int32_t)(x * zmm3[0]));
00036dea          *(uint64_t*)&zmm1[0] = *(uint64_t*)&zmm1[0] + zmm3[0];
00036da8      }
00036da8      
00036e91      return (float)*(uint64_t*)&zmm1[0];
00036a84  }

00036ea5                 cc cc cc cc cc cc cc                                                                   .......

00036eac    double __pow_error(double argx, double argy, int32_t index, uint64_t bitret)

00036eac  {
00036ec3      int128_t zmm7 = argx;
00036eca      int128_t zmm6 = argy;
00036ed6      int32_t flags;
00036ed6      int32_t error;
00036ed6      int64_t var_48_1;
00036ed6      int64_t var_40_1;
00036ed6      uint64_t value;
00036ed6      int32_t type;
00036ed6      
00036ed6      if (index > 0x10)
00036ed6      {
000370a4          if (index == 0x11)
000370a4          {
00036f30          label_36f30:
00036f30              int32_t var_38_1 = 2;
00036f38              var_40_1 = (int64_t)zmm6;
00036f3e              var_48_1 = (int64_t)zmm7;
00036f44              error = 0x22;
00036f4c              type = 2;
00036f52              flags = 4;
00036f5a              value = 0x7ff0000000000000;
000370a4          }
000370a4          else
000370a4          {
000370aa              type = 1;
000370aa              
000370b3              if (index == 0x12)
000370b3              {
00036fe8              label_36fe8:
00036fe8                  int32_t var_38_4 = 2;
00036ff0                  var_40_1 = (int64_t)zmm6;
00036ff6                  var_48_1 = (int64_t)zmm7;
00036ffc                  error = 0x21;
00037004                  value = -0x8000000000000;
0003700e                  flags = 8;
000370b3              }
000370b3              else if (index == 0x17)
000370bc              {
0003718b                  int32_t var_38_11 = 2;
00037193                  var_40_1 = (int64_t)zmm6;
00037199                  var_48_1 = (int64_t)zmm7;
0003719f                  error = 0x22;
000371a7                  type = 3;
000371ad                  flags = 0x11;
00037092                  value = -0x10000000000000;
000370bc              }
000370bc              else if (index == 0x18)
000370c5              {
00036fb9              label_36fb9:
00036fb9                  int32_t var_38_3 = 2;
00036fc1                  var_40_1 = (int64_t)zmm6;
00036fc7                  var_48_1 = (int64_t)zmm7;
00036fcd                  error = 0x22;
00036fd5                  type = 3;
00036fdb                  flags = 0x11;
00036f5a                  value = 0x7ff0000000000000;
000370c5              }
000370c5              else if (index == 0x19)
000370ce              {
00037155                  int32_t var_38_10 = 2;
0003715d                  var_40_1 = (int64_t)zmm6;
00037163                  var_48_1 = (int64_t)zmm7;
00037169                  error = 0;
0003716e                  type = 4;
00037174                  value = -0x8000000000000000;
0003717e                  flags = 0x12;
000370ce              }
000370ce              else
000370ce              {
000370d7                  if (index == 0x1a)
000370d7                  {
00036f8d                  label_36f8d:
00036f8d                      int32_t var_38_2 = 2;
00036f95                      var_40_1 = (int64_t)zmm6;
00036f9b                      var_48_1 = (int64_t)zmm7;
00036fa1                      error = 0;
00036fa1                      goto label_36fa6;
000370d7                  }
000370d7                  
000370e0                  if (index == 0x1b)
000370e0                  {
0003711c                      int32_t var_38_9 = 2;
00037124                      var_40_1 = (int64_t)zmm6;
0003712a                      var_48_1 = (int64_t)zmm7;
0003713a                      type = 4;
00037140                      value = -0x8000000000000000 | bitret;
00037143                      error = 0;
00037148                      flags = 0x12;
000370e0                  }
000370e0                  else
000370e0                  {
000370e5                      if (index != 0x1c)
000370e7                          return _mm_xor_pd(argx, argx);
000370e7                      
000370f0                      int32_t var_38_8 = 2;
000370f8                      var_40_1 = (int64_t)zmm6;
000370fe                      var_48_1 = (int64_t)zmm7;
00037104                      error = 0;
00037109                      type = 4;
0003710f                      flags = 0x12;
00037060                      value = bitret;
000370e0                  }
000370ce              }
000370a4          }
00036ed6      }
00036ed6      else if (index == 0x10)
00036edc      {
00037068          int32_t var_38_7 = 2;
00037070          var_40_1 = (int64_t)zmm6;
00037076          var_48_1 = (int64_t)zmm7;
0003707c          error = 0x22;
00037084          type = 2;
0003708a          flags = 4;
00037092          value = -0x10000000000000;
00036edc      }
00036edc      else
00036edc      {
00036ee2          type = 1;
00036ee2          
00036eea          if (!index)
00036eea              goto label_36fe8;
00036eea          
00036ef3          if (index == 1)
00036ef3          {
0003703c              int32_t var_38_6 = 2;
00037044              var_40_1 = (int64_t)zmm6;
0003704a              var_48_1 = (int64_t)zmm7;
00037050              error = 0x21;
00037058              flags = 8;
00037060              value = bitret;
00036ef3          }
00036ef3          else
00036ef3          {
00036efc              if (index != 8)
00036efc              {
00036f05                  if (index == 9)
00036f05                      goto label_36fe8;
00036f05                  
00036f0e                  if (index == 0xa)
00036f0e                      goto label_36fb9;
00036f0e                  
00036f17                  if (index == 0xb)
00036f17                      goto label_36f30;
00036f17                  
00036f1c                  if (index == 0xc)
00036f1c                      goto label_36fb9;
00036f1c                  
00036f25                  if (index == 0xe)
00036f25                      goto label_36f8d;
00036f25                  
00036f2a                  if (index != 0xf)
000370e7                      return _mm_xor_pd(argx, argx);
000370e7                  
00036f2a                  goto label_36f30;
00036efc              }
00036efc              
0003701b              int32_t var_38_5 = 2;
00037023              var_40_1 = (int64_t)zmm6;
00037029              var_48_1 = (int64_t)zmm7;
0003702f              error = 0x22;
00036fa6          label_36fa6:
00036fa6              flags = 0x12;
00036fae              type = 4;
00036fb4              value = 0;
00036ef3          }
00036edc      }
00036edc      
00036f70      return _handle_error("pow", 0x1d, value, type, flags, error, var_48_1, var_40_1, 2);
00036eac  }

000371ba                                                                                cc cc cc cc cc cc                            ......

000371c0    double _call_matherr(int32_t type, int32_t error, char* name, double arg1, double arg2, double retval, uint64_t cw)

000371c0  {
000371dc      int32_t type_1 = type;
000371ec      double var_28 = arg1;
000371f1      double var_20 = arg2;
000371fb      char* name_1 = name;
000371ff      _ctrlfp(cw, 0xffc0);
00037214      _set_errno_from_matherr(type);
00037224      return retval;
000371c0  }

00037225                 cc cc cc cc cc cc cc                                                                   .......

0003722c    int32_t _exception_enabled(uint32_t flags, uint64_t cw)

0003722c  {
00037240      char rdi = (uint8_t)flags;
00037242      int32_t rbx_1 = flags & 0x1f;
00037242      
0003724c      if ((uint8_t)flags & 8 && (uint8_t)cw < 0)
0003724c      {
00037253          _set_statfp(1);
00037258          rbx_1 &= 0xfffffff7;
0003724c      }
0003724c      else if (4 & rdi && TEST_BITQ(cw, 9))
0003726c      {
0003726e          _set_statfp(4);
00037273          rbx_1 &= 0xfffffffb;
0003726c      }
0003726c      else if (rdi & 1 && TEST_BITQ(cw, 0xa))
00037283      {
0003728a          _set_statfp(8);
0003728f          rbx_1 &= 0xfffffffe;
00037283      }
00037283      else if (rdi & 2 && TEST_BITQ(cw, 0xb))
0003729f      {
000372a5          if (rdi & 0x10)
000372ac              _set_statfp(0x10);
000372ac          
000372b1          rbx_1 &= 0xfffffffd;
0003729f      }
0003729f      
000372bf      if (rdi & 0x10 && TEST_BITQ(cw, 0xc))
000372bf      {
000372c6          _set_statfp(0x20);
000372cb          rbx_1 &= 0xffffffef;
000372bf      }
000372bf      
000372dc      int32_t result;
000372dc      (uint8_t)result = !rbx_1;
000372e4      return result;
0003722c  }

000372e5                 cc cc cc cc cc cc cc                                                                   .......

000372ec    float _handle_errorf(char* fname, int32_t opcode, uint64_t value, int32_t type, int32_t flags, int32_t error, float arg1, float arg2, int32_t nargs)

000372ec  {
00037305      void var_118;
00037305      int64_t rax_1 = __security_cookie ^ &var_118;
00037331      uint64_t cw_2 = _ctrlfp(0x1f80, 0xffc0);
00037340      uint64_t cw_1 = cw_2;
00037345      float presult = (uint32_t)value;
00037350      float zmm6[0x4] = arg2;
00037350      
0003735b      if (!_exception_enabled(flags, cw_1))
0003735b      {
00037365          struct _FPIEEE_RECORD prec;
00037365          
00037365          if (nargs == 2)
00037365          {
0003736e              *(uint32_t*)((char*)prec.Operand2.Value + 0) = zmm6[0];
0003737d              *(uint32_t*)((char*)prec.Operand2.__bitfield10 + 0) =
0003737d                  (*(uint32_t*)((char*)prec.Operand2.__bitfield10 + 0) & 0xffffffe1) | 1;
00037365          }
00037365          
000373b0          _raise_excf(&prec, &cw_2, flags, opcode, &arg1, &presult);
0003735b      }
0003735b      
000373c0      double presult_1;
000373c0      
000373c0      if (_matherr_flag || !type)
000373c0      {
0003740c          _set_errno_from_matherr(type);
0003741b          _ctrlfp(cw_2, 0xffc0);
00037420          presult_1 = presult;
000373c0      }
000373c0      else
000373c0      {
000373c2          presult_1 = (uint64_t)presult;
000373c8          double zmm3 = (uint64_t)arg1;
000373d1          uint64_t cw = cw_2;
000373e2          float temp0_1[0x4] = _mm_unpacklo_ps(zmm6, *(uint64_t*)&zmm6[0]);
000373e5          double retval = _mm_cvtps_pd(presult_1);
000373e8          double temp0_2 = _mm_cvtps_pd(*(uint64_t*)&temp0_1[0]);
00037404          (uint32_t)presult_1 = (float)_call_matherr(type, error, fname, 
00037404              _mm_cvtps_pd(zmm3), temp0_2, retval, cw);
000373c0      }
000373c0      
00037431      __security_check_cookie(rax_1 ^ &var_118);
00037449      return (uint32_t)presult_1;
000372ec  }

0003744a                                cc cc cc cc cc cc                                                            ......

00037450    double _handle_error(char* fname, int32_t opcode, uint64_t value, int32_t type, int32_t flags, int32_t error, double arg1, double arg2, int32_t nargs)

00037450  {
00037469      void var_118;
00037469      int64_t rax_1 = __security_cookie ^ &var_118;
00037495      uint64_t cw_1 = _ctrlfp(0x1f80, 0xffc0);
000374a5      uint64_t cw = cw_1;
000374aa      double var_d0 = value;
000374b5      uint128_t zmm6 = (uint128_t)arg2;
000374b5      
000374c0      if (!_exception_enabled(flags, cw))
000374c0      {
000374ca          struct _FPIEEE_RECORD prec;
000374ca          
000374ca          if (nargs == 2)
000374ca          {
000374d3              *(uint64_t*)((char*)prec.Operand2.Value + 0) = (int64_t)zmm6;
000374e2              *(uint32_t*)((char*)prec.Operand2.__bitfield10 + 0) =
000374e2                  (*(uint32_t*)((char*)prec.Operand2.__bitfield10 + 0) & 0xffffffe3) | 3;
000374ca          }
000374ca          
00037515          _raise_exc(&prec, &cw_1, flags, opcode, &arg1, &var_d0);
000374c0      }
000374c0      
00037525      double result;
00037525      
00037525      if (_matherr_flag || !type)
00037525      {
00037561          _set_errno_from_matherr(type);
00037570          _ctrlfp(cw_1, 0xffc0);
00037575          result = var_d0;
00037525      }
00037525      else
00037558          result = _call_matherr(type, error, fname, arg1, (int64_t)zmm6, var_d0, cw_1);
00037558      
00037586      __security_check_cookie(rax_1 ^ &var_118);
0003759e      return result;
00037450  }

0003759f                                                                                               cc                                 .
000375a0  cc cc cc cc cc cc cc cc                                                                          ........

000375a8    uint32_t _control87(uint32_t newctrl, uint32_t mask)

000375a8  {
000375c5      int32_t rbx_1 = mask & 0x308031f;
000375cb      int32_t mxcsr;
000375cb      int32_t rax = _get_fpsr(mxcsr);
000375d3      int32_t rdi = 0;
000375de      int32_t rax_1 = 0;
000375de      
000375e4      if (0x80 & (uint8_t)rax)
000375e4          rax_1 = 0x10;
000375e4      
000375ed      if (TEST_BITD(rax, 9))
000375ef          rax_1 |= 8;
000375ef      
000375f7      if (TEST_BITD(rax, 0xa))
000375f9          rax_1 |= 4;
000375f9      
00037601      if (TEST_BITD(rax, 0xb))
00037603          rax_1 |= 2;
00037603      
0003760b      if (TEST_BITD(rax, 0xc))
0003760d          rax_1 |= 1;
0003760d      
00037615      if (TEST_BITD(rax, 8))
00037617          rax_1 |= 0x80000;
00037617      
00037624      int32_t rcx_1 = rax & 0x6000;
00037624      
00037627      if (rcx_1)
00037627      {
0003762f          if (rcx_1 == 0x2000)
0003764b              rax_1 |= 0x100;
0003762f          else if (rcx_1 == 0x4000)
00037645              rax_1 |= 0x200;
00037637          else if (rcx_1 == 0x6000)
0003763e              rax_1 |= 0x300;
00037627      }
00037627      
0003764f      int32_t r11_1 = rax & 0x8040;
0003764f      
0003765a      if (r11_1 == 0x40)
00037678          rax_1 |= 0x2000000;
0003765a      else if (r11_1 == 0x8000)
00037671          rax_1 |= 0x3000000;
00037663      else if (r11_1 == 0x8040)
0003766b          rax_1 |= 0x1000000;
0003766b      
00037684      int32_t rcx_5 = (~rbx_1 & rax_1) | (newctrl & rbx_1);
00037684      
00037688      if (rcx_5 == rax_1)
00037841          return rax_1;
00037841      
00037691      int32_t rbx_2 = 0;
00037691      
00037693      if (0x10 & (uint8_t)rcx_5)
00037693          rbx_2 = 0x80;
00037693      
00037697      int32_t arg_8 = rbx_2;
00037697      
0003769e      if ((uint8_t)rcx_5 & 8)
0003769e      {
000376a0          rbx_2 |= 0x200;
000376a4          arg_8 = rbx_2;
0003769e      }
0003769e      
000376ab      if ((uint8_t)rcx_5 & 4)
000376ab      {
000376ad          rbx_2 |= 0x400;
000376b1          arg_8 = rbx_2;
000376ab      }
000376ab      
000376b8      if ((uint8_t)rcx_5 & 2)
000376b8      {
000376ba          rbx_2 |= 0x800;
000376be          arg_8 = rbx_2;
000376b8      }
000376b8      
000376c5      if ((uint8_t)rcx_5 & 1)
000376c5      {
000376c7          rbx_2 |= 0x1000;
000376cb          arg_8 = rbx_2;
000376c5      }
000376c5      
000376d3      if (TEST_BITD(rcx_5, 0x13))
000376d3      {
000376d5          rbx_2 |= 0x100;
000376d9          arg_8 = rbx_2;
000376d3      }
000376d3      
000376df      int32_t rax_3 = rcx_5 & 0x300;
000376df      
000376e4      if (rax_3)
000376e4      {
000376eb          if (rax_3 == 0x100)
000376eb          {
0003770e              rbx_2 |= 0x2000;
00037712              arg_8 = rbx_2;
000376eb          }
000376eb          else if (rax_3 == 0x200)
000376f2          {
00037704              rbx_2 |= 0x4000;
00037708              arg_8 = rbx_2;
000376f2          }
000376f2          else if (rax_3 == 0x300)
000376f9          {
000376fb              rbx_2 |= 0x6000;
000376fe              arg_8 = rbx_2;
000376f9          }
000376e4      }
000376e4      
00037716      int32_t rcx_6 = rcx_5 & 0x3000000;
00037716      
00037722      if (rcx_6 == 0x1000000)
00037722      {
00037747          rbx_2 |= 0x8040;
0003774d          arg_8 = rbx_2;
00037722      }
00037722      else if (rcx_6 == 0x2000000)
0003772a      {
0003773e          rbx_2 |= 0x40;
00037741          arg_8 = rbx_2;
0003772a      }
0003772a      else if (rcx_6 == 0x3000000)
00037732      {
00037734          rbx_2 |= 0x8000;
00037738          arg_8 = rbx_2;
00037732      }
00037732      
0003775d      if (!_control87::dazSupported::~dazSupported || !((uint8_t)rbx_2 & 0x40))
00037791          rbx_2 &= 0xffffffbf;
00037791      
0003779e      if (0x80 & (uint8_t)rbx_2)
0003779e          rdi = 0x10;
0003779e      
000377a6      if (TEST_BITD(rbx_2, 9))
000377a8          rdi |= 8;
000377a8      
000377af      if (TEST_BITD(rbx_2, 0xa))
000377b1          rdi |= 4;
000377b1      
000377b8      if (TEST_BITD(rbx_2, 0xb))
000377ba          rdi |= 2;
000377ba      
000377c1      if (TEST_BITD(rbx_2, 0xc))
000377c3          rdi |= 1;
000377c3      
000377ca      if (TEST_BITD(rbx_2, 8))
000377cc          rdi |= 0x80000;
000377cc      
000377d2      int32_t rax_5 = rbx_2 & 0x6000;
000377d2      
000377d5      if (rax_5)
000377d5      {
000377dc          if (rax_5 == 0x2000)
000377f8              rdi |= 0x100;
000377dc          else if (rax_5 == 0x4000)
000377f2              rdi |= 0x200;
000377e3          else if (rax_5 == 0x6000)
000377ea              rdi |= 0x300;
000377d5      }
000377d5      
000377fc      int32_t rbx_3 = rbx_2 & 0x8040;
000377fc      
00037805      if (rbx_3 == 0x40)
00037822          return rdi | 0x2000000;
00037822      
0003780d      if (rbx_3 == 0x8000)
0003781a          return rdi | 0x3000000;
0003781a      
00037812      if (rbx_3 != 0x8040)
00037826          return rdi;
00037826      
00037814      return rdi | 0x1000000;
000375a8  }

00037768                          33 ff 40 88 3d 37 84 00 00 8b 5c 24 40 83 e3 bf 8b cb e8 51 0a 00 00 41          3.@.=7....\$@......Q...A
00037780  be 80 00 00 00 44 8d 7f 10 41 bc 00 60 00 00                                                     .....D...A..`..
00037842        cc cc cc cc cc cc                                                                            ......

00037848    uint32_t _controlfp(uint32_t newctrl, uint32_t mask)

00037848  {
0003784c      /* tailcall */
0003784c      return _control87(newctrl, mask & 0xfff7ffff);
00037848  }

00037851                                                     cc cc cc cc cc cc cc                                           .......

00037858    void __remainder_piby2(double x, double* r, double* rr, int32_t* region)

00037858  {
000378a8      int64_t var_f60 = 0;
000378cf      int64_t r10_2 = (x & 0xfffffffffffff) | 0x10000000000000;
000378ef      uint64_t rdx_2 = (uint64_t)((((int32_t)(x >> 0x34) & 0x7ff) - 0x3ff) / 0xa);
000378f6      int32_t r11_4 = ((int32_t)(x >> 0x34) & 0x7ff) - 0x3ff - (int32_t)(rdx_2 * 5) * 2;
000378fc      int64_t r8 = (int64_t)(int32_t)(rdx_2 + 0x12);
00037908      int64_t rcx_1 = *(uint64_t*)(&data_3fbb0 + (r8 << 3)) * r10_2;
00037917      int64_t rdx_5 =
00037917          *(uint64_t*)((r8 << 3) + &_control87::dazSupported::~dazSupported) * r10_2
00037917          + (rcx_1 >> 0xa);
00037922      int64_t var_f68 = rcx_1 & 0x3ff;
00037935      int64_t rcx_5 = *(uint64_t*)((r8 << 3) + 0x3fba0) * r10_2 + (rdx_5 >> 0xa);
00037940      int64_t var_f70 = rdx_5 & 0x3ff;
00037953      int64_t rdx_9 = *(uint64_t*)((r8 << 3) + 0x3fb98) * r10_2 + (rcx_5 >> 0xa);
0003795e      int64_t var_f78 = rcx_5 & 0x3ff;
00037971      int64_t rcx_9 = *(uint64_t*)((r8 << 3) + 0x3fb90) * r10_2 + (rdx_9 >> 0xa);
0003797c      int64_t var_f80 = rdx_9 & 0x3ff;
0003798c      int64_t rdx_13 = *(uint64_t*)((r8 << 3) + 0x3fb88) * r10_2 + (rcx_9 >> 0xa);
00037997      int64_t var_f88 = rcx_9 & 0x3ff;
000379a7      int64_t rcx_13 = *(uint64_t*)((r8 << 3) + 0x3fb80) * r10_2 + (rdx_13 >> 0xa);
000379b2      int64_t var_f90 = rdx_13 & 0x3ff;
000379c5      int64_t rdx_17 = *(uint64_t*)((r8 << 3) + 0x3fb78) * r10_2 + (rcx_13 >> 0xa);
000379c8      int64_t var_f98 = rcx_13 & 0x3ff;
000379dc      int64_t var_fa0 = rdx_17 & 0x3ff;
000379e5      int64_t rcx_17 = *(uint64_t*)((r8 << 3) + 0x3fb70) * r10_2 + (rdx_17 >> 0xa);
000379f7      int64_t var_fa8 = rcx_17 & 0x3ff;
00037a00      int64_t rdx_21 = *(uint64_t*)((r8 << 3) + 0x3fb68) * r10_2 + (rcx_17 >> 0xa);
00037a12      int64_t var_fb0 = rdx_21 & 0x3ff;
00037a1b      int64_t rcx_21 = *(uint64_t*)((r8 << 3) + 0x3fb60) * r10_2 + (rdx_21 >> 0xa);
00037a2d      int64_t var_fb8 = rcx_21 & 0x3ff;
00037a36      int64_t rdx_25 = *(uint64_t*)((r8 << 3) + 0x3fb58) * r10_2 + (rcx_21 >> 0xa);
00037a48      int64_t var_fc0 = rdx_25 & 0x3ff;
00037a51      int64_t rcx_25 = *(uint64_t*)((r8 << 3) + 0x3fb50) * r10_2 + (rdx_25 >> 0xa);
00037a63      int64_t var_fc8 = rcx_25 & 0x3ff;
00037a6c      int64_t rdx_29 = *(uint64_t*)((r8 << 3) + 0x3fb48) * r10_2 + (rcx_25 >> 0xa);
00037a7e      int64_t var_fd0 = rdx_29 & 0x3ff;
00037a87      int64_t rcx_29 = *(uint64_t*)((r8 << 3) + &data_3fb40) * r10_2 + (rdx_29 >> 0xa);
00037a99      int64_t var_fd8 = rcx_29 & 0x3ff;
00037aa2      int64_t rdx_33 = *(uint64_t*)((r8 << 3) + 0x3fb38) * r10_2 + (rcx_29 >> 0xa);
00037ab4      int64_t var_fe0 = rdx_33 & 0x3ff;
00037abd      int64_t rcx_33 = (&three_piby4)[r8] * r10_2 + (rdx_33 >> 0xa);
00037ad2      int64_t var_fe8 = rcx_33 & 0x3ff;
00037ae7      int64_t rax_41 = (&piby4)[r8] * r10_2 + (rcx_33 >> 0xa);
00037af4      int64_t rbx_1 = rax_41 & 0x3ff;
00037afc      int64_t rdx_38 = ((&data_3fb20)[r8] * r10_2 + (rax_41 >> 0xa)) & 0x3ff;
00037aff      int64_t var_ff0 = rbx_1;
00037b07      int64_t var_ff8 = rdx_38;
00037b1b      uint64_t r9 = 1;
00037b2d      int32_t rdx_42 = (int32_t)((rdx_38 << 0xa | rbx_1) >> (0xa - (uint8_t)r11_4 - 1)) & 7;
00037b32      int32_t rsi_1 = rdx_42 & 1;
00037b35      uint64_t i;
00037b35      int64_t r8_3;
00037b35      
00037b35      if (!rsi_1)
00037b35      {
00037b8b          *(uint32_t*)region = rdx_42 >> 1;
00037b96          i = ((1 << (0xa - (uint8_t)r11_4)) - 1) & rbx_1;
00037b96          
00037b9c          if (i < 0x20000000000000)
00037b9c          {
00037b9e              int64_t* rax_47 = &var_ff0;
00037b9e              
00037bb4              do
00037bb4              {
00037ba3                  rax_47 = &rax_47[1];
00037bab                  r9 = (uint64_t)((uint32_t)r9 + 1);
00037bae                  i = i << 0xa | *(uint64_t*)rax_47;
00037bb4              } while (i < 0x20000000000000);
00037b9c          }
00037b9c          
00037bb9          r8_3 = (&var_ff0)[(int64_t)(uint32_t)r9];
00037b35      }
00037b35      else
00037b35      {
00037b42          *(uint32_t*)region = ((rdx_42 >> 1) + 1) & 3;
00037b4d          i = ((1 << (0xa - (uint8_t)r11_4)) - 1) & ~rbx_1;
00037b4d          
00037b53          if (i < 0x20000000000000)
00037b53          {
00037b55              int64_t* r8_1 = &var_ff0;
00037b55              
00037b7a              do
00037b7a              {
00037b5d                  r8_1 = &r8_1[1];
00037b61                  r9 = (uint64_t)((uint32_t)r9 + 1);
00037b74                  i = (~*(uint64_t*)r8_1 & 0x3ff) | i << 0xa;
00037b7a              } while (i < 0x20000000000000);
00037b53          }
00037b53          
00037b84          r8_3 = ~(&var_ff0)[(int64_t)(uint32_t)r9];
00037b35      }
00037b35      
00037bc2      int64_t r8_4 = r8_3 << 0x36;
00037bcb      int32_t r11_6 = r11_4 - (int32_t)(r9 * 5) * 2 + 0x34;
00037bcb      
00037bed      for (; i >= 0x20000000000000; i u>>= 1)
00037bed      {
00037bd7          r11_6 += 1;
00037be4          r8_4 = i << 0x3f | r8_4 >> 1;
00037bed      }
00037bed      
00037bf2      int64_t rcx_42 = (int64_t)r11_6;
00037c00      double rax_55 = (rcx_42 + 0x3ff) << 0x34 | (i & 0xfffffffffffff);
00037c00      
00037c05      if (rsi_1)
00037c11          rax_55 |= 0x8000000000000000;
00037c11      
00037c24      uint128_t zmm8 = (uint128_t)rax_55;
00037c35      int64_t rax_57 = (rcx_42 + 0x3ca) << 0x34;
00037c62      uint128_t zmm7;
00037c62      (uint64_t)zmm7 = (r8_4 >> 0xc | rax_57) + _mm_xor_pd(x, x) - rax_57;
00037c62      
00037c68      if (!rsi_1)
00037c74          (uint64_t)zmm7 = (uint64_t)zmm7 * 2.0;
00037c68      else
00037c6a          (uint64_t)zmm7 = (uint64_t)zmm7 * -2.0;
00037c6a      
00037c7c      double zmm1 = 1.5707963109016418;
00037c84      int64_t zmm4 = 0x3ff921fb54442d18;
00037cae      double rax_59 = (int64_t)zmm8 & 0xfffffffff8000000;
00037cb4      (uint64_t)zmm7 = (uint64_t)zmm7 * zmm4;
00037cb8      uint128_t zmm6 = zmm8;
00037cbd      double zmm3 = (uint64_t)zmm8;
00037cc2      (uint64_t)zmm8 = (uint64_t)zmm8 * 6.1232339957367648e-17;
00037cd3      (uint64_t)zmm6 = (uint64_t)zmm6 * zmm4;
00037cd7      (uint64_t)zmm8 = (uint64_t)zmm8 + (uint64_t)zmm7;
00037cea      zmm3 = zmm3 - rax_59;
00037cf6      double zmm5 = rax_59 * zmm1 - (uint64_t)zmm6;
00037cfe      x = zmm3 * zmm1;
00037d02      zmm1 = 1.5893254712295857e-08;
00037d1e      zmm5 = zmm5 + x + rax_59 * zmm1 + zmm3 * zmm1 + (uint64_t)zmm8;
00037d2c      x = zmm5 + (uint64_t)zmm6;
00037d30      (uint64_t)zmm6 = (uint64_t)zmm6 - x;
00037d34      *(uint64_t*)r = x;
00037d3a      (uint64_t)zmm6 = (uint64_t)zmm6 + zmm5;
00037d3e      *(uint64_t*)rr = (int64_t)zmm6;
00037858  }

00037d59                                                                             cc cc cc cc cc cc cc                           .......

00037d60    void RaiseException(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint64_t const* lpArguments)

00037d60  {
00037d67      int64_t var_a0 = 0;
00037d77      uint32_t dwExceptionCode_1 = dwExceptionCode;
00037d7b      int32_t var_a4 = dwExceptionFlags & 1;
00037d7f      void (* var_98)(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, 
00037d7f          uint32_t nNumberOfArguments, uint64_t const* lpArguments) = RaiseException;
00037d7f      
00037d87      if (!lpArguments)
00037db2          int32_t var_90 = 0;
00037d87      else
00037d87      {
00037d91          if (nNumberOfArguments > 0xf)
00037d91              nNumberOfArguments = 0xf;
00037d91          
00037d95          uint32_t nNumberOfArguments_1 = nNumberOfArguments;
00037d9d          char var_88[0x88];
00037d9d          
00037d9d          if (nNumberOfArguments)
00037dab              memmove(&var_88, lpArguments, nNumberOfArguments << 3);
00037d87      }
00037d87      
00037dbc      j_RtlRaiseException(&dwExceptionCode_1);
00037d60  }

00037dc9                             cc cc cc cc cc cc cc                                                           .......

00037dd0    void _raise_exc_ex(struct _FPIEEE_RECORD* prec, uint64_t* pcw, int32_t flags, int32_t opcode, void* parg1, void* presult, int32_t isfloat)

00037dd0  {
00037dda      uint64_t arguments = prec;
00037de7      uint32_t dwExceptionCode = 0;
00037def      __builtin_memset(&prec->Cause, 0, 4);
00037df2      __builtin_memset(&prec->Enable, 0, 4);
00037df5      __builtin_memset(&prec->Status, 0, 4);
00037df5      
00037e03      if ((uint8_t)flags & 0x10)
00037e03      {
00037e05          *(uint32_t*)((char*)prec->Cause.__bitfield0 + 0) |= 1;
00037e09          dwExceptionCode = -0x3fffff71;
00037e03      }
00037e03      
00037e12      if ((uint8_t)flags & 2)
00037e12      {
00037e14          *(uint32_t*)((char*)prec->Cause.__bitfield0 + 0) |= 2;
00037e18          dwExceptionCode = -0x3fffff6d;
00037e12      }
00037e12      
00037e20      if (1 & (uint8_t)flags)
00037e20      {
00037e22          *(uint32_t*)((char*)prec->Cause.__bitfield0 + 0) |= 4;
00037e26          dwExceptionCode = -0x3fffff6f;
00037e20      }
00037e20      
00037e2f      if ((uint8_t)flags & 4)
00037e2f      {
00037e31          *(uint32_t*)((char*)prec->Cause.__bitfield0 + 0) |= 8;
00037e35          dwExceptionCode = -0x3fffff72;
00037e2f      }
00037e2f      
00037e3e      if ((uint8_t)flags & 8)
00037e3e      {
00037e40          *(uint32_t*)((char*)prec->Cause.__bitfield0 + 0) |= 0x10;
00037e44          dwExceptionCode = -0x3fffff70;
00037e3e      }
00037e3e      
00037e5b      *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0) ^= (
00037e5b          ~((int32_t)(*(uint64_t*)pcw >> 7) << 4)
00037e5b          ^ *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0)) & 0x10;
00037e70      *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0) ^= (
00037e70          ~((int32_t)(*(uint64_t*)pcw >> 9) << 3)
00037e70          ^ *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0)) & 8;
00037e85      *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0) ^= (
00037e85          ~((int32_t)(*(uint64_t*)pcw >> 0xa) << 2)
00037e85          ^ *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0)) & 4;
00037e99      *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0) ^= (
00037e99          ~((int32_t)(*(uint64_t*)pcw >> 0xb) * 2)
00037e99          ^ *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0)) & 2;
00037eaa      *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0) ^= (~(*(uint32_t*)pcw >> 0xc)
00037eaa          ^ *(uint32_t*)((char*)prec->Enable.__bitfield0 + 0)) & 1;
00037ead      char rax_29 = _statfp();
00037ead      
00037eb5      if (1 & rax_29)
00037eb7          *(uint32_t*)((char*)prec->Status.__bitfield0 + 0) |= 0x10;
00037eb7      
00037ebd      if (rax_29 & 4)
00037ebf          *(uint32_t*)((char*)prec->Status.__bitfield0 + 0) |= 8;
00037ebf      
00037ec5      if (rax_29 & 8)
00037ec7          *(uint32_t*)((char*)prec->Status.__bitfield0 + 0) |= 4;
00037ec7      
00037ecd      if (rax_29 & 0x10)
00037ecf          *(uint32_t*)((char*)prec->Status.__bitfield0 + 0) |= 2;
00037ecf      
00037ed5      if (rax_29 & 0x20)
00037ed7          *(uint32_t*)((char*)prec->Status.__bitfield0 + 0) |= 1;
00037ed7      
00037ee2      int64_t rax_31 = (uint64_t)*(uint32_t*)pcw & 0x6000;
00037ee2      
00037ee5      if (!rax_31)
00037f11          *(uint32_t*)((char*)prec->__bitfield0 + 0) &= 0xfffffffc;
00037ee5      else if (rax_31 == 0x2000)
00037eed      {
00037f09          *(uint32_t*)((char*)prec->__bitfield0 + 0) &= 0xfffffffd;
00037f0c          *(uint32_t*)((char*)prec->__bitfield0 + 0) |= 1;
00037eed      }
00037eed      else if (rax_31 == 0x4000)
00037ef5      {
00037f01          *(uint32_t*)((char*)prec->__bitfield0 + 0) &= 0xfffffffe;
00037f04          *(uint32_t*)((char*)prec->__bitfield0 + 0) |= 2;
00037ef5      }
00037ef5      else if (rax_31 == 0x6000)
00037efc          *(uint32_t*)((char*)prec->__bitfield0 + 0) |= 3;
00037efc      
00037f14      *(uint32_t*)((char*)prec->__bitfield0 + 0) &= 0xfffe001f;
00037f23      *(uint32_t*)((char*)prec->__bitfield0 + 0) |= (opcode & 0xfff) << 5;
00037f2a      int32_t OperandValid = *(uint32_t*)((char*)prec->Operand1.__bitfield10 + 0);
00037f32      uint64_t rcx;
00037f32      int64_t rdx;
00037f32      
00037f32      if (!isfloat)
00037f32      {
00037f5e          rdx = 0xffffffe3;
00037f68          *(uint32_t*)((char*)prec->Operand1.__bitfield10 + 0) =
00037f68              (OperandValid & 0xffffffe3) | 3;
00037f70          rcx = *(uint64_t*)parg1;
00037f73          *(uint64_t*)((char*)prec->Operand1.Value + 0) = rcx;
00037f7f          *(uint32_t*)((char*)prec->Result.__bitfield10 + 0) =
00037f7f              (*(uint32_t*)((char*)prec->Result.__bitfield10 + 0) & 0xffffffe3) | 3;
00037f86          *(uint64_t*)((char*)prec->Result.Value + 0) = *(uint64_t*)presult;
00037f32      }
00037f32      else
00037f32      {
00037f34          rdx = 0xffffffe1;
00037f3e          *(uint32_t*)((char*)prec->Operand1.__bitfield10 + 0) =
00037f3e              (OperandValid & 0xffffffe1) | 1;
00037f46          rcx = (uint64_t)*(uint32_t*)parg1;
00037f48          *(uint32_t*)((char*)prec->Operand1.Value + 0) = (uint32_t)rcx;
00037f53          *(uint32_t*)((char*)prec->Result.__bitfield10 + 0) =
00037f53              (*(uint32_t*)((char*)prec->Result.__bitfield10 + 0) & 0xffffffe1) | 1;
00037f59          *(uint32_t*)((char*)prec->Result.Value + 0) = *(uint32_t*)presult;
00037f32      }
00037f32      
00037f8a      _clrfp(rcx, rdx);
00037f9b      RaiseException(dwExceptionCode, 0, 1, &arguments);
00037fa0      uint64_t arguments_1 = arguments;
00037fa0      
00037faa      if (*(uint8_t*)(arguments_1 + 8) & 0x10)
00037fac          *(uint64_t*)pcw &= 0xffffffffffffff7f;
00037fac      
00037fb6      if (*(uint8_t*)(arguments_1 + 8) & 8)
00037fb8          *(uint64_t*)pcw &= 0xfffffffffffffdff;
00037fb8      
00037fc2      if (*(uint8_t*)(arguments_1 + 8) & 4)
00037fc4          *(uint64_t*)pcw &= 0xfffffffffffffbff;
00037fc4      
00037fce      if (*(uint8_t*)(arguments_1 + 8) & 2)
00037fd0          *(uint64_t*)pcw &= 0xfffffffffffff7ff;
00037fd0      
00037fd9      if (*(uint8_t*)(arguments_1 + 8) & 1)
00037fdb          *(uint64_t*)pcw &= 0xffffffffffffefff;
00037fdb      
00037fe3      int32_t rax_47 = *(uint32_t*)arguments_1 & 3;
00037fe3      
00037fe6      if (!rax_47)
00038018          *(uint64_t*)pcw &= 0xffffffffffff9fff;
00037fe6      else if (rax_47 == 1)
00037feb      {
0003800c          *(uint64_t*)pcw &= 0xffffffffffffbfff;
00038011          *(uint64_t*)pcw |= 0x2000;
00037feb      }
00037feb      else if (rax_47 == 2)
00037ff0      {
00038000          *(uint64_t*)pcw &= 0xffffffffffffdfff;
00038005          *(uint64_t*)pcw |= 0x4000;
00037ff0      }
00037ff0      else if (rax_47 == 3)
00037ff7          *(uint64_t*)pcw |= 0x6000;
00037ff7      
00038024      if (!isfloat)
00038033          *(uint64_t*)presult = *(uint64_t*)(arguments_1 + 0x50);
00038024      else
0003802a          *(uint32_t*)presult = *(uint32_t*)(arguments_1 + 0x50);
00037dd0  }

0003804a                                cc cc cc cc cc cc                                                            ......

00038050    void _raise_exc(struct _FPIEEE_RECORD* prec, uint64_t* pcw, int32_t flags, int32_t opcode, double* parg1, double* presult)

00038050  {
0003806d      _raise_exc_ex(prec, pcw, flags, opcode, parg1, presult, 0);
00038050  }

00038077                                                                       cc cc cc cc cc cc cc cc cc                         .........

00038080    void _raise_excf(struct _FPIEEE_RECORD* prec, uint64_t* pcw, int32_t flags, int32_t opcode, float* parg1, float* presult)

00038080  {
000380a0      _raise_exc_ex(prec, pcw, flags, opcode, parg1, presult, 1);
00038080  }

000380aa                                cc cc cc cc cc cc                                                            ......

000380b0    void _set_errno_from_matherr(int32_t matherrtype)

000380b0  {
000380b3      if (matherrtype == 1)
000380c7          errno = 0x21;
000380b3      else if (matherrtype > 1 && matherrtype <= 3)
000380bc          errno = 0x22;
000380b0  }

000380d2                                                        cc cc cc cc cc cc                                            ......

000380d8    int32_t DllInitialize(struct _DRIVER_OBJECT* DriverObject, struct _UNICODE_STRING* RegistryPath) __pure

000380d8  {
000380da      return 0;
000380d8  }

000380db                                                                                   cc cc cc cc cc                             .....
000380e0  cc cc cc cc                                                                                      ....

000380e4    uint64_t _statfp(...)

000380e4  {
000380f4      int32_t mxcsr;
000380f4      return (uint64_t)_get_fpsr(mxcsr) & 0x3f;
000380e4  }

000380f5                                                                 cc cc cc cc cc cc cc                                   .......

000380fc    uint64_t _clrfp(...)

000380fc  {
00038118      int32_t mxcsr;
00038118      return (uint64_t)_get_fpsr(mxcsr) & 0x3f;
000380fc  }

00038119                                                                             cc cc cc cc cc cc cc                           .......

00038120    uint64_t _ctrlfp(uint64_t newctrl, uint64_t _mask)

00038120  {
0003812f      int32_t rbx = (uint32_t)_mask;
00038135      int32_t mxcsr;
00038135      int32_t rax = _get_fpsr(mxcsr);
0003813c      int32_t arg_10 = rax;
00038150      int32_t arg_8 = ((~rbx | 0xffff807f) & rax) | ((uint32_t)newctrl & rbx);
00038154      data_40174;
0003819b      return (uint64_t)rax;
00038120  }

00038169                             c6 05 04 80 00 00 00 8b 4c 24 30 83 e1 bf e8 54 00 00 00 8b 74 24 38           ........L$0....T....t$8
0003819c                                                                                      cc cc cc cc                              ....
000381a0  cc cc cc cc                                                                                      ....

000381a4    void _set_statfp(uint64_t sw)

000381a4  {
000381be      /* tailcall */
000381be      return _set_fpsr();
000381a4  }

000381c3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

000381d0    int64_t _set_fpsr() __pure

000381d0  {
000381d0      int32_t rcx;
000381d0      int32_t arg_8 = rcx;
000381d0  }


000381da    int64_t _fclrf(int32_t arg1 @ mxcsr) __pure

000381da  {
000381e4      int32_t arg_8 = arg1 & 0xffffffc0;
000381da  }

000381ee                                            cc cc cc cc cc cc                                                    ......

000381f4    enum _EXCEPTION_DISPOSITION __C_specific_handler(struct _EXCEPTION_RECORD* ExceptionRecord, void* EstablisherFrame, struct _CONTEXT* ContextRecord, struct _DISPATCHER_CONTEXT* DispatcherContext)

000381f4  {
00038214      int64_t r14 = *(int64_t*)((char*)DispatcherContext + 8);
0003821b      int64_t rdi = (int64_t)*(int64_t*)((char*)DispatcherContext + 0x48);
0003821f      int32_t* r12 = *(int64_t*)((char*)DispatcherContext + 0x38);
00038223      int64_t r13_1 = *(int64_t*)DispatcherContext - r14;
00038223      
00038236      if (ExceptionRecord->ExceptionFlags & 0x66)
00038236      {
000382db          int64_t rsi_2 = *(int64_t*)((char*)DispatcherContext + 0x20) - r14;
000382db          
000382e2          if ((uint32_t)rdi < *(uint32_t*)r12)
000382e2          {
000382e7              void* rbx_2 = &r12[rdi * 4 + 2];
000382e7              
0003833d              do
0003833d              {
000382ec                  uint64_t rax_11 = (uint64_t)*(uint32_t*)((char*)rbx_2 - 4);
000382ec                  
000382f2                  if (r13_1 >= rax_11)
000382f2                  {
000382f4                      uint64_t rcx_4 = (uint64_t)*(uint32_t*)rbx_2;
000382f4                      
000382f9                      if (r13_1 < rcx_4)
000382f9                      {
0003830a                          if (rsi_2 >= rax_11 && rsi_2 <= rcx_4
0003830a                                  && ExceptionRecord->ExceptionFlags & 0x20)
0003830a                              break;
0003830a                          
00038310                          if (!*(uint32_t*)((char*)rbx_2 + 8))
00038310                          {
00038324                              (uint8_t)rcx_4 = 1;
00038326                              *(int64_t*)((char*)DispatcherContext + 0x48) =
00038326                                  (int32_t)(rdi + 1);
00038330                              ((uint64_t)*(uint32_t*)((char*)rbx_2 + 4) + r14)(rcx_4, 
00038330                                  EstablisherFrame);
00038310                          }
00038310                          else if (rsi_2 == (uint64_t)*(uint32_t*)((char*)rbx_2 + 8))
00038318                              break;
000382f9                      }
000382f2                  }
000382f2                  
00038333                  rdi = (uint64_t)((uint32_t)rdi + 1);
00038335                  rbx_2 += 0x10;
0003833d              } while ((uint32_t)rdi < *(uint32_t*)r12);
000382e2          }
00038236      }
00038236      else
00038236      {
0003823c          struct _EXCEPTION_RECORD* ExceptionRecord_1 = ExceptionRecord;
00038240          struct _CONTEXT* ContextRecord_1 = ContextRecord;
00038240          
00038248          if ((uint32_t)rdi < *(uint32_t*)r12)
00038248          {
00038251              void* rbx_1 = &r12[rdi * 4 + 3];
00038251              
000382cf              do
000382cf              {
0003826a                  if (r13_1 >= (uint64_t)*(uint32_t*)((char*)rbx_1 - 8)
0003826a                      && r13_1 < (uint64_t)*(uint32_t*)((char*)rbx_1 - 4)
0003826a                      && *(uint32_t*)((char*)rbx_1 + 4))
0003826a                  {
0003826f                      if (*(uint32_t*)rbx_1 == 1)
0003826f                      {
00038286                      label_38286:
00038286                          *(uint32_t*)((char*)rbx_1 + 4);
00038295                          _NLG_Notify();
000382bb                          j_RtlUnwindEx(EstablisherFrame, 
000382bb                              (uint64_t)*(uint32_t*)((char*)rbx_1 + 4) + r14, 
000382bb                              ExceptionRecord, (int64_t)ExceptionRecord->ExceptionCode, 
000382bb                              *(int64_t*)((char*)DispatcherContext + 0x28), 
000382bb                              *(int64_t*)((char*)DispatcherContext + 0x40));
0003826f                      }
0003826f                      else
0003826f                      {
0003827e                          int32_t rax_6 = ((uint64_t)*(uint32_t*)rbx_1 + r14)(
0003827e                              &ExceptionRecord_1, EstablisherFrame);
0003827e                          
00038282                          if (rax_6 < 0)
000382d3                              return 0;
000382d3                          
00038284                          if (rax_6 > 0)
00038284                              goto label_38286;
0003826f                      }
0003826a                  }
0003826a                  
000382c5                  rdi = (uint64_t)((uint32_t)rdi + 1);
000382c7                  rbx_1 += 0x10;
000382cf              } while ((uint32_t)rdi < *(uint32_t*)r12);
00038248          }
00038236      }
00038236      
0003833f      return 1;
000381f4  }

00038362        cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00    ....................ff........

00038380    int64_t _NLG_Notify()

00038380  {
00038380      int64_t rcx;
00038380      int64_t arg_8 = rcx;
00038385      int64_t rdx;
00038385      int64_t arg_18 = rdx;
0003838a      int32_t r8;
0003838a      int32_t arg_10 = r8;
00038396      /* tailcall */
00038396      return __NLG_Dispatch2();
00038380  }

00038398                                                                          cc cc cc cc cc cc 66 90                          ......f.

000383a0    int64_t __NLG_Dispatch2() __pure

000383a0  {
000383a0      return;
000383a0  }

000383a1     cc cc cc cc cc cc 66 0f 1f 84 00 00 00 00 00                                                   ......f........

000383b0    int64_t __NLG_Return2() __pure

000383b0  {
000383b0      return;
000383b0  }

000383b1                                                     cc cc cc cc cc cc cc                                           .......

000383b8    int64_t j_RtlRaiseException()

000383b8  {
000383b8      /* tailcall */
000383b8      return RtlRaiseException();
000383b8  }

000383be                                                                                            cc cc                                ..
000383c0  cc cc cc cc                                                                                      ....

000383c4    int64_t j_RtlUnwindEx()

000383c4  {
000383c4      /* tailcall */
000383c4      return RtlUnwindEx();
000383c4  }

000383ca                                cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc            ......................

000383e0    int64_t _frnd(double arg1) __pure

000383fe  {
000383fe      return;
000383fe  }

000383ff                                                                                               cc                                 .
00038400  cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00                                                  ......ff........

00038410    uint64_t _get_fpsr(int32_t arg1 @ mxcsr) __pure

00038410  {
0003841f      return (uint64_t)arg1;
00038410  }

00038420  char `string'::TLInitialize Failed to locate se...[0x3b] = "TLInitialize Failed to locate settings folder in regsitry\n", 0

0003845b                                                                                   cc cc cc cc cc                             .....

00038460  char `string'::TLInitialize No callback functio...[0x35] = "TLInitialize No callback function passed to library\n", 0

00038495                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

000384a0  char `string'::TLInitialize Failed to initializ...[0x41] = "TLInitialize Failed to initialize TL Reader thread Status %08lX\n", 0

000384e1     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                   ...............

000384f0  char `string'::TLInitialize Failed to initializ...[0x42] = "TLInitialize Failed to initialize USB Reader thread Status %08lX\n", 0

00038532                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

00038540  char `string'::TLInitialize Failed to initializ...[0x3d] = "TLInitialize Failed to initialize timer thread Status %08lX\n", 0

0003857d                                                                                         cc cc cc                               ...

00038580  char `string'::TLInitialize Failed to initializ...[0x4d] = "TLInitialize Failed to initialize consumer queue worker thread Status %08lX\n", 0

000385cd                                         cc cc cc                                                               ...

000385d0  char `string'::TLInitialize Initialization of N...[0x43] = "TLInitialize Initialization of NW Trans Library Exit Status %08lX\n", 0

00038613                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

00038620  char `string'::TLShutdown: Shutdown of NW Trans...[0x2a] = "TLShutdown: Shutdown of NW Trans Library\n", 0

0003864a                                cc cc cc cc cc cc                                                            ......

00038650  char `string'::TLShutdown Failed to shutdown co...[0x42] = "TLShutdown Failed to shutdown consumer queue worker Status %08lX\n", 0

00038692                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

000386a0  char `string'::TLShutdown Failed to shutdown TL...[0x36] = "TLShutdown Failed to shutdown TL Reader Status %08lX\n", 0

000386d6                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

000386e0  char `string'::TLShutdown Failed to shutdown US...[0x37] = "TLShutdown Failed to shutdown USB Reader Status %08lX\n", 0

00038717                                                                       cc cc cc cc cc cc cc cc cc                         .........

00038720  char `string'::TLShutdown Failed to shutdown ti...[0x32] = "TLShutdown Failed to shutdown timer Status %08lX\n", 0

00038752                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

00038760  char `string'::TLShutdown Failed to cleanup reg...[0x36] = "TLShutdown Failed to cleanup registry - Status %08lX\n", 0

00038796                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

000387a0  char `string'::gProcessTouchStatus = FALSE\n[0x1d] = "gProcessTouchStatus = FALSE\n", 0

000387bd                                                                                         cc cc cc                               ...

000387c0  char `string'::%08lX:[0x7] = "%08lX:", 0

000387c7                       cc cc cc cc cc cc cc cc cc                                                         .........

000387d0  char `string'::%08lX: %s [0xb] = "%08lX: %s ", 0

000387db                                                                                   cc cc cc cc cc                             .....

000387e0  wchar16 `string'::DebugLevel[0xb] = "DebugLevel", 0

000387f6                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

00038800  wchar16 `string'::TraceSubsystem[0xf] = "TraceSubsystem", 0

0003881e                                                                                            cc cc                                ..

00038820  wchar16 `string'::DebugFlags[0xb] = "DebugFlags", 0

00038836                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

00038840  wchar16 `string'::TraceBufferSize[0x10] = "TraceBufferSize", 0
00038860  char `string'::TL Log Initialized %d-%d-%d %d:%...[0x3d] = "TL Log Initialized %d-%d-%d %d:%d Level %d Subsystems %08lX\n", 0

0003889d                                                                                         cc cc cc                               ...

000388a0  char `string'::NWTransLib DllInitialize Initial...[0x3d] = "NWTransLib DllInitialize Initialization of NW Trans Library\n", 0

000388dd                                                                                         cc cc cc                               ...

000388e0  char `string'::NWTransLib DllInitialize Failed ...[0x47] = "NWTransLib DllInitialize Failed to locate settings folder in regsitry\n", 0

00038927                       cc cc cc cc cc cc cc cc cc                                                         .........

00038930  wchar16 `string'::\\Parameters[0xc] = "\\Parameters", 0

00038948                          cc cc cc cc cc cc cc cc                                                          ........

00038950  wchar16 `string'::NO NAME[0x8] = "NO NAME", 0
00038960  wchar16 `string'::SettingsFolder[0xf] = "SettingsFolder", 0

0003897e                                                                                            cc cc                                ..

00038980  wchar16 `string'::CSFEnabled[0xb] = "CSFEnabled", 0

00038996                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

000389a0  wchar16 `string'::FirmwareVersion[0x10] = "FirmwareVersion", 0
000389c0  wchar16 `string'::%s\\Parameters\\Settings[0x17] = "%s\\Parameters\\Settings", 0

000389ee                                            cc cc                                                                ..

000389f0  wchar16 `string'::%s\\Parameters\\Settings\\%d[0x1a] = "%s\\Parameters\\Settings\\%d", 0

00038a24              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

00038a30  wchar16 `string'::DefaultTree[0xc] = "DefaultTree", 0

00038a48                          cc cc cc cc cc cc cc cc                                                          ........

00038a50  wchar16 `string'::%dTree[0x7] = "%dTree", 0

00038a5e                                                                                            cc cc                                ..

00038a60  wchar16 `string'::DefaultData[0xc] = "DefaultData", 0

00038a78                                                                          cc cc cc cc cc cc cc cc                          ........

00038a80  wchar16 `string'::%dData[0x7] = "%dData", 0

00038a8e                                            cc cc                                                                ..

00038a90  wchar16 `string'::%s\\%d[0x6] = "%s\\%d", 0

00038a9c                                                                                      cc cc cc cc                              ....

00038aa0  char `string'::pContext->ProcessTouchStatus = T...[0x25] = "pContext->ProcessTouchStatus = TRUE\n", 0

00038ac5                 cc cc cc cc cc cc cc cc cc cc cc                                                       ...........

00038ad0  char `string'::c:\\development_work\\csf_release_...[0x3b] = "c:\\development_work\\csf_release_hp\\driver\\csf\\calibrator.c", 0

00038b0b                                   cc cc cc cc cc                                                             .....

00038b10  char `string'::Calibration canceled[0x15] = "Calibration canceled", 0

00038b25                 cc cc cc cc cc cc cc cc cc cc cc                                                       ...........

00038b30  char `string'::c:\\development_work\\csf_release_...[0x3c] = "c:\\development_work\\csf_release_hp\\driver\\csf\\mouseengine.c", 0

00038b6c                                      cc cc cc cc                                                              ....

00038b70  char `string'::Mouse Engine Buffer Overrun[0x1c] = "Mouse Engine Buffer Overrun", 0

00038b8c                                      cc cc cc cc                                                              ....

00038b90  char `string'::ARRRRG WE ARE IN LIMBO![0x18] = "ARRRRG WE ARE IN LIMBO!", 0

00038ba8                          cc cc cc cc cc cc cc cc                                                          ........

00038bb0  char `string'::c:\\development_work\\csf_release_...[0x48] = "c:\\development_work\\csf_release_hp\\driver\\wincommon\\translibinputdist.c", 0

00038bf8                                                                          cc cc cc cc cc cc cc cc                          ........

00038c00  char `string'::TransLibInputDist.c: TLSendInput...[0x47] = "TransLibInputDist.c: TLSendInput SendInputReportCallback not assigned!", 0

00038c47                       cc cc cc cc cc cc cc cc cc                                                         .........

00038c50  char `string'::c:\\development_work\\csf_release_...[0x40] = "c:\\development_work\\csf_release_hp\\driver\\translib\\fwsettings.c", 0
00038c90  char `string'::LoadFWTreeAndValues: TreeSize or...[0x36] = "LoadFWTreeAndValues: TreeSize or ValueSize too large\n", 0

00038cc6                    cc cc cc cc cc cc cc cc cc cc                                                        ..........

00038cd0  char `string'::LoadFWTreeAndValues: dataLength ...[0x31] = "LoadFWTreeAndValues: dataLength too large small\n", 0

00038d01     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                   ...............

00038d10  char `string'::fw_UpdateCSFDeviceSettings: fe_d...[0x45] = "fw_UpdateCSFDeviceSettings: fe_dev_settings.numSensors > MAX_SENSORS", 0

00038d55                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

00038d60  char `string'::pSt_Device->Properties has unrec...[0x46] = "pSt_Device->Properties has unrecognised trigger level, setting to 75%", 0

00038da6                    cc cc cc cc cc cc cc cc cc cc                                                        ..........

00038db0  char `string'::c:\\development_work\\csf_release_...[0x3c] = "c:\\development_work\\csf_release_hp\\driver\\translib\\parser.c", 0

00038dec                                      cc cc cc cc                                                              ....

00038df0  char `string'::Invalid frame header![0x16] = "Invalid frame header!", 0

00038e06                    cc cc cc cc cc cc cc cc cc cc                                                        ..........

00038e10  char `string'::c:\\development_work\\csf_release_...[0x40] = "c:\\development_work\\csf_release_hp\\driver\\translib\\translibio.c", 0
00038e50  char `string'::TransLibUserModeContextInit: fai...[0x39] = "TransLibUserModeContextInit: failed to alloc pCSFContext", 0

00038e89                             cc cc cc cc cc cc cc                                                           .......

00038e90  char `string'::TransLibUserModeContextCleanup: ...[0x39] = "TransLibUserModeContextCleanup: pCSFContext already NULL", 0

00038ec9                             cc cc cc cc cc cc cc                                                           .......

00038ed0  char `string'::TransLibIO.c: SendHWReportCallba...[0x30] = "TransLibIO.c: SendHWReportCallback not assigned", 0
00038f00  char `string'::TransLibIO.c: ReceiveHWReportCal...[0x33] = "TransLibIO.c: ReceiveHWReportCallback not assigned", 0

00038f33                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

00038f40  char `string'::TransLibIO.c: SendTLReportCallba...[0x30] = "TransLibIO.c: SendTLReportCallback not assigned", 0
00038f70  char `string'::TransLibIO.c: ReceiveTLReportCal...[0x33] = "TransLibIO.c: ReceiveTLReportCallback not assigned", 0

00038fa3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

00038fb0  char `string'::TransLibIO.c: UpdateCamerasCallb...[0x31] = "TransLibIO.c: UpdateCamerasCallback not assigned", 0

00038fe1     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                   ...............

00038ff0  char `string'::c:\\development_work\\csf_release_...[0x4a] = "c:\\development_work\\csf_release_hp\\driver\\translib\\devsettingsinterface.c", 0

0003903a                                                                                cc cc cc cc cc cc                            ......

00039040  char `string'::Size cannot exceed USB_PACKET_SI...[0x23] = "Size cannot exceed USB_PACKET_SIZE", 0

00039063           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

00039070  char `string'::HandleSetSettingConfirmed: data ...[0x33] = "HandleSetSettingConfirmed: data size is too small\n", 0

000390a3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

000390b0  char `string'::HandleSetSettingConfirmed: Could...[0x32] = "HandleSetSettingConfirmed: Could not find dataPtr", 0

000390e2        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

000390f0  char `string'::HandleSetSettingConfirmed: dataS...[0x28] = "HandleSetSettingConfirmed: dataSize = 0", 0

00039118                                                                          cc cc cc cc cc cc cc cc                          ........

00039120  char `string'::HandleSetSettingConfirmed: resul...[0x29] = "HandleSetSettingConfirmed: result not ok", 0

00039149                             cc cc cc cc cc cc cc                                                           .......

00039150  char `string'::Unsupported data type.[0x17] = "Unsupported data type.", 0

00039167                       cc cc cc cc cc cc cc cc cc                                                         .........

00039170  char `string'::c:\\development_work\\csf_release_...[0x41] = "c:\\development_work\\csf_release_hp\\driver\\translib\\drvsettings.c", 0

000391b1                                                     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                   ...............

000391c0  char `string'::LoadSettingsFromFile - GetDefaul...[0x45] = "LoadSettingsFromFile - GetDefaultSettingsDataCallback not assigned!\n", 0

00039205                 cc cc cc cc cc cc cc cc cc cc cc                                                       ...........

00039210  char `string'::LoadSettingsFromFile - GetSettin...[0x3e] = "LoadSettingsFromFile - GetSettingsDataCallback not assigned!\n", 0

0003924e                                            cc cc                                                                ..

00039250  char `string'::No serial number received from d...[0x43] = "No serial number received from device, cannot write settings file.", 0

00039293                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

000392a0  char `string'::Settings.c: WriteSettingsToFile ...[0x4b] = "Settings.c: WriteSettingsToFile - SetSetSettingsDataCallback not assigned!", 0

000392eb                                   cc cc cc cc cc                                                             .....

000392f0  char `string'::Not implemented[0x10] = "Not implemented", 0
00039300  char `string'::Unknown [0x9] = "Unknown ", 0

00039309                             cc cc cc cc cc cc cc                                                           .......

00039310  char `string'::c:\\development_work\\csf_release_...[0x47] = "c:\\development_work\\csf_release_hp\\driver\\translib\\settingsinterface.c", 0

00039357                                                                       cc cc cc cc cc cc cc cc cc                         .........

00039360  char `string'::USB_Handle_Scope: data size not ...[0x2c] = "USB_Handle_Scope: data size not big enough\n", 0

0003938c                                      cc cc cc cc                                                              ....

00039390  char `string'::RestoreDefaults[0x10] = "RestoreDefaults", 0
000393a0  char `string'::ResetUSB[0x9] = "ResetUSB", 0

000393a9                             cc cc cc cc cc cc cc                                                           .......

000393b0  char `string'::Reset[0x6] = "Reset", 0

000393b6                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

000393c0  char `string'::Error: Unsupported[0x13] = "Error: Unsupported", 0

000393d3                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

000393e0  char `string'::Send tree to BULK Not supported....[0x36] = "Send tree to BULK Not supported. No BULK connection !", 0

00039416                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

00039420  char `string'::Send values to BULK Not supporte...[0x38] = "Send values to BULK Not supported. No BULK connection !", 0

00039458                                                                          cc cc cc cc cc cc cc cc                          ........

00039460  char `string'::Send rewrites to BULK Not suppor...[0x3a] = "Send rewrites to BULK Not supported. No BULK connection !", 0

0003949a                                                                                cc cc cc cc cc cc                            ......

000394a0  char `string'::Send all settings to BULK Not su...[0x3e] = "Send all settings to BULK Not supported. No BULK connection !", 0

000394de                                                                                            cc cc                                ..

000394e0  char `string'::SendText: Length is too large\n[0x1f] = "SendText: Length is too large\n", 0

000394ff                                                                                               cc                                 .

00039500  char `string'::Request INT8 of data that is not...[0x48] = "Request INT8 of data that is not INT8 on device for setting[%d] %d, %d\n", 0

00039548                          cc cc cc cc cc cc cc cc                                                          ........

00039550  char `string'::c:\\development_work\\csf_release_...[0x3e] = "c:\\development_work\\csf_release_hp\\driver\\translib\\settings.c", 0

0003958e                                            cc cc                                                                ..

00039590  char `string'::index could not be found[0x19] = "index could not be found", 0

000395a9                             cc cc cc cc cc cc cc                                                           .......

000395b0  char `string'::Request INT16 of data that is no...[0x4a] = "Request INT16 of data that is not INT16 on device for setting[%d] %d, %d\n", 0

000395fa                                                                                cc cc cc cc cc cc                            ......

00039600  char `string'::Request INT32 of data that is no...[0x4a] = "Request INT32 of data that is not INT32 on device for setting[%d] %d, %d\n", 0

0003964a                                cc cc cc cc cc cc                                                            ......

00039650  char `string'::Request FLOAT of data that is no...[0x4a] = "Request FLOAT of data that is not FLOAT on device for setting[%d] %d, %d\n", 0

0003969a                                                                                cc cc cc cc cc cc                            ......

000396a0  char `string'::c:\\development_work\\csf_release_...[0x44] = "c:\\development_work\\csf_release_hp\\driver\\tlcommon\\safefloatpoint.c", 0

000396e4              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

000396f0  char `string'::!VERIFY! %s; LINE: %d;\n[0x18] = "!VERIFY! %s; LINE: %d;\n", 0

00039708                          cc cc cc cc cc cc cc cc                                                          ........

00039710  char `string'::!ERROR! - %s  %s; LINE: %d;\n[0x1d] = "!ERROR! - %s  %s; LINE: %d;\n", 0

0003972d                                         cc cc cc                                                               ...

00039730  char `string'::!WARNING! - %s  %s; LINE: %d;\n[0x1f] = "!WARNING! - %s  %s; LINE: %d;\n", 0

0003974f                                               cc                                                                 .

00039750  char `string'::!INFO! - %s  %s; LINE: %d;\n[0x1c] = "!INFO! - %s  %s; LINE: %d;\n", 0

0003976c                                      cc cc cc cc                                                              ....

00039770  char `string'::!BUG! - %s  %s; LINE: %d;\n[0x1b] = "!BUG! - %s  %s; LINE: %d;\n", 0

0003978b                                   cc cc cc cc cc                                                             .....

00039790  char `string'::c:\\development_work\\csf_release_...[0x42] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\ctl_waveform.c", 0

000397d2                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

000397e0  char `string'::wf->pixelCount < 1[0x13] = "wf->pixelCount < 1", 0

000397f3                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

00039800  char `string'::wf->pixelStart > FOCAL_LENGTH[0x1e] = "wf->pixelStart > FOCAL_LENGTH", 0

0003981e                                                                                            cc cc                                ..

00039820  char `string'::wf->pixelStart + wf->pixelCount ...[0x2d] = "wf->pixelStart + wf->pixelCount > MAX_PIXELS", 0

0003984d                                         cc cc cc                                                               ...

00039850  char `string'::startAperture >= MAX_PIXELS - 1[0x20] = "startAperture >= MAX_PIXELS - 1", 0
00039870  char `string'::stopAperture <= startAperture[0x1e] = "stopAperture <= startAperture", 0

0003988e                                            cc cc                                                                ..

00039890  char `string'::stopAperture >= MAX_PIXELS[0x1b] = "stopAperture >= MAX_PIXELS", 0

000398ab                                   cc cc cc cc cc                                                             .....

000398b0  char `string'::c:\\development_work\\csf_release_...[0x3e] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\ctl2path.c", 0

000398ee                                            cc cc                                                                ..

000398f0  char `string'::performTriangulation() called in...[0x49] = "performTriangulation() called instead of performQuickTapTriangulation().", 0

00039939                                                                             cc cc cc cc cc cc cc                           .......

00039940  char `string'::Unknown triangulation type %d.[0x1f] = "Unknown triangulation type %d.", 0

0003995f                                                                                               cc                                 .

00039960  char `string'::c:\\development_work\\csf_release_...[0x3f] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\subsample.c", 0

0003999f                                                                                               cc                                 .

000399a0  char `string'::FindBestMatches() for 3 sensor s...[0x2f] = "FindBestMatches() for 3 sensor system missing!", 0

000399cf                                               cc                                                                 .

000399d0  char `string'::Unsupported number of sensors.[0x1f] = "Unsupported number of sensors.", 0

000399ef                                               cc                                                                 .

000399f0  char `string'::Unknown or unexpected old touch ...[0x2a] = "Unknown or unexpected old touch state %d!", 0

00039a1a                                                                                cc cc cc cc cc cc                            ......

00039a20  char `string'::c:\\development_work\\csf_release_...[0x44] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\fe_track_state.c", 0

00039a64              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

00039a70  char `string'::Too many touches: %d![0x16] = "Too many touches: %d!", 0

00039a86                    cc cc cc cc cc cc cc cc cc cc                                                        ..........

00039a90  char `string'::Expected 1 touch but found none![0x21] = "Expected 1 touch but found none!", 0

00039ab1                                                     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                   ...............

00039ac0  char `string'::Expected 2 touches but found non...[0x23] = "Expected 2 touches but found none!", 0

00039ae3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

00039af0  char `string'::Too many old touches: %d![0x1a] = "Too many old touches: %d!", 0

00039b0a                                cc cc cc cc cc cc                                                            ......

00039b10  char `string'::ProcessOneToTwoTransition(): Inv...[0x31] = "ProcessOneToTwoTransition(): Invalid input data?", 0

00039b41     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                   ...............

00039b50  char `string'::ProcessTwoToTwoTransition(): inv...[0x37] = "ProcessTwoToTwoTransition(): invalid past touch state!", 0

00039b87                       cc cc cc cc cc cc cc cc cc                                                         .........

00039b90  char `string'::Too many future touches: %d![0x1d] = "Too many future touches: %d!", 0

00039bad                                         cc cc cc                                                               ...

00039bb0  char `string'::c:\\development_work\\csf_release_...[0x3e] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\ctl_math.c", 0

00039bee                                            cc cc                                                                ..

00039bf0  char `string'::c:\\development_work\\csf_release_...[0x4c] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\filter_doubleocclusion.c", 0

00039c3c                                                                                      cc cc cc cc                              ....

00039c40  char `string'::c:\\development_work\\csf_release_...[0x3e] = "c:\\development_work\\csf_release_hp\\driver\\foureyes\\fe_kites.c", 0

00039c7e                                                                                            cc cc                                ..

00039c80  char `string'::Bad kite point values![0x17] = "Bad kite point values!", 0

00039c97                                                                       cc cc cc cc cc cc                                  ......

00039c9d    int64_t sub_39c9d(int64_t* arg1)

00039c9d  {
00039ca6      int32_t* rax = *(uint64_t*)arg1;
00039ca6      
00039cb7      if (*(uint32_t*)rax != 0xc0000005 && *(uint32_t*)rax != 0xc000001d)
00039cb9          return 0;
00039cb9      
00039cbd      return 1;
00039c9d  }

.text section ended  {0x11000-0x39cc8}

.rdata section started  {0x3a000-0x3eab4}
0003a000  int64_t (* const HAL:KeQueryPerformanceCounter)(int64_t* PerformanceFrequency) = KeQueryPerformanceCounter

0003a008  HAL_NULL_THUNK_DATA:
0003a008                          00 00 00 00 00 00 00 00                                                          ........

0003a010  int32_t (* const ntoskrnl:KeSetEvent)(KEVENT* Event, int32_t Increment, BOOLEAN Wait) = KeSetEvent
0003a018  void (* const ntoskrnl:KeInitializeDpc)(KDPC* Dpc, PKDEFERRED_ROUTINE DeferredRoutine, void* DeferredContext) = KeInitializeDpc
0003a020  void (* const ntoskrnl:KeInitializeTimer)(KTIMER* Timer) = KeInitializeTimer
0003a028  BOOLEAN (* const ntoskrnl:KeSetTimerEx)(KTIMER* Timer, int64_t DueTime, int32_t Period, KDPC* Dpc) = KeSetTimerEx
0003a030  uint32_t (* const ntoskrnl:KeQueryTimeIncrement)() = KeQueryTimeIncrement
0003a038  BOOLEAN (* const ntoskrnl:KeCancelTimer)(KTIMER* param0) = KeCancelTimer
0003a040  uint32_t (* const ntoskrnl:DbgPrint)(char* Format, ...) = DbgPrint
0003a048  void (* const ntoskrnl:RtlInitUnicodeString)(UNICODE_STRING* DestinationString, wchar16* SourceString) = RtlInitUnicodeString
0003a050  void (* const ntoskrnl:ExSystemTimeToLocalTime)(int64_t* SystemTime, int64_t* LocalTime) = ExSystemTimeToLocalTime
0003a058  int64_t (* const ntoskrnl:_vsnprintf)() = _vsnprintf
0003a060  void (* const ntoskrnl:RtlTimeToTimeFields)(int64_t* Time, TIME_FIELDS* TimeFields) = RtlTimeToTimeFields
0003a068  NTSTATUS (* const ntoskrnl:ExDeleteResourceLite)(ERESOURCE* Resource) = ExDeleteResourceLite
0003a070  NTSTATUS (* const ntoskrnl:ExInitializeResourceLite)(ERESOURCE* Resource) = ExInitializeResourceLite
0003a078  uint32_t (* const ntoskrnl:KeQueryRuntimeThread)(PKTHREAD Thread, uint32_t* UserTime) = KeQueryRuntimeThread
0003a080  int32_t (* const ntoskrnl:KeResetEvent)(KEVENT* Event) = KeResetEvent
0003a088  void (* const ntoskrnl:KeInitializeEvent)(KEVENT* Event, EVENT_TYPE Type, BOOLEAN State) = KeInitializeEvent
0003a090  void (* const ntoskrnl:KeReleaseSpinLock)(void* SpinLock, uint64_t NewIrql) = KeReleaseSpinLock
0003a098  NTSTATUS (* const ntoskrnl:KeDelayExecutionThread)(char WaitMode, BOOLEAN Alertable, int64_t* Interval) = KeDelayExecutionThread
0003a0a0  NTSTATUS (* const ntoskrnl:PsCreateSystemThread)(HANDLE* ThreadHandle, uint32_t DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, HANDLE ProcessHandle, CLIENT_ID* ClientId, PKSTART_ROUTINE StartRoutine, void* StartContext) = PsCreateSystemThread
0003a0a8  void (* const ntoskrnl:ExFreePoolWithTag)(void* P, uint32_t Tag) = ExFreePoolWithTag
0003a0b0  NTSTATUS (* const ntoskrnl:ZwClose)(HANDLE Handle) = ZwClose
0003a0b8  NTSTATUS (* const ntoskrnl:ObReferenceObjectByHandle)(HANDLE Handle, uint32_t DesiredAccess, POBJECT_TYPE ObjectType, char AccessMode, void** Object, OBJECT_HANDLE_INFORMATION* HandleInformation) = ObReferenceObjectByHandle
0003a0c0  NTSTATUS (* const ntoskrnl:KeWaitForSingleObject)(void* Object, KWAIT_REASON WaitReason, char WaitMode, BOOLEAN Alertable, int64_t* Timeout) = KeWaitForSingleObject
0003a0c8  int64_t (* const ntoskrnl:ObfDereferenceObject)(void* Object) = ObfDereferenceObject
0003a0d0  NTSTATUS (* const ntoskrnl:KeWaitForMultipleObjects)(uint32_t Count, void** Object, WAIT_TYPE WaitType, KWAIT_REASON WaitReason, char WaitMode, BOOLEAN Alertable, int64_t* Timeout, KWAIT_BLOCK* WaitBlockArray) = KeWaitForMultipleObjects
0003a0d8  uint64_t (* const ntoskrnl:KeAcquireSpinLockRaiseToDpc)(void* SpinLock) = KeAcquireSpinLockRaiseToDpc
0003a0e0  NTSTATUS (* const ntoskrnl:RtlQueryRegistryValues)(uint32_t RelativeTo, wchar16* Path, RTL_QUERY_REGISTRY_TABLE* QueryTable, void* Context, void* Environment) = RtlQueryRegistryValues
0003a0e8  NTSTATUS (* const ntoskrnl:ZwSetValueKey)(HANDLE KeyHandle, UNICODE_STRING* ValueName, uint32_t TitleIndex, uint32_t Type, void* Data, uint32_t DataSize) = ZwSetValueKey
0003a0f0  NTSTATUS (* const ntoskrnl:ZwOpenKey)(HANDLE* KeyHandle, uint32_t DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes) = ZwOpenKey
0003a0f8  BOOLEAN (* const ntoskrnl:ExAcquireResourceExclusiveLite)(ERESOURCE* Resource, BOOLEAN Wait) = ExAcquireResourceExclusiveLite
0003a100  void (* const ntoskrnl:KeLeaveCriticalRegion)() = KeLeaveCriticalRegion
0003a108  void (* const ntoskrnl:KeEnterCriticalRegion)() = KeEnterCriticalRegion
0003a110  BOOLEAN (* const ntoskrnl:ExAcquireResourceSharedLite)(ERESOURCE* Resource, BOOLEAN Wait) = ExAcquireResourceSharedLite
0003a118  void (* const ntoskrnl:ExReleaseResourceLite)(ERESOURCE* Resource) = ExReleaseResourceLite
0003a120  NTSTATUS (* const ntoskrnl:ZwCreateKey)(HANDLE* KeyHandle, uint32_t DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, uint32_t TitleIndex, UNICODE_STRING* Class, uint32_t CreateOptions, uint32_t* Disposition) = ZwCreateKey
0003a128  NTSTATUS (* const ntoskrnl:ZwQueryValueKey)(HANDLE KeyHandle, UNICODE_STRING* ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, void* KeyValueInformation, uint32_t Length, uint32_t* ResultLength) = ZwQueryValueKey
0003a130  int32_t (* const ntoskrnl:_vsnwprintf)(wchar16* _Buffer, uint64_t _BufferCount, wchar16* _Format, void* _ArgList) = _vsnwprintf
0003a138  void (* const ntoskrnl:KeBugCheckEx)(enum BUGCHECK_ERROR BugCheckCode, uint64_t BugCheckParameter1, uint64_t BugCheckParameter2, uint64_t BugCheckParameter3, uint64_t BugCheckParameter4) = KeBugCheckEx
0003a140  NTSTATUS (* const ntoskrnl:PsTerminateSystemThread)(NTSTATUS ExitStatus) = PsTerminateSystemThread
0003a148  void* (* const ntoskrnl:ExAllocatePoolWithTag)(POOL_TYPE PoolType, uint64_t NumberOfBytes, uint32_t Tag) = ExAllocatePoolWithTag
0003a150  void (* const ntoskrnl:KeInitializeMutex)(KMUTANT* Mutex, uint32_t Level) = KeInitializeMutex
0003a158  int32_t (* const ntoskrnl:KeReleaseMutex)(KMUTANT* Mutex, BOOLEAN Wait) = KeReleaseMutex
0003a160  int64_t (* const ntoskrnl:strrchr)() = strrchr
0003a168  int64_t (* const ntoskrnl:RtlRaiseException)() = RtlRaiseException
0003a170  int64_t (* const ntoskrnl:RtlUnwindEx)() = RtlUnwindEx

0003a178  ntoskrnl_NULL_THUNK_DATA:
0003a178                                                                          00 00 00 00 00 00 00 00                          ........
0003a180  struct Debug_Directory_Table __debug_directory_entries[0x1] = 
0003a180  {
0003a180      [0x0] = 
0003a180      {
0003a180          uint32_t characteristics = 0x0
0003a184          uint32_t timeDateStamp = 0x510f14d3
0003a188          uint16_t majorVersion = 0x0
0003a18a          uint16_t minorVersion = 0x0
0003a18c          enum type = IMAGE_DEBUG_TYPE_CODEVIEW
0003a190          uint32_t sizeOfData = 0x5c
0003a194          uint32_t addressOfRawData = 0x2d5e0
0003a198          uint32_t pointerToRawData = 0x2c7e0
0003a19c      }
0003a19c  }
0003a19c  char `string'::end2[0x5] = "end2", 0

0003a1a1     00 00 00                                                                                       ...

0003a1a4  char `string'::end1[0x5] = "end1", 0

0003a1a9                             00 00 00 00 00 00 00                                                           .......

0003a1b0  char `string'::USBPower[0x9] = "USBPower", 0

0003a1b9                                                                             00 00 00                                       ...

0003a1bc  char `string'::Step[0x5] = "Step", 0

0003a1c1     00 00 00 00 00 00 00                                                                           .......

0003a1c8  char `string'::EdgeStretch[0xc] = "EdgeStretch", 0

0003a1d4                                                              00 00 00 00                                              ....

0003a1d8  char `string'::EdgeShift[0xa] = "EdgeShift", 0

0003a1e2        00 00                                                                                        ..

0003a1e4  char `string'::Type[0x5] = "Type", 0

0003a1e9                             00 00 00 00 00 00 00                                                           .......

0003a1f0  char `string'::ShutterRate[0xc] = "ShutterRate", 0

0003a1fc                                                                                      00 00 00 00                              ....

0003a200  char `string'::ShutterMax[0xb] = "ShutterMax", 0

0003a20b                                   00 00 00 00 00                                                             .....

0003a210  char `string'::ShutterMin[0xb] = "ShutterMin", 0

0003a21b                                                                                   00 00 00 00 00                             .....

0003a220  char `string'::ShutterDown[0xc] = "ShutterDown", 0

0003a22c                                      00 00 00 00                                                              ....

0003a230  char `string'::ShutterUp[0xa] = "ShutterUp", 0

0003a23a                                                                                00 00 00 00 00 00                            ......

0003a240  char `string'::LuminanceScale[0xf] = "LuminanceScale", 0

0003a24f                                               00                                                                 .

0003a250  char `string'::DistancePower[0xe] = "DistancePower", 0

0003a25e                                                                                            00 00                                ..

0003a260  char `string'::CamSysTemperatureOffset[0x18] = "CamSysTemperatureOffset", 0
0003a278  char `string'::Correction[0xb] = "Correction", 0

0003a283           00                                                                                         .

0003a284  char `string'::Rate[0x5] = "Rate", 0

0003a289                             00 00 00 00 00 00 00                                                           .......

0003a290  char `string'::BufferLength[0xd] = "BufferLength", 0

0003a29d                                                                                         00 00 00                               ...

0003a2a0  char `string'::SettingsTime[0xd] = "SettingsTime", 0

0003a2ad                                         00 00 00                                                               ...

0003a2b0  char `string'::Threshold[0xa] = "Threshold", 0

0003a2ba                                                                                00 00 00 00 00 00                            ......

0003a2c0  char `string'::Timeout[0x8] = "Timeout", 0
0003a2c8  char `string'::USBMode[0x8] = "USBMode", 0
0003a2d0  char `string'::PenGain[0x8] = "PenGain", 0
0003a2d8  char `string'::PenPixelMap[0xc] = "PenPixelMap", 0

0003a2e4              00 00 00 00                                                                              ....

0003a2e8  char `string'::PenShutter[0xb] = "PenShutter", 0

0003a2f3                                                           00 00 00 00 00                                             .....

0003a2f8  char `string'::SeqStep19[0xa] = "SeqStep19", 0

0003a302        00 00 00 00 00 00                                                                            ......

0003a308  char `string'::SeqStep18[0xa] = "SeqStep18", 0

0003a312                                                        00 00 00 00 00 00                                            ......

0003a318  char `string'::SeqStep17[0xa] = "SeqStep17", 0

0003a322        00 00 00 00 00 00                                                                            ......

0003a328  char `string'::SeqStep16[0xa] = "SeqStep16", 0

0003a332                                                        00 00 00 00 00 00                                            ......

0003a338  char `string'::DriverSettingsMode[0x13] = "DriverSettingsMode", 0

0003a34b                                   00 00 00 00 00                                                             .....

0003a350  char `string'::DriverScopesMode[0x11] = "DriverScopesMode", 0

0003a361     00 00 00 00 00 00 00                                                                           .......

0003a368  char `string'::ActiveSequence[0xf] = "ActiveSequence", 0

0003a377                                                                       00                                                 .

0003a378  char `string'::ProcessWaveformEnable[0x16] = "ProcessWaveformEnable", 0

0003a38e                                            00 00                                                                ..

0003a390  char `string'::SendDriverEnable[0x11] = "SendDriverEnable", 0

0003a3a1     00 00 00 00 00 00 00                                                                           .......

0003a3a8  char `string'::SyncPeriod[0xb] = "SyncPeriod", 0

0003a3b3                                                           00 00 00 00 00                                             .....

0003a3b8  char `string'::FactoryTestStatus[0x12] = "FactoryTestStatus", 0

0003a3ca                                00 00 00 00 00 00                                                            ......

0003a3d0  char `string'::FactoryTestDate[0x10] = "FactoryTestDate", 0
0003a3e0  char `string'::FactoryTemp[0xc] = "FactoryTemp", 0
0003a3ec  char `string'::SVNRev[0x7] = "SVNRev", 0

0003a3f3                                                           00 00 00 00 00                                             .....

0003a3f8  char `string'::SeqShutterOffset[0x11] = "SeqShutterOffset", 0

0003a409                             00 00 00                                                                       ...

0003a40c  char `string'::PenSeq[0x7] = "PenSeq", 0

0003a413                                                           00 00 00 00 00                                             .....

0003a418  char `string'::DefaultSeq[0xb] = "DefaultSeq", 0

0003a423           00 00 00 00 00                                                                             .....

0003a428  char `string'::NextSeqCountDown[0x11] = "NextSeqCountDown", 0

0003a439                                                                             00 00 00 00 00 00 00                           .......

0003a440  char `string'::SeqCountDown[0xd] = "SeqCountDown", 0

0003a44d                                         00 00 00                                                               ...

0003a450  char `string'::NextSeq[0x8] = "NextSeq", 0
0003a458  char `string'::SeqStep15[0xa] = "SeqStep15", 0

0003a462        00 00 00 00 00 00                                                                            ......

0003a468  char `string'::SeqStep14[0xa] = "SeqStep14", 0

0003a472                                                        00 00 00 00 00 00                                            ......

0003a478  char `string'::SeqStep13[0xa] = "SeqStep13", 0

0003a482        00 00 00 00 00 00                                                                            ......

0003a488  char `string'::SeqStep12[0xa] = "SeqStep12", 0

0003a492                                                        00 00 00 00 00 00                                            ......

0003a498  char `string'::SeqStep11[0xa] = "SeqStep11", 0

0003a4a2        00 00 00 00 00 00                                                                            ......

0003a4a8  char `string'::SeqStep10[0xa] = "SeqStep10", 0

0003a4b2                                                        00 00 00 00 00 00                                            ......

0003a4b8  char `string'::SeqStep9[0x9] = "SeqStep9", 0

0003a4c1     00 00 00 00 00 00 00                                                                           .......

0003a4c8  char `string'::SeqStep8[0x9] = "SeqStep8", 0

0003a4d1                                                     00 00 00 00 00 00 00                                           .......

0003a4d8  char `string'::SeqStep7[0x9] = "SeqStep7", 0

0003a4e1     00 00 00 00 00 00 00                                                                           .......

0003a4e8  char `string'::SeqStep6[0x9] = "SeqStep6", 0

0003a4f1                                                     00 00 00 00 00 00 00                                           .......

0003a4f8  char `string'::SeqStep5[0x9] = "SeqStep5", 0

0003a501     00 00 00 00 00 00 00                                                                           .......

0003a508  char `string'::SeqStep4[0x9] = "SeqStep4", 0

0003a511                                                     00 00 00 00 00 00 00                                           .......

0003a518  char `string'::SeqStep3[0x9] = "SeqStep3", 0

0003a521     00 00 00 00 00 00 00                                                                           .......

0003a528  char `string'::SeqStep2[0x9] = "SeqStep2", 0

0003a531                                                     00 00 00 00 00 00 00                                           .......

0003a538  char `string'::SeqStep1[0x9] = "SeqStep1", 0

0003a541     00 00 00 00 00 00 00                                                                           .......

0003a548  char `string'::SeqStep0[0x9] = "SeqStep0", 0

0003a551                                                     00 00 00 00 00 00 00                                           .......

0003a558  char `string'::thresholdTouchSpeed[0x14] = "thresholdTouchSpeed", 0

0003a56c                                      00 00 00 00                                                              ....

0003a570  char `string'::thresholdTimeSlow[0x12] = "thresholdTimeSlow", 0

0003a582        00 00 00 00 00 00                                                                            ......

0003a588  char `string'::thresholdTimeFast[0x12] = "thresholdTimeFast", 0

0003a59a                                                                                00 00 00 00 00 00                            ......

0003a5a0  char `string'::BlackSubtraction[0x11] = "BlackSubtraction", 0

0003a5b1                                                     00 00 00 00 00 00 00                                           .......

0003a5b8  char `string'::StreamingMode[0xe] = "StreamingMode", 0

0003a5c6                    00 00                                                                                ..

0003a5c8  char `string'::FeatureReportMode[0x12] = "FeatureReportMode", 0

0003a5da                                                                                00 00 00 00 00 00                            ......

0003a5e0  char `string'::RemoteWakeTime[0xf] = "RemoteWakeTime", 0

0003a5ef                                               00                                                                 .

0003a5f0  char `string'::RemoteWakeEnable[0x11] = "RemoteWakeEnable", 0

0003a601     00 00 00 00 00 00 00                                                                           .......

0003a608  char `string'::DisplayResolutionY[0x13] = "DisplayResolutionY", 0

0003a61b                                                                                   00 00 00 00 00                             .....

0003a620  char `string'::DisplayResolutionX[0x13] = "DisplayResolutionX", 0

0003a633                                                           00 00 00 00 00                                             .....

0003a638  char `string'::ActiveOffsetY[0xe] = "ActiveOffsetY", 0

0003a646                    00 00                                                                                ..

0003a648  char `string'::ActiveOffsetX[0xe] = "ActiveOffsetX", 0

0003a656                                                                    00 00                                                ..

0003a658  char `string'::ActiveAreaY[0xc] = "ActiveAreaY", 0

0003a664              00 00 00 00                                                                              ....

0003a668  char `string'::ActiveAreaX[0xc] = "ActiveAreaX", 0

0003a674                                                              00 00 00 00                                              ....

0003a678  char `string'::SystemDate[0xb] = "SystemDate", 0

0003a683           00 00 00 00 00                                                                             .....

0003a688  char `string'::IntegrationDate[0x10] = "IntegrationDate", 0
0003a698  wchar16 `string'::R[0x1] = "R"

0003a69a                                                                                00 00 00 00 00 00                            ......

0003a6a0  char `string'::USBRevision[0xc] = "USBRevision", 0

0003a6ac                                      00 00 00 00                                                              ....

0003a6b0  char `string'::USBProductID[0xd] = "USBProductID", 0

0003a6bd                                                                                         00 00 00                               ...

0003a6c0  char `string'::USBVendorID[0xc] = "USBVendorID", 0

0003a6cc                                      00 00 00 00                                                              ....

0003a6d0  char `string'::AmbientSubtraction[0x13] = "AmbientSubtraction", 0

0003a6e3           00                                                                                         .

0003a6e4  char `string'::Touch1[0x7] = "Touch1", 0

0003a6eb                                   00                                                                         .

0003a6ec  char `string'::Touch0[0x7] = "Touch0", 0

0003a6f3                                                           00 00 00 00 00                                             .....

0003a6f8  char `string'::OffscreenMode[0xe] = "OffscreenMode", 0

0003a706                    00 00                                                                                ..

0003a708  char `string'::AmbientRate[0xc] = "AmbientRate", 0

0003a714                                                              00 00 00 00                                              ....

0003a718  char `string'::PixelMap[0x9] = "PixelMap", 0

0003a721     00 00 00 00 00 00 00                                                                           .......

0003a728  char `string'::StatusLED[0xa] = "StatusLED", 0

0003a732                                                        00 00 00 00 00 00                                            ......

0003a738  char `string'::VersionBuild[0xd] = "VersionBuild", 0

0003a745                 00 00 00                                                                               ...

0003a748  char `string'::VersionRelease[0xf] = "VersionRelease", 0

0003a757                                                                       00                                                 .

0003a758  char `string'::VersionMinor[0xd] = "VersionMinor", 0

0003a765                 00 00 00                                                                               ...

0003a768  char `string'::VersionMajor[0xd] = "VersionMajor", 0

0003a775                                                                 00 00 00                                               ...

0003a778  char `string'::TouchSplitRate[0xf] = "TouchSplitRate", 0

0003a787                       00                                                                                 .

0003a788  char `string'::TouchSplitThreshold[0x14] = "TouchSplitThreshold", 0

0003a79c                                                                                      00 00 00 00                              ....

0003a7a0  char `string'::Enabled[0x8] = "Enabled", 0
0003a7a8  char `string'::PivotThreshold[0xf] = "PivotThreshold", 0

0003a7b7                                                                       00                                                 .

0003a7b8  char `string'::MinPacketDelay[0xf] = "MinPacketDelay", 0

0003a7c7                       00                                                                                 .

0003a7c8  char `string'::DoubleTouch[0xc] = "DoubleTouch", 0

0003a7d4                                                              00 00 00 00                                              ....

0003a7d8  char `string'::SingleTouch[0xc] = "SingleTouch", 0

0003a7e4              00 00 00 00                                                                              ....

0003a7e8  char `string'::Max_Sample_Delay[0x11] = "Max_Sample_Delay", 0

0003a7f9                                                                             00 00 00 00 00 00 00                           .......

0003a800  char `string'::Mid_Sample_Delay[0x11] = "Mid_Sample_Delay", 0

0003a811                                                     00 00 00 00 00 00 00                                           .......

0003a818  char `string'::Min_Sample_Delay[0x11] = "Min_Sample_Delay", 0

0003a829                             00 00 00                                                                       ...

0003a82c  char `string'::Bottom[0x7] = "Bottom", 0

0003a833                                                           00                                                         .

0003a834  char `string'::Right[0x6] = "Right", 0

0003a83a                                                                                00 00                                        ..

0003a83c  char `string'::Top[0x4] = "Top", 0
0003a840  char `string'::Left[0x5] = "Left", 0

0003a845                 00 00 00                                                                               ...

0003a848  char `string'::ReportMode[0xb] = "ReportMode", 0

0003a853                                                           00 00 00 00 00                                             .....

0003a858  char `string'::CornerPixel[0xc] = "CornerPixel", 0

0003a864              00 00 00 00                                                                              ....

0003a868  char `string'::LED1Separation[0xf] = "LED1Separation", 0

0003a877                                                                       00                                                 .

0003a878  char `string'::LED0Separation[0xf] = "LED0Separation", 0

0003a887                       00                                                                                 .

0003a888  char `string'::Test_ID[0x8] = "Test_ID", 0
0003a890  char `string'::Infill_OnTime[0xe] = "Infill_OnTime", 0

0003a89e                                                                                            00 00                                ..

0003a8a0  char `string'::Infill_Delay[0xd] = "Infill_Delay", 0

0003a8ad                                         00 00 00                                                               ...

0003a8b0  char `string'::Coeff7[0x7] = "Coeff7", 0

0003a8b7                                                                       00                                                 .

0003a8b8  char `string'::thresholdFloor[0xf] = "thresholdFloor", 0

0003a8c7                       00                                                                                 .

0003a8c8  char `string'::Gain[0x5] = "Gain", 0

0003a8cd                                         00 00 00                                                               ...

0003a8d0  char `string'::Shutter[0x8] = "Shutter", 0
0003a8d8  char `string'::PostTouch[0xa] = "PostTouch", 0

0003a8e2        00 00 00 00 00 00                                                                            ......

0003a8e8  char `string'::ReTouch[0x8] = "ReTouch", 0
0003a8f0  char `string'::Hysteresis[0xb] = "Hysteresis", 0

0003a8fb                                                                                   00                                         .

0003a8fc  char `string'::Mode[0x5] = "Mode", 0

0003a901     00 00 00 00 00 00 00                                                                           .......

0003a908  char `string'::ReportType[0xb] = "ReportType", 0

0003a913                                                           00 00 00 00 00                                             .....

0003a918  char `string'::LowSpeedPeriod[0xf] = "LowSpeedPeriod", 0

0003a927                       00                                                                                 .

0003a928  char `string'::LowSpeedTime[0xd] = "LowSpeedTime", 0

0003a935                                                                 00 00 00                                               ...

0003a938  char `string'::Buzzer_Tone[0xc] = "Buzzer_Tone", 0

0003a944              00 00 00 00                                                                              ....

0003a948  char `string'::Buzzer_Time[0xc] = "Buzzer_Time", 0

0003a954                                                              00 00 00 00                                              ....

0003a958  char `string'::DragThreshold[0xe] = "DragThreshold", 0

0003a966                    00 00                                                                                ..

0003a968  char `string'::DoubleClickTime[0x10] = "DoubleClickTime", 0
0003a978  char `string'::RightClickDelay[0x10] = "RightClickDelay", 0
0003a988  char `string'::Cal_Strokes[0xc] = "Cal_Strokes", 0

0003a994                                                              00 00 00 00                                              ....

0003a998  char `string'::Cal_Key[0x8] = "Cal_Key", 0
0003a9a0  char `string'::CamOrientation[0xf] = "CamOrientation", 0

0003a9af                                               00                                                                 .

0003a9b0  char `string'::BaudRate[0x9] = "BaudRate", 0

0003a9b9                                                                             00 00 00 00 00 00 00                           .......

0003a9c0  char `string'::Serial_Mode[0xc] = "Serial_Mode", 0

0003a9cc                                      00 00 00 00                                                              ....

0003a9d0  char `string'::Hardware[0x9] = "Hardware", 0

0003a9d9                                                                             00 00 00 00 00 00 00                           .......

0003a9e0  char `string'::Cam_Edges[0xa] = "Cam_Edges", 0

0003a9ea                                00 00 00 00 00 00                                                            ......

0003a9f0  char `string'::TotalPixels[0xc] = "TotalPixels", 0

0003a9fc                                                                                      00 00 00 00                              ....

0003aa00  char `string'::Gui_Flags[0xa] = "Gui_Flags", 0

0003aa0a                                00 00 00 00 00 00                                                            ......

0003aa10  char `string'::Version_Minor[0xe] = "Version_Minor", 0

0003aa1e                                                                                            00 00                                ..

0003aa20  char `string'::Version_Major[0xe] = "Version_Major", 0

0003aa2e                                            00 00                                                                ..

0003aa30  char `string'::spare[0x6] = "spare", 0

0003aa36                                                                    00 00                                                ..

0003aa38  char `string'::ThresholdPercent[0x11] = "ThresholdPercent", 0

0003aa49                             00 00 00 00 00 00 00                                                           .......

0003aa50  char `string'::focalLength[0xc] = "focalLength", 0

0003aa5c                                                                                      00 00 00 00                              ....

0003aa60  char `string'::NumberOfCameras[0x10] = "NumberOfCameras", 0
0003aa70  char `string'::To3Y[0x5] = "To3Y", 0

0003aa75                                                                 00 00 00                                               ...

0003aa78  char `string'::To3X[0x5] = "To3X", 0

0003aa7d                                                                                         00 00 00                               ...

0003aa80  char `string'::To2Y[0x5] = "To2Y", 0

0003aa85                 00 00 00                                                                               ...

0003aa88  char `string'::To2X[0x5] = "To2X", 0

0003aa8d                                         00 00 00                                                               ...

0003aa90  char `string'::To1Y[0x5] = "To1Y", 0

0003aa95                                                                 00 00 00                                               ...

0003aa98  char `string'::To1X[0x5] = "To1X", 0

0003aa9d                                                                                         00 00 00                               ...

0003aaa0  char `string'::To0Y[0x5] = "To0Y", 0

0003aaa5                 00 00 00                                                                               ...

0003aaa8  char `string'::To0X[0x5] = "To0X", 0

0003aaad                                         00 00 00                                                               ...

0003aab0  char `string'::From3Y[0x7] = "From3Y", 0

0003aab7                                                                       00                                                 .

0003aab8  char `string'::From3X[0x7] = "From3X", 0

0003aabf                                                                                               00                                 .

0003aac0  char `string'::From2Y[0x7] = "From2Y", 0

0003aac7                       00                                                                                 .

0003aac8  char `string'::From2X[0x7] = "From2X", 0

0003aacf                                               00                                                                 .

0003aad0  char `string'::From1Y[0x7] = "From1Y", 0

0003aad7                                                                       00                                                 .

0003aad8  char `string'::From1X[0x7] = "From1X", 0

0003aadf                                                                                               00                                 .

0003aae0  char `string'::From0Y[0x7] = "From0Y", 0

0003aae7                       00                                                                                 .

0003aae8  char `string'::From0X[0x7] = "From0X", 0

0003aaef                                               00                                                                 .

0003aaf0  char `string'::NumberOfCalibrationPoints[0x1a] = "NumberOfCalibrationPoints", 0

0003ab0a                                00 00 00 00 00 00                                                            ......

0003ab10  char `string'::PixelMap9[0xa] = "PixelMap9", 0

0003ab1a                                                                                00 00 00 00 00 00                            ......

0003ab20  char `string'::PixelMap8[0xa] = "PixelMap8", 0

0003ab2a                                00 00 00 00 00 00                                                            ......

0003ab30  char `string'::PixelMap7[0xa] = "PixelMap7", 0

0003ab3a                                                                                00 00 00 00 00 00                            ......

0003ab40  char `string'::PixelMap6[0xa] = "PixelMap6", 0

0003ab4a                                00 00 00 00 00 00                                                            ......

0003ab50  char `string'::PixelMap5[0xa] = "PixelMap5", 0

0003ab5a                                                                                00 00 00 00 00 00                            ......

0003ab60  char `string'::PixelMap4[0xa] = "PixelMap4", 0

0003ab6a                                00 00 00 00 00 00                                                            ......

0003ab70  char `string'::PixelMap3[0xa] = "PixelMap3", 0

0003ab7a                                                                                00 00 00 00 00 00                            ......

0003ab80  char `string'::PixelMap2[0xa] = "PixelMap2", 0

0003ab8a                                00 00 00 00 00 00                                                            ......

0003ab90  char `string'::PixelMap1[0xa] = "PixelMap1", 0

0003ab9a                                                                                00 00 00 00 00 00                            ......

0003aba0  char `string'::PixelMap0[0xa] = "PixelMap0", 0

0003abaa                                00 00                                                                        ..

0003abac  char `string'::Coeff6[0x7] = "Coeff6", 0

0003abb3                                                           00                                                         .

0003abb4  char `string'::Coeff5[0x7] = "Coeff5", 0

0003abbb                                                                                   00                                         .

0003abbc  char `string'::Coeff4[0x7] = "Coeff4", 0

0003abc3           00                                                                                         .

0003abc4  char `string'::Coeff3[0x7] = "Coeff3", 0

0003abcb                                   00                                                                         .

0003abcc  char `string'::Coeff2[0x7] = "Coeff2", 0

0003abd3                                                           00                                                         .

0003abd4  char `string'::Coeff1[0x7] = "Coeff1", 0

0003abdb                                                                                   00                                         .

0003abdc  char `string'::Coeff0[0x7] = "Coeff0", 0

0003abe3           00 00 00 00 00                                                                             .....

0003abe8  char `string'::stopAperture[0xd] = "stopAperture", 0

0003abf5                                                                 00 00 00                                               ...

0003abf8  char `string'::startAperture[0xe] = "startAperture", 0

0003ac06                    00 00                                                                                ..

0003ac08  char `string'::Angle[0x6] = "Angle", 0

0003ac0e                                            00 00                                                                ..

0003ac10  char `string'::Shutter1[0x9] = "Shutter1", 0

0003ac19                                                                             00 00 00 00 00 00 00                           .......

0003ac20  char `string'::Shutter0[0x9] = "Shutter0", 0

0003ac29                             00 00 00                                                                       ...

0003ac2c  wchar16 `string'::Y[0x1] = "Y"

0003ac2e                                            00 00                                                                ..

0003ac30  wchar16 `string'::X[0x1] = "X"

0003ac32                                                        00 00 00 00 00 00                                            ......

0003ac38  char `string'::Properties[0xb] = "Properties", 0

0003ac43           00 00 00 00 00                                                                             .....

0003ac48  char `string'::HoldOff[0x8] = "HoldOff", 0
0003ac50  char `string'::InFill[0x7] = "InFill", 0

0003ac57                                                                       00                                                 .

0003ac58  char `string'::Integration[0xc] = "Integration", 0

0003ac64              00 00 00 00                                                                              ....

0003ac68  char `string'::DeadBand[0x9] = "DeadBand", 0

0003ac71                                                     00 00 00 00 00 00 00                                           .......

0003ac78  char `string'::thresholdDown[0xe] = "thresholdDown", 0

0003ac86                    00 00                                                                                ..

0003ac88  char `string'::thresholdUp[0xc] = "thresholdUp", 0

0003ac94                                                              00 00 00 00                                              ....

0003ac98  char `string'::ThresholdRate[0xe] = "ThresholdRate", 0

0003aca6                    00 00                                                                                ..

0003aca8  char `string'::UniqueID[0x9] = "UniqueID", 0

0003acb1                                                     00 00 00 00 00 00 00                                           .......

0003acb8  char `string'::Revision_Build[0xf] = "Revision_Build", 0

0003acc7                       00                                                                                 .

0003acc8  char `string'::ReworkCount[0xc] = "ReworkCount", 0

0003acd4                                                              00 00 00 00                                              ....

0003acd8  char `string'::ReworkDate[0xb] = "ReworkDate", 0

0003ace3           00 00 00 00 00                                                                             .....

0003ace8  char `string'::FactoryDate[0xc] = "FactoryDate", 0

0003acf4                                                              00 00 00 00                                              ....

0003acf8  char `string'::FirmwareVersion[0x10] = "FirmwareVersion", 0
0003ad08  char `string'::ModelNumber[0xc] = "ModelNumber", 0

0003ad14                                                              00 00 00 00                                              ....

0003ad18  char `string'::SerialNumber[0xd] = "SerialNumber", 0

0003ad25                 00 00 00                                                                               ...

0003ad28  char `string'::AutoCorrect[0xc] = "AutoCorrect", 0
0003ad34  char `string'::CAM7[0x5] = "CAM7", 0

0003ad39                                                                             00 00 00                                       ...

0003ad3c  char `string'::CAM6[0x5] = "CAM6", 0

0003ad41     00 00 00                                                                                       ...

0003ad44  char `string'::CAM5[0x5] = "CAM5", 0

0003ad49                             00 00 00                                                                       ...

0003ad4c  char `string'::CAM4[0x5] = "CAM4", 0

0003ad51                                                     00 00 00                                                       ...

0003ad54  char `string'::Podium[0x7] = "Podium", 0

0003ad5b                                                                                   00                                         .

0003ad5c  char `string'::Bulk[0x5] = "Bulk", 0

0003ad61     00 00 00 00 00 00 00                                                                           .......

0003ad68  char `string'::CamCtrl[0x8] = "CamCtrl", 0
0003ad70  char `string'::Pen[0x4] = "Pen", 0

0003ad74                                                              00 00 00 00                                              ....

0003ad78  char `string'::SysTemperature[0xf] = "SysTemperature", 0

0003ad87                       00                                                                                 .

0003ad88  char `string'::Seq9[0x5] = "Seq9", 0

0003ad8d                                         00 00 00                                                               ...

0003ad90  char `string'::Seq8[0x5] = "Seq8", 0

0003ad95                                                                 00 00 00                                               ...

0003ad98  char `string'::Seq7[0x5] = "Seq7", 0

0003ad9d                                                                                         00 00 00                               ...

0003ada0  char `string'::Seq6[0x5] = "Seq6", 0

0003ada5                 00 00 00                                                                               ...

0003ada8  char `string'::Seq5[0x5] = "Seq5", 0

0003adad                                         00 00 00                                                               ...

0003adb0  char `string'::Seq4[0x5] = "Seq4", 0

0003adb5                                                                 00 00 00                                               ...

0003adb8  char `string'::Seq3[0x5] = "Seq3", 0

0003adbd                                                                                         00 00 00                               ...

0003adc0  char `string'::Seq2[0x5] = "Seq2", 0

0003adc5                 00 00 00                                                                               ...

0003adc8  char `string'::Seq1[0x5] = "Seq1", 0

0003adcd                                         00 00 00                                                               ...

0003add0  char `string'::Seq0[0x5] = "Seq0", 0

0003add5                                                                 00 00 00                                               ...

0003add8  char `string'::CSF[0x4] = "CSF", 0
0003addc  char `string'::Buzzer[0x7] = "Buzzer", 0

0003ade3           00                                                                                         .

0003ade4  char `string'::Sensor[0x7] = "Sensor", 0

0003adeb                                   00 00 00 00 00                                                             .....

0003adf0  char `string'::Protocol[0x9] = "Protocol", 0

0003adf9                                                                             00 00 00 00 00 00 00                           .......

0003ae00  char `string'::Production[0xb] = "Production", 0

0003ae0b                                   00                                                                         .

0003ae0c  char `string'::ID[0x3] = "ID", 0

0003ae0f                                               00                                                                 .

0003ae10  char `string'::Mouse[0x6] = "Mouse", 0

0003ae16                                                                    00 00                                                ..

0003ae18  char `string'::Drag_Threshold[0xf] = "Drag_Threshold", 0

0003ae27                       00                                                                                 .

0003ae28  char `string'::Diameter_Threshold[0x13] = "Diameter_Threshold", 0

0003ae3b                                                                                   00 00 00 00 00                             .....

0003ae40  char `string'::BackPropagation[0x10] = "BackPropagation", 0
0003ae50  char `string'::Filters[0x8] = "Filters", 0
0003ae58  char `string'::Border[0x7] = "Border", 0

0003ae5f                                                                                               00                                 .

0003ae60  char `string'::NearField[0xa] = "NearField", 0

0003ae6a                                00 00 00 00 00 00                                                            ......

0003ae70  char `string'::Calibration[0xc] = "Calibration", 0
0003ae7c  char `string'::CAM3[0x5] = "CAM3", 0

0003ae81     00 00 00                                                                                       ...

0003ae84  char `string'::CAM2[0x5] = "CAM2", 0

0003ae89                             00 00 00                                                                       ...

0003ae8c  char `string'::CAM1[0x5] = "CAM1", 0

0003ae91                                                     00 00 00                                                       ...

0003ae94  char `string'::CAM0[0x5] = "CAM0", 0

0003ae99                                                                             00 00 00                                       ...

0003ae9c  char `string'::Panel[0x6] = "Panel", 0

0003aea2        00 00                                                                                        ..

0003aea4  char `string'::My[0x3] = "My", 0
0003aea7  wchar16 `string'::[0x0] = 
0003aea7  {
0003aea7  }
0003aea7                       00 00 00 00 00 00 00 00 00                                                         .........
0003aeb0  struct <unnamed-tag> const tchCentreCalcData[0x4][0x4] = 
0003aeb0  {
0003aeb0      [0x0] = 
0003aeb0      {
0003aeb0          [0x0] = 
0003aeb0          {
0003aeb0                                                  00                                                               .
0003aeb1          }
0003aeb1          [0x1] = 
0003aeb1          {
0003aeb1                                                     00                                                             .
0003aeb2          }
0003aeb2          [0x2] = 
0003aeb2          {
0003aeb2                                                        00                                                           .
0003aeb3          }
0003aeb3          [0x3] = 
0003aeb3          {
0003aeb3                                                           00                                                         .
0003aeb4          }
0003aeb4      }
0003aeb4      [0x1] = 
0003aeb4      {
0003aeb4          [0x0] = 
0003aeb4          {
0003aeb4                                                              00                                                       .
0003aeb5          }
0003aeb5          [0x1] = 
0003aeb5          {
0003aeb5                                                                 00                                                     .
0003aeb6          }
0003aeb6          [0x2] = 
0003aeb6          {
0003aeb6                                                                    00                                                   .
0003aeb7          }
0003aeb7          [0x3] = 
0003aeb7          {
0003aeb7                                                                       00                                                 .
0003aeb8          }
0003aeb8      }
0003aeb8      [0x2] = 
0003aeb8      {
0003aeb8          [0x0] = 
0003aeb8          {
0003aeb8                                                                          00                                               .
0003aeb9          }
0003aeb9          [0x1] = 
0003aeb9          {
0003aeb9                                                                             00                                             .
0003aeba          }
0003aeba          [0x2] = 
0003aeba          {
0003aeba                                                                                00                                           .
0003aebb          }
0003aebb          [0x3] = 
0003aebb          {
0003aebb                                                                                   00                                         .
0003aebc          }
0003aebc      }
0003aebc      [0x3] = 
0003aebc      {
0003aebc          [0x0] = 
0003aebc          {
0003aebc                                                                                      01                                       .
0003aebd          }
0003aebd          [0x1] = 
0003aebd          {
0003aebd                                                                                         00                                     .
0003aebe          }
0003aebe          [0x2] = 
0003aebe          {
0003aebe                                                                                            00                                   .
0003aebf          }
0003aebf          [0x3] = 
0003aebf          {
0003aebf                                                                                               00                                 .
0003aec0          }
0003aec0      }
0003aec0  }

0003aec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0003aee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00  ................................
0003af00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00  ................................
0003af20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
0003af30  struct <unnamed-tag> const centreAnglesCalcData[0x4][0x4] = 
0003af30  {
0003af30      [0x0] = 
0003af30      {
0003af30          [0x0] = 
0003af30          {
0003af30                                                  01                                                               .
0003af31          }
0003af31          [0x1] = 
0003af31          {
0003af31                                                     00                                                             .
0003af32          }
0003af32          [0x2] = 
0003af32          {
0003af32                                                        00                                                           .
0003af33          }
0003af33          [0x3] = 
0003af33          {
0003af33                                                           00                                                         .
0003af34          }
0003af34      }
0003af34      [0x1] = 
0003af34      {
0003af34          [0x0] = 
0003af34          {
0003af34                                                              00                                                       .
0003af35          }
0003af35          [0x1] = 
0003af35          {
0003af35                                                                 00                                                     .
0003af36          }
0003af36          [0x2] = 
0003af36          {
0003af36                                                                    00                                                   .
0003af37          }
0003af37          [0x3] = 
0003af37          {
0003af37                                                                       00                                                 .
0003af38          }
0003af38      }
0003af38      [0x2] = 
0003af38      {
0003af38          [0x0] = 
0003af38          {
0003af38                                                                          00                                               .
0003af39          }
0003af39          [0x1] = 
0003af39          {
0003af39                                                                             00                                             .
0003af3a          }
0003af3a          [0x2] = 
0003af3a          {
0003af3a                                                                                00                                           .
0003af3b          }
0003af3b          [0x3] = 
0003af3b          {
0003af3b                                                                                   00                                         .
0003af3c          }
0003af3c      }
0003af3c      [0x3] = 
0003af3c      {
0003af3c          [0x0] = 
0003af3c          {
0003af3c                                                                                      01                                       .
0003af3d          }
0003af3d          [0x1] = 
0003af3d          {
0003af3d                                                                                         00                                     .
0003af3e          }
0003af3e          [0x2] = 
0003af3e          {
0003af3e                                                                                            00                                   .
0003af3f          }
0003af3f          [0x3] = 
0003af3f          {
0003af3f                                                                                               00                                 .
0003af40          }
0003af40      }
0003af40  }

0003af40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0003af60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00  ................................
0003af80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00  ................................
0003afa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

0003afb0  float const mu_cutoff = 0.00100000005
0003afb4  char const __real@3f266666[0x4] = "ff&?"
0003afb8  int32_t __real@3f8ccccd = 0x3f8ccccd
0003afbc  int32_t __real@3fa66666 = 0x3fa66666
0003afc0  int64_t __real@3fb999999999999a = 0x3fb999999999999a
0003afc8  int32_t __real@60ad78ec = 0x60ad78ec
0003afcc  int32_t __real@1e3ce508 = 0x1e3ce508
0003afd0  int32_t __real@3f800000 = 0x3f800000

0003afd4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

0003afe0  int128_t __mask@@AbsDouble@ = 
0003afe0  ff ff ff ff ff ff ff 7f ff ff ff ff ff ff ff 7f                                                  ................
0003aff0  int32_t __real@3f000000 = 0x3f000000

0003aff4                                                              00 00 00 00                                              ....

0003aff8  int64_t __real@bff0000000000000 = -0x4010000000000000
0003b000  int64_t __real@bd719799812dea11 = -0x428e68667ed215ef
0003b008  int64_t __real@3d719799812dea11 = 0x3d719799812dea11
0003b010  int32_t __real@447a0000 = 0x447a0000
0003b014  int32_t __real@43480000 = 0x43480000
0003b018  char const __real@3fe3333333333333[0x6] = "333333"

0003b01e                                                                                            e3 3f                                .?

0003b020  int64_t __real@3fd999999999999a = 0x3fd999999999999a
0003b028  int32_t __real@bf800000 = -0x40800000
0003b02c  int32_t __real@3e800000 = 0x3e800000
0003b030  int32_t __real@c47a0000 = -0x3b860000

0003b034                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

0003b040  int128_t __mask@@NegFloat@ = 
0003b040  00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 80                                                  ................
0003b050  int32_t __real@358637bd = 0x358637bd
0003b054  int32_t __real@b58637bd = -0x4a79c843
0003b058  int64_t __real@3eb0c6f7a0000000 = 0x3eb0c6f7a0000000
0003b060  int32_t __real@3f490fdb = 0x3f490fdb
0003b064  int32_t __real@3b000000 = 0x3b000000
0003b068  int32_t __real@3fc90fdb = 0x3fc90fdb

0003b06c                                      00 00 00 00                                                              ....

0003b070  int64_t __real@400921fb54442d18 = 0x400921fb54442d18
0003b078  int32_t __real@40490fdb = 0x40490fdb

0003b07c                                                                                      00 00 00 00                              ....

0003b080  int64_t __real@c00921fb54442d18 = -0x3ff6de04abbbd2e8
0003b088  int64_t __real@4022d97c7f3321d2 = 0x4022d97c7f3321d2
0003b090  int64_t __real@3f1a36e2eb1c432d = 0x3f1a36e2eb1c432d
0003b098  int64_t __real@3ff921fb54442d18 = 0x3ff921fb54442d18
0003b0a0  int32_t __real@4b189680 = 0x4b189680
0003b0a4  int32_t __real@4cbebc20 = 0x4cbebc20
0003b0a8  int64_t __real@4000000000000000 = 0x4000000000000000
0003b0b0  int32_t __real@40800000 = 0x40800000
0003b0b4  int32_t __real@3dcccccd = 0x3dcccccd
0003b0b8  int32_t __real@40000000 = 0x40000000
0003b0bc  int32_t __real@423e0000 = 0x423e0000
0003b0c0  int32_t __real@42340000 = 0x42340000
0003b0c4  int32_t __real@3fb2bf6f = 0x3fb2bf6f
0003b0c8  int32_t __real@3e32b8c2 = 0x3e32b8c2
0003b0cc  int32_t __real@3ecccccd = 0x3ecccccd
0003b0d0  int32_t __real@4528c000 = 0x4528c000
0003b0d4  int32_t __real@49742400 = 0x49742400
0003b0d8  int32_t __real@41400000 = 0x41400000
0003b0dc  int32_t __real@41600000 = 0x41600000
0003b0e0  int32_t __real@44000000 = 0x44000000
0003b0e4  int32_t __real@3f400000 = 0x3f400000
0003b0e8  int32_t __real@41200000 = 0x41200000
0003b0ec  int32_t __real@3f547ae1 = 0x3f547ae1
0003b0f0  int32_t __real@3d4ccccd = 0x3d4ccccd
0003b0f4  char const __real@3f733333[0x4] = "33s?"
0003b0f8  int32_t __real@3e99999a = 0x3e99999a
0003b0fc  char const __real@3f333333[0x5] = "333?", 0

0003b101     00 00 00 80 84 2e 41                                                                           ......A

0003b108  int32_t __real@3e124925 = 0x3e124925

0003b10c                                      00 00 00 00                                                              ....

0003b110  int64_t __real@3ff0000000000000 = 0x3ff0000000000000
0003b118  int32_t __real@cb18967f = -0x34e76981
0003b11c  int32_t __real@33d6bf95 = 0x33d6bf95
0003b120  int32_t __real@4b18967f = 0x4b18967f
0003b124  int32_t __real@47756fdb = 0x47756fdb
0003b128  int32_t __real@c61c4000 = -0x39e3c000
0003b12c  int32_t __real@407b53d2 = 0x407b53d2
0003b130  int32_t __real@461c4000 = 0x461c4000
0003b134  int32_t __real@4096cbe4 = 0x4096cbe4
0003b138  int32_t __real@3c8efa35 = 0x3c8efa35
0003b13c  int32_t __real@4000a3d7 = 0x4000a3d7
0003b140  int32_t __real@4d0583b0 = 0x4d0583b0
0003b144  int32_t __real@40400000 = 0x40400000
0003b148  int32_t __real@3e4ccccd = 0x3e4ccccd
0003b14c  int32_t __real@3356bf95 = 0x3356bf95
0003b150  int32_t __real@46fffe00 = 0x46fffe00
0003b154  int32_t __real@428c0000 = 0x428c0000
0003b158  int32_t __real@ff61b1e6 = -0x9e4e1a
0003b15c  int32_t __real@7f61b1e6 = 0x7f61b1e6
0003b160  int32_t __real@40a00000 = 0x40a00000
0003b164  int32_t __real@465ac000 = 0x465ac000
0003b168  int32_t __real@46bb8000 = 0x46bb8000
0003b16c  int32_t __real@41f80000 = 0x41f80000
0003b170  int32_t __real@43340000 = 0x43340000
0003b174  int32_t __real@42480000 = 0x42480000
0003b178  int32_t __real@41f00000 = 0x41f00000

0003b17c                                                                                      00 00 00 00                              ....

0003b180  int64_t __real@4004000000000000 = 0x4004000000000000
0003b188  int32_t __real@bf000000 = -0x41000000
0003b18c  int32_t __real@38d1b717 = 0x38d1b717
0003b190  int32_t __real@3a800000 = 0x3a800000
0003b194  int32_t __real@41c80000 = 0x41c80000
0003b198  int32_t __real@3c23d70a = 0x3c23d70a
0003b19c  int32_t __real@3a000000 = 0x3a000000
0003b1a0  int32_t __real@48bbce20 = 0x48bbce20
0003b1a4  int32_t __real@00000000 = 0x0
0003b1a8  int32_t __real@43960000 = 0x43960000
0003b1ac  int32_t __real@43c80000 = 0x43c80000
0003b1b0  int32_t __real@3df5c28f = 0x3df5c28f
0003b1b4  int32_t __real@40c90fdb = 0x40c90fdb
0003b1b8  int32_t __real@3f800001 = 0x3f800001
0003b1bc  int32_t __real@b3d6bf95 = -0x4c29406b
0003b1c0  int32_t __real@467ffc00 = 0x467ffc00
0003b1c4  int32_t __real@43a68000 = 0x43a68000
0003b1c8  int32_t __real@40100000 = 0x40100000

0003b1cc                                      00 00 00 00                                                              ....

0003b1d0  int64_t __real@3e7ad7f2a0000000 = 0x3e7ad7f2a0000000
0003b1d8  int32_t __real@441c4000 = 0x441c4000
0003b1dc  int32_t __real@3fea9280 = 0x3fea9280
0003b1e0  int64_t __real@4013e591a9110b46 = 0x4013e591a9110b46
0003b1e8  int64_t __real@4011cd6761110b46 = 0x4011cd6761110b46
0003b1f0  int32_t __real@3fa78d36 = 0x3fa78d36
0003b1f4  int32_t __real@40384e89 = 0x40384e89
0003b1f8  int32_t __real@4059d12d = 0x4059d12d
0003b1fc  int32_t __real@3e860a92 = 0x3e860a92
0003b200  int32_t __real@461c3c00 = 0x461c3c00
0003b204  int32_t __real@41100000 = 0x41100000
0003b208  int32_t __real@3e04b5dd = 0x3e04b5dd
0003b20c  int32_t __real@41700000 = 0x41700000
0003b210  int32_t __real@3eb851ec = 0x3eb851ec
0003b214  int32_t __real@41a00000 = 0x41a00000
0003b218  char const __real@3f666666[0x5] = "fff?", 0

0003b21d                                                                                         00 c8 42                               ..B

0003b220  int32_t __real@4b18967e = 0x4b18967e
0003b224  int32_t __real@42440000 = 0x42440000
0003b228  int32_t __real@c3b56d4f = -0x3c4a92b1
0003b22c  int32_t __real@42200000 = 0x42200000
0003b230  int32_t __real@42aa0000 = 0x42aa0000
0003b234  int32_t __real@42f00000 = 0x42f00000
0003b238  int32_t __real@3fcccccd = 0x3fcccccd
0003b23c  int32_t __real@3f7ae148 = 0x3f7ae148
0003b240  int32_t __real@3f99999a = 0x3f99999a
0003b244  int32_t __real@4479c000 = 0x4479c000
0003b248  int32_t __real@44064000 = 0x44064000
0003b24c  char const __real@3f4a3d71[0x5] = "q=J?", 0

0003b251                                                     00 20 40                                                       . @

0003b254  int32_t __real@43020000 = 0x43020000
0003b258  int32_t __real@40600000 = 0x40600000
0003b25c  int32_t __real@47c34f80 = 0x47c34f80
0003b260  int32_t __real@3e19999a = 0x3e19999a

0003b264              00 00 00 00                                                                              ....

0003b268  int64_t __real@3f50624dd2f1a9fc = 0x3f50624dd2f1a9fc
0003b270  int32_t __real@3f866666 = 0x3f866666
0003b274  int32_t __real@3f59999a = 0x3f59999a
0003b278  int32_t __real@42652eed = 0x42652eed
0003b27c  int32_t __real@43ff8000 = 0x43ff8000
0003b280  int32_t __real@c3ff8000 = -0x3c008000
0003b284  int32_t __real@42b40000 = 0x42b40000
0003b288  int32_t __real@42652ee1 = 0x42652ee1
0003b28c  int32_t __real@41000000 = 0x41000000
0003b290  int32_t __real@3f4ccccd = 0x3f4ccccd
0003b294  int32_t __real@3b83126f = 0x3b83126f
0003b298  int32_t __real@44228000 = 0x44228000
0003b29c  int32_t __real@43fa0000 = 0x43fa0000
0003b2a0  int32_t __real@42840000 = 0x42840000
0003b2a4  int32_t __real@42a60000 = 0x42a60000
0003b2a8  int32_t __real@42960000 = 0x42960000

0003b2ac                                      00 00 00 00                                                              ....

0003b2b0  int64_t __real_3ff0000000000000 = 0x3ff0000000000000

0003b2b8                                                                          00 00 00 00 00 00 00 00                          ........

0003b2c0  int64_t __real_fffffffff8000000 = -0x8000000

0003b2c8                          00 00 00 00 00 00 00 00                                                          ........

0003b2d0  int64_t __real_03d0000000000000 = 0x3d0000000000000

0003b2d8                                                                          00 00 00 00 00 00 00 00                          ........

0003b2e0  int64_t __real_3f80000000000000 = 0x3f80000000000000

0003b2e8                          00 00 00 00 00 00 00 00                                                          ........

0003b2f0  int64_t __real_8000000000000000 = --0x8000000000000000

0003b2f8                                                                          00 00 00 00 00 00 00 00                          ........

0003b300  int64_t __real_4090040000000000 = 0x4090040000000000

0003b308                          00 00 00 00 00 00 00 00                                                          ........

0003b310  int64_t __real_C090C80000000000 = -0x3f6f380000000000

0003b318                                                                          00 00 00 00 00 00 00 00                          ........

0003b320  int64_t __real_4060000000000000 = 0x4060000000000000

0003b328                          00 00 00 00 00 00 00 00                                                          ........

0003b330  int64_t __real_4040000000000000 = 0x4040000000000000

0003b338                                                                          00 00 00 00 00 00 00 00                          ........

0003b340  int64_t __real_3FA0000000000000 = 0x3fa0000000000000

0003b348                          00 00 00 00 00 00 00 00                                                          ........

0003b350  int64_t __real_3fe0000000000000 = 0x3fe0000000000000

0003b358                                                                          00 00 00 00 00 00 00 00                          ........

0003b360  char const __real_3fd5555555555555[0x6] = "UUUUUU"

0003b366                    d5 3f 00 00 00 00 00 00 00 00                                                        .?........

0003b370  int64_t __real_3fd0000000000000 = 0x3fd0000000000000

0003b378                                                                          00 00 00 00 00 00 00 00                          ........

0003b380  int64_t __real_3fc999999999999a = 0x3fc999999999999a

0003b388                          00 00 00 00 00 00 00 00                                                          ........

0003b390  char const __real_3fc5555555555555[0x6] = "UUUUUU"

0003b396                                                                    c5 3f 00 00 00 00 00 00 00 00                        .?........

0003b3a0  int64_t __real_3fc2492492492492 = 0x3fc2492492492492

0003b3a8                          00 00 00 00 00 00 00 00                                                          ........

0003b3b0  int64_t __real_3fc0000000000000 = 0x3fc0000000000000

0003b3b8                                                                          00 00 00 00 00 00 00 00                          ........

0003b3c0  int64_t __real_3f56c1728d739765 = 0x3f56c1728d739765

0003b3c8                          00 00 00 00 00 00 00 00                                                          ........

0003b3d0  int64_t __real_3F811115B7AA905E = 0x3f811115b7aa905e

0003b3d8                                                                          00 00 00 00 00 00 00 00                          ........

0003b3e0  char const __real_3FA5555555545D4E[0x6] = "N]TUUU"

0003b3e6                    a5 3f 00 00 00 00 00 00 00 00                                                        .?........

0003b3f0  int64_t __real_3FC5555555548F7C = 0x3fc5555555548f7c

0003b3f8                                                                          00 00 00 00 00 00 00 00                          ........

0003b400  int64_t __real_3feffc6f012164ad = 0x3feffc6f012164ad

0003b408                          00 00 00 00 00 00 00 00                                                          ........

0003b410  int64_t __real_3f437d98a3a06a02 = 0x3f437d98a3a06a02

0003b418                                                                          00 00 00 00 00 00 00 00                          ........

0003b420  int64_t __real_3e9208a80efa0f9c = 0x3e9208a80efa0f9c

0003b428                          00 00 00 00 00 00 00 00                                                          ........

0003b430  int64_t __real_3f885dd726cbfa41 = 0x3f885dd726cbfa41

0003b438                                                                          00 00 00 00 00 00 00 00                          ........

0003b440  int64_t __real_3f985eaf935d972d = 0x3f985eaf935d972d

0003b448                          00 00 00 00 00 00 00 00                                                          ........

0003b450  int64_t __real_3fbb6a194bd1cdeb = 0x3fbb6a194bd1cdeb

0003b458                                                                          00 00 00 00 00 00 00 00                          ........

0003b460  int64_t __real_3ef0e88e25daf0f3 = 0x3ef0e88e25daf0f3

0003b468                          00 00 00 00 00 00 00 00                                                          ........

0003b470  int64_t __real_3fdffc2b5ee8cd41 = 0x3fdffc2b5ee8cd41

0003b478                                                                          00 00 00 00 00 00 00 00                          ........

0003b480  int64_t __real_3fe62e42fefa39ef = 0x3fe62e42fefa39ef

0003b488                          00 00 00 00 00 00 00 00                                                          ........

0003b490  int64_t __real_3fe62e42f8000000 = 0x3fe62e42f8000000

0003b498                                                                          00 00 00 00 00 00 00 00                          ........

0003b4a0  int64_t __real_3e4be8e7bcd5e4f1 = 0x3e4be8e7bcd5e4f1

0003b4a8                          00 00 00 00 00 00 00 00                                                          ........

0003b4b0  int64_t __real_3FF71547652B82FE = 0x3ff71547652b82fe

0003b4b8                                                                          00 00 00 00 00 00 00 00                          ........

0003b4c0  int64_t __real_3FF7154760000000 = 0x3ff7154760000000

0003b4c8                          00 00 00 00 00 00 00 00                                                          ........
0003b4d0  __real_3e54ae0bf8000000:
0003b4d0                                                  00 00 00 f8 0b ae 54 3e 00 00 00 00 00 00 00 00                  ......T>........

0003b4e0  int64_t __real_3C7777D0FFDA0D20 = 0x3c7777d0ffda0d20

0003b4e8                          00 00 00 00 00 00 00 00                                                          ........
0003b4f0  __real_deadbeefdeadbeef:
0003b4f0                                                  ef be ad de ef be ad de 00 00 00 00 00 00 00 00                  ................
0003b500  __np_log2_lead_table:
0003b500  00 00 00 00 00 00 00 00 00 00 00 80 96 e7 96 3f 00 00 00 60 d3 ba a6 3f 00 00 00 80 38 eb b0 3f  ...............?...`...?....8..?
0003b520  00 00 00 e0 f6 63 b6 3f 00 00 00 40 42 c8 bb 3f 00 00 00 80 58 8c c0 3f 00 00 00 e0 e9 2a c3 3f  .....c.?...@B..?....X..?.....*.?
0003b540  00 00 00 20 1a c0 c5 3f 00 00 00 c0 2b 4c c8 3f 00 00 00 20 5e cf ca 3f 00 00 00 40 ee 49 cd 3f  ... ...?....+L.?... ^..?...@.I.?
0003b560  00 00 00 a0 16 bc cf 3f 00 00 00 c0 07 13 d1 3f 00 00 00 a0 07 44 d2 3f 00 00 00 c0 24 71 d3 3f  .......?.......?.....D.?....$q.?
0003b580  00 00 00 40 78 9a d4 3f 00 00 00 20 1a c0 d5 3f 00 00 00 c0 21 e2 d6 3f 00 00 00 60 a5 00 d8 3f  ...@x..?... ...?....!..?...`...?
0003b5a0  00 00 00 80 ba 1b d9 3f 00 00 00 00 76 33 da 3f 00 00 00 e0 eb 47 db 3f 00 00 00 a0 2f 59 dc 3f  .......?....v3.?.....G.?..../Y.?
0003b5c0  00 00 00 e0 53 67 dd 3f 00 00 00 a0 6a 72 de 3f 00 00 00 60 85 7a df 3f 00 00 00 80 da 3f e0 3f  ....Sg.?....jr.?...`.z.?.....?.?
0003b5e0  00 00 00 00 05 c1 e0 3f 00 00 00 e0 c9 40 e1 3f 00 00 00 00 31 bf e1 3f 00 00 00 c0 41 3c e2 3f  .......?.....@.?....1..?....A<.?
0003b600  00 00 00 40 03 b8 e2 3f 00 00 00 60 7c 32 e3 3f 00 00 00 e0 b3 ab e3 3f 00 00 00 60 b0 23 e4 3f  ...@...?...`|2.?.......?...`.#.?
0003b620  00 00 00 40 78 9a e4 3f 00 00 00 80 11 10 e5 3f 00 00 00 20 82 84 e5 3f 00 00 00 e0 cf f7 e5 3f  ...@x..?.......?... ...?.......?
0003b640  00 00 00 80 00 6a e6 3f 00 00 00 60 19 db e6 3f 00 00 00 c0 1f 4b e7 3f 00 00 00 e0 18 ba e7 3f  .....j.?...`...?.....K.?.......?
0003b660  00 00 00 c0 09 28 e8 3f 00 00 00 40 f7 94 e8 3f 00 00 00 00 e6 00 e9 3f 00 00 00 c0 da 6b e9 3f  .....(.?...@...?.......?.....k.?
0003b680  00 00 00 e0 d9 d5 e9 3f 00 00 00 e0 e7 3e ea 3f 00 00 00 e0 08 a7 ea 3f 00 00 00 20 41 0e eb 3f  .......?.....>.?.......?... A..?
0003b6a0  00 00 00 80 94 74 eb 3f 00 00 00 00 07 da eb 3f 00 00 00 a0 9c 3e ec 3f 00 00 00 c0 58 a2 ec 3f  .....t.?.......?.....>.?....X..?
0003b6c0  00 00 00 60 3f 05 ed 3f 00 00 00 e0 53 67 ed 3f 00 00 00 a0 99 c8 ed 3f 00 00 00 20 14 29 ee 3f  ...`?..?....Sg.?.......?... .).?
0003b6e0  00 00 00 a0 c6 88 ee 3f 00 00 00 60 b4 e7 ee 3f 00 00 00 80 e0 45 ef 3f 00 00 00 00 4e a3 ef 3f  .......?...`...?.....E.?....N..?
0003b700  00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 00 00                                                  .......?........
0003b710  __np_log2_tail_table:
0003b710                                                  00 00 00 00 00 00 00 00 9c b8 29 a6 48 0b f7 3d                  ..........).H..=
0003b720  06 36 31 87 fd 8e 25 3e 74 cf b3 9a 9f a2 3f 3e 53 cc 7c 16 13 c9 3a 3e a0 58 76 4c 77 b5 e5 3d  .61...%>t.....?>S.|...:>.XvLw..=
0003b740  78 4f 2c c7 f3 b4 39 3e 90 8f fa d0 70 c5 13 3e 0b a0 9f 87 d6 fb 49 3e 24 d2 fd b2 03 2f 40 3e  xO,...9>....p..>......I>$..../@>
0003b760  3c c2 df 27 d9 69 3b 3e 6a e9 91 df b2 64 38 3e d9 a8 23 0a 68 02 49 3e 70 09 cb 75 0b d3 5a 3e  <..'.i;>j....d8>..#.h.I>p..u..Z>
0003b780  72 8b 04 73 0e 1c 46 3e 66 22 b3 d9 9b 49 4d 3e 56 92 fc 15 37 9a 47 3e 0b a0 9f 87 d6 fb 59 3e  r..s..F>f"...IM>V...7.G>......Y>
0003b7a0  a4 1a af bc 19 3a 4b 3e b0 75 95 a1 e2 b0 28 3e 6a 65 69 11 2e 3e 42 3e 80 f8 3a a1 c0 fe 44 3e  .....:K>.u....(>jei..>B>..:...D>
0003b7c0  6e 14 a4 a0 82 38 57 3e ca fd fc ac b6 52 4a 3e 00 5f 1f 7f 07 75 e9 3d e0 19 c5 20 4d 75 1e 3e  n....8W>.....RJ>._...u.=... Mu.>
0003b7e0  62 32 9c 9d 0d 96 41 3e 68 28 67 fe 32 2f 57 3e e0 4a 10 cb 54 c7 1a 3e a5 15 9e 43 e5 a1 6a 3e  b2....A>h(g.2/W>.J..T..>...C..j>
0003b800  13 b5 e3 0d d0 95 6e 3e cc 0e 08 c8 27 27 64 3e 04 d0 cf 43 eb fd 4c 3e 24 d7 90 4d 39 69 55 3e  ......n>....''d>...C..L>$..M9iU>
0003b820  b2 ca cc 66 21 a0 6a 3e 61 07 67 a9 6a 98 6e 3e 56 92 fc 15 37 9a 57 3e 24 a5 77 e3 a3 22 4c 3e  ...f!.j>a.g.j.n>V...7.W>$.w.."L>
0003b840  2c 36 0e cf 74 62 4a 3e 1a cb b8 ae 09 1e 64 3e b6 5d 9a 97 11 8f 5c 3e e0 fb b2 93 32 ec 54 3e  ,6..tbJ>......d>.]....\>....2.T>
0003b860  78 e5 c6 53 07 4e 66 3e b7 ea 09 e4 02 35 69 3e 04 dc db 72 70 be 65 3e 44 dd 80 16 df 0d 56 3e  x..S.Nf>.....5i>...rp.e>D.....V>
0003b880  f5 43 fe cc 02 00 66 3e 49 ec ef f5 b5 ac 62 3e 59 65 66 b3 10 50 6d 3e 8d 79 d0 1e 18 8e 63 3e  .C....f>I.....b>Yef..Pm>.y....c>
0003b8a0  37 de 7c d3 14 80 65 3e b4 9b 5e af 21 f3 4a 3e e2 96 96 b4 65 aa 5e 3e de 16 b5 6d 7e c6 6c 3e  7.|...e>..^.!.J>....e.^>...m~.l>
0003b8c0  58 4c 9b a9 02 0d 37 3e e3 fe 35 16 33 a9 6c 3e 2e 31 e6 2c 11 4c 5a 3e 00 5f 1f 7f 07 75 f9 3d  XL....7>..5.3.l>.1.,.LZ>._...u.=
0003b8e0  74 ce bc d8 ea 7f 56 3e 54 75 3f 80 02 1c 5c 3e a3 21 aa 72 6a 62 63 3e c1 6d 7d 50 a9 b3 61 3e  t.....V>Tu?...\>.!.rjbc>.m}P..a>
0003b900  b6 9a 9c aa 0c 9e 57 3e 8b 92 62 33 c2 77 61 3e 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ......W>..b3.wa>................
0003b920  __two_to_jby32_lead_table:
0003b920  00 00 00 00 00 00 f0 3f 00 00 00 d0 b0 59 f0 3f 00 00 00 60 58 b5 f0 3f 00 00 00 d0 01 13 f1 3f  .......?.....Y.?...`X..?.......?
0003b940  00 00 00 30 b8 72 f1 3f 00 00 00 30 87 d4 f1 3f 00 00 00 60 7a 38 f2 3f 00 00 00 f0 9d 9e f2 3f  ...0.r.?...0...?...`z8.?.......?
0003b960  00 00 00 00 fe 06 f3 3f 00 00 00 30 a7 71 f3 3f 00 00 00 40 a6 de f3 3f 00 00 00 60 08 4e f4 3f  .......?...0.q.?...@...?...`.N.?
0003b980  00 00 00 d0 da bf f4 3f 00 00 00 50 2b 34 f5 3f 00 00 00 d0 07 ab f5 3f 00 00 00 b0 7e 24 f6 3f  .......?...P+4.?.......?....~$.?
0003b9a0  00 00 00 60 9e a0 f6 3f 00 00 00 e0 75 1f f7 3f 00 00 00 70 14 a1 f7 3f 00 00 00 90 89 25 f8 3f  ...`...?....u..?...p...?.....%.?
0003b9c0  00 00 00 40 e5 ac f8 3f 00 00 00 b0 37 37 f9 3f 00 00 00 80 91 c4 f9 3f 00 00 00 b0 03 55 fa 3f  ...@...?....77.?.......?.....U.?
0003b9e0  00 00 00 90 9f e8 fa 3f 00 00 00 f0 76 7f fb 3f 00 00 00 d0 9b 19 fc 3f 00 00 00 d0 20 b7 fc 3f  .......?....v..?.......?.... ..?
0003ba00  00 00 00 d0 18 58 fd 3f 00 00 00 30 97 fc fd 3f 00 00 00 a0 af a4 fe 3f 00 00 00 50 76 50 ff 3f  .....X.?...0...?.......?...PvP.?
0003ba20  00 00 00 00 00 00 00 00                                                                          ........
0003ba28  __two_to_jby32_trail_table:
0003ba28                          00 00 00 00 00 00 00 00 2a 3e d7 a1 2b ac 48 3e 72 31 c5 1e 12 f3 69 3e          ........*>..+.H>r1....i>
0003ba40  1b bf eb a4 50 5b f2 3d f9 be b9 f5 a2 fa 68 3e 80 5b 80 a7 9a 8b 36 3e f6 83 cd 70 c4 ea 6c 3e  ....P[.=......h>.[....6>...p..l>
0003ba60  45 97 b0 84 7b 7f 54 3e ab d1 5b 2a 6e 63 64 3e 54 51 9c 2a a7 ea 5c 3e 24 68 6b 44 68 24 68 3e  E...{.T>..[*ncd>TQ.*..\>$hkDh$h>
0003ba80  d0 db c4 40 4b 62 18 3e 5e 0e 75 9c a8 d8 54 3e 0f 2a 7c 07 3e 75 5a 3e 60 92 b1 52 a8 90 6a 3e  ...@Kb.>^.u...T>.*|.>uZ>`..R..j>
0003baa0  03 7d f8 58 c2 2a 0d 3e bf 2c 42 32 ef fc 59 3e e2 46 ba e7 be d8 61 3e 81 a8 be 36 0c 58 4f 3e  .}.X.*.>.,B2..Y>.F....a>...6.XO>
0003bac0  11 9f 15 25 9c 99 62 3e 2a 3e dd da 06 55 41 3e 88 03 8a 9e bc b8 29 3e 36 e2 e3 80 84 1f 45 3e  ...%..b>*>...UA>......)>6.....E>
0003bae0  24 12 5a e4 2a f1 41 3e 6a 0e bd 5a a7 b5 62 3e 84 3d 55 37 f2 da 47 3e 96 41 44 38 a5 0a 6b 3e  $.Z.*.A>j..Z..b>.=U7..G>.AD8..k>
0003bb00  98 07 2a d2 20 df 69 3e 0b b4 4b 0e 49 f7 69 3e 56 46 cb f5 da dc 4b 3e 9d 7b 2c cc 86 24 45 3e  ..*. .i>..K.I.i>VF....K>.{,..$E>
0003bb20  09 9f ce 80 8a dc 66 3e 00 00 00 00 00 00 00 00                                                  ......f>........

0003bb30  char const `string'::sqrt[0x5] = "sqrt", 0

0003bb35                                                                 00 00 00                                               ...

0003bb38  double const piby2 = 1.5707963267948966
0003bb40  double const twobypi = 0.63661977236758138
0003bb48  double const piby2_1 = 1.5707963267341256
0003bb50  double const piby2_1tail = 6.0771005065061922e-11
0003bb58  double const piby2_2 = 6.077100506303966e-11
0003bb60  double const piby2_2tail = 2.0222662487959506e-21
0003bb68  double const piby2_3 = 2.0222662487111665e-21
0003bb70  double const piby2_3tail = 8.4784276603688996e-32
0003bb78  int64_t __real@3ff27e84a3e73a2e = 0x3ff27e84a3e73a2e
0003bb80  int64_t __real@3fe07266d7b3511b = 0x3fe07266d7b3511b
0003bb88  int64_t __real@3f92e29003c692d9 = 0x3f92e29003c692d9
0003bb90  int64_t __real@3f919dba6efd6aad = 0x3f919dba6efd6aad
0003bb98  int64_t __real@3fd8a8b0da56cb17 = 0x3fd8a8b0da56cb17
0003bba0  int64_t __real@3fe0000000000000 = 0x3fe0000000000000
0003bba8  int64_t __real@411e848000000000 = 0x411e848000000000
0003bbb0  int64_t __mask@@NegDouble@ = --0x8000000000000000

0003bbb8                                                                          00 00 00 00 00 00 00 80                          ........

0003bbc0  char `string'::tanf[0x5] = "tanf", 0

0003bbc5                 00 00 00                                                                               ...

0003bbc8  char const __real@3fd5555555555555[0x6] = "UUUUUU"

0003bbce                                            d5 3f                                                                .?
0003bbd0  double const atan_jby256_lead[0xf1] = 
0003bbd0  {
0003bbd0      [0x00] = 0.06241878867149353
0003bbd8      [0x01] = 0.066308856010437012
0003bbe0      [0x02] = 0.070196926593780518
0003bbe8      [0x03] = 0.074082911014556885
0003bbf0      [0x04] = 0.077966630458831787
0003bbf8      [0x05] = 0.081847965717315674
0003bc00      [0x06] = 0.08572685718536377
0003bc08      [0x07] = 0.089603126049041748
0003bc10      [0x08] = 0.093476772308349609
0003bc18      [0x09] = 0.097347557544708252
0003bc20      [0x0a] = 0.1012154221534729
0003bc28      [0x0b] = 0.105080246925354
0003bc30      [0x0c] = 0.10894191265106201
0003bc38      [0x0d] = 0.11280035972595215
0003bc40      [0x0e] = 0.11665540933609009
0003bc48      [0x0f] = 0.12050700187683105
0003bc50      [0x10] = 0.12435495853424072
0003bc58      [0x11] = 0.12819921970367432
0003bc60      [0x12] = 0.13203966617584229
0003bc68      [0x13] = 0.13587629795074463
0003bc70      [0x14] = 0.1397087574005127
0003bc78      [0x15] = 0.14353728294372559
0003bc80      [0x16] = 0.1473613977432251
0003bc88      [0x17] = 0.15118122100830078
0003bc90      [0x18] = 0.15499663352966309
0003bc98      [0x19] = 0.15880751609802246
0003bca0      [0x1a] = 0.16261374950408936
0003bca8      [0x1b] = 0.16641521453857422
0003bcb0      [0x1c] = 0.17021191120147705
0003bcb8      [0x1d] = 0.1740034818649292
0003bcc0      [0x1e] = 0.17779016494750977
0003bcc8      [0x1f] = 0.1815716028213501
0003bcd0      [0x20] = 0.18534791469573975
0003bcd8      [0x21] = 0.18911874294281006
0003bce0      [0x22] = 0.19288420677185059
0003bce8      [0x23] = 0.19664418697357178
0003bcf0      [0x24] = 0.20039844512939453
0003bcf8      [0x25] = 0.2041471004486084
0003bd00      [0x26] = 0.20788991451263428
0003bd08      [0x27] = 0.21162676811218262
0003bd10      [0x28] = 0.21535766124725342
0003bd18      [0x29] = 0.21908247470855713
0003bd20      [0x2a] = 0.2228010892868042
0003bd28      [0x2b] = 0.22651350498199463
0003bd30      [0x2c] = 0.23021948337554932
0003bd38      [0x2d] = 0.23391914367675781
0003bd40      [0x2e] = 0.23761224746704102
0003bd48      [0x2f] = 0.24129879474639893
0003bd50      [0x30] = 0.24497854709625244
0003bd58      [0x31] = 0.24865162372589111
0003bd60      [0x32] = 0.25231790542602539
0003bd68      [0x33] = 0.25597715377807617
0003bd70      [0x34] = 0.25962948799133301
0003bd78      [0x35] = 0.2632746696472168
0003bd80      [0x36] = 0.26691293716430664
0003bd88      [0x37] = 0.27054381370544434
0003bd90      [0x38] = 0.27416729927062988
0003bd98      [0x39] = 0.27778363227844238
0003bda0      [0x3a] = 0.28139233589172363
0003bda8      [0x3b] = 0.28499364852905273
0003bdb0      [0x3c] = 0.28858733177185059
0003bdb8      [0x3d] = 0.29217314720153809
0003bdc0      [0x3e] = 0.29575157165527344
0003bdc8      [0x3f] = 0.29932212829589844
0003bdd0      [0x40] = 0.30288481712341309
0003bdd8      [0x41] = 0.30643939971923828
0003bde0      [0x42] = 0.30998635292053223
0003bde8      [0x43] = 0.31352496147155762
0003bdf0      [0x44] = 0.31705570220947266
0003bdf8      [0x45] = 0.32057809829711914
0003be00      [0x46] = 0.32409238815307617
0003be08      [0x47] = 0.32759833335876465
0003be10      [0x48] = 0.33109593391418457
0003be18      [0x49] = 0.33458518981933594
0003be20      [0x4a] = 0.33806610107421875
0003be28      [0x4b] = 0.3415381908416748
0003be30      [0x4c] = 0.34500217437744141
0003be38      [0x4d] = 0.34845709800720215
0003be40      [0x4e] = 0.35190367698669434
0003be48      [0x4f] = 0.35534143447875977
0003be50      [0x50] = 0.35877060890197754
0003be58      [0x51] = 0.36219072341918945
0003be60      [0x52] = 0.36560225486755371
0003be68      [0x53] = 0.36900472640991211
0003be70      [0x54] = 0.37239837646484375
0003be78      [0x55] = 0.37578296661376953
0003be80      [0x56] = 0.37915849685668945
0003be88      [0x57] = 0.38252520561218262
0003be90      [0x58] = 0.38588261604309082
0003be98      [0x59] = 0.38923096656799316
0003bea0      [0x5a] = 0.39257001876831055
0003bea8      [0x5b] = 0.39590001106262207
0003beb0      [0x5c] = 0.39922070503234863
0003beb8      [0x5d] = 0.40253210067749023
0003bec0      [0x5e] = 0.40583419799804688
0003bec8      [0x5f] = 0.40912699699401855
0003bed0      [0x60] = 0.41241025924682617
0003bed8      [0x61] = 0.41568422317504883
0003bee0      [0x62] = 0.41894888877868652
0003bee8      [0x63] = 0.42220401763916016
0003bef0      [0x64] = 0.42544960975646973
0003bef8      [0x65] = 0.42868566513061523
0003bf00      [0x66] = 0.43191218376159668
0003bf08      [0x67] = 0.43512916564941406
0003bf10      [0x68] = 0.43833637237548828
0003bf18      [0x69] = 0.44153428077697754
0003bf20      [0x6a] = 0.44472241401672363
0003bf28      [0x6b] = 0.44790077209472656
0003bf30      [0x6c] = 0.45106959342956543
0003bf38      [0x6d] = 0.45422863960266113
0003bf40      [0x6e] = 0.45737791061401367
0003bf48      [0x6f] = 0.46051764488220215
0003bf50      [0x70] = 0.46364760398864746
0003bf58      [0x71] = 0.46676754951477051
0003bf60      [0x72] = 0.46987795829772949
0003bf68      [0x73] = 0.47297859191894531
0003bf70      [0x74] = 0.47606921195983887
0003bf78      [0x75] = 0.47915005683898926
0003bf80      [0x76] = 0.48222112655639648
0003bf88      [0x77] = 0.48528242111206055
0003bf90      [0x78] = 0.48833394050598145
0003bf98      [0x79] = 0.49137544631958008
0003bfa0      [0x7a] = 0.49440693855285645
0003bfa8      [0x7b] = 0.49742889404296875
0003bfb0      [0x7c] = 0.50044059753417969
0003bfb8      [0x7d] = 0.50344276428222656
0003bfc0      [0x7e] = 0.50643491744995117
0003bfc8      [0x7f] = 0.50941705703735352
0003bfd0      [0x80] = 0.51238918304443359
0003bfd8      [0x81] = 0.51535177230834961
0003bfe0      [0x82] = 0.51830434799194336
0003bfe8      [0x83] = 0.52124691009521484
0003bff0      [0x84] = 0.52417945861816406
0003bff8      [0x85] = 0.52710199356079102
0003c000      [0x86] = 0.53001499176025391
0003c008      [0x87] = 0.53291797637939453
0003c010      [0x88] = 0.53581094741821289
0003c018      [0x89] = 0.53869390487670898
0003c020      [0x8a] = 0.54156732559204102
0003c028      [0x8b] = 0.54443073272705078
0003c030      [0x8c] = 0.54728412628173828
0003c038      [0x8d] = 0.55012750625610352
0003c040      [0x8e] = 0.55296134948730469
0003c048      [0x8f] = 0.55578517913818359
0003c050      [0x90] = 0.55859899520874023
0003c058      [0x91] = 0.56140327453613281
0003c060      [0x92] = 0.56419754028320312
0003c068      [0x93] = 0.56698179244995117
0003c070      [0x94] = 0.56975603103637695
0003c078      [0x95] = 0.57252073287963867
0003c080      [0x96] = 0.57527589797973633
0003c088      [0x97] = 0.57802104949951172
0003c090      [0x98] = 0.58075618743896484
0003c098      [0x99] = 0.58348178863525391
0003c0a0      [0x9a] = 0.5861973762512207
0003c0a8      [0x9b] = 0.58890342712402344
0003c0b0      [0x9c] = 0.59159946441650391
0003c0b8      [0x9d] = 0.59428596496582031
0003c0c0      [0x9e] = 0.59696292877197266
0003c0c8      [0x9f] = 0.59962987899780273
0003c0d0      [0xa0] = 0.60228729248046875
0003c0d8      [0xa1] = 0.6049346923828125
0003c0e0      [0xa2] = 0.60757303237915039
0003c0e8      [0xa3] = 0.61020135879516602
0003c0f0      [0xa4] = 0.61282014846801758
0003c0f8      [0xa5] = 0.61542892456054688
0003c100      [0xa6] = 0.61802864074707031
0003c108      [0xa7] = 0.62061882019042969
0003c110      [0xa8] = 0.6231989860534668
0003c118      [0xa9] = 0.62577009201049805
0003c120      [0xaa] = 0.62833118438720703
0003c128      [0xab] = 0.63088321685791016
0003c130      [0xac] = 0.63342571258544922
0003c138      [0xad] = 0.63595867156982422
0003c140      [0xae] = 0.63848209381103516
0003c148      [0xaf] = 0.64099597930908203
0003c150      [0xb0] = 0.64350080490112305
0003c158      [0xb1] = 0.64599609375
0003c160      [0xb2] = 0.64848232269287109
0003c168      [0xb3] = 0.65095901489257812
0003c170      [0xb4] = 0.65342617034912109
0003c178      [0xb5] = 0.6558842658996582
0003c180      [0xb6] = 0.65833282470703125
0003c188      [0xb7] = 0.66077232360839844
0003c190      [0xb8] = 0.66320276260375977
0003c198      [0xb9] = 0.66562366485595703
0003c1a0      [0xba] = 0.66803598403930664
0003c1a8      [0xbb] = 0.67043876647949219
0003c1b0      [0xbc] = 0.67283248901367188
0003c1b8      [0xbd] = 0.6752166748046875
0003c1c0      [0xbe] = 0.67759227752685547
0003c1c8      [0xbf] = 0.67995882034301758
0003c1d0      [0xc0] = 0.68231630325317383
0003c1d8      [0xc1] = 0.68466472625732422
0003c1e0      [0xc2] = 0.68700408935546875
0003c1e8      [0xc3] = 0.68933486938476562
0003c1f0      [0xc4] = 0.69165658950805664
0003c1f8      [0xc5] = 0.6939692497253418
0003c200      [0xc6] = 0.69627285003662109
0003c208      [0xc7] = 0.69856786727905273
0003c210      [0xc8] = 0.70085430145263672
0003c218      [0xc9] = 0.70313167572021484
0003c220      [0xca] = 0.70540046691894531
0003c228      [0xcb] = 0.70766019821166992
0003c230      [0xcc] = 0.70991134643554688
0003c238      [0xcd] = 0.71215391159057617
0003c240      [0xce] = 0.71438789367675781
0003c248      [0xcf] = 0.7166132926940918
0003c250      [0xd0] = 0.71882963180541992
0003c258      [0xd1] = 0.72103786468505859
0003c260      [0xd2] = 0.72323751449584961
0003c268      [0xd3] = 0.72542858123779297
0003c270      [0xd4] = 0.72761106491088867
0003c278      [0xd5] = 0.72978544235229492
0003c280      [0xd6] = 0.73195075988769531
0003c288      [0xd7] = 0.73410844802856445
0003c290      [0xd8] = 0.73625707626342773
0003c298      [0xd9] = 0.73839759826660156
0003c2a0      [0xda] = 0.74053001403808594
0003c2a8      [0xdb] = 0.74265432357788086
0003c2b0      [0xdc] = 0.74477005004882812
0003c2b8      [0xdd] = 0.74687767028808594
0003c2c0      [0xde] = 0.74897670745849609
0003c2c8      [0xdf] = 0.751068115234375
0003c2d0      [0xe0] = 0.75315093994140625
0003c2d8      [0xe1] = 0.75522613525390625
0003c2e0      [0xe2] = 0.75729274749755859
0003c2e8      [0xe3] = 0.75935173034667969
0003c2f0      [0xe4] = 0.76140260696411133
0003c2f8      [0xe5] = 0.76344537734985352
0003c300      [0xe6] = 0.76548004150390625
0003c308      [0xe7] = 0.76750707626342773
0003c310      [0xe8] = 0.76952600479125977
0003c318      [0xe9] = 0.77153730392456055
0003c320      [0xea] = 0.77354097366333008
0003c328      [0xeb] = 0.77553653717041016
0003c330      [0xec] = 0.77752399444580078
0003c338      [0xed] = 0.77950429916381836
0003c340      [0xee] = 0.78147649765014648
0003c348      [0xef] = 0.78344106674194336
0003c350      [0xf0] = 0.78539800643920898
0003c358  }

0003c358                                                                          00 00 00 00 00 00 00 00                          ........
0003c360  double const atan_jby256_tail[0xf1] = 
0003c360  {
0003c360      [0x00] = 2.132446381820054e-08
0003c368      [0x01] = 3.8909386476171276e-08
0003c370      [0x02] = 4.4478090000943745e-08
0003c378      [0x03] = 1.1534476846011275e-08
0003c380      [0x04] = 3.3727105194539531e-09
0003c388      [0x05] = 2.4085760873610986e-08
0003c390      [0x06] = 1.8585381045062381e-08
0003c398      [0x07] = 5.1435829996922508e-08
0003c3a0      [0x08] = 8.8502398541295249e-09
0003c3a8      [0x09] = 1.5942515421435843e-08
0003c3b0      [0x0a] = 1.9513993773775575e-08
0003c3b8      [0x0b] = 2.6490975527354432e-08
0003c3c0      [0x0c] = 4.4338803788123107e-08
0003c3c8      [0x0d] = 2.1475707242182127e-08
0003c3d0      [0x0e] = 2.6104979267075422e-08
0003c3d8      [0x0f] = 7.814393506744663e-09
0003c3e0      [0x10] = 3.6012520712375102e-08
0003c3e8      [0x11] = 6.1527623817934377e-08
0003c3f0      [0x12] = 9.5438796464118429e-08
0003c3f8      [0x13] = 3.0278956685150275e-08
0003c400      [0x14] = 1.1688865094987086e-07
0003c408      [0x15] = 1.0758095646865334e-08
0003c410      [0x16] = 8.3345426537953543e-08
0003c418      [0x17] = 1.1079027927262953e-07
0003c420      [0x18] = 1.0839427789636621e-07
0003c428      [0x19] = 9.221760861268411e-08
0003c430      [0x1a] = 7.9093859219904879e-08
0003c438      [0x1b] = 8.6644540716429313e-08
0003c440      [0x1c] = 1.4083997353709244e-08
0003c448      [0x1d] = 1.190704385073076e-07
0003c450      [0x1e] = 6.404516630517162e-08
0003c458      [0x1f] = 1.0833868207634367e-07
0003c460      [0x20] = 3.5299955018792274e-08
0003c468      [0x21] = 1.0598327393004308e-07
0003c470      [0x22] = 1.0548612407825955e-07
0003c478      [0x23] = 5.8216773228177648e-08
0003c480      [0x24] = 1.0869648398340394e-07
0003c488      [0x25] = 4.4733508612237754e-08
0003c490      [0x26] = 1.2689628716261572e-08
0003c498      [0x27] = 4.065344715891514e-08
0003c4a0      [0x28] = 3.8450484630055703e-08
0003c4a8      [0x29] = 3.6071500640480727e-08
0003c4b0      [0x2a] = 6.4472590316552272e-08
0003c4b8      [0x2b] = 3.6374924997640946e-08
0003c4c0      [0x2c] = 1.0390129441383391e-07
0003c4c8      [0x2d] = 6.2537975630216788e-08
0003c4d0      [0x2e] = 6.6398430236848883e-08
0003c4d8      [0x2f] = 3.2184459897154828e-08
0003c4e0      [0x30] = 1.1603061171276583e-07
0003c4e8      [0x31] = 1.1746462214234773e-07
0003c4f0      [0x32] = 7.54604017965809e-08
0003c4f8      [0x33] = 1.4923492935620656e-07
0003c500      [0x34] = 1.4141692452321743e-07
0003c508      [0x35] = 2.1330806561748349e-07
0003c510      [0x36] = 5.0423093793330232e-08
0003c518      [0x37] = 5.4587492228165552e-08
0003c520      [0x38] = 1.5184902891478687e-07
0003c528      [0x39] = 3.0900430870376927e-08
0003c530      [0x3a] = 9.6757454818473832e-08
0003c538      [0x3b] = 4.0250828552932221e-08
0003c540      [0x3c] = 3.0122226809686109e-08
0003c548      [0x3d] = 2.3618986067007929e-07
0003c550      [0x3e] = 1.1409515811108089e-07
0003c558      [0x3f] = 7.4234908974657347e-08
0003c560      [0x40] = 5.1251558319623038e-08
0003c568      [0x41] = 2.1929039182876392e-07
0003c570      [0x42] = 3.8326351218755389e-08
0003c578      [0x43] = 1.6151348628409052e-07
0003c580      [0x44] = 5.0999674353558992e-08
0003c588      [0x45] = 1.2369403786124677e-07
0003c590      [0x46] = 8.2336795535112378e-08
0003c598      [0x47] = 1.0759176621305369e-07
0003c5a0      [0x48] = 1.4278994752463182e-07
0003c5a8      [0x49] = 1.3234712302471188e-07
0003c5b0      [0x4a] = 2.1762606731659815e-08
0003c5b8      [0x4b] = 2.3445486692304429e-07
0003c5c0      [0x4c] = 2.8296637026176692e-09
0003c5c8      [0x4d] = 2.2930091989090763e-07
0003c5d0      [0x4e] = 1.4842827045026128e-07
0003c5d8      [0x4f] = 1.8793740857431398e-07
0003c5e0      [0x50] = 6.1368594681333406e-08
0003c5e8      [0x51] = 1.9858502273358382e-07
0003c5f0      [0x52] = 7.6839413162375296e-08
0003c5f8      [0x53] = 1.2811905231243675e-07
0003c600      [0x54] = 7.021191047192365e-08
0003c608      [0x55] = 9.879547938206363e-08
0003c610      [0x56] = 1.7217675238103499e-07
0003c618      [0x57] = 1.128772251461697e-08
0003c620      [0x58] = 5.3354982955585174e-08
0003c628      [0x59] = 2.1383327571081652e-08
0003c630      [0x5a] = 1.1624351804829056e-07
0003c638      [0x5b] = 6.2992640836905588e-08
0003c640      [0x5c] = 6.4542903932802196e-08
0003c648      [0x5d] = 8.6400192281428193e-08
0003c650      [0x5e] = 9.507675722023258e-08
0003c658      [0x5f] = 5.8085149750812114e-08
0003c660      [0x60] = 1.8235056113502477e-07
0003c668      [0x61] = 1.9894868058739061e-07
0003c670      [0x62] = 7.8354866345019766e-08
0003c678      [0x63] = 3.0437423448679859e-08
0003c680      [0x64] = 2.7613572562979741e-08
0003c688      [0x65] = 4.3261010545420307e-08
0003c690      [0x66] = 5.1710751532412726e-08
0003c698      [0x67] = 2.8239832787584144e-08
0003c6a0      [0x68] = 1.874824695241956e-07
0003c6a8      [0x69] = 2.974818916627141e-08
0003c6b0      [0x6a] = 9.9442157084358432e-09
0003c6b8      [0x6b] = 1.0705621073039185e-07
0003c6c0      [0x6c] = 6.2558958046688116e-08
0003c6c8      [0x6d] = 9.5664101386946459e-08
0003c6d0      [0x6e] = 1.8805630714835544e-07
0003c6d8      [0x6f] = 8.3885068937955788e-08
0003c6e0      [0x70] = 5.0121586552767412e-09
0003c6e8      [0x71] = 1.7416609599852209e-07
0003c6f0      [0x72] = 9.9677957439536359e-08
0003c6f8      [0x73] = 5.9843202636832146e-09
0003c700      [0x74] = 1.1836292236688758e-07
0003c708      [0x75] = 1.8608683328415422e-07
0003c710      [0x76] = 1.9767145725134894e-07
0003c718      [0x77] = 1.4244716071719924e-07
0003c720      [0x78] = 1.0550424078554657e-08
0003c728      [0x79] = 3.1333521837163919e-08
0003c730      [0x7a] = 1.9651841890191454e-07
0003c738      [0x7b] = 2.1769203503917354e-08
0003c740      [0x7c] = 2.1561311442652998e-07
0003c748      [0x7d] = 5.6827109830044121e-08
0003c750      [0x7e] = 1.7033145582336912e-08
0003c758      [0x7f] = 9.1759002809570958e-08
0003c760      [0x80] = 2.7726630411291657e-07
0003c768      [0x81] = 9.3704193761465694e-08
0003c770      [0x82] = 1.561163463683168e-08
0003c778      [0x83] = 4.1396743380838273e-08
0003c780      [0x84] = 1.7016474918582162e-07
0003c788      [0x85] = 4.0170878854560009e-07
0003c790      [0x86] = 2.5966353922605055e-07
0003c798      [0x87] = 2.2200748765502747e-07
0003c7a0      [0x88] = 2.9054225080964408e-07
0003c7a8      [0x89] = 4.677205376666289e-07
0003c7b0      [0x8a] = 2.7979980395677255e-07
0003c7b8      [0x8b] = 2.0734455232743255e-07
0003c7c0      [0x8c] = 2.547056986927352e-07
0003c7c8      [0x8d] = 4.2684858953954845e-07
0003c7d0      [0x8e] = 2.5250672363355222e-07
0003c7d8      [0x8f] = 2.146841299338497e-07
0003c7e0      [0x90] = 3.2013482220159651e-07
0003c7e8      [0x91] = 9.9353756574985571e-08
0003c7f0      [0x92] = 3.7079294482791725e-08
0003c7f8      [0x93] = 1.417727493690837e-07
0003c800      [0x94] = 4.224466014901988e-07
0003c808      [0x95] = 4.1181843372480151e-07
0003c810      [0x96] = 1.1997638150260531e-07
0003c818      [0x97] = 3.4370307857152091e-08
0003c820      [0x98] = 1.6612870555545327e-07
0003c828      [0x99] = 5.0049961002328301e-08
0003c830      [0x9a] = 1.7510513994120806e-07
0003c838      [0x9b] = 7.7080714672903033e-08
0003c840      [0x9c] = 2.4591860752689584e-07
0003c848      [0x9d] = 2.183590209586262e-07
0003c850      [0x9e] = 8.4434288797644533e-09
0003c858      [0x9f] = 1.0750614868788863e-07
0003c860      [0xa0] = 5.365449543168209e-08
0003c868      [0xa1] = 3.391091015183966e-07
0003c870      [0xa2] = 2.6009872029392061e-08
0003c878      [0xa3] = 8.4267899166462146e-08
0003c880      [0xa4] = 5.3697223747018363e-08
0003c888      [0xa5] = 4.2819255817192168e-07
0003c890      [0xa6] = 2.7153549148395514e-07
0003c898      [0xa7] = 7.8409499814507578e-08
0003c8a0      [0xa8] = 3.4388059913411743e-07
0003c8a8      [0xa9] = 1.3287806506036648e-07
0003c8b0      [0xaa] = 4.1804680262796763e-07
0003c8b8      [0xab] = 2.6504241176576602e-07
0003c8c0      [0xac] = 1.7038369534751864e-07
0003c8c8      [0xad] = 1.5409649725961352e-07
0003c8d0      [0xae] = 2.3654340241245981e-07
0003c8d8      [0xaf] = 4.3841635010687674e-07
0003c8e0      [0xb0] = 3.0389216133992778e-07
0003c8e8      [0xb1] = 3.311367716056649e-07
0003c8f0      [0xb2] = 6.4949429452659068e-08
0003c8f8      [0xb3] = 4.1042342988718135e-09
0003c900      [0xb4] = 1.7083164086911385e-07
0003c908      [0xb5] = 1.1081151265790918e-07
0003c910      [0xb6] = 3.2367772474978361e-07
0003c918      [0xb7] = 3.5566273425919268e-07
0003c920      [0xb8] = 2.3010233348973822e-07
0003c928      [0xb9] = 4.4742900400073863e-07
0003c930      [0xba] = 7.781671356173296e-08
0003c938      [0xbb] = 9.9034529190853542e-08
0003c940      [0xbc] = 5.8580091314311373e-08
0003c948      [0xbd] = 4.5785906241087184e-07
0003c950      [0xbe] = 3.6799306972339093e-07
0003c958      [0xbf] = 2.9083646432297728e-07
0003c960      [0xc0] = 2.5162157425013139e-07
0003c968      [0xc1] = 2.7578982474065282e-07
0003c970      [0xc2] = 3.889857762503144e-07
0003c978      [0xc3] = 1.4021408018376802e-07
0003c980      [0xc4] = 3.2345143222355048e-08
0003c988      [0xc5] = 9.1597918073060844e-08
0003c990      [0xc6] = 3.4437140249864047e-07
0003c998      [0xc7] = 3.404018972150595e-07
0003c9a0      [0xc8] = 1.0643181345370795e-07
0003c9a8      [0xc9] = 1.4620423893233885e-07
0003c9b0      [0xca] = 9.9461037697203905e-09
0003c9b8      [0xcb] = 2.0171152809268177e-07
0003c9c0      [0xcc] = 2.7202797798619157e-07
0003c9c8      [0xcd] = 2.4840260251169376e-07
0003c9d0      [0xce] = 1.5848001121924962e-07
0003c9d8      [0xcf] = 3.0037282811336871e-08
0003c9e0      [0xd0] = 3.6781620458354198e-07
0003c9e8      [0xd1] = 2.4616979303234382e-07
0003c9f0      [0xd2] = 1.7008046827020425e-07
0003c9f8      [0xd3] = 1.6780671776387291e-07
0003ca00      [0xd4] = 2.6771562200690794e-07
0003ca08      [0xd5] = 2.1441134255029917e-08
0003ca10      [0xd6] = 4.1122822128366907e-07
0003ca18      [0xd7] = 3.5231175239674966e-08
0003ca20      [0xd8] = 3.5271800039736782e-07
0003ca28      [0xd9] = 4.3885738799291113e-07
0003ca30      [0xda] = 3.2257460675348254e-07
0003ca38      [0xdb] = 3.287303711828043e-08
0003ca40      [0xdc] = 7.5667247060763928e-08
0003ca48      [0xdd] = 3.2675015531636968e-09
0003ca50      [0xde] = 3.2172444536209528e-07
0003ca58      [0xdf] = 1.0663942737177657e-07
0003ca60      [0xe0] = 3.4102078813952472e-07
0003ca68      [0xe1] = 1.0058283863123255e-07
0003ca70      [0xe2] = 3.6843943385927664e-07
0003ca78      [0xe3] = 2.2040307834238801e-07
0003ca80      [0xe4] = 1.6284146709829814e-07
0003ca88      [0xe5] = 2.2532534829668073e-07
0003ca90      [0xe6] = 4.3746223822642161e-07
0003ca98      [0xe7] = 3.5205588055504071e-07
0003caa0      [0xe8] = 4.7561439849478178e-07
0003caa8      [0xe9] = 3.6099839903321532e-07
0003cab0      [0xea] = 3.7929243461151395e-08
0003cab8      [0xeb] = 1.298590155285493e-08
0003cac0      [0xec] = 3.1592754698547491e-07
0003cac8      [0xed] = 2.2853367988737967e-08
0003cad0      [0xee] = 1.1722254182355313e-07
0003cad8      [0xef] = 1.5199120840546442e-07
0003cae0      [0xf0] = 1.5695823932524066e-07
0003cae8  }
0003cae8  int64_t __real@4010000000000000 = 0x4010000000000000
0003caf0  char const __real@3fd5555555555538[0x6] = "8UUUUU"

0003caf6                                                                    d5 3f                                                .?

0003caf8  int64_t __real@3fc99999999643a3 = 0x3fc99999999643a3
0003cb00  int64_t __real@3fc2492482bd6be1 = 0x3fc2492482bd6be1
0003cb08  int64_t __real@3fb70c3192d751c2 = 0x3fb70c3192d751c2
0003cb10  int64_t __real@3fbc718839b8c4eb = 0x3fbc718839b8c4eb
0003cb18  int64_t __real@3e45798ee2308c3a = 0x3e45798ee2308c3a
0003cb20  int64_t __real@3fc99992b9802d7d = 0x3fc99992b9802d7d
0003cb28  int64_t __real@3fd5555555550877 = 0x3fd5555555550877
0003cb30  int64_t __real@3f70000000000000 = 0x3f70000000000000
0003cb38  int64_t __real@4070000000000000 = 0x4070000000000000
0003cb40  int64_t __real@3fb0000000000000 = 0x3fb0000000000000
0003cb48  int64_t __real@8000000000000000 = --0x8000000000000000
0003cb50  char const `string'::atan2[0x6] = "atan2", 0

0003cb56                                                                    00 00                                                ..

0003cb58  char `string'::sqrtf[0x6] = "sqrtf", 0

0003cb5e                                                                                            00 00                                ..

0003cb60  double const c1 = -0.16666666666666666
0003cb68  double const c2 = 0.0083333333333309497
0003cb70  double const c3 = -0.00019841269836761127
0003cb78  double const c4 = 2.7557316103728802e-06
0003cb80  double const c5 = -2.5051132068021698e-08
0003cb88  double const c6 = 1.5918144304485914e-10
0003cb90  char const data_3cb90[0x6] = "UUUUUU"

0003cb96                                                                    a5 3f 67 69 c1 16 6c c1 56 bf                        .?gi..l.V.

0003cba0  int64_t data_3cba0 = 0x3efa01a019f4ec90

0003cba8                          f6 65 7f a1 4f 7e 92 be                                                          .e..O~..

0003cbb0  int64_t data_3cbb0 = 0x3e21eeb69037ab78

0003cbb8                                                                          42 5e cc 46 db 07 a9 bd                          B^.F....

0003cbc0  int64_t data_3cbc0 = 0x3fe45f306dc9c883
0003cbc8  int64_t data_3cbc8 = 0x3ff921fb54400000
0003cbd0  int64_t data_3cbd0 = 0x3dd0b4611a626331
0003cbd8  int64_t data_3cbd8 = 0x3dd0b4611a600000
0003cbe0  int64_t data_3cbe0 = 0x3ba3198a2e037073
0003cbe8  int64_t data_3cbe8 = 0x3ba3198a2e000000
0003cbf0  int64_t data_3cbf0 = 0x397b839a252049c1

0003cbf8                                                                          83 c8 c9 6d 30 5f e4 3f                          ...m0_.?
0003cc00  00 00 40 54 fb 21 f9 3f 31 63 62 1a 61 b4 d0 3d 00 00 60 1a 61 b4 d0 3d 73 70 03 2e 8a 19 a3 3b  ..@T.!.?1cb.a..=..`.a..=sp.....;
0003cc20  00 00 00 2e 8a 19 a3 3b c1 49 20 25 9a 83 7b 39                                                  .......;.I %..{9

0003cc30  char const __real@3fc5555555555555[0x6] = "UUUUUU"

0003cc36                                                                    c5 3f                                                .?

0003cc38  int64_t __real@3f2a01a019e83e5c = 0x3f2a01a019e83e5c
0003cc40  int64_t __real@3e5ae600b42fdfa7 = 0x3e5ae600b42fdfa7
0003cc48  int64_t __real@0000000000000000 = 0x0
0003cc50  int64_t __real@3f56c16c16c16967 = 0x3f56c16c16c16967
0003cc58  int64_t __real@3e927e4fa17f65f6 = 0x3e927e4fa17f65f6
0003cc60  int64_t __real@3da907db46cc5e42 = 0x3da907db46cc5e42
0003cc68  char const `string'::sin[0x4] = "sin", 0
0003cc6c  char `string'::cos[0x4] = "cos", 0
0003cc70  double const atan_jby256[0xf1] = 
0003cc70  {
0003cc70      [0x00] = 0.062418809995957343
0003cc78      [0x01] = 0.066308894919823475
0003cc80      [0x02] = 0.070196971071870506
0003cc88      [0x03] = 0.074082922549033731
0003cc90      [0x04] = 0.077966633831542301
0003cc98      [0x05] = 0.081847989803076546
0003cca0      [0x06] = 0.085726875770744809
0003cca8      [0x07] = 0.089603177484871732
0003ccb0      [0x08] = 0.093476781158589456
0003ccb8      [0x09] = 0.097347573487223671
0003ccc0      [0x0a] = 0.10121544166746667
0003ccc8      [0x0b] = 0.10508027341632953
0003ccd0      [0x0c] = 0.10894195698986579
0003ccd8      [0x0d] = 0.11280038120165939
0003cce0      [0x0e] = 0.11665543544106935
0003cce8      [0x0f] = 0.12050700969122455
0003ccf0      [0x10] = 0.12435499454676142
0003ccf8      [0x11] = 0.12819928123129812
0003cd00      [0x12] = 0.13203976161463873
0003cd08      [0x13] = 0.1358763282297013
0003cd10      [0x14] = 0.13970887428916362
0003cd18      [0x15] = 0.14353729370182122
0003cd20      [0x16] = 0.14736148108865163
0003cd28      [0x17] = 0.15118133179858004
0003cd30      [0x18] = 0.15499674192394097
0003cd38      [0x19] = 0.15880760831563107
0003cd40      [0x1a] = 0.16261382859794857
0003cd48      [0x1b] = 0.16641530118311493
0003cd50      [0x1c] = 0.17021192528547438
0003cd58      [0x1d] = 0.17400360093536768
0003cd60      [0x1e] = 0.17779022899267605
0003cd68      [0x1f] = 0.18157171116003215
0003cd70      [0x20] = 0.18534794999569476
0003cd78      [0x21] = 0.18911884892608397
0003cd80      [0x22] = 0.19288431225797464
0003cd88      [0x23] = 0.19664424519034499
0003cd90      [0x24] = 0.20039855382587851
0003cd98      [0x25] = 0.20414714518211699
0003cda0      [0x26] = 0.20788992720226299
0003cda8      [0x27] = 0.21162680876562975
0003cdb0      [0x28] = 0.21535769969773805
0003cdb8      [0x29] = 0.21908251078005775
0003cdc0      [0x2a] = 0.22280115375939449
0003cdc8      [0x2b] = 0.22651354135691962
0003cdd0      [0x2c] = 0.23021958727684372
0003cdd8      [0x2d] = 0.23391920621473342
0003cde0      [0x2e] = 0.23761231386547124
0003cde8      [0x2f] = 0.2412988269308588
0003cdf0      [0x30] = 0.24497866312686414
0003cdf8      [0x31] = 0.24865174119051325
0003ce00      [0x32] = 0.25231798088642715
0003ce08      [0x33] = 0.25597730301300547
0003ce10      [0x34] = 0.25962962940825751
0003ce18      [0x35] = 0.2632748829552824
0003ce20      [0x36] = 0.2669129875874004
0003ce28      [0x37] = 0.27054386829293653
0003ce30      [0x38] = 0.27416745111965879
0003ce38      [0x39] = 0.27778366317887321
0003ce40      [0x3a] = 0.2813924326491784
0003ce48      [0x3b] = 0.28499368877988124
0003ce50      [0x3c] = 0.28858736189407735
0003ce58      [0x3d] = 0.29217338339139876
0003ce60      [0x3e] = 0.29575168575043154
0003ce68      [0x3f] = 0.29932220253080738
0003ce70      [0x40] = 0.30288486837497136
0003ce78      [0x41] = 0.30643961900963007
0003ce80      [0x42] = 0.30998639124688343
0003ce88      [0x43] = 0.31352512298504387
0003ce90      [0x44] = 0.31705575320914697
0003ce98      [0x45] = 0.32057822199115699
0003cea0      [0x46] = 0.32409247048987166
0003cea8      [0x47] = 0.32759844095053081
0003ceb0      [0x48] = 0.33109607670413205
0003ceb8      [0x49] = 0.33458532216645892
0003cec0      [0x4a] = 0.33806612283682547
0003cec8      [0x4b] = 0.34153842529654171
0003ced0      [0x4c] = 0.34500217720710508
0003ced8      [0x4d] = 0.34845732730812201
0003cee0      [0x4e] = 0.35190382541496473
0003cee8      [0x4f] = 0.35534162241616829
0003cef0      [0x50] = 0.35877067027057219
0003cef8      [0x51] = 0.36219092200421216
0003cf00      [0x52] = 0.36560233170696682
0003cf08      [0x53] = 0.36900485452896442
0003cf10      [0x54] = 0.3723984466767542
0003cf18      [0x55] = 0.37578306540924888
0003cf20      [0x56] = 0.37915866903344181
0003cf28      [0x57] = 0.3825252168999051
0003cf30      [0x58] = 0.38588266939807375
0003cf38      [0x59] = 0.38923098795132072
0003cf40      [0x5a] = 0.39257013501182858
0003cf48      [0x5b] = 0.3959000740552629
0003cf50      [0x5c] = 0.39922076957525254
0003cf58      [0x5d] = 0.40253218707768251
0003cf60      [0x5e] = 0.40583429307480406
0003cf68      [0x5f] = 0.4091270550791683
0003cf70      [0x60] = 0.41241044159738727
0003cf78      [0x61] = 0.41568442212372941
0003cf80      [0x62] = 0.41894896713355284
0003cf88      [0x63] = 0.42220404807658357
0003cf90      [0x64] = 0.42544963737004227
0003cf98      [0x65] = 0.42868570839162573
0003cfa0      [0x66] = 0.43191223547234819
0003cfa8      [0x67] = 0.43512919388924681
0003cfb0      [0x68] = 0.43833655985795777
0003cfb8      [0x69] = 0.44153431052516667
0003cfc0      [0x6a] = 0.44472242396093931
0003cfc8      [0x6b] = 0.44790087915093729
0003cfd0      [0x6c] = 0.45106965598852344
0003cfd8      [0x6d] = 0.4542287352667625
0003cfe0      [0x6e] = 0.45737809867032081
0003cfe8      [0x6f] = 0.46051772876727104
0003cff0      [0x70] = 0.46364760900080609
0003cff8      [0x71] = 0.4667677236808665
0003d000      [0x72] = 0.46987805797568688
0003d008      [0x73] = 0.47297859790326557
0003d010      [0x74] = 0.47606933032276122
0003d018      [0x75] = 0.47915024292582253
0003d020      [0x76] = 0.48222132422785369
0003d028      [0x77] = 0.48528256355922123
0003d030      [0x78] = 0.48833395105640548
0003d038      [0x79] = 0.49137547765310191
0003d040      [0x7a] = 0.49440713507127532
0003d048      [0x7b] = 0.49742891581217225
0003d050      [0x7c] = 0.50044081314729405
0003d058      [0x7d] = 0.50344282110933636
0003d060      [0x7e] = 0.50643493448309673
0003d068      [0x7f] = 0.50941714879635625
0003d070      [0x80] = 0.51238946031073762
0003d078      [0x81] = 0.51535186601254335
0003d080      [0x82] = 0.5183043636035779
0003d088      [0x83] = 0.52124695149195821
0003d090      [0x84] = 0.52417962878291324
0003d098      [0x85] = 0.52710239526957947
0003d0a0      [0x86] = 0.53001525142379313
0003d0a8      [0x87] = 0.53291819838688215
0003d0b0      [0x88] = 0.53581123796046359
0003d0b8      [0x89] = 0.53869437259724662
0003d0c0      [0x8a] = 0.5415676053918449
0003d0c8      [0x8b] = 0.54443094007160309
0003d0d0      [0x8c] = 0.54728438098743692
0003d0d8      [0x8d] = 0.55012793310469299
0003d0e0      [0x8e] = 0.55296160199402822
0003d0e8      [0x8f] = 0.55578539382231351
0003d0f0      [0x90] = 0.55859931534356233
0003d0f8      [0x91] = 0.56140337388988937
0003d100      [0x92] = 0.56419757736249754
0003d108      [0x93] = 0.56698193422270049
0003d110      [0x94] = 0.56975645348297843
0003d118      [0x95] = 0.57252114469807236
0003d120      [0x96] = 0.57527601795611782
0003d128      [0x97] = 0.57802108386981954
0003d130      [0x98] = 0.5807563535676703
0003d138      [0x99] = 0.58348183868521486
0003d140      [0x9a] = 0.58619755135636054
0003d148      [0x9b] = 0.58890350420473803
0003d150      [0x9c] = 0.59159971033511138
0003d158      [0x9d] = 0.59428618332484118
0003d160      [0x9e] = 0.5969629372154015
0003d168      [0x9f] = 0.59962998650395138
0003d170      [0xa0] = 0.60228734613496415
0003d178      [0xa1] = 0.60493503149191397
0003d180      [0xa2] = 0.60757305838902231
0003d188      [0xa3] = 0.61020144306306512
0003d190      [0xa4] = 0.61282020216524125
0003d198      [0xa5] = 0.61542935275310495
0003d1a0      [0xa6] = 0.61802891228256174
0003d1a8      [0xa7] = 0.62061889859992947
0003d1b0      [0xa8] = 0.6231993299340659
0003d1b8      [0xa9] = 0.62577022488856304
0003d1c0      [0xaa] = 0.62833160243400965
0003d1c8      [0xab] = 0.63088348190032184
0003d1d0      [0xac] = 0.63342588296914448
0003d1d8      [0xad] = 0.63595882566632145
0003d1e0      [0xae] = 0.63848233035443747
0003d1e8      [0xaf] = 0.64099641772543203
0003d1f0      [0xb0] = 0.64350110879328437
0003d1f8      [0xb1] = 0.64599642488677156
0003d200      [0xb2] = 0.64848238764230048
0003d208      [0xb3] = 0.65095901899681241
0003d210      [0xb4] = 0.65342634118076193
0003d218      [0xb5] = 0.65588437671117084
0003d220      [0xb6] = 0.65833314838475598
0003d228      [0xb7] = 0.66077267927113259
0003d230      [0xb8] = 0.66320299270609318
0003d238      [0xb9] = 0.66562411228496099
0003d240      [0xba] = 0.66803606185602016
0003d248      [0xbb] = 0.67043886551402132
0003d250      [0xbc] = 0.6728325475937631
0003d258      [0xbd] = 0.67521713266374983
0003d260      [0xbe] = 0.67759264551992515
0003d268      [0xbf] = 0.67995911117948182
0003d270      [0xc0] = 0.68231655487474807
0003d278      [0xc1] = 0.68466500204714886
0003d280      [0xc2] = 0.6870044783412449
0003d288      [0xc3] = 0.68933500959884575
0003d290      [0xc4] = 0.69165662185319976
0003d298      [0xc5] = 0.69396934132325983
0003d2a0      [0xc6] = 0.69627319440802349
0003d2a8      [0xc7] = 0.69856820768094985
0003d2b0      [0xc8] = 0.70085440788445008
0003d2b8      [0xc9] = 0.70313182192445367
0003d2c0      [0xca] = 0.70540047686504903
0003d2c8      [0xcb] = 0.70766039992319796
0003d2d0      [0xcc] = 0.7099116184635248
0003d2d8      [0xcd] = 0.71215415999317866
0003d2e0      [0xce] = 0.71438805215676893
0003d2e8      [0xcf] = 0.71661332273137457
0003d2f0      [0xd0] = 0.71882999962162442
0003d2f8      [0xd1] = 0.72103811085485159
0003d300      [0xd2] = 0.72323768457631787
0003d308      [0xd3] = 0.72542874904451071
0003d310      [0xd4] = 0.72761133262651068
0003d318      [0xd5] = 0.72978546379342912
0003d320      [0xd6] = 0.73195117111591657
0003d328      [0xd7] = 0.73410848325973965
0003d330      [0xd8] = 0.7362574289814281
0003d338      [0xd9] = 0.73839803712398955
0003d340      [0xda] = 0.74053033661269263
0003d348      [0xdb] = 0.74265435645091793
0003d350      [0xdc] = 0.74477012571607515
0003d358      [0xdd] = 0.74687767355558743
0003d360      [0xde] = 0.7489770291829414
0003d368      [0xdf] = 0.75106822187380229
0003d370      [0xe0] = 0.7531512809621943
0003d378      [0xe1] = 0.75522623583674486
0003d380      [0xe2] = 0.75729311593699244
0003d388      [0xe3] = 0.75935195074975792
0003d390      [0xe4] = 0.76140276980557842
0003d398      [0xe5] = 0.76344560267520178
0003d3a0      [0xe6] = 0.76548047896614446
0003d3a8      [0xe7] = 0.76750742831930818
0003d3b0      [0xe8] = 0.76952648040565819
0003d3b8      [0xe9] = 0.7715376649229595
0003d3c0      [0xea] = 0.77354101159257349
0003d3c8      [0xeb] = 0.77553655015631162
0003d3d0      [0xec] = 0.77752431037334768
0003d3d8      [0xed] = 0.77950432201718634
0003d3e0      [0xee] = 0.78147661487268827
0003d3e8      [0xef] = 0.78344121873315176
0003d3f0      [0xf0] = 0.78539816339744828
0003d3f8  }
0003d3f8  int32_t __real@80000000 = -0x80000000
0003d3fc  char `string'::atan2f[0x7] = "atan2f", 0

0003d403           00 00 00 00 00                                                                             .....

0003d408  int64_t data_3d408 = 0x3ff921fb54442d18

0003d410                                                  7d e8 45 55 55 55 c5 bf                                          }.EUUU..

0003d418  int64_t data_3d418 = 0x3f811110df01232d

0003d420  96 71 a3 88 3a 01 2a bf                                                                          .q..:.*.

0003d428  int64_t data_3d428 = 0x3ec6dbe4ad1572d5
0003d430  char const data_3d430[0x6] = "1/PUUU"

0003d436                                                                    a5 3f d7 99 56 f5 6b c1 56 bf                        .?..V.k.V.

0003d440  int64_t data_3d440 = 0x3efa015c50a93b49

0003d448                          b8 46 cc 43 47 52 92 be                                                          .F.CGR..

0003d450  int64_t data_3d450 = 0x3fe45f306dc9c883
0003d458  int64_t data_3d458 = 0x3ff921fb54400000
0003d460  int64_t data_3d460 = 0x3dd0b4611a626331
0003d468  int64_t data_3d468 = 0x3dd0b4611a600000
0003d470  int64_t data_3d470 = 0x3ba3198a2e037073
0003d478  int64_t data_3d478 = 0x3ba3198a2e000000
0003d480  int64_t data_3d480 = 0x397b839a252049c1

0003d488                          83 c8 c9 6d 30 5f e4 3f 00 00 40 54 fb 21 f9 3f 31 63 62 1a 61 b4 d0 3d          ...m0_.?..@T.!.?1cb.a..=
0003d4a0  00 00 60 1a 61 b4 d0 3d 73 70 03 2e 8a 19 a3 3b 00 00 00 2e 8a 19 a3 3b c1 49 20 25 9a 83 7b 39  ..`.a..=sp.....;.......;.I %..{9

0003d4c0  int64_t __real@3fc555555545e87d = 0x3fc555555545e87d
0003d4c8  int64_t __real@3f2a013a88a37196 = 0x3f2a013a88a37196
0003d4d0  int64_t __real@3f56c16bf55699d7 = 0x3f56c16bf55699d7
0003d4d8  int64_t __real@3e92524743cc46b8 = 0x3e92524743cc46b8
0003d4e0  char `string'::sinf[0x5] = "sinf", 0

0003d4e5                 00 00 00                                                                               ...

0003d4e8  char `string'::cosf[0x5] = "cosf", 0

0003d4ed                                         00 00 00                                                               ...

0003d4f0  char `string'::pow[0x4] = "pow", 0

0003d4f4                                                              00 00 00 00                                              ....

0003d4f8  double const piby2_lead = 1.5707963267948966
0003d500  double const piby2_part1 = 1.5707963109016418
0003d508  double const piby2_part2 = 1.5893254712295857e-08
0003d510  double const piby2_part3 = 6.1232339957367648e-17
0003d518  int64_t __real@c000000000000000 = -0x4000000000000000
0003d520  char const `string'::_nextafter[0xb] = "_nextafter", 0

0003d52b                                   00                                                                         .

0003d52c  char const `string'::_logb[0x6] = "_logb", 0

0003d532                                                        00 00                                                        ..

0003d534  char `string'::_yn[0x4] = "_yn", 0
0003d538  char `string'::_y1[0x4] = "_y1", 0
0003d53c  char `string'::_y0[0x4] = "_y0", 0
0003d540  char const `string'::frexp[0x6] = "frexp", 0

0003d546                    00 00                                                                                ..

0003d548  char const `string'::fmod[0x5] = "fmod", 0

0003d54d                                         00 00 00                                                               ...

0003d550  char const `string'::_hypot[0x7] = "_hypot", 0

0003d557                                                                       00                                                 .

0003d558  char const `string'::_cabs[0x6] = "_cabs", 0

0003d55e                                                                                            00 00                                ..

0003d560  char const `string'::ldexp[0x6] = "ldexp", 0

0003d566                    00 00                                                                                ..

0003d568  char const `string'::modf[0x5] = "modf", 0

0003d56d                                         00 00 00                                                               ...

0003d570  char const `string'::fabs[0x5] = "fabs", 0

0003d575                                                                 00 00 00                                               ...

0003d578  char const `string'::floor[0x6] = "floor", 0

0003d57e                                                                                            00 00                                ..

0003d580  char const `string'::ceil[0x5] = "ceil", 0

0003d585                 00 00 00                                                                               ...

0003d588  char `string'::tan[0x4] = "tan", 0
0003d58c  char const `string'::atan[0x5] = "atan", 0

0003d591                                                     00 00 00                                                       ...

0003d594  char const `string'::acos[0x5] = "acos", 0

0003d599                                                                             00 00 00                                       ...

0003d59c  char const `string'::asin[0x5] = "asin", 0

0003d5a1     00 00 00                                                                                       ...

0003d5a4  char const `string'::tanh[0x5] = "tanh", 0

0003d5a9                             00 00 00                                                                       ...

0003d5ac  char const `string'::cosh[0x5] = "cosh", 0

0003d5b1                                                     00 00 00                                                       ...

0003d5b4  char const `string'::sinh[0x5] = "sinh", 0

0003d5b9                                                                             00 00 00                                       ...

0003d5bc  char const `string'::log10[0x6] = "log10", 0

0003d5c2        00 00                                                                                        ..

0003d5c4  char `string'::log[0x4] = "log", 0
0003d5c8  char `string'::exp[0x4] = "exp", 0

0003d5cc                                      00 00 00 00                                                              ....

0003d5d0  int64_t __real@433fffffffffffff = 0x433fffffffffffff
0003d5d8  int64_t __real@c33fffffffffffff = -0x3cc0000000000001
0003d5e0  uint32_t debugInfoType = 'RSDS'
0003d5e4  uint8_t PDBGuid[0x10] = 
0003d5e4  {
0003d5e4      [0x0] =  0xde
0003d5e5      [0x1] =  0xd8
0003d5e6      [0x2] =  0x5a
0003d5e7      [0x3] =  0x61
0003d5e8      [0x4] =  0xf7
0003d5e9      [0x5] =  0x52
0003d5ea      [0x6] =  0x94
0003d5eb      [0x7] =  0x47
0003d5ec      [0x8] =  0xb6
0003d5ed      [0x9] =  0xa5
0003d5ee      [0xa] =  0x5d
0003d5ef      [0xb] =  0x4c
0003d5f0      [0xc] =  0xde
0003d5f1      [0xd] =  0xfc
0003d5f2      [0xe] =  0xef
0003d5f3      [0xf] =  0x2f
0003d5f4  }
0003d5f4  uint32_t PDBAge = 0x1
0003d5f8  char PDBFileName[0x44] = "c:\\development_work\\csf_release_hp\\driver\\bin\\amd64\\NWTransLibV.pdb", 0

0003d63c                                                                                      00 00 00 00                              ....

0003d640  struct UNWIND_INFO data_3d640 = 
0003d640  {
0003d640      uint8_t VersionAndFlag = 0x1
0003d641      uint8_t SizeOfProlog = 0x4
0003d642      uint8_t CountOfUnwindCodes = 0x1
0003d643      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d644  }
0003d644  uint16_t data_3d644[0x1] = 
0003d644  {
0003d644      [0x0] =  0x4204
0003d646  }

0003d646                    00 00                                                                                ..

0003d648  struct UNWIND_INFO data_3d648 = 
0003d648  {
0003d648      uint8_t VersionAndFlag = 0x1
0003d649      uint8_t SizeOfProlog = 0x4
0003d64a      uint8_t CountOfUnwindCodes = 0x1
0003d64b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d64c  }
0003d64c  uint16_t data_3d64c[0x1] = 
0003d64c  {
0003d64c      [0x0] =  0x6204
0003d64e  }

0003d64e                                            00 00                                                                ..

0003d650  struct UNWIND_INFO data_3d650 = 
0003d650  {
0003d650      uint8_t VersionAndFlag = 0x1
0003d651      uint8_t SizeOfProlog = 0xf
0003d652      uint8_t CountOfUnwindCodes = 0x4
0003d653      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d654  }
0003d654  uint16_t data_3d654[0x4] = 
0003d654  {
0003d654      [0x0] =  0x340f
0003d656      [0x1] =  0x0006
0003d658      [0x2] =  0x320f
0003d65a      [0x3] =  0x700b
0003d65c  }
0003d65c  struct UNWIND_INFO data_3d65c = 
0003d65c  {
0003d65c      uint8_t VersionAndFlag = 0x1
0003d65d      uint8_t SizeOfProlog = 0x27
0003d65e      uint8_t CountOfUnwindCodes = 0xa
0003d65f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d660  }
0003d660  uint16_t data_3d660[0xa] = 
0003d660  {
0003d660      [0x0] =  0x7827
0003d662      [0x1] =  0x0002
0003d664      [0x2] =  0x681c
0003d666      [0x3] =  0x0003
0003d668      [0x4] =  0x6410
0003d66a      [0x5] =  0x000b
0003d66c      [0x6] =  0x3410
0003d66e      [0x7] =  0x000a
0003d670      [0x8] =  0x7210
0003d672      [0x9] =  0x700c
0003d674  }
0003d674  struct UNWIND_INFO data_3d674 = 
0003d674  {
0003d674      uint8_t VersionAndFlag = 0x1
0003d675      uint8_t SizeOfProlog = 0x16
0003d676      uint8_t CountOfUnwindCodes = 0x6
0003d677      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d678  }
0003d678  uint16_t data_3d678[0x6] = 
0003d678  {
0003d678      [0x0] =  0x3416
0003d67a      [0x1] =  0x0008
0003d67c      [0x2] =  0x3216
0003d67e      [0x3] =  0x7012
0003d680      [0x4] =  0x6011
0003d682      [0x5] =  0x5010
0003d684  }
0003d684  struct UNWIND_INFO data_3d684 = 
0003d684  {
0003d684      uint8_t VersionAndFlag = 0x19
0003d685      uint8_t SizeOfProlog = 0x27
0003d686      uint8_t CountOfUnwindCodes = 0x9
0003d687      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d688  }
0003d688  uint16_t data_3d688[0x9] = 
0003d688  {
0003d688      [0x0] =  0x5415
0003d68a      [0x1] =  0x0022
0003d68c      [0x2] =  0x3415
0003d68e      [0x3] =  0x0021
0003d690      [0x4] =  0x0115
0003d692      [0x5] =  0x001c
0003d694      [0x6] =  0xc00e
0003d696      [0x7] =  0x700c
0003d698      [0x8] =  0x600b
0003d69a  }

0003d69a                                                                                00 00                                        ..

0003d69c  uint32_t data_3d69c = 0x2393c

0003d6a0  d0 00 00 00                                                                                      ....

0003d6a4  struct UNWIND_INFO data_3d6a4 = 
0003d6a4  {
0003d6a4      uint8_t VersionAndFlag = 0x1
0003d6a5      uint8_t SizeOfProlog = 0x1b
0003d6a6      uint8_t CountOfUnwindCodes = 0x7
0003d6a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d6a8  }
0003d6a8  uint16_t data_3d6a8[0x7] = 
0003d6a8  {
0003d6a8      [0x0] =  0x641b
0003d6aa      [0x1] =  0x001d
0003d6ac      [0x2] =  0x341b
0003d6ae      [0x3] =  0x001c
0003d6b0      [0x4] =  0x011b
0003d6b2      [0x5] =  0x001a
0003d6b4      [0x6] =  0x7014
0003d6b6  }

0003d6b6                                                                    00 00                                                ..

0003d6b8  struct UNWIND_INFO data_3d6b8 = 
0003d6b8  {
0003d6b8      uint8_t VersionAndFlag = 0x1
0003d6b9      uint8_t SizeOfProlog = 0x1c
0003d6ba      uint8_t CountOfUnwindCodes = 0xb
0003d6bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d6bc  }
0003d6bc  uint16_t data_3d6bc[0xb] = 
0003d6bc  {
0003d6bc      [0x0] =  0x741c
0003d6be      [0x1] =  0x001d
0003d6c0      [0x2] =  0x641c
0003d6c2      [0x3] =  0x001c
0003d6c4      [0x4] =  0x541c
0003d6c6      [0x5] =  0x001b
0003d6c8      [0x6] =  0x341c
0003d6ca      [0x7] =  0x001a
0003d6cc      [0x8] =  0x011c
0003d6ce      [0x9] =  0x0018
0003d6d0      [0xa] =  0xc015
0003d6d2  }

0003d6d2                                                        00 00                                                        ..

0003d6d4  struct UNWIND_INFO data_3d6d4 = 
0003d6d4  {
0003d6d4      uint8_t VersionAndFlag = 0x1
0003d6d5      uint8_t SizeOfProlog = 0x2a
0003d6d6      uint8_t CountOfUnwindCodes = 0xc
0003d6d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d6d8  }
0003d6d8  uint16_t data_3d6d8[0xc] = 
0003d6d8  {
0003d6d8      [0x0] =  0x682a
0003d6da      [0x1] =  0x0004
0003d6dc      [0x2] =  0x3426
0003d6de      [0x3] =  0x0012
0003d6e0      [0x4] =  0x9226
0003d6e2      [0x5] =  0xf022
0003d6e4      [0x6] =  0xe020
0003d6e6      [0x7] =  0xd01e
0003d6e8      [0x8] =  0xc01c
0003d6ea      [0x9] =  0x701a
0003d6ec      [0xa] =  0x6019
0003d6ee      [0xb] =  0x5018
0003d6f0  }
0003d6f0  struct UNWIND_INFO data_3d6f0 = 
0003d6f0  {
0003d6f0      uint8_t VersionAndFlag = 0x1
0003d6f1      uint8_t SizeOfProlog = 0xf
0003d6f2      uint8_t CountOfUnwindCodes = 0x6
0003d6f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d6f4  }
0003d6f4  uint16_t data_3d6f4[0x6] = 
0003d6f4  {
0003d6f4      [0x0] =  0x640f
0003d6f6      [0x1] =  0x0007
0003d6f8      [0x2] =  0x340f
0003d6fa      [0x3] =  0x0006
0003d6fc      [0x4] =  0x320f
0003d6fe      [0x5] =  0x700b
0003d700  }
0003d700  struct UNWIND_INFO data_3d700 = 
0003d700  {
0003d700      uint8_t VersionAndFlag = 0x1
0003d701      uint8_t SizeOfProlog = 0x17
0003d702      uint8_t CountOfUnwindCodes = 0x8
0003d703      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d704  }
0003d704  uint16_t data_3d704[0x8] = 
0003d704  {
0003d704      [0x0] =  0x7817
0003d706      [0x1] =  0x0002
0003d708      [0x2] =  0x680f
0003d70a      [0x3] =  0x0003
0003d70c      [0x4] =  0x340a
0003d70e      [0x5] =  0x000a
0003d710      [0x6] =  0x720a
0003d712      [0x7] =  0x7006
0003d714  }
0003d714  struct UNWIND_INFO data_3d714 = 
0003d714  {
0003d714      uint8_t VersionAndFlag = 0x1
0003d715      uint8_t SizeOfProlog = 0x13
0003d716      uint8_t CountOfUnwindCodes = 0x6
0003d717      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d718  }
0003d718  uint16_t data_3d718[0x6] = 
0003d718  {
0003d718      [0x0] =  0x6413
0003d71a      [0x1] =  0x0013
0003d71c      [0x2] =  0x3413
0003d71e      [0x3] =  0x0012
0003d720      [0x4] =  0xf213
0003d722      [0x5] =  0x700c
0003d724  }
0003d724  struct UNWIND_INFO data_3d724 = 
0003d724  {
0003d724      uint8_t VersionAndFlag = 0x1
0003d725      uint8_t SizeOfProlog = 0x18
0003d726      uint8_t CountOfUnwindCodes = 0xb
0003d727      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d728  }
0003d728  uint16_t data_3d728[0xb] = 
0003d728  {
0003d728      [0x0] =  0x6418
0003d72a      [0x1] =  0x0009
0003d72c      [0x2] =  0x5418
0003d72e      [0x3] =  0x0008
0003d730      [0x4] =  0x3418
0003d732      [0x5] =  0x0006
0003d734      [0x6] =  0xf018
0003d736      [0x7] =  0xe016
0003d738      [0x8] =  0xd014
0003d73a      [0x9] =  0xc012
0003d73c      [0xa] =  0x7010
0003d73e  }

0003d73e                                                                                            00 00                                ..

0003d740  struct UNWIND_INFO data_3d740 = 
0003d740  {
0003d740      uint8_t VersionAndFlag = 0x1
0003d741      uint8_t SizeOfProlog = 0x18
0003d742      uint8_t CountOfUnwindCodes = 0xa
0003d743      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d744  }
0003d744  uint16_t data_3d744[0xa] = 
0003d744  {
0003d744      [0x0] =  0x6418
0003d746      [0x1] =  0x0008
0003d748      [0x2] =  0x5418
0003d74a      [0x3] =  0x0007
0003d74c      [0x4] =  0x3418
0003d74e      [0x5] =  0x0006
0003d750      [0x6] =  0x1218
0003d752      [0x7] =  0xe014
0003d754      [0x8] =  0xd012
0003d756      [0x9] =  0x7010
0003d758  }
0003d758  struct UNWIND_INFO data_3d758 = 
0003d758  {
0003d758      uint8_t VersionAndFlag = 0x1
0003d759      uint8_t SizeOfProlog = 0x27
0003d75a      uint8_t CountOfUnwindCodes = 0x5
0003d75b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d75c  }
0003d75c  uint16_t data_3d75c[0x5] = 
0003d75c  {
0003d75c      [0x0] =  0x7827
0003d75e      [0x1] =  0x0001
0003d760      [0x2] =  0x6814
0003d762      [0x3] =  0x0002
0003d764      [0x4] =  0x6204
0003d766  }

0003d766                    00 00                                                                                ..

0003d768  struct UNWIND_INFO data_3d768 = 
0003d768  {
0003d768      uint8_t VersionAndFlag = 0x1
0003d769      uint8_t SizeOfProlog = 0x3c
0003d76a      uint8_t CountOfUnwindCodes = 0x10
0003d76b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d76c  }
0003d76c  uint16_t data_3d76c[0x10] = 
0003d76c  {
0003d76c      [0x0] =  0xa83c
0003d76e      [0x1] =  0x0000
0003d770      [0x2] =  0x9837
0003d772      [0x3] =  0x0001
0003d774      [0x4] =  0x8832
0003d776      [0x5] =  0x0002
0003d778      [0x6] =  0x781b
0003d77a      [0x7] =  0x0003
0003d77c      [0x8] =  0x6814
0003d77e      [0x9] =  0x0004
0003d780      [0xa] =  0x6410
0003d782      [0xb] =  0x000d
0003d784      [0xc] =  0x3410
0003d786      [0xd] =  0x000c
0003d788      [0xe] =  0x9210
0003d78a      [0xf] =  0x700c
0003d78c  }
0003d78c  struct UNWIND_INFO data_3d78c = 
0003d78c  {
0003d78c      uint8_t VersionAndFlag = 0x1
0003d78d      uint8_t SizeOfProlog = 0x32
0003d78e      uint8_t CountOfUnwindCodes = 0xb
0003d78f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d790  }
0003d790  uint16_t data_3d790[0xb] = 
0003d790  {
0003d790      [0x0] =  0xa832
0003d792      [0x1] =  0x0000
0003d794      [0x2] =  0x981c
0003d796      [0x3] =  0x0001
0003d798      [0x4] =  0x8817
0003d79a      [0x5] =  0x0002
0003d79c      [0x6] =  0x7812
0003d79e      [0x7] =  0x0003
0003d7a0      [0x8] =  0x680b
0003d7a2      [0x9] =  0x0004
0003d7a4      [0xa] =  0xa207
0003d7a6  }

0003d7a6                    00 00                                                                                ..

0003d7a8  struct UNWIND_INFO data_3d7a8 = 
0003d7a8  {
0003d7a8      uint8_t VersionAndFlag = 0x1
0003d7a9      uint8_t SizeOfProlog = 0x21
0003d7aa      uint8_t CountOfUnwindCodes = 0xb
0003d7ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d7ac  }
0003d7ac  uint16_t data_3d7ac[0xb] = 
0003d7ac  {
0003d7ac      [0x0] =  0x3421
0003d7ae      [0x1] =  0x0020
0003d7b0      [0x2] =  0x0121
0003d7b2      [0x3] =  0x0016
0003d7b4      [0x4] =  0xf01a
0003d7b6      [0x5] =  0xe018
0003d7b8      [0x6] =  0xd016
0003d7ba      [0x7] =  0xc014
0003d7bc      [0x8] =  0x7012
0003d7be      [0x9] =  0x6011
0003d7c0      [0xa] =  0x5010
0003d7c2  }

0003d7c2        00 00                                                                                        ..

0003d7c4  struct UNWIND_INFO data_3d7c4 = 
0003d7c4  {
0003d7c4      uint8_t VersionAndFlag = 0x1
0003d7c5      uint8_t SizeOfProlog = 0x1f
0003d7c6      uint8_t CountOfUnwindCodes = 0xa
0003d7c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d7c8  }
0003d7c8  uint16_t data_3d7c8[0xa] = 
0003d7c8  {
0003d7c8      [0x0] =  0x541f
0003d7ca      [0x1] =  0x000d
0003d7cc      [0x2] =  0x341f
0003d7ce      [0x3] =  0x000a
0003d7d0      [0x4] =  0x321f
0003d7d2      [0x5] =  0xe01b
0003d7d4      [0x6] =  0xd019
0003d7d6      [0x7] =  0xc017
0003d7d8      [0x8] =  0x7015
0003d7da      [0x9] =  0x6014
0003d7dc  }
0003d7dc  struct UNWIND_INFO data_3d7dc = 
0003d7dc  {
0003d7dc      uint8_t VersionAndFlag = 0x1
0003d7dd      uint8_t SizeOfProlog = 0x2b
0003d7de      uint8_t CountOfUnwindCodes = 0x3
0003d7df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d7e0  }
0003d7e0  uint16_t data_3d7e0[0x3] = 
0003d7e0  {
0003d7e0      [0x0] =  0x682b
0003d7e2      [0x1] =  0x0000
0003d7e4      [0x2] =  0x2217
0003d7e6  }

0003d7e6                    00 00                                                                                ..

0003d7e8  struct UNWIND_INFO data_3d7e8 = 
0003d7e8  {
0003d7e8      uint8_t VersionAndFlag = 0x1
0003d7e9      uint8_t SizeOfProlog = 0xf
0003d7ea      uint8_t CountOfUnwindCodes = 0x6
0003d7eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d7ec  }
0003d7ec  uint16_t data_3d7ec[0x6] = 
0003d7ec  {
0003d7ec      [0x0] =  0x740f
0003d7ee      [0x1] =  0x0003
0003d7f0      [0x2] =  0x640a
0003d7f2      [0x3] =  0x0002
0003d7f4      [0x4] =  0x3405
0003d7f6      [0x5] =  0x0001
0003d7f8  }
0003d7f8  struct UNWIND_INFO data_3d7f8 = 
0003d7f8  {
0003d7f8      uint8_t VersionAndFlag = 0x1
0003d7f9      uint8_t SizeOfProlog = 0x14
0003d7fa      uint8_t CountOfUnwindCodes = 0x8
0003d7fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d7fc  }
0003d7fc  uint16_t data_3d7fc[0x8] = 
0003d7fc  {
0003d7fc      [0x0] =  0x6414
0003d7fe      [0x1] =  0x0008
0003d800      [0x2] =  0x5414
0003d802      [0x3] =  0x0007
0003d804      [0x4] =  0x3414
0003d806      [0x5] =  0x0006
0003d808      [0x6] =  0x3214
0003d80a      [0x7] =  0x7010
0003d80c  }
0003d80c  struct UNWIND_INFO data_3d80c = 
0003d80c  {
0003d80c      uint8_t VersionAndFlag = 0x1
0003d80d      uint8_t SizeOfProlog = 0x1f
0003d80e      uint8_t CountOfUnwindCodes = 0xd
0003d80f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d810  }
0003d810  uint16_t data_3d810[0xd] = 
0003d810  {
0003d810      [0x0] =  0x641f
0003d812      [0x1] =  0x0054
0003d814      [0x2] =  0x541f
0003d816      [0x3] =  0x0053
0003d818      [0x4] =  0x341f
0003d81a      [0x5] =  0x0052
0003d81c      [0x6] =  0x011f
0003d81e      [0x7] =  0x004c
0003d820      [0x8] =  0xf018
0003d822      [0x9] =  0xe016
0003d824      [0xa] =  0xd014
0003d826      [0xb] =  0xc012
0003d828      [0xc] =  0x7010
0003d82a  }

0003d82a                                00 00                                                                        ..

0003d82c  struct UNWIND_INFO data_3d82c = 
0003d82c  {
0003d82c      uint8_t VersionAndFlag = 0x1
0003d82d      uint8_t SizeOfProlog = 0x1c
0003d82e      uint8_t CountOfUnwindCodes = 0x5
0003d82f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d830  }
0003d830  uint16_t data_3d830[0x5] = 
0003d830  {
0003d830      [0x0] =  0x881c
0003d832      [0x1] =  0x0000
0003d834      [0x2] =  0x6814
0003d836      [0x3] =  0x0001
0003d838      [0x4] =  0x4204
0003d83a  }

0003d83a                                                                                00 00                                        ..

0003d83c  struct UNWIND_INFO data_3d83c = 
0003d83c  {
0003d83c      uint8_t VersionAndFlag = 0x1
0003d83d      uint8_t SizeOfProlog = 0x13
0003d83e      uint8_t CountOfUnwindCodes = 0x6
0003d83f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d840  }
0003d840  uint16_t data_3d840[0x6] = 
0003d840  {
0003d840      [0x0] =  0x740f
0003d842      [0x1] =  0x0004
0003d844      [0x2] =  0x640b
0003d846      [0x3] =  0x0003
0003d848      [0x4] =  0x3407
0003d84a      [0x5] =  0x0002
0003d84c  }
0003d84c  struct UNWIND_INFO data_3d84c = 
0003d84c  {
0003d84c      uint8_t VersionAndFlag = 0x1
0003d84d      uint8_t SizeOfProlog = 0xc
0003d84e      uint8_t CountOfUnwindCodes = 0x4
0003d84f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d850  }
0003d850  uint16_t data_3d850[0x4] = 
0003d850  {
0003d850      [0x0] =  0x340c
0003d852      [0x1] =  0x0010
0003d854      [0x2] =  0xd20c
0003d856      [0x3] =  0x7008
0003d858  }
0003d858  struct UNWIND_INFO data_3d858 = 
0003d858  {
0003d858      uint8_t VersionAndFlag = 0x19
0003d859      uint8_t SizeOfProlog = 0x2a
0003d85a      uint8_t CountOfUnwindCodes = 0xa
0003d85b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d85c  }
0003d85c  uint16_t data_3d85c[0xa] = 
0003d85c  {
0003d85c      [0x0] =  0x641b
0003d85e      [0x1] =  0x0017
0003d860      [0x2] =  0x541b
0003d862      [0x3] =  0x0015
0003d864      [0x4] =  0x341b
0003d866      [0x5] =  0x0014
0003d868      [0x6] =  0xf21b
0003d86a      [0x7] =  0xd014
0003d86c      [0x8] =  0xc012
0003d86e      [0x9] =  0x7010
0003d870  }
0003d870  uint32_t data_3d870 = 0x2393c

0003d874                                                              78 00 00 00                                              x...

0003d878  struct UNWIND_INFO data_3d878 = 
0003d878  {
0003d878      uint8_t VersionAndFlag = 0x1
0003d879      uint8_t SizeOfProlog = 0x13
0003d87a      uint8_t CountOfUnwindCodes = 0x9
0003d87b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d87c  }
0003d87c  uint16_t data_3d87c[0x9] = 
0003d87c  {
0003d87c      [0x0] =  0x3413
0003d87e      [0x1] =  0x001b
0003d880      [0x2] =  0x0113
0003d882      [0x3] =  0x0014
0003d884      [0x4] =  0xd00c
0003d886      [0x5] =  0xc00a
0003d888      [0x6] =  0x7008
0003d88a      [0x7] =  0x6007
0003d88c      [0x8] =  0x5006
0003d88e  }

0003d88e                                            00 00                                                                ..

0003d890  struct UNWIND_INFO data_3d890 = 
0003d890  {
0003d890      uint8_t VersionAndFlag = 0x19
0003d891      uint8_t SizeOfProlog = 0x2b
0003d892      uint8_t CountOfUnwindCodes = 0xc
0003d893      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d894  }
0003d894  uint16_t data_3d894[0xc] = 
0003d894  {
0003d894      [0x0] =  0x641c
0003d896      [0x1] =  0x000f
0003d898      [0x2] =  0x541c
0003d89a      [0x3] =  0x000e
0003d89c      [0x4] =  0x341c
0003d89e      [0x5] =  0x000d
0003d8a0      [0x6] =  0x521c
0003d8a2      [0x7] =  0xf018
0003d8a4      [0x8] =  0xe016
0003d8a6      [0x9] =  0xd014
0003d8a8      [0xa] =  0xc012
0003d8aa      [0xb] =  0x7010
0003d8ac  }
0003d8ac  uint32_t data_3d8ac = 0x2393c

0003d8b0                                                  20 00 00 00                                                       ...

0003d8b4  struct UNWIND_INFO data_3d8b4 = 
0003d8b4  {
0003d8b4      uint8_t VersionAndFlag = 0x1
0003d8b5      uint8_t SizeOfProlog = 0x1d
0003d8b6      uint8_t CountOfUnwindCodes = 0xc
0003d8b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d8b8  }
0003d8b8  uint16_t data_3d8b8[0xc] = 
0003d8b8  {
0003d8b8      [0x0] =  0x741d
0003d8ba      [0x1] =  0x000b
0003d8bc      [0x2] =  0x641d
0003d8be      [0x3] =  0x000a
0003d8c0      [0x4] =  0x541d
0003d8c2      [0x5] =  0x0009
0003d8c4      [0x6] =  0x341d
0003d8c6      [0x7] =  0x0008
0003d8c8      [0x8] =  0x321d
0003d8ca      [0x9] =  0xe019
0003d8cc      [0xa] =  0xd017
0003d8ce      [0xb] =  0xc015
0003d8d0  }
0003d8d0  struct UNWIND_INFO data_3d8d0 = 
0003d8d0  {
0003d8d0      uint8_t VersionAndFlag = 0x1
0003d8d1      uint8_t SizeOfProlog = 0x5
0003d8d2      uint8_t CountOfUnwindCodes = 0x2
0003d8d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d8d4  }
0003d8d4  uint16_t data_3d8d4[0x2] = 
0003d8d4  {
0003d8d4      [0x0] =  0x3405
0003d8d6      [0x1] =  0x0001
0003d8d8  }
0003d8d8  struct UNWIND_INFO data_3d8d8 = 
0003d8d8  {
0003d8d8      uint8_t VersionAndFlag = 0x1
0003d8d9      uint8_t SizeOfProlog = 0x1c
0003d8da      uint8_t CountOfUnwindCodes = 0xc
0003d8db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d8dc  }
0003d8dc  uint16_t data_3d8dc[0xc] = 
0003d8dc  {
0003d8dc      [0x0] =  0x641c
0003d8de      [0x1] =  0x000f
0003d8e0      [0x2] =  0x541c
0003d8e2      [0x3] =  0x000e
0003d8e4      [0x4] =  0x341c
0003d8e6      [0x5] =  0x000c
0003d8e8      [0x6] =  0x521c
0003d8ea      [0x7] =  0xf018
0003d8ec      [0x8] =  0xe016
0003d8ee      [0x9] =  0xd014
0003d8f0      [0xa] =  0xc012
0003d8f2      [0xb] =  0x7010
0003d8f4  }
0003d8f4  struct UNWIND_INFO data_3d8f4 = 
0003d8f4  {
0003d8f4      uint8_t VersionAndFlag = 0x1
0003d8f5      uint8_t SizeOfProlog = 0x19
0003d8f6      uint8_t CountOfUnwindCodes = 0xb
0003d8f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d8f8  }
0003d8f8  uint16_t data_3d8f8[0xb] = 
0003d8f8  {
0003d8f8      [0x0] =  0x7419
0003d8fa      [0x1] =  0x0007
0003d8fc      [0x2] =  0x6419
0003d8fe      [0x3] =  0x0006
0003d900      [0x4] =  0x5419
0003d902      [0x5] =  0x0005
0003d904      [0x6] =  0x3419
0003d906      [0x7] =  0x0004
0003d908      [0x8] =  0xe019
0003d90a      [0x9] =  0xd017
0003d90c      [0xa] =  0xc015
0003d90e  }

0003d90e                                            00 00                                                                ..

0003d910  struct UNWIND_INFO data_3d910 = 
0003d910  {
0003d910      uint8_t VersionAndFlag = 0x1
0003d911      uint8_t SizeOfProlog = 0x33
0003d912      uint8_t CountOfUnwindCodes = 0xc
0003d913      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d914  }
0003d914  uint16_t data_3d914[0xc] = 
0003d914  {
0003d914      [0x0] =  0x7833
0003d916      [0x1] =  0x0000
0003d918      [0x2] =  0x5417
0003d91a      [0x3] =  0x000a
0003d91c      [0x4] =  0x3417
0003d91e      [0x5] =  0x0009
0003d920      [0x6] =  0x1217
0003d922      [0x7] =  0xf013
0003d924      [0x8] =  0xe011
0003d926      [0x9] =  0xd00f
0003d928      [0xa] =  0xc00d
0003d92a      [0xb] =  0x700b
0003d92c  }
0003d92c  struct UNWIND_INFO data_3d92c = 
0003d92c  {
0003d92c      uint8_t VersionAndFlag = 0x1
0003d92d      uint8_t SizeOfProlog = 0xe
0003d92e      uint8_t CountOfUnwindCodes = 0x1
0003d92f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d930  }
0003d930  uint16_t data_3d930[0x1] = 
0003d930  {
0003d930      [0x0] =  0x220e
0003d932  }

0003d932                                                        00 00                                                        ..

0003d934  struct UNWIND_INFO data_3d934 = 
0003d934  {
0003d934      uint8_t VersionAndFlag = 0x1
0003d935      uint8_t SizeOfProlog = 0x3c
0003d936      uint8_t CountOfUnwindCodes = 0x14
0003d937      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d938  }
0003d938  uint16_t data_3d938[0x14] = 
0003d938  {
0003d938      [0x00] =  0x983c
0003d93a      [0x01] =  0x0000
0003d93c      [0x02] =  0x8837
0003d93e      [0x03] =  0x0001
0003d940      [0x04] =  0x7828
0003d942      [0x05] =  0x0002
0003d944      [0x06] =  0x6824
0003d946      [0x07] =  0x0003
0003d948      [0x08] =  0x641c
0003d94a      [0x09] =  0x0010
0003d94c      [0x0a] =  0x541c
0003d94e      [0x0b] =  0x000f
0003d950      [0x0c] =  0x341c
0003d952      [0x0d] =  0x000e
0003d954      [0x0e] =  0x721c
0003d956      [0x0f] =  0xf018
0003d958      [0x10] =  0xe016
0003d95a      [0x11] =  0xd014
0003d95c      [0x12] =  0xc012
0003d95e      [0x13] =  0x7010
0003d960  }
0003d960  struct UNWIND_INFO data_3d960 = 
0003d960  {
0003d960      uint8_t VersionAndFlag = 0x19
0003d961      uint8_t SizeOfProlog = 0x2b
0003d962      uint8_t CountOfUnwindCodes = 0xc
0003d963      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d964  }
0003d964  uint16_t data_3d964[0xc] = 
0003d964  {
0003d964      [0x0] =  0x641c
0003d966      [0x1] =  0x0012
0003d968      [0x2] =  0x541c
0003d96a      [0x3] =  0x0011
0003d96c      [0x4] =  0x341c
0003d96e      [0x5] =  0x0010
0003d970      [0x6] =  0x921c
0003d972      [0x7] =  0xf018
0003d974      [0x8] =  0xe016
0003d976      [0x9] =  0xd014
0003d978      [0xa] =  0xc012
0003d97a      [0xb] =  0x7010
0003d97c  }
0003d97c  uint32_t data_3d97c = 0x2393c

0003d980  48 00 00 00                                                                                      H...

0003d984  struct UNWIND_INFO data_3d984 = 
0003d984  {
0003d984      uint8_t VersionAndFlag = 0x1
0003d985      uint8_t SizeOfProlog = 0x13
0003d986      uint8_t CountOfUnwindCodes = 0x8
0003d987      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d988  }
0003d988  uint16_t data_3d988[0x8] = 
0003d988  {
0003d988      [0x0] =  0x7413
0003d98a      [0x1] =  0x0004
0003d98c      [0x2] =  0x640f
0003d98e      [0x3] =  0x0003
0003d990      [0x4] =  0x540b
0003d992      [0x5] =  0x0002
0003d994      [0x6] =  0x3407
0003d996      [0x7] =  0x0001
0003d998  }
0003d998  struct UNWIND_INFO data_3d998 = 
0003d998  {
0003d998      uint8_t VersionAndFlag = 0x1
0003d999      uint8_t SizeOfProlog = 0x10
0003d99a      uint8_t CountOfUnwindCodes = 0x3
0003d99b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d99c  }
0003d99c  uint16_t data_3d99c[0x3] = 
0003d99c  {
0003d99c      [0x0] =  0x6810
0003d99e      [0x1] =  0x0000
0003d9a0      [0x2] =  0x2209
0003d9a2  }

0003d9a2        00 00                                                                                        ..

0003d9a4  struct UNWIND_INFO data_3d9a4 = 
0003d9a4  {
0003d9a4      uint8_t VersionAndFlag = 0x1
0003d9a5      uint8_t SizeOfProlog = 0x85
0003d9a6      uint8_t CountOfUnwindCodes = 0x16
0003d9a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d9a8  }
0003d9a8  uint16_t data_3d9a8[0x16] = 
0003d9a8  {
0003d9a8      [0x00] =  0xf885
0003d9aa      [0x01] =  0x0000
0003d9ac      [0x02] =  0xe87d
0003d9ae      [0x03] =  0x0001
0003d9b0      [0x04] =  0xd877
0003d9b2      [0x05] =  0x0002
0003d9b4      [0x06] =  0xc871
0003d9b6      [0x07] =  0x0003
0003d9b8      [0x08] =  0xb860
0003d9ba      [0x09] =  0x0004
0003d9bc      [0x0a] =  0xa85b
0003d9be      [0x0b] =  0x0005
0003d9c0      [0x0c] =  0x9856
0003d9c2      [0x0d] =  0x0006
0003d9c4      [0x0e] =  0x883d
0003d9c6      [0x0f] =  0x0007
0003d9c8      [0x10] =  0x7838
0003d9ca      [0x11] =  0x0008
0003d9cc      [0x12] =  0x6833
0003d9ce      [0x13] =  0x0009
0003d9d0      [0x14] =  0x011c
0003d9d2      [0x15] =  0x0015
0003d9d4  }
0003d9d4  struct UNWIND_INFO data_3d9d4 = 
0003d9d4  {
0003d9d4      uint8_t VersionAndFlag = 0x1
0003d9d5      uint8_t SizeOfProlog = 0x1c
0003d9d6      uint8_t CountOfUnwindCodes = 0x3
0003d9d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d9d8  }
0003d9d8  uint16_t data_3d9d8[0x3] = 
0003d9d8  {
0003d9d8      [0x0] =  0x681c
0003d9da      [0x1] =  0x0002
0003d9dc      [0x2] =  0x6204
0003d9de  }

0003d9de                                                                                            00 00                                ..

0003d9e0  struct UNWIND_INFO data_3d9e0 = 
0003d9e0  {
0003d9e0      uint8_t VersionAndFlag = 0x1
0003d9e1      uint8_t SizeOfProlog = 0xa
0003d9e2      uint8_t CountOfUnwindCodes = 0x4
0003d9e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d9e4  }
0003d9e4  uint16_t data_3d9e4[0x4] = 
0003d9e4  {
0003d9e4      [0x0] =  0x340a
0003d9e6      [0x1] =  0x0009
0003d9e8      [0x2] =  0x520a
0003d9ea      [0x3] =  0x7006
0003d9ec  }
0003d9ec  struct UNWIND_INFO data_3d9ec = 
0003d9ec  {
0003d9ec      uint8_t VersionAndFlag = 0x1
0003d9ed      uint8_t SizeOfProlog = 0x11
0003d9ee      uint8_t CountOfUnwindCodes = 0x4
0003d9ef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d9f0  }
0003d9f0  uint16_t data_3d9f0[0x4] = 
0003d9f0  {
0003d9f0      [0x0] =  0x3211
0003d9f2      [0x1] =  0x700d
0003d9f4      [0x2] =  0x600c
0003d9f6      [0x3] =  0x300b
0003d9f8  }
0003d9f8  struct UNWIND_INFO data_3d9f8 = 
0003d9f8  {
0003d9f8      uint8_t VersionAndFlag = 0x1
0003d9f9      uint8_t SizeOfProlog = 0x4
0003d9fa      uint8_t CountOfUnwindCodes = 0x1
0003d9fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003d9fc  }
0003d9fc  uint16_t data_3d9fc[0x1] = 
0003d9fc  {
0003d9fc      [0x0] =  0x2204
0003d9fe  }

0003d9fe                                                                                            00 00                                ..

0003da00  struct UNWIND_INFO data_3da00 = 
0003da00  {
0003da00      uint8_t VersionAndFlag = 0x1
0003da01      uint8_t SizeOfProlog = 0xa
0003da02      uint8_t CountOfUnwindCodes = 0x2
0003da03      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da04  }
0003da04  uint16_t data_3da04[0x2] = 
0003da04  {
0003da04      [0x0] =  0x010a
0003da06      [0x1] =  0x0011
0003da08  }
0003da08  struct UNWIND_INFO data_3da08 = 
0003da08  {
0003da08      uint8_t VersionAndFlag = 0x1
0003da09      uint8_t SizeOfProlog = 0x13
0003da0a      uint8_t CountOfUnwindCodes = 0x7
0003da0b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da0c  }
0003da0c  uint16_t data_3da0c[0x7] = 
0003da0c  {
0003da0c      [0x0] =  0x6413
0003da0e      [0x1] =  0x0041
0003da10      [0x2] =  0x3413
0003da12      [0x3] =  0x0040
0003da14      [0x4] =  0x0113
0003da16      [0x5] =  0x003e
0003da18      [0x6] =  0x700c
0003da1a  }

0003da1a                                                                                00 00                                        ..

0003da1c  struct UNWIND_INFO data_3da1c = 
0003da1c  {
0003da1c      uint8_t VersionAndFlag = 0x1
0003da1d      uint8_t SizeOfProlog = 0x64
0003da1e      uint8_t CountOfUnwindCodes = 0x14
0003da1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da20  }
0003da20  uint16_t data_3da20[0x14] = 
0003da20  {
0003da20      [0x00] =  0xf864
0003da22      [0x01] =  0x0000
0003da24      [0x02] =  0xe85f
0003da26      [0x03] =  0x0001
0003da28      [0x04] =  0xd84d
0003da2a      [0x05] =  0x0002
0003da2c      [0x06] =  0xc848
0003da2e      [0x07] =  0x0003
0003da30      [0x08] =  0xa843
0003da32      [0x09] =  0x0004
0003da34      [0x0a] =  0x982b
0003da36      [0x0b] =  0x0005
0003da38      [0x0c] =  0x8826
0003da3a      [0x0d] =  0x0006
0003da3c      [0x0e] =  0x7821
0003da3e      [0x0f] =  0x0007
0003da40      [0x10] =  0x681d
0003da42      [0x11] =  0x0008
0003da44      [0x12] =  0x010e
0003da46      [0x13] =  0x0013
0003da48  }
0003da48  struct UNWIND_INFO data_3da48 = 
0003da48  {
0003da48      uint8_t VersionAndFlag = 0x1
0003da49      uint8_t SizeOfProlog = 0x12
0003da4a      uint8_t CountOfUnwindCodes = 0x5
0003da4b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da4c  }
0003da4c  uint16_t data_3da4c[0x5] = 
0003da4c  {
0003da4c      [0x0] =  0x4212
0003da4e      [0x1] =  0x700e
0003da50      [0x2] =  0x600d
0003da52      [0x3] =  0x500c
0003da54      [0x4] =  0x300b
0003da56  }

0003da56                                                                    00 00                                                ..

0003da58  struct UNWIND_INFO data_3da58 = 
0003da58  {
0003da58      uint8_t VersionAndFlag = 0x1
0003da59      uint8_t SizeOfProlog = 0x13
0003da5a      uint8_t CountOfUnwindCodes = 0x7
0003da5b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da5c  }
0003da5c  uint16_t data_3da5c[0x7] = 
0003da5c  {
0003da5c      [0x0] =  0x6413
0003da5e      [0x1] =  0x0015
0003da60      [0x2] =  0x3413
0003da62      [0x3] =  0x0014
0003da64      [0x4] =  0x0113
0003da66      [0x5] =  0x0012
0003da68      [0x6] =  0x700c
0003da6a  }

0003da6a                                00 00                                                                        ..

0003da6c  struct UNWIND_INFO data_3da6c = 
0003da6c  {
0003da6c      uint8_t VersionAndFlag = 0x19
0003da6d      uint8_t SizeOfProlog = 0x29
0003da6e      uint8_t CountOfUnwindCodes = 0x9
0003da6f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da70  }
0003da70  uint16_t data_3da70[0x9] = 
0003da70  {
0003da70      [0x0] =  0x6417
0003da72      [0x1] =  0x0021
0003da74      [0x2] =  0x5417
0003da76      [0x3] =  0x0020
0003da78      [0x4] =  0x3417
0003da7a      [0x5] =  0x001f
0003da7c      [0x6] =  0x0117
0003da7e      [0x7] =  0x001c
0003da80      [0x8] =  0x7010
0003da82  }

0003da82        00 00                                                                                        ..

0003da84  uint32_t data_3da84 = 0x2393c

0003da88                          d8 00 00 00                                                                      ....

0003da8c  struct UNWIND_INFO data_3da8c = 
0003da8c  {
0003da8c      uint8_t VersionAndFlag = 0x19
0003da8d      uint8_t SizeOfProlog = 0x25
0003da8e      uint8_t CountOfUnwindCodes = 0x7
0003da8f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003da90  }
0003da90  uint16_t data_3da90[0x7] = 
0003da90  {
0003da90      [0x0] =  0x6413
0003da92      [0x1] =  0x001e
0003da94      [0x2] =  0x3413
0003da96      [0x3] =  0x001c
0003da98      [0x4] =  0x0113
0003da9a      [0x5] =  0x001a
0003da9c      [0x6] =  0x700c
0003da9e  }

0003da9e                                                                                            00 00                                ..

0003daa0  uint32_t data_3daa0 = 0x2393c

0003daa4              c8 00 00 00                                                                              ....

0003daa8  struct UNWIND_INFO data_3daa8 = 
0003daa8  {
0003daa8      uint8_t VersionAndFlag = 0x19
0003daa9      uint8_t SizeOfProlog = 0x25
0003daaa      uint8_t CountOfUnwindCodes = 0x7
0003daab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003daac  }
0003daac  uint16_t data_3daac[0x7] = 
0003daac  {
0003daac      [0x0] =  0x6413
0003daae      [0x1] =  0x001e
0003dab0      [0x2] =  0x3413
0003dab2      [0x3] =  0x001d
0003dab4      [0x4] =  0x0113
0003dab6      [0x5] =  0x001a
0003dab8      [0x6] =  0x700c
0003daba  }

0003daba                                                                                00 00                                        ..

0003dabc  uint32_t data_3dabc = 0x2393c

0003dac0  c8 00 00 00                                                                                      ....

0003dac4  struct UNWIND_INFO data_3dac4 = 
0003dac4  {
0003dac4      uint8_t VersionAndFlag = 0x1
0003dac5      uint8_t SizeOfProlog = 0x19
0003dac6      uint8_t CountOfUnwindCodes = 0xa
0003dac7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dac8  }
0003dac8  uint16_t data_3dac8[0xa] = 
0003dac8  {
0003dac8      [0x0] =  0x7419
0003daca      [0x1] =  0x0009
0003dacc      [0x2] =  0x6419
0003dace      [0x3] =  0x0008
0003dad0      [0x4] =  0x5419
0003dad2      [0x5] =  0x0007
0003dad4      [0x6] =  0x3419
0003dad6      [0x7] =  0x0006
0003dad8      [0x8] =  0x3219
0003dada      [0x9] =  0xd015
0003dadc  }
0003dadc  struct UNWIND_INFO data_3dadc = 
0003dadc  {
0003dadc      uint8_t VersionAndFlag = 0x19
0003dadd      uint8_t SizeOfProlog = 0x18
0003dade      uint8_t CountOfUnwindCodes = 0x2
0003dadf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dae0  }
0003dae0  uint16_t data_3dae0[0x2] = 
0003dae0  {
0003dae0      [0x0] =  0xf209
0003dae2      [0x1] =  0x3002
0003dae4  }
0003dae4  uint32_t data_3dae4 = 0x2393c

0003dae8                          70 00 00 00                                                                      p...

0003daec  struct UNWIND_INFO data_3daec = 
0003daec  {
0003daec      uint8_t VersionAndFlag = 0x1
0003daed      uint8_t SizeOfProlog = 0x10
0003daee      uint8_t CountOfUnwindCodes = 0x6
0003daef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003daf0  }
0003daf0  uint16_t data_3daf0[0x6] = 
0003daf0  {
0003daf0      [0x0] =  0x6410
0003daf2      [0x1] =  0x000a
0003daf4      [0x2] =  0x3410
0003daf6      [0x3] =  0x0009
0003daf8      [0x4] =  0x5210
0003dafa      [0x5] =  0x700c
0003dafc  }
0003dafc  struct UNWIND_INFO data_3dafc = 
0003dafc  {
0003dafc      uint8_t VersionAndFlag = 0x1
0003dafd      uint8_t SizeOfProlog = 0x45
0003dafe      uint8_t CountOfUnwindCodes = 0x10
0003daff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003db00  }
0003db00  uint16_t data_3db00[0x10] = 
0003db00  {
0003db00      [0x0] =  0x7845
0003db02      [0x1] =  0x0006
0003db04      [0x2] =  0x6832
0003db06      [0x3] =  0x0007
0003db08      [0x4] =  0x6423
0003db0a      [0x5] =  0x0019
0003db0c      [0x6] =  0x5423
0003db0e      [0x7] =  0x0017
0003db10      [0x8] =  0x3423
0003db12      [0x9] =  0x0016
0003db14      [0xa] =  0xf223
0003db16      [0xb] =  0xf01c
0003db18      [0xc] =  0xe01a
0003db1a      [0xd] =  0xd018
0003db1c      [0xe] =  0xc016
0003db1e      [0xf] =  0x7014
0003db20  }
0003db20  struct UNWIND_INFO data_3db20 = 
0003db20  {
0003db20      uint8_t VersionAndFlag = 0x1
0003db21      uint8_t SizeOfProlog = 0x12
0003db22      uint8_t CountOfUnwindCodes = 0x8
0003db23      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003db24  }
0003db24  uint16_t data_3db24[0x8] = 
0003db24  {
0003db24      [0x0] =  0x5412
0003db26      [0x1] =  0x000a
0003db28      [0x2] =  0x3412
0003db2a      [0x3] =  0x0008
0003db2c      [0x4] =  0x3212
0003db2e      [0x5] =  0xc00e
0003db30      [0x6] =  0x700c
0003db32      [0x7] =  0x600b
0003db34  }
0003db34  struct UNWIND_INFO data_3db34 = 
0003db34  {
0003db34      uint8_t VersionAndFlag = 0x1
0003db35      uint8_t SizeOfProlog = 0x6b
0003db36      uint8_t CountOfUnwindCodes = 0x1f
0003db37      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003db38  }
0003db38  uint16_t data_3db38[0x1f] = 
0003db38  {
0003db38      [0x00] =  0xf86b
0003db3a      [0x01] =  0x000c
0003db3c      [0x02] =  0xe863
0003db3e      [0x03] =  0x000d
0003db40      [0x04] =  0xd85b
0003db42      [0x05] =  0x000e
0003db44      [0x06] =  0xc853
0003db46      [0x07] =  0x000f
0003db48      [0x08] =  0xb847
0003db4a      [0x09] =  0x0010
0003db4c      [0x0a] =  0xa842
0003db4e      [0x0b] =  0x0011
0003db50      [0x0c] =  0x983d
0003db52      [0x0d] =  0x0012
0003db54      [0x0e] =  0x8828
0003db56      [0x0f] =  0x0013
0003db58      [0x10] =  0x7823
0003db5a      [0x11] =  0x0014
0003db5c      [0x12] =  0x681f
0003db5e      [0x13] =  0x0015
0003db60      [0x14] =  0x641b
0003db62      [0x15] =  0x0032
0003db64      [0x16] =  0x541b
0003db66      [0x17] =  0x0031
0003db68      [0x18] =  0x341b
0003db6a      [0x19] =  0x0030
0003db6c      [0x1a] =  0x011b
0003db6e      [0x1b] =  0x002c
0003db70      [0x1c] =  0xd014
0003db72      [0x1d] =  0xc012
0003db74      [0x1e] =  0x7010
0003db76  }

0003db76                                                                    00 00                                                ..

0003db78  struct UNWIND_INFO data_3db78 = 
0003db78  {
0003db78      uint8_t VersionAndFlag = 0x1
0003db79      uint8_t SizeOfProlog = 0x2e
0003db7a      uint8_t CountOfUnwindCodes = 0x9
0003db7b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003db7c  }
0003db7c  uint16_t data_3db7c[0x9] = 
0003db7c  {
0003db7c      [0x0] =  0x982e
0003db7e      [0x1] =  0x0003
0003db80      [0x2] =  0x8829
0003db82      [0x3] =  0x0004
0003db84      [0x4] =  0x7824
0003db86      [0x5] =  0x0005
0003db88      [0x6] =  0x6813
0003db8a      [0x7] =  0x0006
0003db8c      [0x8] =  0xe207
0003db8e  }

0003db8e                                            00 00                                                                ..

0003db90  struct UNWIND_INFO data_3db90 = 
0003db90  {
0003db90      uint8_t VersionAndFlag = 0x1
0003db91      uint8_t SizeOfProlog = 0x3e
0003db92      uint8_t CountOfUnwindCodes = 0xc
0003db93      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003db94  }
0003db94  uint16_t data_3db94[0xc] = 
0003db94  {
0003db94      [0x0] =  0xa83e
0003db96      [0x1] =  0x0003
0003db98      [0x2] =  0x9839
0003db9a      [0x3] =  0x0004
0003db9c      [0x4] =  0x8826
0003db9e      [0x5] =  0x0005
0003dba0      [0x6] =  0x7817
0003dba2      [0x7] =  0x0006
0003dba4      [0x8] =  0x6813
0003dba6      [0x9] =  0x0007
0003dba8      [0xa] =  0xf20f
0003dbaa      [0xb] =  0x3008
0003dbac  }
0003dbac  struct UNWIND_INFO data_3dbac = 
0003dbac  {
0003dbac      uint8_t VersionAndFlag = 0x1
0003dbad      uint8_t SizeOfProlog = 0xa
0003dbae      uint8_t CountOfUnwindCodes = 0x4
0003dbaf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dbb0  }
0003dbb0  uint16_t data_3dbb0[0x4] = 
0003dbb0  {
0003dbb0      [0x0] =  0x340a
0003dbb2      [0x1] =  0x000a
0003dbb4      [0x2] =  0x720a
0003dbb6      [0x3] =  0x7006
0003dbb8  }
0003dbb8  struct UNWIND_INFO data_3dbb8 = 
0003dbb8  {
0003dbb8      uint8_t VersionAndFlag = 0x1
0003dbb9      uint8_t SizeOfProlog = 0x58
0003dbba      uint8_t CountOfUnwindCodes = 0x14
0003dbbb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dbbc  }
0003dbbc  uint16_t data_3dbbc[0x14] = 
0003dbbc  {
0003dbbc      [0x00] =  0xc858
0003dbbe      [0x01] =  0x000d
0003dbc0      [0x02] =  0xa850
0003dbc2      [0x03] =  0x000e
0003dbc4      [0x04] =  0x8848
0003dbc6      [0x05] =  0x000f
0003dbc8      [0x06] =  0x7832
0003dbca      [0x07] =  0x0010
0003dbcc      [0x08] =  0x682e
0003dbce      [0x09] =  0x0011
0003dbd0      [0x0a] =  0x0122
0003dbd2      [0x0b] =  0x0025
0003dbd4      [0x0c] =  0xf01b
0003dbd6      [0x0d] =  0xe019
0003dbd8      [0x0e] =  0xd017
0003dbda      [0x0f] =  0xc015
0003dbdc      [0x10] =  0x7013
0003dbde      [0x11] =  0x6012
0003dbe0      [0x12] =  0x5011
0003dbe2      [0x13] =  0x3010
0003dbe4  }
0003dbe4  struct UNWIND_INFO data_3dbe4 = 
0003dbe4  {
0003dbe4      uint8_t VersionAndFlag = 0x1
0003dbe5      uint8_t SizeOfProlog = 0x13
0003dbe6      uint8_t CountOfUnwindCodes = 0x2
0003dbe7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dbe8  }
0003dbe8  uint16_t data_3dbe8[0x2] = 
0003dbe8  {
0003dbe8      [0x0] =  0x7213
0003dbea      [0x1] =  0x300f
0003dbec  }
0003dbec  struct UNWIND_INFO data_3dbec = 
0003dbec  {
0003dbec      uint8_t VersionAndFlag = 0x1
0003dbed      uint8_t SizeOfProlog = 0x5e
0003dbee      uint8_t CountOfUnwindCodes = 0x13
0003dbef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dbf0  }
0003dbf0  uint16_t data_3dbf0[0x13] = 
0003dbf0  {
0003dbf0      [0x00] =  0xd85e
0003dbf2      [0x01] =  0x0002
0003dbf4      [0x02] =  0xc83e
0003dbf6      [0x03] =  0x0003
0003dbf8      [0x04] =  0xb839
0003dbfa      [0x05] =  0x0004
0003dbfc      [0x06] =  0xa834
0003dbfe      [0x07] =  0x0005
0003dc00      [0x08] =  0x981d
0003dc02      [0x09] =  0x0006
0003dc04      [0x0a] =  0x8818
0003dc06      [0x0b] =  0x0007
0003dc08      [0x0c] =  0x6813
0003dc0a      [0x0d] =  0x0008
0003dc0c      [0x0e] =  0x340f
0003dc0e      [0x0f] =  0x0014
0003dc10      [0x10] =  0x010f
0003dc12      [0x11] =  0x0012
0003dc14      [0x12] =  0x7008
0003dc16  }

0003dc16                                                                    00 00                                                ..

0003dc18  struct UNWIND_INFO data_3dc18 = 
0003dc18  {
0003dc18      uint8_t VersionAndFlag = 0x1
0003dc19      uint8_t SizeOfProlog = 0x6d
0003dc1a      uint8_t CountOfUnwindCodes = 0x19
0003dc1b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dc1c  }
0003dc1c  uint16_t data_3dc1c[0x19] = 
0003dc1c  {
0003dc1c      [0x00] =  0xc86d
0003dc1e      [0x01] =  0x0003
0003dc20      [0x02] =  0xb867
0003dc22      [0x03] =  0x0004
0003dc24      [0x04] =  0xa848
0003dc26      [0x05] =  0x0005
0003dc28      [0x06] =  0x9843
0003dc2a      [0x07] =  0x0006
0003dc2c      [0x08] =  0x883e
0003dc2e      [0x09] =  0x0007
0003dc30      [0x0a] =  0x782a
0003dc32      [0x0b] =  0x0008
0003dc34      [0x0c] =  0x6826
0003dc36      [0x0d] =  0x0009
0003dc38      [0x0e] =  0x541a
0003dc3a      [0x0f] =  0x001c
0003dc3c      [0x10] =  0x341a
0003dc3e      [0x11] =  0x001b
0003dc40      [0x12] =  0x011a
0003dc42      [0x13] =  0x0014
0003dc44      [0x14] =  0xe013
0003dc46      [0x15] =  0xd011
0003dc48      [0x16] =  0xc00f
0003dc4a      [0x17] =  0x700d
0003dc4c      [0x18] =  0x600c
0003dc4e  }

0003dc4e                                            00 00                                                                ..

0003dc50  struct UNWIND_INFO data_3dc50 = 
0003dc50  {
0003dc50      uint8_t VersionAndFlag = 0x1
0003dc51      uint8_t SizeOfProlog = 0x37
0003dc52      uint8_t CountOfUnwindCodes = 0x12
0003dc53      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dc54  }
0003dc54  uint16_t data_3dc54[0x12] = 
0003dc54  {
0003dc54      [0x00] =  0x8837
0003dc56      [0x01] =  0x0002
0003dc58      [0x02] =  0x782c
0003dc5a      [0x03] =  0x0003
0003dc5c      [0x04] =  0x6828
0003dc5e      [0x05] =  0x0004
0003dc60      [0x06] =  0x641c
0003dc62      [0x07] =  0x0012
0003dc64      [0x08] =  0x541c
0003dc66      [0x09] =  0x0011
0003dc68      [0x0a] =  0x341c
0003dc6a      [0x0b] =  0x0010
0003dc6c      [0x0c] =  0x921c
0003dc6e      [0x0d] =  0xf018
0003dc70      [0x0e] =  0xe016
0003dc72      [0x0f] =  0xd014
0003dc74      [0x10] =  0xc012
0003dc76      [0x11] =  0x7010
0003dc78  }
0003dc78  struct UNWIND_INFO data_3dc78 = 
0003dc78  {
0003dc78      uint8_t VersionAndFlag = 0x1
0003dc79      uint8_t SizeOfProlog = 0x1e
0003dc7a      uint8_t CountOfUnwindCodes = 0xa
0003dc7b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dc7c  }
0003dc7c  uint16_t data_3dc7c[0xa] = 
0003dc7c  {
0003dc7c      [0x0] =  0x341e
0003dc7e      [0x1] =  0x000f
0003dc80      [0x2] =  0x521e
0003dc82      [0x3] =  0xf01a
0003dc84      [0x4] =  0xe018
0003dc86      [0x5] =  0xd016
0003dc88      [0x6] =  0xc014
0003dc8a      [0x7] =  0x7012
0003dc8c      [0x8] =  0x6011
0003dc8e      [0x9] =  0x5010
0003dc90  }
0003dc90  struct UNWIND_INFO data_3dc90 = 
0003dc90  {
0003dc90      uint8_t VersionAndFlag = 0x1
0003dc91      uint8_t SizeOfProlog = 0x6
0003dc92      uint8_t CountOfUnwindCodes = 0x2
0003dc93      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dc94  }
0003dc94  uint16_t data_3dc94[0x2] = 
0003dc94  {
0003dc94      [0x0] =  0x3206
0003dc96      [0x1] =  0x3002
0003dc98  }
0003dc98  struct UNWIND_INFO data_3dc98 = 
0003dc98  {
0003dc98      uint8_t VersionAndFlag = 0x1
0003dc99      uint8_t SizeOfProlog = 0x1d
0003dc9a      uint8_t CountOfUnwindCodes = 0x3
0003dc9b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dc9c  }
0003dc9c  uint16_t data_3dc9c[0x3] = 
0003dc9c  {
0003dc9c      [0x0] =  0x681d
0003dc9e      [0x1] =  0x0002
0003dca0      [0x2] =  0x620f
0003dca2  }

0003dca2        00 00                                                                                        ..

0003dca4  struct UNWIND_INFO data_3dca4 = 
0003dca4  {
0003dca4      uint8_t VersionAndFlag = 0x1
0003dca5      uint8_t SizeOfProlog = 0x18
0003dca6      uint8_t CountOfUnwindCodes = 0xa
0003dca7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dca8  }
0003dca8  uint16_t data_3dca8[0xa] = 
0003dca8  {
0003dca8      [0x0] =  0x7818
0003dcaa      [0x1] =  0x0002
0003dcac      [0x2] =  0x6814
0003dcae      [0x3] =  0x0003
0003dcb0      [0x4] =  0x6410
0003dcb2      [0x5] =  0x000b
0003dcb4      [0x6] =  0x5410
0003dcb6      [0x7] =  0x000a
0003dcb8      [0x8] =  0x7210
0003dcba      [0x9] =  0x700c
0003dcbc  }
0003dcbc  struct UNWIND_INFO data_3dcbc = 
0003dcbc  {
0003dcbc      uint8_t VersionAndFlag = 0x1
0003dcbd      uint8_t SizeOfProlog = 0x3b
0003dcbe      uint8_t CountOfUnwindCodes = 0x10
0003dcbf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dcc0  }
0003dcc0  uint16_t data_3dcc0[0x10] = 
0003dcc0  {
0003dcc0      [0x0] =  0x883b
0003dcc2      [0x1] =  0x0002
0003dcc4      [0x2] =  0x7828
0003dcc6      [0x3] =  0x0003
0003dcc8      [0x4] =  0x6824
0003dcca      [0x5] =  0x0004
0003dccc      [0x6] =  0x6418
0003dcce      [0x7] =  0x0010
0003dcd0      [0x8] =  0x5418
0003dcd2      [0x9] =  0x000f
0003dcd4      [0xa] =  0x3418
0003dcd6      [0xb] =  0x000e
0003dcd8      [0xc] =  0x9218
0003dcda      [0xd] =  0xd014
0003dcdc      [0xe] =  0xc012
0003dcde      [0xf] =  0x7010
0003dce0  }
0003dce0  struct UNWIND_INFO data_3dce0 = 
0003dce0  {
0003dce0      uint8_t VersionAndFlag = 0x1
0003dce1      uint8_t SizeOfProlog = 0x6
0003dce2      uint8_t CountOfUnwindCodes = 0x2
0003dce3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dce4  }
0003dce4  uint16_t data_3dce4[0x2] = 
0003dce4  {
0003dce4      [0x0] =  0x5206
0003dce6      [0x1] =  0x3002
0003dce8  }
0003dce8  struct UNWIND_INFO data_3dce8 = 
0003dce8  {
0003dce8      uint8_t VersionAndFlag = 0x1
0003dce9      uint8_t SizeOfProlog = 0x1c
0003dcea      uint8_t CountOfUnwindCodes = 0xc
0003dceb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dcec  }
0003dcec  uint16_t data_3dcec[0xc] = 
0003dcec  {
0003dcec      [0x0] =  0x641c
0003dcee      [0x1] =  0x000e
0003dcf0      [0x2] =  0x541c
0003dcf2      [0x3] =  0x000d
0003dcf4      [0x4] =  0x341c
0003dcf6      [0x5] =  0x000c
0003dcf8      [0x6] =  0x521c
0003dcfa      [0x7] =  0xf018
0003dcfc      [0x8] =  0xe016
0003dcfe      [0x9] =  0xd014
0003dd00      [0xa] =  0xc012
0003dd02      [0xb] =  0x7010
0003dd04  }
0003dd04  struct UNWIND_INFO data_3dd04 = 
0003dd04  {
0003dd04      uint8_t VersionAndFlag = 0x1
0003dd05      uint8_t SizeOfProlog = 0x1e
0003dd06      uint8_t CountOfUnwindCodes = 0xa
0003dd07      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd08  }
0003dd08  uint16_t data_3dd08[0xa] = 
0003dd08  {
0003dd08      [0x0] =  0x341e
0003dd0a      [0x1] =  0x000e
0003dd0c      [0x2] =  0x521e
0003dd0e      [0x3] =  0xf01a
0003dd10      [0x4] =  0xe018
0003dd12      [0x5] =  0xd016
0003dd14      [0x6] =  0xc014
0003dd16      [0x7] =  0x7012
0003dd18      [0x8] =  0x6011
0003dd1a      [0x9] =  0x5010
0003dd1c  }
0003dd1c  struct UNWIND_INFO data_3dd1c = 
0003dd1c  {
0003dd1c      uint8_t VersionAndFlag = 0x1
0003dd1d      uint8_t SizeOfProlog = 0x1c
0003dd1e      uint8_t CountOfUnwindCodes = 0xc
0003dd1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd20  }
0003dd20  uint16_t data_3dd20[0xc] = 
0003dd20  {
0003dd20      [0x0] =  0x641c
0003dd22      [0x1] =  0x000c
0003dd24      [0x2] =  0x541c
0003dd26      [0x3] =  0x000b
0003dd28      [0x4] =  0x341c
0003dd2a      [0x5] =  0x000a
0003dd2c      [0x6] =  0x321c
0003dd2e      [0x7] =  0xf018
0003dd30      [0x8] =  0xe016
0003dd32      [0x9] =  0xd014
0003dd34      [0xa] =  0xc012
0003dd36      [0xb] =  0x7010
0003dd38  }
0003dd38  struct UNWIND_INFO data_3dd38 = 
0003dd38  {
0003dd38      uint8_t VersionAndFlag = 0x1
0003dd39      uint8_t SizeOfProlog = 0xf
0003dd3a      uint8_t CountOfUnwindCodes = 0x6
0003dd3b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd3c  }
0003dd3c  uint16_t data_3dd3c[0x6] = 
0003dd3c  {
0003dd3c      [0x0] =  0x640f
0003dd3e      [0x1] =  0x0008
0003dd40      [0x2] =  0x340f
0003dd42      [0x3] =  0x0007
0003dd44      [0x4] =  0x320f
0003dd46      [0x5] =  0x700b
0003dd48  }
0003dd48  struct UNWIND_INFO data_3dd48 = 
0003dd48  {
0003dd48      uint8_t VersionAndFlag = 0x1
0003dd49      uint8_t SizeOfProlog = 0x4
0003dd4a      uint8_t CountOfUnwindCodes = 0x1
0003dd4b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd4c  }
0003dd4c  uint16_t data_3dd4c[0x1] = 
0003dd4c  {
0003dd4c      [0x0] =  0xc204
0003dd4e  }

0003dd4e                                            00 00                                                                ..

0003dd50  struct UNWIND_INFO data_3dd50 = 
0003dd50  {
0003dd50      uint8_t VersionAndFlag = 0x1
0003dd51      uint8_t SizeOfProlog = 0x20
0003dd52      uint8_t CountOfUnwindCodes = 0xd
0003dd53      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd54  }
0003dd54  uint16_t data_3dd54[0xd] = 
0003dd54  {
0003dd54      [0x0] =  0xc420
0003dd56      [0x1] =  0x001b
0003dd58      [0x2] =  0x6420
0003dd5a      [0x3] =  0x001a
0003dd5c      [0x4] =  0x5420
0003dd5e      [0x5] =  0x0019
0003dd60      [0x6] =  0x3420
0003dd62      [0x7] =  0x0018
0003dd64      [0x8] =  0x0120
0003dd66      [0x9] =  0x0014
0003dd68      [0xa] =  0xf019
0003dd6a      [0xb] =  0xe017
0003dd6c      [0xc] =  0xd015
0003dd6e  }

0003dd6e                                            00 00                                                                ..

0003dd70  struct UNWIND_INFO data_3dd70 = 
0003dd70  {
0003dd70      uint8_t VersionAndFlag = 0x1
0003dd71      uint8_t SizeOfProlog = 0x1f
0003dd72      uint8_t CountOfUnwindCodes = 0xd
0003dd73      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd74  }
0003dd74  uint16_t data_3dd74[0xd] = 
0003dd74  {
0003dd74      [0x0] =  0x641f
0003dd76      [0x1] =  0x001a
0003dd78      [0x2] =  0x541f
0003dd7a      [0x3] =  0x0019
0003dd7c      [0x4] =  0x341f
0003dd7e      [0x5] =  0x0018
0003dd80      [0x6] =  0x011f
0003dd82      [0x7] =  0x0012
0003dd84      [0x8] =  0xf018
0003dd86      [0x9] =  0xe016
0003dd88      [0xa] =  0xd014
0003dd8a      [0xb] =  0xc012
0003dd8c      [0xc] =  0x7010
0003dd8e  }

0003dd8e                                            00 00                                                                ..

0003dd90  struct UNWIND_INFO data_3dd90 = 
0003dd90  {
0003dd90      uint8_t VersionAndFlag = 0x1
0003dd91      uint8_t SizeOfProlog = 0x7
0003dd92      uint8_t CountOfUnwindCodes = 0x1
0003dd93      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd94  }
0003dd94  uint16_t data_3dd94[0x1] = 
0003dd94  {
0003dd94      [0x0] =  0x4207
0003dd96  }

0003dd96                                                                    00 00                                                ..

0003dd98  struct UNWIND_INFO data_3dd98 = 
0003dd98  {
0003dd98      uint8_t VersionAndFlag = 0x1
0003dd99      uint8_t SizeOfProlog = 0x13
0003dd9a      uint8_t CountOfUnwindCodes = 0x8
0003dd9b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dd9c  }
0003dd9c  uint16_t data_3dd9c[0x8] = 
0003dd9c  {
0003dd9c      [0x0] =  0x5413
0003dd9e      [0x1] =  0x0010
0003dda0      [0x2] =  0x3413
0003dda2      [0x3] =  0x000f
0003dda4      [0x4] =  0x9213
0003dda6      [0x5] =  0xe00f
0003dda8      [0x6] =  0x700d
0003ddaa      [0x7] =  0x600c
0003ddac  }
0003ddac  struct UNWIND_INFO data_3ddac = 
0003ddac  {
0003ddac      uint8_t VersionAndFlag = 0x1
0003ddad      uint8_t SizeOfProlog = 0x10
0003ddae      uint8_t CountOfUnwindCodes = 0x6
0003ddaf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ddb0  }
0003ddb0  uint16_t data_3ddb0[0x6] = 
0003ddb0  {
0003ddb0      [0x0] =  0x6410
0003ddb2      [0x1] =  0x000f
0003ddb4      [0x2] =  0x3410
0003ddb6      [0x3] =  0x000e
0003ddb8      [0x4] =  0x9210
0003ddba      [0x5] =  0x700c
0003ddbc  }
0003ddbc  struct UNWIND_INFO data_3ddbc = 
0003ddbc  {
0003ddbc      uint8_t VersionAndFlag = 0x1
0003ddbd      uint8_t SizeOfProlog = 0xf
0003ddbe      uint8_t CountOfUnwindCodes = 0x6
0003ddbf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ddc0  }
0003ddc0  uint16_t data_3ddc0[0x6] = 
0003ddc0  {
0003ddc0      [0x0] =  0x640f
0003ddc2      [0x1] =  0x000c
0003ddc4      [0x2] =  0x340f
0003ddc6      [0x3] =  0x000b
0003ddc8      [0x4] =  0x720f
0003ddca      [0x5] =  0x700b
0003ddcc  }
0003ddcc  struct UNWIND_INFO data_3ddcc = 
0003ddcc  {
0003ddcc      uint8_t VersionAndFlag = 0x1
0003ddcd      uint8_t SizeOfProlog = 0x18
0003ddce      uint8_t CountOfUnwindCodes = 0xa
0003ddcf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ddd0  }
0003ddd0  uint16_t data_3ddd0[0xa] = 
0003ddd0  {
0003ddd0      [0x0] =  0x6418
0003ddd2      [0x1] =  0x000e
0003ddd4      [0x2] =  0x5418
0003ddd6      [0x3] =  0x000d
0003ddd8      [0x4] =  0x3418
0003ddda      [0x5] =  0x000c
0003dddc      [0x6] =  0x7218
0003ddde      [0x7] =  0xd014
0003dde0      [0x8] =  0xc012
0003dde2      [0x9] =  0x7010
0003dde4  }
0003dde4  struct UNWIND_INFO data_3dde4 = 
0003dde4  {
0003dde4      uint8_t VersionAndFlag = 0x1
0003dde5      uint8_t SizeOfProlog = 0x16
0003dde6      uint8_t CountOfUnwindCodes = 0x7
0003dde7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dde8  }
0003dde8  uint16_t data_3dde8[0x7] = 
0003dde8  {
0003dde8      [0x0] =  0x4216
0003ddea      [0x1] =  0xf012
0003ddec      [0x2] =  0xe010
0003ddee      [0x3] =  0x700e
0003ddf0      [0x4] =  0x600d
0003ddf2      [0x5] =  0x500c
0003ddf4      [0x6] =  0x300b
0003ddf6  }

0003ddf6                                                                    00 00                                                ..

0003ddf8  struct UNWIND_INFO data_3ddf8 = 
0003ddf8  {
0003ddf8      uint8_t VersionAndFlag = 0x1
0003ddf9      uint8_t SizeOfProlog = 0xa
0003ddfa      uint8_t CountOfUnwindCodes = 0x4
0003ddfb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ddfc  }
0003ddfc  uint16_t data_3ddfc[0x4] = 
0003ddfc  {
0003ddfc      [0x0] =  0x340a
0003ddfe      [0x1] =  0x0008
0003de00      [0x2] =  0x520a
0003de02      [0x3] =  0x7006
0003de04  }
0003de04  struct UNWIND_INFO data_3de04 = 
0003de04  {
0003de04      uint8_t VersionAndFlag = 0x1
0003de05      uint8_t SizeOfProlog = 0x1d
0003de06      uint8_t CountOfUnwindCodes = 0xc
0003de07      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003de08  }
0003de08  uint16_t data_3de08[0xc] = 
0003de08  {
0003de08      [0x0] =  0x741d
0003de0a      [0x1] =  0x000d
0003de0c      [0x2] =  0x641d
0003de0e      [0x3] =  0x000c
0003de10      [0x4] =  0x541d
0003de12      [0x5] =  0x000b
0003de14      [0x6] =  0x341d
0003de16      [0x7] =  0x000a
0003de18      [0x8] =  0x521d
0003de1a      [0x9] =  0xe019
0003de1c      [0xa] =  0xd017
0003de1e      [0xb] =  0xc015
0003de20  }
0003de20  struct UNWIND_INFO data_3de20 = 
0003de20  {
0003de20      uint8_t VersionAndFlag = 0x1
0003de21      uint8_t SizeOfProlog = 0x40
0003de22      uint8_t CountOfUnwindCodes = 0x13
0003de23      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003de24  }
0003de24  uint16_t data_3de24[0x13] = 
0003de24  {
0003de24      [0x00] =  0x9840
0003de26      [0x01] =  0x0005
0003de28      [0x02] =  0x883b
0003de2a      [0x03] =  0x0006
0003de2c      [0x04] =  0x782b
0003de2e      [0x05] =  0x0007
0003de30      [0x06] =  0x6827
0003de32      [0x07] =  0x0008
0003de34      [0x08] =  0x641b
0003de36      [0x09] =  0x0018
0003de38      [0x0a] =  0x541b
0003de3a      [0x0b] =  0x0017
0003de3c      [0x0c] =  0x341b
0003de3e      [0x0d] =  0x0016
0003de40      [0x0e] =  0x011b
0003de42      [0x0f] =  0x0012
0003de44      [0x10] =  0xd014
0003de46      [0x11] =  0xc012
0003de48      [0x12] =  0x7010
0003de4a  }

0003de4a                                00 00                                                                        ..

0003de4c  struct UNWIND_INFO data_3de4c = 
0003de4c  {
0003de4c      uint8_t VersionAndFlag = 0x1
0003de4d      uint8_t SizeOfProlog = 0x15
0003de4e      uint8_t CountOfUnwindCodes = 0x4
0003de4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003de50  }
0003de50  uint16_t data_3de50[0x4] = 
0003de50  {
0003de50      [0x0] =  0x6815
0003de52      [0x1] =  0x0002
0003de54      [0x2] =  0x5206
0003de56      [0x3] =  0x3002
0003de58  }
0003de58  struct UNWIND_INFO data_3de58 = 
0003de58  {
0003de58      uint8_t VersionAndFlag = 0x19
0003de59      uint8_t SizeOfProlog = 0x37
0003de5a      uint8_t CountOfUnwindCodes = 0x11
0003de5b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003de5c  }
0003de5c  uint16_t data_3de5c[0x11] = 
0003de5c  {
0003de5c      [0x00] =  0x8828
0003de5e      [0x01] =  0x0006
0003de60      [0x02] =  0x7823
0003de62      [0x03] =  0x0007
0003de64      [0x04] =  0x681f
0003de66      [0x05] =  0x0008
0003de68      [0x06] =  0x641b
0003de6a      [0x07] =  0x0019
0003de6c      [0x08] =  0x541b
0003de6e      [0x09] =  0x0018
0003de70      [0x0a] =  0x341b
0003de72      [0x0b] =  0x0017
0003de74      [0x0c] =  0x011b
0003de76      [0x0d] =  0x0012
0003de78      [0x0e] =  0xd014
0003de7a      [0x0f] =  0xc012
0003de7c      [0x10] =  0x7010
0003de7e  }

0003de7e                                                                                            00 00                                ..

0003de80  uint32_t data_3de80 = 0x2393c

0003de84              58 00 00 00                                                                              X...

0003de88  struct UNWIND_INFO data_3de88 = 
0003de88  {
0003de88      uint8_t VersionAndFlag = 0x1
0003de89      uint8_t SizeOfProlog = 0x1d
0003de8a      uint8_t CountOfUnwindCodes = 0xc
0003de8b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003de8c  }
0003de8c  uint16_t data_3de8c[0xc] = 
0003de8c  {
0003de8c      [0x0] =  0x741d
0003de8e      [0x1] =  0x0011
0003de90      [0x2] =  0x641d
0003de92      [0x3] =  0x0010
0003de94      [0x4] =  0x541d
0003de96      [0x5] =  0x000f
0003de98      [0x6] =  0x341d
0003de9a      [0x7] =  0x000e
0003de9c      [0x8] =  0x921d
0003de9e      [0x9] =  0xe019
0003dea0      [0xa] =  0xd017
0003dea2      [0xb] =  0xc015
0003dea4  }
0003dea4  struct UNWIND_INFO data_3dea4 = 
0003dea4  {
0003dea4      uint8_t VersionAndFlag = 0x1
0003dea5      uint8_t SizeOfProlog = 0x30
0003dea6      uint8_t CountOfUnwindCodes = 0xd
0003dea7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dea8  }
0003dea8  uint16_t data_3dea8[0xd] = 
0003dea8  {
0003dea8      [0x0] =  0x6830
0003deaa      [0x1] =  0x0008
0003deac      [0x2] =  0x341d
0003deae      [0x3] =  0x001b
0003deb0      [0x4] =  0x011d
0003deb2      [0x5] =  0x0012
0003deb4      [0x6] =  0xf016
0003deb6      [0x7] =  0xe014
0003deb8      [0x8] =  0xd012
0003deba      [0x9] =  0xc010
0003debc      [0xa] =  0x700e
0003debe      [0xb] =  0x600d
0003dec0      [0xc] =  0x500c
0003dec2  }

0003dec2        00 00                                                                                        ..

0003dec4  struct UNWIND_INFO data_3dec4 = 
0003dec4  {
0003dec4      uint8_t VersionAndFlag = 0x1
0003dec5      uint8_t SizeOfProlog = 0x1f
0003dec6      uint8_t CountOfUnwindCodes = 0xd
0003dec7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dec8  }
0003dec8  uint16_t data_3dec8[0xd] = 
0003dec8  {
0003dec8      [0x0] =  0x641f
0003deca      [0x1] =  0x0023
0003decc      [0x2] =  0x541f
0003dece      [0x3] =  0x0022
0003ded0      [0x4] =  0x341f
0003ded2      [0x5] =  0x0021
0003ded4      [0x6] =  0x011f
0003ded6      [0x7] =  0x001a
0003ded8      [0x8] =  0xf018
0003deda      [0x9] =  0xe016
0003dedc      [0xa] =  0xd014
0003dede      [0xb] =  0xc012
0003dee0      [0xc] =  0x7010
0003dee2  }

0003dee2        00 00                                                                                        ..

0003dee4  struct UNWIND_INFO data_3dee4 = 
0003dee4  {
0003dee4      uint8_t VersionAndFlag = 0x1
0003dee5      uint8_t SizeOfProlog = 0x19
0003dee6      uint8_t CountOfUnwindCodes = 0xa
0003dee7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dee8  }
0003dee8  uint16_t data_3dee8[0xa] = 
0003dee8  {
0003dee8      [0x0] =  0x7419
0003deea      [0x1] =  0x000f
0003deec      [0x2] =  0x6419
0003deee      [0x3] =  0x000e
0003def0      [0x4] =  0x5419
0003def2      [0x5] =  0x000d
0003def4      [0x6] =  0x3419
0003def6      [0x7] =  0x000c
0003def8      [0x8] =  0x9219
0003defa      [0x9] =  0xc015
0003defc  }
0003defc  struct UNWIND_INFO data_3defc = 
0003defc  {
0003defc      uint8_t VersionAndFlag = 0x1
0003defd      uint8_t SizeOfProlog = 0xf
0003defe      uint8_t CountOfUnwindCodes = 0x6
0003deff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003df00  }
0003df00  uint16_t data_3df00[0x6] = 
0003df00  {
0003df00      [0x0] =  0x680f
0003df02      [0x1] =  0x0002
0003df04      [0x2] =  0x340a
0003df06      [0x3] =  0x0008
0003df08      [0x4] =  0x520a
0003df0a      [0x5] =  0x7006
0003df0c  }
0003df0c  struct UNWIND_INFO data_3df0c = 
0003df0c  {
0003df0c      uint8_t VersionAndFlag = 0x1
0003df0d      uint8_t SizeOfProlog = 0x49
0003df0e      uint8_t CountOfUnwindCodes = 0x15
0003df0f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003df10  }
0003df10  uint16_t data_3df10[0x15] = 
0003df10  {
0003df10      [0x00] =  0xa849
0003df12      [0x01] =  0x0005
0003df14      [0x02] =  0x9843
0003df16      [0x03] =  0x0006
0003df18      [0x04] =  0x8826
0003df1a      [0x05] =  0x0007
0003df1c      [0x06] =  0x7821
0003df1e      [0x07] =  0x0008
0003df20      [0x08] =  0x681d
0003df22      [0x09] =  0x0009
0003df24      [0x0a] =  0x3419
0003df26      [0x0b] =  0x001c
0003df28      [0x0c] =  0x0119
0003df2a      [0x0d] =  0x0014
0003df2c      [0x0e] =  0xf012
0003df2e      [0x0f] =  0xe010
0003df30      [0x10] =  0xd00e
0003df32      [0x11] =  0xc00c
0003df34      [0x12] =  0x700a
0003df36      [0x13] =  0x6009
0003df38      [0x14] =  0x5008
0003df3a  }

0003df3a                                                                                00 00                                        ..

0003df3c  struct UNWIND_INFO data_3df3c = 
0003df3c  {
0003df3c      uint8_t VersionAndFlag = 0x1
0003df3d      uint8_t SizeOfProlog = 0x38
0003df3e      uint8_t CountOfUnwindCodes = 0xe
0003df3f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003df40  }
0003df40  uint16_t data_3df40[0xe] = 
0003df40  {
0003df40      [0x0] =  0xa838
0003df42      [0x1] =  0x0002
0003df44      [0x2] =  0x9827
0003df46      [0x3] =  0x0003
0003df48      [0x4] =  0x8819
0003df4a      [0x5] =  0x0004
0003df4c      [0x6] =  0x6414
0003df4e      [0x7] =  0x000e
0003df50      [0x8] =  0x5414
0003df52      [0x9] =  0x000d
0003df54      [0xa] =  0x3414
0003df56      [0xb] =  0x000c
0003df58      [0xc] =  0x9214
0003df5a      [0xd] =  0x7010
0003df5c  }
0003df5c  struct UNWIND_INFO data_3df5c = 
0003df5c  {
0003df5c      uint8_t VersionAndFlag = 0x19
0003df5d      uint8_t SizeOfProlog = 0x4d
0003df5e      uint8_t CountOfUnwindCodes = 0x17
0003df5f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003df60  }
0003df60  uint16_t data_3df60[0x17] = 
0003df60  {
0003df60      [0x00] =  0xb83b
0003df62      [0x01] =  0x0012
0003df64      [0x02] =  0xa833
0003df66      [0x03] =  0x0013
0003df68      [0x04] =  0x982b
0003df6a      [0x05] =  0x0014
0003df6c      [0x06] =  0x8826
0003df6e      [0x07] =  0x0015
0003df70      [0x08] =  0x7821
0003df72      [0x09] =  0x0016
0003df74      [0x0a] =  0x681d
0003df76      [0x0b] =  0x0017
0003df78      [0x0c] =  0x3419
0003df7a      [0x0d] =  0x003b
0003df7c      [0x0e] =  0x0119
0003df7e      [0x0f] =  0x0030
0003df80      [0x10] =  0xf012
0003df82      [0x11] =  0xe010
0003df84      [0x12] =  0xd00e
0003df86      [0x13] =  0xc00c
0003df88      [0x14] =  0x700a
0003df8a      [0x15] =  0x6009
0003df8c      [0x16] =  0x5008
0003df8e  }

0003df8e                                            00 00                                                                ..

0003df90  uint32_t data_3df90 = 0x2393c

0003df94                                                              10 01 00 00                                              ....

0003df98  struct UNWIND_INFO data_3df98 = 
0003df98  {
0003df98      uint8_t VersionAndFlag = 0x1
0003df99      uint8_t SizeOfProlog = 0x31
0003df9a      uint8_t CountOfUnwindCodes = 0xe
0003df9b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003df9c  }
0003df9c  uint16_t data_3df9c[0xe] = 
0003df9c  {
0003df9c      [0x0] =  0x7831
0003df9e      [0x1] =  0x0004
0003dfa0      [0x2] =  0x682a
0003dfa2      [0x3] =  0x0005
0003dfa4      [0x4] =  0x341d
0003dfa6      [0x5] =  0x0017
0003dfa8      [0x6] =  0xb21d
0003dfaa      [0x7] =  0xf019
0003dfac      [0x8] =  0xe017
0003dfae      [0x9] =  0xd015
0003dfb0      [0xa] =  0xc013
0003dfb2      [0xb] =  0x7011
0003dfb4      [0xc] =  0x6010
0003dfb6      [0xd] =  0x500f
0003dfb8  }
0003dfb8  struct UNWIND_INFO data_3dfb8 = 
0003dfb8  {
0003dfb8      uint8_t VersionAndFlag = 0x1
0003dfb9      uint8_t SizeOfProlog = 0x24
0003dfba      uint8_t CountOfUnwindCodes = 0x10
0003dfbb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dfbc  }
0003dfbc  uint16_t data_3dfbc[0x10] = 
0003dfbc  {
0003dfbc      [0x0] =  0x7824
0003dfbe      [0x1] =  0x0004
0003dfc0      [0x2] =  0x6820
0003dfc2      [0x3] =  0x0005
0003dfc4      [0x4] =  0x641c
0003dfc6      [0x5] =  0x0014
0003dfc8      [0x6] =  0x541c
0003dfca      [0x7] =  0x0013
0003dfcc      [0x8] =  0x341c
0003dfce      [0x9] =  0x0012
0003dfd0      [0xa] =  0xb21c
0003dfd2      [0xb] =  0xf018
0003dfd4      [0xc] =  0xe016
0003dfd6      [0xd] =  0xd014
0003dfd8      [0xe] =  0xc012
0003dfda      [0xf] =  0x7010
0003dfdc  }
0003dfdc  struct UNWIND_INFO data_3dfdc = 
0003dfdc  {
0003dfdc      uint8_t VersionAndFlag = 0x1
0003dfdd      uint8_t SizeOfProlog = 0x14
0003dfde      uint8_t CountOfUnwindCodes = 0xa
0003dfdf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dfe0  }
0003dfe0  uint16_t data_3dfe0[0xa] = 
0003dfe0  {
0003dfe0      [0x0] =  0x3414
0003dfe2      [0x1] =  0x0012
0003dfe4      [0x2] =  0x9214
0003dfe6      [0x3] =  0xf010
0003dfe8      [0x4] =  0xe00e
0003dfea      [0x5] =  0xd00c
0003dfec      [0x6] =  0xc00a
0003dfee      [0x7] =  0x7008
0003dff0      [0x8] =  0x6007
0003dff2      [0x9] =  0x5006
0003dff4  }
0003dff4  struct UNWIND_INFO data_3dff4 = 
0003dff4  {
0003dff4      uint8_t VersionAndFlag = 0x1
0003dff5      uint8_t SizeOfProlog = 0x35
0003dff6      uint8_t CountOfUnwindCodes = 0x11
0003dff7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003dff8  }
0003dff8  uint16_t data_3dff8[0x11] = 
0003dff8  {
0003dff8      [0x00] =  0x8835
0003dffa      [0x01] =  0x0006
0003dffc      [0x02] =  0x782d
0003dffe      [0x03] =  0x0007
0003e000      [0x04] =  0x6829
0003e002      [0x05] =  0x0008
0003e004      [0x06] =  0x341d
0003e006      [0x07] =  0x001b
0003e008      [0x08] =  0x011d
0003e00a      [0x09] =  0x0012
0003e00c      [0x0a] =  0xf016
0003e00e      [0x0b] =  0xe014
0003e010      [0x0c] =  0xd012
0003e012      [0x0d] =  0xc010
0003e014      [0x0e] =  0x700e
0003e016      [0x0f] =  0x600d
0003e018      [0x10] =  0x500c
0003e01a  }

0003e01a                                                                                00 00                                        ..

0003e01c  struct UNWIND_INFO data_3e01c = 
0003e01c  {
0003e01c      uint8_t VersionAndFlag = 0x1
0003e01d      uint8_t SizeOfProlog = 0x22
0003e01e      uint8_t CountOfUnwindCodes = 0x8
0003e01f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e020  }
0003e020  uint16_t data_3e020[0x8] = 
0003e020  {
0003e020      [0x0] =  0x8822
0003e022      [0x1] =  0x0002
0003e024      [0x2] =  0x781c
0003e026      [0x3] =  0x0003
0003e028      [0x4] =  0x6810
0003e02a      [0x5] =  0x0004
0003e02c      [0x6] =  0x9206
0003e02e      [0x7] =  0x3002
0003e030  }
0003e030  struct UNWIND_INFO data_3e030 = 
0003e030  {
0003e030      uint8_t VersionAndFlag = 0x1
0003e031      uint8_t SizeOfProlog = 0x18
0003e032      uint8_t CountOfUnwindCodes = 0xa
0003e033      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e034  }
0003e034  uint16_t data_3e034[0xa] = 
0003e034  {
0003e034      [0x0] =  0x0118
0003e036      [0x1] =  0x0013
0003e038      [0x2] =  0xf011
0003e03a      [0x3] =  0xe00f
0003e03c      [0x4] =  0xd00d
0003e03e      [0x5] =  0xc00b
0003e040      [0x6] =  0x7009
0003e042      [0x7] =  0x6008
0003e044      [0x8] =  0x5007
0003e046      [0x9] =  0x3006
0003e048  }
0003e048  struct UNWIND_INFO data_3e048 = 
0003e048  {
0003e048      uint8_t VersionAndFlag = 0x1
0003e049      uint8_t SizeOfProlog = 0xf
0003e04a      uint8_t CountOfUnwindCodes = 0x4
0003e04b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e04c  }
0003e04c  uint16_t data_3e04c[0x4] = 
0003e04c  {
0003e04c      [0x0] =  0x340f
0003e04e      [0x1] =  0x0007
0003e050      [0x2] =  0x320f
0003e052      [0x3] =  0x700b
0003e054  }
0003e054  struct UNWIND_INFO data_3e054 = 
0003e054  {
0003e054      uint8_t VersionAndFlag = 0x1
0003e055      uint8_t SizeOfProlog = 0x31
0003e056      uint8_t CountOfUnwindCodes = 0xc
0003e057      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e058  }
0003e058  uint16_t data_3e058[0xc] = 
0003e058  {
0003e058      [0x0] =  0x6831
0003e05a      [0x1] =  0x0004
0003e05c      [0x2] =  0x3419
0003e05e      [0x3] =  0x0015
0003e060      [0x4] =  0x9219
0003e062      [0x5] =  0xf015
0003e064      [0x6] =  0xe013
0003e066      [0x7] =  0xd011
0003e068      [0x8] =  0xc00f
0003e06a      [0x9] =  0x700d
0003e06c      [0xa] =  0x600c
0003e06e      [0xb] =  0x500b
0003e070  }
0003e070  struct UNWIND_INFO data_3e070 = 
0003e070  {
0003e070      uint8_t VersionAndFlag = 0x1
0003e071      uint8_t SizeOfProlog = 0x6a
0003e072      uint8_t CountOfUnwindCodes = 0x1e
0003e073      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e074  }
0003e074  uint16_t data_3e074[0x1e] = 
0003e074  {
0003e074      [0x00] =  0xf86a
0003e076      [0x01] =  0x0014
0003e078      [0x02] =  0xe862
0003e07a      [0x03] =  0x0015
0003e07c      [0x04] =  0xd85a
0003e07e      [0x05] =  0x0016
0003e080      [0x06] =  0xc852
0003e082      [0x07] =  0x0017
0003e084      [0x08] =  0xb84a
0003e086      [0x09] =  0x0018
0003e088      [0x0a] =  0xa842
0003e08a      [0x0b] =  0x0019
0003e08c      [0x0c] =  0x983a
0003e08e      [0x0d] =  0x001a
0003e090      [0x0e] =  0x8832
0003e092      [0x0f] =  0x001b
0003e094      [0x10] =  0x782d
0003e096      [0x11] =  0x001c
0003e098      [0x12] =  0x6829
0003e09a      [0x13] =  0x001d
0003e09c      [0x14] =  0x0125
0003e09e      [0x15] =  0x003d
0003e0a0      [0x16] =  0xf01e
0003e0a2      [0x17] =  0xe01c
0003e0a4      [0x18] =  0xd01a
0003e0a6      [0x19] =  0xc018
0003e0a8      [0x1a] =  0x7016
0003e0aa      [0x1b] =  0x6015
0003e0ac      [0x1c] =  0x5014
0003e0ae      [0x1d] =  0x3013
0003e0b0  }
0003e0b0  struct UNWIND_INFO data_3e0b0 = 
0003e0b0  {
0003e0b0      uint8_t VersionAndFlag = 0x19
0003e0b1      uint8_t SizeOfProlog = 0x35
0003e0b2      uint8_t CountOfUnwindCodes = 0x10
0003e0b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e0b4  }
0003e0b4  uint16_t data_3e0b4[0x10] = 
0003e0b4  {
0003e0b4      [0x0] =  0x8823
0003e0b6      [0x1] =  0x002a
0003e0b8      [0x2] =  0x781e
0003e0ba      [0x3] =  0x002b
0003e0bc      [0x4] =  0x681a
0003e0be      [0x5] =  0x002c
0003e0c0      [0x6] =  0x0116
0003e0c2      [0x7] =  0x005b
0003e0c4      [0x8] =  0xf00f
0003e0c6      [0x9] =  0xe00d
0003e0c8      [0xa] =  0xd00b
0003e0ca      [0xb] =  0xc009
0003e0cc      [0xc] =  0x7007
0003e0ce      [0xd] =  0x6006
0003e0d0      [0xe] =  0x5005
0003e0d2      [0xf] =  0x3004
0003e0d4  }
0003e0d4  uint32_t data_3e0d4 = 0x2393c

0003e0d8                                                                          90 02 00 00                                      ....

0003e0dc  struct UNWIND_INFO data_3e0dc = 
0003e0dc  {
0003e0dc      uint8_t VersionAndFlag = 0x1
0003e0dd      uint8_t SizeOfProlog = 0x52
0003e0de      uint8_t CountOfUnwindCodes = 0x15
0003e0df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e0e0  }
0003e0e0  uint16_t data_3e0e0[0x15] = 
0003e0e0  {
0003e0e0      [0x00] =  0xb852
0003e0e2      [0x01] =  0x0005
0003e0e4      [0x02] =  0xa842
0003e0e6      [0x03] =  0x0006
0003e0e8      [0x04] =  0x783d
0003e0ea      [0x05] =  0x0007
0003e0ec      [0x06] =  0x6839
0003e0ee      [0x07] =  0x0008
0003e0f0      [0x08] =  0x6423
0003e0f2      [0x09] =  0x001b
0003e0f4      [0x0a] =  0x5423
0003e0f6      [0x0b] =  0x0019
0003e0f8      [0x0c] =  0x3423
0003e0fa      [0x0d] =  0x0018
0003e0fc      [0x0e] =  0x0123
0003e0fe      [0x0f] =  0x0012
0003e100      [0x10] =  0xf01c
0003e102      [0x11] =  0xe01a
0003e104      [0x12] =  0xd018
0003e106      [0x13] =  0xc016
0003e108      [0x14] =  0x7014
0003e10a  }

0003e10a                                00 00                                                                        ..

0003e10c  struct UNWIND_INFO data_3e10c = 
0003e10c  {
0003e10c      uint8_t VersionAndFlag = 0x1
0003e10d      uint8_t SizeOfProlog = 0x22
0003e10e      uint8_t CountOfUnwindCodes = 0xa
0003e10f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e110  }
0003e110  uint16_t data_3e110[0xa] = 
0003e110  {
0003e110      [0x0] =  0x3422
0003e112      [0x1] =  0x000d
0003e114      [0x2] =  0x3222
0003e116      [0x3] =  0xf01e
0003e118      [0x4] =  0xe01c
0003e11a      [0x5] =  0xd01a
0003e11c      [0x6] =  0xc018
0003e11e      [0x7] =  0x7016
0003e120      [0x8] =  0x6015
0003e122      [0x9] =  0x5014
0003e124  }
0003e124  struct UNWIND_INFO data_3e124 = 
0003e124  {
0003e124      uint8_t VersionAndFlag = 0x19
0003e125      uint8_t SizeOfProlog = 0x26
0003e126      uint8_t CountOfUnwindCodes = 0xa
0003e127      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e128  }
0003e128  uint16_t data_3e128[0xa] = 
0003e128  {
0003e128      [0x0] =  0x0114
0003e12a      [0x1] =  0x0013
0003e12c      [0x2] =  0xf00d
0003e12e      [0x3] =  0xe00b
0003e130      [0x4] =  0xd009
0003e132      [0x5] =  0xc007
0003e134      [0x6] =  0x7005
0003e136      [0x7] =  0x6004
0003e138      [0x8] =  0x5003
0003e13a      [0x9] =  0x3002
0003e13c  }
0003e13c  uint32_t data_3e13c = 0x2393c

0003e140  80 00 00 00                                                                                      ....

0003e144  struct UNWIND_INFO data_3e144 = 
0003e144  {
0003e144      uint8_t VersionAndFlag = 0x19
0003e145      uint8_t SizeOfProlog = 0x1a
0003e146      uint8_t CountOfUnwindCodes = 0x4
0003e147      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e148  }
0003e148  uint16_t data_3e148[0x4] = 
0003e148  {
0003e148      [0x0] =  0xf20b
0003e14a      [0x1] =  0x7004
0003e14c      [0x2] =  0x6003
0003e14e      [0x3] =  0x3002
0003e150  }
0003e150  uint32_t data_3e150 = 0x2393c

0003e154                                                              70 00 00 00                                              p...

0003e158  struct UNWIND_INFO data_3e158 = 
0003e158  {
0003e158      uint8_t VersionAndFlag = 0x1
0003e159      uint8_t SizeOfProlog = 0x18
0003e15a      uint8_t CountOfUnwindCodes = 0xa
0003e15b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e15c  }
0003e15c  uint16_t data_3e15c[0xa] = 
0003e15c  {
0003e15c      [0x0] =  0x6418
0003e15e      [0x1] =  0x000f
0003e160      [0x2] =  0x5418
0003e162      [0x3] =  0x000d
0003e164      [0x4] =  0x3418
0003e166      [0x5] =  0x000c
0003e168      [0x6] =  0x7218
0003e16a      [0x7] =  0xd014
0003e16c      [0x8] =  0xc012
0003e16e      [0x9] =  0x7010
0003e170  }
0003e170  struct UNWIND_INFO data_3e170 = 
0003e170  {
0003e170      uint8_t VersionAndFlag = 0x1
0003e171      uint8_t SizeOfProlog = 0xa
0003e172      uint8_t CountOfUnwindCodes = 0x4
0003e173      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e174  }
0003e174  uint16_t data_3e174[0x4] = 
0003e174  {
0003e174      [0x0] =  0x340a
0003e176      [0x1] =  0x0007
0003e178      [0x2] =  0x320a
0003e17a      [0x3] =  0x7006
0003e17c  }
0003e17c  struct UNWIND_INFO data_3e17c = 
0003e17c  {
0003e17c      uint8_t VersionAndFlag = 0x1
0003e17d      uint8_t SizeOfProlog = 0xa
0003e17e      uint8_t CountOfUnwindCodes = 0x4
0003e17f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e180  }
0003e180  uint16_t data_3e180[0x4] = 
0003e180  {
0003e180      [0x0] =  0x340a
0003e182      [0x1] =  0x0006
0003e184      [0x2] =  0x320a
0003e186      [0x3] =  0x7006
0003e188  }
0003e188  struct UNWIND_INFO data_3e188 = 
0003e188  {
0003e188      uint8_t VersionAndFlag = 0x1
0003e189      uint8_t SizeOfProlog = 0xf
0003e18a      uint8_t CountOfUnwindCodes = 0x6
0003e18b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e18c  }
0003e18c  uint16_t data_3e18c[0x6] = 
0003e18c  {
0003e18c      [0x0] =  0x540f
0003e18e      [0x1] =  0x000b
0003e190      [0x2] =  0x340f
0003e192      [0x3] =  0x000a
0003e194      [0x4] =  0x720f
0003e196      [0x5] =  0x700b
0003e198  }
0003e198  struct UNWIND_INFO data_3e198 = 
0003e198  {
0003e198      uint8_t VersionAndFlag = 0x1
0003e199      uint8_t SizeOfProlog = 0x17
0003e19a      uint8_t CountOfUnwindCodes = 0x8
0003e19b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e19c  }
0003e19c  uint16_t data_3e19c[0x8] = 
0003e19c  {
0003e19c      [0x0] =  0x5417
0003e19e      [0x1] =  0x000b
0003e1a0      [0x2] =  0x3417
0003e1a2      [0x3] =  0x000a
0003e1a4      [0x4] =  0x5217
0003e1a6      [0x5] =  0xc013
0003e1a8      [0x6] =  0x7011
0003e1aa      [0x7] =  0x6010
0003e1ac  }
0003e1ac  struct UNWIND_INFO data_3e1ac = 
0003e1ac  {
0003e1ac      uint8_t VersionAndFlag = 0x1
0003e1ad      uint8_t SizeOfProlog = 0x14
0003e1ae      uint8_t CountOfUnwindCodes = 0x8
0003e1af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e1b0  }
0003e1b0  uint16_t data_3e1b0[0x8] = 
0003e1b0  {
0003e1b0      [0x0] =  0x6414
0003e1b2      [0x1] =  0x000a
0003e1b4      [0x2] =  0x5414
0003e1b6      [0x3] =  0x0009
0003e1b8      [0x4] =  0x3414
0003e1ba      [0x5] =  0x0008
0003e1bc      [0x6] =  0x5214
0003e1be      [0x7] =  0x7010
0003e1c0  }
0003e1c0  struct UNWIND_INFO data_3e1c0 = 
0003e1c0  {
0003e1c0      uint8_t VersionAndFlag = 0x1
0003e1c1      uint8_t SizeOfProlog = 0x19
0003e1c2      uint8_t CountOfUnwindCodes = 0xa
0003e1c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e1c4  }
0003e1c4  uint16_t data_3e1c4[0xa] = 
0003e1c4  {
0003e1c4      [0x0] =  0xc419
0003e1c6      [0x1] =  0x000b
0003e1c8      [0x2] =  0x7419
0003e1ca      [0x3] =  0x000a
0003e1cc      [0x4] =  0x6419
0003e1ce      [0x5] =  0x0009
0003e1d0      [0x6] =  0x3419
0003e1d2      [0x7] =  0x0008
0003e1d4      [0x8] =  0x5219
0003e1d6      [0x9] =  0xd015
0003e1d8  }
0003e1d8  struct UNWIND_INFO data_3e1d8 = 
0003e1d8  {
0003e1d8      uint8_t VersionAndFlag = 0x1
0003e1d9      uint8_t SizeOfProlog = 0x2d
0003e1da      uint8_t CountOfUnwindCodes = 0xd
0003e1db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e1dc  }
0003e1dc  uint16_t data_3e1dc[0xd] = 
0003e1dc  {
0003e1dc      [0x0] =  0x782d
0003e1de      [0x1] =  0x0004
0003e1e0      [0x2] =  0x6824
0003e1e2      [0x3] =  0x0005
0003e1e4      [0x4] =  0xc211
0003e1e6      [0x5] =  0xf00d
0003e1e8      [0x6] =  0xe00b
0003e1ea      [0x7] =  0xd009
0003e1ec      [0x8] =  0xc007
0003e1ee      [0x9] =  0x7005
0003e1f0      [0xa] =  0x6004
0003e1f2      [0xb] =  0x5003
0003e1f4      [0xc] =  0x3002
0003e1f6  }

0003e1f6                                                                    00 00                                                ..

0003e1f8  struct UNWIND_INFO data_3e1f8 = 
0003e1f8  {
0003e1f8      uint8_t VersionAndFlag = 0x1
0003e1f9      uint8_t SizeOfProlog = 0x24
0003e1fa      uint8_t CountOfUnwindCodes = 0x10
0003e1fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e1fc  }
0003e1fc  uint16_t data_3e1fc[0x10] = 
0003e1fc  {
0003e1fc      [0x0] =  0x7824
0003e1fe      [0x1] =  0x0002
0003e200      [0x2] =  0x6820
0003e202      [0x3] =  0x0003
0003e204      [0x4] =  0x641c
0003e206      [0x5] =  0x0010
0003e208      [0x6] =  0x541c
0003e20a      [0x7] =  0x000f
0003e20c      [0x8] =  0x341c
0003e20e      [0x9] =  0x000e
0003e210      [0xa] =  0x721c
0003e212      [0xb] =  0xf018
0003e214      [0xc] =  0xe016
0003e216      [0xd] =  0xd014
0003e218      [0xe] =  0xc012
0003e21a      [0xf] =  0x7010
0003e21c  }
0003e21c  struct UNWIND_INFO data_3e21c = 
0003e21c  {
0003e21c      uint8_t VersionAndFlag = 0x1
0003e21d      uint8_t SizeOfProlog = 0x18
0003e21e      uint8_t CountOfUnwindCodes = 0xa
0003e21f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e220  }
0003e220  uint16_t data_3e220[0xa] = 
0003e220  {
0003e220      [0x0] =  0x6418
0003e222      [0x1] =  0x000c
0003e224      [0x2] =  0x5418
0003e226      [0x3] =  0x000b
0003e228      [0x4] =  0x3418
0003e22a      [0x5] =  0x000a
0003e22c      [0x6] =  0x5218
0003e22e      [0x7] =  0xd014
0003e230      [0x8] =  0xc012
0003e232      [0x9] =  0x7010
0003e234  }
0003e234  struct UNWIND_INFO data_3e234 = 
0003e234  {
0003e234      uint8_t VersionAndFlag = 0x1
0003e235      uint8_t SizeOfProlog = 0x14
0003e236      uint8_t CountOfUnwindCodes = 0x8
0003e237      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e238  }
0003e238  uint16_t data_3e238[0x8] = 
0003e238  {
0003e238      [0x0] =  0x6414
0003e23a      [0x1] =  0x0009
0003e23c      [0x2] =  0x5414
0003e23e      [0x3] =  0x0007
0003e240      [0x4] =  0x3414
0003e242      [0x5] =  0x0006
0003e244      [0x6] =  0x3214
0003e246      [0x7] =  0x7010
0003e248  }
0003e248  struct UNWIND_INFO data_3e248 = 
0003e248  {
0003e248      uint8_t VersionAndFlag = 0x19
0003e249      uint8_t SizeOfProlog = 0x21
0003e24a      uint8_t CountOfUnwindCodes = 0x5
0003e24b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e24c  }
0003e24c  uint16_t data_3e24c[0x5] = 
0003e24c  {
0003e24c      [0x0] =  0x340f
0003e24e      [0x1] =  0x0048
0003e250      [0x2] =  0x010f
0003e252      [0x3] =  0x0044
0003e254      [0x4] =  0x6008
0003e256  }

0003e256                                                                    00 00                                                ..

0003e258  uint32_t data_3e258 = 0x2393c

0003e25c                                                                                      10 02 00 00                              ....

0003e260  struct UNWIND_INFO data_3e260 = 
0003e260  {
0003e260      uint8_t VersionAndFlag = 0x1
0003e261      uint8_t SizeOfProlog = 0x13
0003e262      uint8_t CountOfUnwindCodes = 0x4
0003e263      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e264  }
0003e264  uint16_t data_3e264[0x4] = 
0003e264  {
0003e264      [0x0] =  0x6813
0003e266      [0x1] =  0x0006
0003e268      [0x2] =  0xd206
0003e26a      [0x3] =  0x3002
0003e26c  }
0003e26c  struct UNWIND_INFO data_3e26c = 
0003e26c  {
0003e26c      uint8_t VersionAndFlag = 0x1
0003e26d      uint8_t SizeOfProlog = 0x19
0003e26e      uint8_t CountOfUnwindCodes = 0xa
0003e26f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e270  }
0003e270  uint16_t data_3e270[0xa] = 
0003e270  {
0003e270      [0x0] =  0x7419
0003e272      [0x1] =  0x0009
0003e274      [0x2] =  0x6419
0003e276      [0x3] =  0x0008
0003e278      [0x4] =  0x5419
0003e27a      [0x5] =  0x0007
0003e27c      [0x6] =  0x3419
0003e27e      [0x7] =  0x0006
0003e280      [0x8] =  0x3219
0003e282      [0x9] =  0xc015
0003e284  }
0003e284  struct UNWIND_INFO data_3e284 = 
0003e284  {
0003e284      uint8_t VersionAndFlag = 0x19
0003e285      uint8_t SizeOfProlog = 0x24
0003e286      uint8_t CountOfUnwindCodes = 0x9
0003e287      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e288  }
0003e288  uint16_t data_3e288[0x9] = 
0003e288  {
0003e288      [0x0] =  0x0112
0003e28a      [0x1] =  0x001a
0003e28c      [0x2] =  0xe00b
0003e28e      [0x3] =  0xd009
0003e290      [0x4] =  0xc007
0003e292      [0x5] =  0x7005
0003e294      [0x6] =  0x6004
0003e296      [0x7] =  0x5003
0003e298      [0x8] =  0x3002
0003e29a  }

0003e29a                                                                                00 00                                        ..

0003e29c  uint32_t data_3e29c = 0x2393c

0003e2a0  c0 00 00 00                                                                                      ....

0003e2a4  struct UNWIND_INFO data_3e2a4 = 
0003e2a4  {
0003e2a4      uint8_t VersionAndFlag = 0x19
0003e2a5      uint8_t SizeOfProlog = 0x2b
0003e2a6      uint8_t CountOfUnwindCodes = 0xb
0003e2a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e2a8  }
0003e2a8  uint16_t data_3e2a8[0xb] = 
0003e2a8  {
0003e2a8      [0x0] =  0x5419
0003e2aa      [0x1] =  0x001e
0003e2ac      [0x2] =  0x3419
0003e2ae      [0x3] =  0x001d
0003e2b0      [0x4] =  0x0119
0003e2b2      [0x5] =  0x0016
0003e2b4      [0x6] =  0xe012
0003e2b6      [0x7] =  0xd010
0003e2b8      [0x8] =  0xc00e
0003e2ba      [0x9] =  0x700c
0003e2bc      [0xa] =  0x600b
0003e2be  }

0003e2be                                                                                            00 00                                ..

0003e2c0  uint32_t data_3e2c0 = 0x2393c

0003e2c4              a0 00 00 00                                                                              ....

0003e2c8  struct UNWIND_INFO data_3e2c8 = 
0003e2c8  {
0003e2c8      uint8_t VersionAndFlag = 0x1
0003e2c9      uint8_t SizeOfProlog = 0x54
0003e2ca      uint8_t CountOfUnwindCodes = 0x17
0003e2cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e2cc  }
0003e2cc  uint16_t data_3e2cc[0x17] = 
0003e2cc  {
0003e2cc      [0x00] =  0xc854
0003e2ce      [0x01] =  0x0006
0003e2d0      [0x02] =  0xb84e
0003e2d2      [0x03] =  0x0007
0003e2d4      [0x04] =  0x9848
0003e2d6      [0x05] =  0x0008
0003e2d8      [0x06] =  0x8843
0003e2da      [0x07] =  0x0009
0003e2dc      [0x08] =  0x7829
0003e2de      [0x09] =  0x000a
0003e2e0      [0x0a] =  0x6825
0003e2e2      [0x0b] =  0x000b
0003e2e4      [0x0c] =  0x3419
0003e2e6      [0x0d] =  0x0020
0003e2e8      [0x0e] =  0x0119
0003e2ea      [0x0f] =  0x0018
0003e2ec      [0x10] =  0xf012
0003e2ee      [0x11] =  0xe010
0003e2f0      [0x12] =  0xd00e
0003e2f2      [0x13] =  0xc00c
0003e2f4      [0x14] =  0x700a
0003e2f6      [0x15] =  0x6009
0003e2f8      [0x16] =  0x5008
0003e2fa  }

0003e2fa                                                                                00 00                                        ..

0003e2fc  struct UNWIND_INFO data_3e2fc = 
0003e2fc  {
0003e2fc      uint8_t VersionAndFlag = 0x1
0003e2fd      uint8_t SizeOfProlog = 0x1f
0003e2fe      uint8_t CountOfUnwindCodes = 0xd
0003e2ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e300  }
0003e300  uint16_t data_3e300[0xd] = 
0003e300  {
0003e300      [0x0] =  0x641f
0003e302      [0x1] =  0x002f
0003e304      [0x2] =  0x541f
0003e306      [0x3] =  0x002e
0003e308      [0x4] =  0x341f
0003e30a      [0x5] =  0x002d
0003e30c      [0x6] =  0x011f
0003e30e      [0x7] =  0x0026
0003e310      [0x8] =  0xf018
0003e312      [0x9] =  0xe016
0003e314      [0xa] =  0xd014
0003e316      [0xb] =  0xc012
0003e318      [0xc] =  0x7010
0003e31a  }

0003e31a                                                                                00 00                                        ..

0003e31c  struct UNWIND_INFO data_3e31c = 
0003e31c  {
0003e31c      uint8_t VersionAndFlag = 0x1
0003e31d      uint8_t SizeOfProlog = 0x2c
0003e31e      uint8_t CountOfUnwindCodes = 0x10
0003e31f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e320  }
0003e320  uint16_t data_3e320[0x10] = 
0003e320  {
0003e320      [0x0] =  0x782c
0003e322      [0x1] =  0x0004
0003e324      [0x2] =  0x6828
0003e326      [0x3] =  0x0005
0003e328      [0x4] =  0x641c
0003e32a      [0x5] =  0x0014
0003e32c      [0x6] =  0x541c
0003e32e      [0x7] =  0x0013
0003e330      [0x8] =  0x341c
0003e332      [0x9] =  0x0012
0003e334      [0xa] =  0xb21c
0003e336      [0xb] =  0xf018
0003e338      [0xc] =  0xe016
0003e33a      [0xd] =  0xd014
0003e33c      [0xe] =  0xc012
0003e33e      [0xf] =  0x7010
0003e340  }
0003e340  struct UNWIND_INFO data_3e340 = 
0003e340  {
0003e340      uint8_t VersionAndFlag = 0x19
0003e341      uint8_t SizeOfProlog = 0x35
0003e342      uint8_t CountOfUnwindCodes = 0x10
0003e343      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e344  }
0003e344  uint16_t data_3e344[0x10] = 
0003e344  {
0003e344      [0x0] =  0x8826
0003e346      [0x1] =  0x0005
0003e348      [0x2] =  0x7821
0003e34a      [0x3] =  0x0006
0003e34c      [0x4] =  0x681d
0003e34e      [0x5] =  0x0007
0003e350      [0x6] =  0x3419
0003e352      [0x7] =  0x001b
0003e354      [0x8] =  0xf219
0003e356      [0x9] =  0xf012
0003e358      [0xa] =  0xe010
0003e35a      [0xb] =  0xd00e
0003e35c      [0xc] =  0xc00c
0003e35e      [0xd] =  0x700a
0003e360      [0xe] =  0x6009
0003e362      [0xf] =  0x5008
0003e364  }
0003e364  uint32_t data_3e364 = 0x2393c

0003e368                          40 00 00 00                                                                      @...

0003e36c  struct UNWIND_INFO data_3e36c = 
0003e36c  {
0003e36c      uint8_t VersionAndFlag = 0x19
0003e36d      uint8_t SizeOfProlog = 0x2b
0003e36e      uint8_t CountOfUnwindCodes = 0xb
0003e36f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e370  }
0003e370  uint16_t data_3e370[0xb] = 
0003e370  {
0003e370      [0x0] =  0x3419
0003e372      [0x1] =  0x001f
0003e374      [0x2] =  0x0119
0003e376      [0x3] =  0x0016
0003e378      [0x4] =  0xf012
0003e37a      [0x5] =  0xe010
0003e37c      [0x6] =  0xd00e
0003e37e      [0x7] =  0xc00c
0003e380      [0x8] =  0x700a
0003e382      [0x9] =  0x6009
0003e384      [0xa] =  0x5008
0003e386  }

0003e386                    00 00                                                                                ..

0003e388  uint32_t data_3e388 = 0x2393c

0003e38c                                      a0 00 00 00                                                              ....

0003e390  struct UNWIND_INFO data_3e390 = 
0003e390  {
0003e390      uint8_t VersionAndFlag = 0x19
0003e391      uint8_t SizeOfProlog = 0x30
0003e392      uint8_t CountOfUnwindCodes = 0xd
0003e393      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e394  }
0003e394  uint16_t data_3e394[0xd] = 
0003e394  {
0003e394      [0x0] =  0x681e
0003e396      [0x1] =  0x0009
0003e398      [0x2] =  0x541a
0003e39a      [0x3] =  0x001b
0003e39c      [0x4] =  0x341a
0003e39e      [0x5] =  0x001a
0003e3a0      [0x6] =  0x011a
0003e3a2      [0x7] =  0x0014
0003e3a4      [0x8] =  0xe013
0003e3a6      [0x9] =  0xd011
0003e3a8      [0xa] =  0xc00f
0003e3aa      [0xb] =  0x700d
0003e3ac      [0xc] =  0x600c
0003e3ae  }

0003e3ae                                            00 00                                                                ..

0003e3b0  uint32_t data_3e3b0 = 0x2393c

0003e3b4                                                              80 00 00 00                                              ....

0003e3b8  struct UNWIND_INFO data_3e3b8 = 
0003e3b8  {
0003e3b8      uint8_t VersionAndFlag = 0x1
0003e3b9      uint8_t SizeOfProlog = 0x3e
0003e3ba      uint8_t CountOfUnwindCodes = 0x11
0003e3bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e3bc  }
0003e3bc  uint16_t data_3e3bc[0x11] = 
0003e3bc  {
0003e3bc      [0x00] =  0x883e
0003e3be      [0x01] =  0x0016
0003e3c0      [0x02] =  0x7839
0003e3c2      [0x03] =  0x0017
0003e3c4      [0x04] =  0x6835
0003e3c6      [0x05] =  0x0018
0003e3c8      [0x06] =  0x3419
0003e3ca      [0x07] =  0x003a
0003e3cc      [0x08] =  0x0119
0003e3ce      [0x09] =  0x0032
0003e3d0      [0x0a] =  0xf012
0003e3d2      [0x0b] =  0xe010
0003e3d4      [0x0c] =  0xd00e
0003e3d6      [0x0d] =  0xc00c
0003e3d8      [0x0e] =  0x700a
0003e3da      [0x0f] =  0x6009
0003e3dc      [0x10] =  0x5008
0003e3de  }

0003e3de                                                                                            00 00                                ..

0003e3e0  struct UNWIND_INFO data_3e3e0 = 
0003e3e0  {
0003e3e0      uint8_t VersionAndFlag = 0x1
0003e3e1      uint8_t SizeOfProlog = 0x24
0003e3e2      uint8_t CountOfUnwindCodes = 0xe
0003e3e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e3e4  }
0003e3e4  uint16_t data_3e3e4[0xe] = 
0003e3e4  {
0003e3e4      [0x0] =  0x7824
0003e3e6      [0x1] =  0x0002
0003e3e8      [0x2] =  0x681d
0003e3ea      [0x3] =  0x0003
0003e3ec      [0x4] =  0x7419
0003e3ee      [0x5] =  0x000d
0003e3f0      [0x6] =  0x6419
0003e3f2      [0x7] =  0x000c
0003e3f4      [0x8] =  0x5419
0003e3f6      [0x9] =  0x000b
0003e3f8      [0xa] =  0x3419
0003e3fa      [0xb] =  0x000a
0003e3fc      [0xc] =  0x7219
0003e3fe      [0xd] =  0xc015
0003e400  }
0003e400  struct UNWIND_INFO data_3e400 = 
0003e400  {
0003e400      uint8_t VersionAndFlag = 0x1
0003e401      uint8_t SizeOfProlog = 0x39
0003e402      uint8_t CountOfUnwindCodes = 0xf
0003e403      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e404  }
0003e404  uint16_t data_3e404[0xf] = 
0003e404  {
0003e404      [0x0] =  0x8839
0003e406      [0x1] =  0x000a
0003e408      [0x2] =  0x7428
0003e40a      [0x3] =  0x001d
0003e40c      [0x4] =  0x6428
0003e40e      [0x5] =  0x001c
0003e410      [0x6] =  0x5428
0003e412      [0x7] =  0x001b
0003e414      [0x8] =  0x3428
0003e416      [0x9] =  0x001a
0003e418      [0xa] =  0x0128
0003e41a      [0xb] =  0x0016
0003e41c      [0xc] =  0xe021
0003e41e      [0xd] =  0xd01f
0003e420      [0xe] =  0xc01d
0003e422  }

0003e422        00 00                                                                                        ..

0003e424  struct UNWIND_INFO data_3e424 = 
0003e424  {
0003e424      uint8_t VersionAndFlag = 0x1
0003e425      uint8_t SizeOfProlog = 0x2a
0003e426      uint8_t CountOfUnwindCodes = 0xe
0003e427      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e428  }
0003e428  uint16_t data_3e428[0xe] = 
0003e428  {
0003e428      [0x0] =  0x782a
0003e42a      [0x1] =  0x000d
0003e42c      [0x2] =  0x6826
0003e42e      [0x3] =  0x000e
0003e430      [0x4] =  0x0119
0003e432      [0x5] =  0x001f
0003e434      [0x6] =  0xf012
0003e436      [0x7] =  0xe010
0003e438      [0x8] =  0xd00e
0003e43a      [0x9] =  0xc00c
0003e43c      [0xa] =  0x700a
0003e43e      [0xb] =  0x6009
0003e440      [0xc] =  0x5008
0003e442      [0xd] =  0x3007
0003e444  }
0003e444  struct UNWIND_INFO data_3e444 = 
0003e444  {
0003e444      uint8_t VersionAndFlag = 0x1
0003e445      uint8_t SizeOfProlog = 0xf
0003e446      uint8_t CountOfUnwindCodes = 0x6
0003e447      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e448  }
0003e448  uint16_t data_3e448[0x6] = 
0003e448  {
0003e448      [0x0] =  0x640f
0003e44a      [0x1] =  0x0009
0003e44c      [0x2] =  0x340f
0003e44e      [0x3] =  0x0008
0003e450      [0x4] =  0x520f
0003e452      [0x5] =  0x700b
0003e454  }
0003e454  struct UNWIND_INFO data_3e454 = 
0003e454  {
0003e454      uint8_t VersionAndFlag = 0x19
0003e455      uint8_t SizeOfProlog = 0x1b
0003e456      uint8_t CountOfUnwindCodes = 0x3
0003e457      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e458  }
0003e458  uint16_t data_3e458[0x3] = 
0003e458  {
0003e458      [0x0] =  0x0109
0003e45a      [0x1] =  0x0018
0003e45c      [0x2] =  0x3002
0003e45e  }

0003e45e                                                                                            00 00                                ..

0003e460  uint32_t data_3e460 = 0x2393c

0003e464              b0 00 00 00                                                                              ....

0003e468  struct UNWIND_INFO data_3e468 = 
0003e468  {
0003e468      uint8_t VersionAndFlag = 0x1
0003e469      uint8_t SizeOfProlog = 0x18
0003e46a      uint8_t CountOfUnwindCodes = 0xa
0003e46b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e46c  }
0003e46c  uint16_t data_3e46c[0xa] = 
0003e46c  {
0003e46c      [0x0] =  0x6418
0003e46e      [0x1] =  0x000a
0003e470      [0x2] =  0x5418
0003e472      [0x3] =  0x0009
0003e474      [0x4] =  0x3418
0003e476      [0x5] =  0x0008
0003e478      [0x6] =  0x3218
0003e47a      [0x7] =  0xd014
0003e47c      [0x8] =  0xc012
0003e47e      [0x9] =  0x7010
0003e480  }
0003e480  struct UNWIND_INFO data_3e480 = 
0003e480  {
0003e480      uint8_t VersionAndFlag = 0x1
0003e481      uint8_t SizeOfProlog = 0x19
0003e482      uint8_t CountOfUnwindCodes = 0xa
0003e483      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e484  }
0003e484  uint16_t data_3e484[0xa] = 
0003e484  {
0003e484      [0x0] =  0x7419
0003e486      [0x1] =  0x000d
0003e488      [0x2] =  0x6419
0003e48a      [0x3] =  0x000c
0003e48c      [0x4] =  0x5419
0003e48e      [0x5] =  0x000b
0003e490      [0x6] =  0x3419
0003e492      [0x7] =  0x000a
0003e494      [0x8] =  0x7219
0003e496      [0x9] =  0xc015
0003e498  }
0003e498  struct UNWIND_INFO data_3e498 = 
0003e498  {
0003e498      uint8_t VersionAndFlag = 0x1
0003e499      uint8_t SizeOfProlog = 0x12
0003e49a      uint8_t CountOfUnwindCodes = 0x4
0003e49b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e49c  }
0003e49c  uint16_t data_3e49c[0x4] = 
0003e49c  {
0003e49c      [0x0] =  0x3412
0003e49e      [0x1] =  0x000e
0003e4a0      [0x2] =  0xb212
0003e4a2      [0x3] =  0x700e
0003e4a4  }
0003e4a4  struct UNWIND_INFO data_3e4a4 = 
0003e4a4  {
0003e4a4      uint8_t VersionAndFlag = 0x1
0003e4a5      uint8_t SizeOfProlog = 0x19
0003e4a6      uint8_t CountOfUnwindCodes = 0xa
0003e4a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e4a8  }
0003e4a8  uint16_t data_3e4a8[0xa] = 
0003e4a8  {
0003e4a8      [0x0] =  0x7419
0003e4aa      [0x1] =  0x0009
0003e4ac      [0x2] =  0x6419
0003e4ae      [0x3] =  0x0008
0003e4b0      [0x4] =  0x5419
0003e4b2      [0x5] =  0x0007
0003e4b4      [0x6] =  0x3419
0003e4b6      [0x7] =  0x0006
0003e4b8      [0x8] =  0x3219
0003e4ba      [0x9] =  0xe015
0003e4bc  }
0003e4bc  struct UNWIND_INFO data_3e4bc = 
0003e4bc  {
0003e4bc      uint8_t VersionAndFlag = 0x19
0003e4bd      uint8_t SizeOfProlog = 0x2b
0003e4be      uint8_t CountOfUnwindCodes = 0xb
0003e4bf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e4c0  }
0003e4c0  uint16_t data_3e4c0[0xb] = 
0003e4c0  {
0003e4c0      [0x0] =  0x5419
0003e4c2      [0x1] =  0x0023
0003e4c4      [0x2] =  0x3419
0003e4c6      [0x3] =  0x0022
0003e4c8      [0x4] =  0x0119
0003e4ca      [0x5] =  0x001a
0003e4cc      [0x6] =  0xe012
0003e4ce      [0x7] =  0xd010
0003e4d0      [0x8] =  0xc00e
0003e4d2      [0x9] =  0x700c
0003e4d4      [0xa] =  0x600b
0003e4d6  }

0003e4d6                                                                    00 00                                                ..

0003e4d8  uint32_t data_3e4d8 = 0x2393c

0003e4dc                                                                                      c0 00 00 00                              ....

0003e4e0  struct UNWIND_INFO data_3e4e0 = 
0003e4e0  {
0003e4e0      uint8_t VersionAndFlag = 0x1
0003e4e1      uint8_t SizeOfProlog = 0x2a
0003e4e2      uint8_t CountOfUnwindCodes = 0xa
0003e4e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e4e4  }
0003e4e4  uint16_t data_3e4e4[0xa] = 
0003e4e4  {
0003e4e4      [0x0] =  0x982a
0003e4e6      [0x1] =  0x0002
0003e4e8      [0x2] =  0x8825
0003e4ea      [0x3] =  0x0003
0003e4ec      [0x4] =  0x7810
0003e4ee      [0x5] =  0x0004
0003e4f0      [0x6] =  0x680c
0003e4f2      [0x7] =  0x0005
0003e4f4      [0x8] =  0xb208
0003e4f6      [0x9] =  0x3004
0003e4f8  }
0003e4f8  struct UNWIND_INFO data_3e4f8 = 
0003e4f8  {
0003e4f8      uint8_t VersionAndFlag = 0x1
0003e4f9      uint8_t SizeOfProlog = 0x10
0003e4fa      uint8_t CountOfUnwindCodes = 0x6
0003e4fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e4fc  }
0003e4fc  uint16_t data_3e4fc[0x6] = 
0003e4fc  {
0003e4fc      [0x0] =  0x6410
0003e4fe      [0x1] =  0x000b
0003e500      [0x2] =  0x3410
0003e502      [0x3] =  0x000a
0003e504      [0x4] =  0x7210
0003e506      [0x5] =  0x700c
0003e508  }
0003e508  struct UNWIND_INFO data_3e508 = 
0003e508  {
0003e508      uint8_t VersionAndFlag = 0x19
0003e509      uint8_t SizeOfProlog = 0x25
0003e50a      uint8_t CountOfUnwindCodes = 0xa
0003e50b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e50c  }
0003e50c  uint16_t data_3e50c[0xa] = 
0003e50c  {
0003e50c      [0x0] =  0x5416
0003e50e      [0x1] =  0x0016
0003e510      [0x2] =  0x3416
0003e512      [0x3] =  0x0015
0003e514      [0x4] =  0xd216
0003e516      [0x5] =  0xe012
0003e518      [0x6] =  0xd010
0003e51a      [0x7] =  0xc00e
0003e51c      [0x8] =  0x700c
0003e51e      [0x9] =  0x600b
0003e520  }
0003e520  uint32_t data_3e520 = 0x2393c

0003e524              60 00 00 00                                                                              `...

0003e528  struct UNWIND_INFO data_3e528 = 
0003e528  {
0003e528      uint8_t VersionAndFlag = 0x19
0003e529      uint8_t SizeOfProlog = 0x1e
0003e52a      uint8_t CountOfUnwindCodes = 0x6
0003e52b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e52c  }
0003e52c  uint16_t data_3e52c[0x6] = 
0003e52c  {
0003e52c      [0x0] =  0xf20f
0003e52e      [0x1] =  0xd008
0003e530      [0x2] =  0xc006
0003e532      [0x3] =  0x6004
0003e534      [0x4] =  0x5003
0003e536      [0x5] =  0x3002
0003e538  }
0003e538  uint32_t data_3e538 = 0x2393c

0003e53c                                                                                      70 00 00 00                              p...

0003e540  struct UNWIND_INFO data_3e540 = 
0003e540  {
0003e540      uint8_t VersionAndFlag = 0x19
0003e541      uint8_t SizeOfProlog = 0x21
0003e542      uint8_t CountOfUnwindCodes = 0x5
0003e543      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e544  }
0003e544  uint16_t data_3e544[0x5] = 
0003e544  {
0003e544      [0x0] =  0x340f
0003e546      [0x1] =  0x0047
0003e548      [0x2] =  0x010f
0003e54a      [0x3] =  0x0044
0003e54c      [0x4] =  0x7008
0003e54e  }

0003e54e                                            00 00                                                                ..

0003e550  uint32_t data_3e550 = 0x2393c

0003e554                                                              10 02 00 00                                              ....

0003e558  struct UNWIND_INFO data_3e558 = 
0003e558  {
0003e558      uint8_t VersionAndFlag = 0x1
0003e559      uint8_t SizeOfProlog = 0x7
0003e55a      uint8_t CountOfUnwindCodes = 0x1
0003e55b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e55c  }
0003e55c  uint16_t data_3e55c[0x1] = 
0003e55c  {
0003e55c      [0x0] =  0x8207
0003e55e  }

0003e55e                                                                                            00 00                                ..

0003e560  struct UNWIND_INFO data_3e560 = 
0003e560  {
0003e560      uint8_t VersionAndFlag = 0x19
0003e561      uint8_t SizeOfProlog = 0x19
0003e562      uint8_t CountOfUnwindCodes = 0x4
0003e563      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e564  }
0003e564  uint16_t data_3e564[0x4] = 
0003e564  {
0003e564      [0x0] =  0x340a
0003e566      [0x1] =  0x0011
0003e568      [0x2] =  0xd20a
0003e56a      [0x3] =  0x7006
0003e56c  }
0003e56c  uint32_t data_3e56c = 0x2393c

0003e570                                                  60 00 00 00                                                      `...

0003e574  struct UNWIND_INFO data_3e574 = 
0003e574  {
0003e574      uint8_t VersionAndFlag = 0x19
0003e575      uint8_t SizeOfProlog = 0x15
0003e576      uint8_t CountOfUnwindCodes = 0x2
0003e577      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e578  }
0003e578  uint16_t data_3e578[0x2] = 
0003e578  {
0003e578      [0x0] =  0xd206
0003e57a      [0x1] =  0x3002
0003e57c  }
0003e57c  uint32_t data_3e57c = 0x2393c

0003e580  60 00 00 00                                                                                      `...

0003e584  struct UNWIND_INFO data_3e584 = 
0003e584  {
0003e584      uint8_t VersionAndFlag = 0x19
0003e585      uint8_t SizeOfProlog = 0x1e
0003e586      uint8_t CountOfUnwindCodes = 0x6
0003e587      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e588  }
0003e588  uint16_t data_3e588[0x6] = 
0003e588  {
0003e588      [0x0] =  0x640f
0003e58a      [0x1] =  0x0012
0003e58c      [0x2] =  0x340f
0003e58e      [0x3] =  0x0011
0003e590      [0x4] =  0xd20f
0003e592      [0x5] =  0x700b
0003e594  }
0003e594  uint32_t data_3e594 = 0x2393c

0003e598                                                                          60 00 00 00                                      `...

0003e59c  struct UNWIND_INFO data_3e59c = 
0003e59c  {
0003e59c      uint8_t VersionAndFlag = 0x1
0003e59d      uint8_t SizeOfProlog = 0x19
0003e59e      uint8_t CountOfUnwindCodes = 0xa
0003e59f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e5a0  }
0003e5a0  uint16_t data_3e5a0[0xa] = 
0003e5a0  {
0003e5a0      [0x0] =  0x7419
0003e5a2      [0x1] =  0x000b
0003e5a4      [0x2] =  0x6419
0003e5a6      [0x3] =  0x000a
0003e5a8      [0x4] =  0x5419
0003e5aa      [0x5] =  0x0009
0003e5ac      [0x6] =  0x3419
0003e5ae      [0x7] =  0x0008
0003e5b0      [0x8] =  0x5219
0003e5b2      [0x9] =  0xd015
0003e5b4  }
0003e5b4  struct UNWIND_INFO data_3e5b4 = 
0003e5b4  {
0003e5b4      uint8_t VersionAndFlag = 0x1
0003e5b5      uint8_t SizeOfProlog = 0x14
0003e5b6      uint8_t CountOfUnwindCodes = 0x8
0003e5b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e5b8  }
0003e5b8  uint16_t data_3e5b8[0x8] = 
0003e5b8  {
0003e5b8      [0x0] =  0x6414
0003e5ba      [0x1] =  0x000c
0003e5bc      [0x2] =  0x5414
0003e5be      [0x3] =  0x000b
0003e5c0      [0x4] =  0x3414
0003e5c2      [0x5] =  0x000a
0003e5c4      [0x6] =  0x7214
0003e5c6      [0x7] =  0x7010
0003e5c8  }
0003e5c8  struct UNWIND_INFO data_3e5c8 = 
0003e5c8  {
0003e5c8      uint8_t VersionAndFlag = 0x19
0003e5c9      uint8_t SizeOfProlog = 0x15
0003e5ca      uint8_t CountOfUnwindCodes = 0x2
0003e5cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e5cc  }
0003e5cc  uint16_t data_3e5cc[0x2] = 
0003e5cc  {
0003e5cc      [0x0] =  0x5206
0003e5ce      [0x1] =  0x3002
0003e5d0  }
0003e5d0  uint32_t data_3e5d0 = 0x2393c

0003e5d4                                                              28 00 00 00                                              (...

0003e5d8  struct UNWIND_INFO data_3e5d8 = 
0003e5d8  {
0003e5d8      uint8_t VersionAndFlag = 0x1
0003e5d9      uint8_t SizeOfProlog = 0x1c
0003e5da      uint8_t CountOfUnwindCodes = 0xb
0003e5db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e5dc  }
0003e5dc  uint16_t data_3e5dc[0xb] = 
0003e5dc  {
0003e5dc      [0x0] =  0x341c
0003e5de      [0x1] =  0x004b
0003e5e0      [0x2] =  0x011c
0003e5e2      [0x3] =  0x0042
0003e5e4      [0x4] =  0xf015
0003e5e6      [0x5] =  0xe013
0003e5e8      [0x6] =  0xd011
0003e5ea      [0x7] =  0xc00f
0003e5ec      [0x8] =  0x700d
0003e5ee      [0x9] =  0x600c
0003e5f0      [0xa] =  0x500b
0003e5f2  }

0003e5f2                                                        00 00                                                        ..

0003e5f4  struct UNWIND_INFO data_3e5f4 = 
0003e5f4  {
0003e5f4      uint8_t VersionAndFlag = 0x1
0003e5f5      uint8_t SizeOfProlog = 0x21
0003e5f6      uint8_t CountOfUnwindCodes = 0xd
0003e5f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e5f8  }
0003e5f8  uint16_t data_3e5f8[0xd] = 
0003e5f8  {
0003e5f8      [0x0] =  0x6821
0003e5fa      [0x1] =  0x0008
0003e5fc      [0x2] =  0x541a
0003e5fe      [0x3] =  0x001a
0003e600      [0x4] =  0x341a
0003e602      [0x5] =  0x0019
0003e604      [0x6] =  0x011a
0003e606      [0x7] =  0x0012
0003e608      [0x8] =  0xe013
0003e60a      [0x9] =  0xd011
0003e60c      [0xa] =  0xc00f
0003e60e      [0xb] =  0x700d
0003e610      [0xc] =  0x600c
0003e612  }

0003e612                                                        00 00                                                        ..

0003e614  struct UNWIND_INFO data_3e614 = 
0003e614  {
0003e614      uint8_t VersionAndFlag = 0x1
0003e615      uint8_t SizeOfProlog = 0x29
0003e616      uint8_t CountOfUnwindCodes = 0x8
0003e617      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e618  }
0003e618  uint16_t data_3e618[0x8] = 
0003e618  {
0003e618      [0x0] =  0x7829
0003e61a      [0x1] =  0x0006
0003e61c      [0x2] =  0x6825
0003e61e      [0x3] =  0x0007
0003e620      [0x4] =  0x340f
0003e622      [0x5] =  0x0014
0003e624      [0x6] =  0xf20f
0003e626      [0x7] =  0x7008
0003e628  }
0003e628  struct UNWIND_INFO data_3e628 = 
0003e628  {
0003e628      uint8_t VersionAndFlag = 0x19
0003e629      uint8_t SizeOfProlog = 0x50
0003e62a      uint8_t CountOfUnwindCodes = 0x19
0003e62b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e62c  }
0003e62c  uint16_t data_3e62c[0x19] = 
0003e62c  {
0003e62c      [0x00] =  0xf83e
0003e62e      [0x01] =  0x0012
0003e630      [0x02] =  0xa836
0003e632      [0x03] =  0x0013
0003e634      [0x04] =  0x9831
0003e636      [0x05] =  0x0014
0003e638      [0x06] =  0x882c
0003e63a      [0x07] =  0x0015
0003e63c      [0x08] =  0x7827
0003e63e      [0x09] =  0x0016
0003e640      [0x0a] =  0x6823
0003e642      [0x0b] =  0x0017
0003e644      [0x0c] =  0x641f
0003e646      [0x0d] =  0x0039
0003e648      [0x0e] =  0x541f
0003e64a      [0x0f] =  0x0038
0003e64c      [0x10] =  0x341f
0003e64e      [0x11] =  0x0037
0003e650      [0x12] =  0x011f
0003e652      [0x13] =  0x0030
0003e654      [0x14] =  0xf018
0003e656      [0x15] =  0xe016
0003e658      [0x16] =  0xd014
0003e65a      [0x17] =  0xc012
0003e65c      [0x18] =  0x7010
0003e65e  }

0003e65e                                                                                            00 00                                ..

0003e660  uint32_t data_3e660 = 0x2393c

0003e664              10 01 00 00                                                                              ....

0003e668  struct UNWIND_INFO data_3e668 = 
0003e668  {
0003e668      uint8_t VersionAndFlag = 0x1
0003e669      uint8_t SizeOfProlog = 0x36
0003e66a      uint8_t CountOfUnwindCodes = 0x10
0003e66b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e66c  }
0003e66c  uint16_t data_3e66c[0x10] = 
0003e66c  {
0003e66c      [0x0] =  0x7836
0003e66e      [0x1] =  0x0002
0003e670      [0x2] =  0x682b
0003e672      [0x3] =  0x0003
0003e674      [0x4] =  0x641c
0003e676      [0x5] =  0x0010
0003e678      [0x6] =  0x541c
0003e67a      [0x7] =  0x000f
0003e67c      [0x8] =  0x341c
0003e67e      [0x9] =  0x000e
0003e680      [0xa] =  0x721c
0003e682      [0xb] =  0xf018
0003e684      [0xc] =  0xe016
0003e686      [0xd] =  0xd014
0003e688      [0xe] =  0xc012
0003e68a      [0xf] =  0x7010
0003e68c  }
0003e68c  struct UNWIND_INFO data_3e68c = 
0003e68c  {
0003e68c      uint8_t VersionAndFlag = 0x1
0003e68d      uint8_t SizeOfProlog = 0x52
0003e68e      uint8_t CountOfUnwindCodes = 0xd
0003e68f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e690  }
0003e690  uint16_t data_3e690[0xd] = 
0003e690  {
0003e690      [0x0] =  0x6852
0003e692      [0x1] =  0x0014
0003e694      [0x2] =  0x3419
0003e696      [0x3] =  0x0032
0003e698      [0x4] =  0x0119
0003e69a      [0x5] =  0x002a
0003e69c      [0x6] =  0xf012
0003e69e      [0x7] =  0xe010
0003e6a0      [0x8] =  0xd00e
0003e6a2      [0x9] =  0xc00c
0003e6a4      [0xa] =  0x700a
0003e6a6      [0xb] =  0x6009
0003e6a8      [0xc] =  0x5008
0003e6aa  }

0003e6aa                                00 00                                                                        ..

0003e6ac  struct UNWIND_INFO data_3e6ac = 
0003e6ac  {
0003e6ac      uint8_t VersionAndFlag = 0x1
0003e6ad      uint8_t SizeOfProlog = 0x31
0003e6ae      uint8_t CountOfUnwindCodes = 0xe
0003e6af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e6b0  }
0003e6b0  uint16_t data_3e6b0[0xe] = 
0003e6b0  {
0003e6b0      [0x0] =  0x6831
0003e6b2      [0x1] =  0x0003
0003e6b4      [0x2] =  0x741d
0003e6b6      [0x3] =  0x000f
0003e6b8      [0x4] =  0x641d
0003e6ba      [0x5] =  0x000e
0003e6bc      [0x6] =  0x541d
0003e6be      [0x7] =  0x000d
0003e6c0      [0x8] =  0x341d
0003e6c2      [0x9] =  0x000c
0003e6c4      [0xa] =  0x721d
0003e6c6      [0xb] =  0xe019
0003e6c8      [0xc] =  0xd017
0003e6ca      [0xd] =  0xc015
0003e6cc  }
0003e6cc  struct UNWIND_INFO data_3e6cc = 
0003e6cc  {
0003e6cc      uint8_t VersionAndFlag = 0x1
0003e6cd      uint8_t SizeOfProlog = 0x61
0003e6ce      uint8_t CountOfUnwindCodes = 0x17
0003e6cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e6d0  }
0003e6d0  uint16_t data_3e6d0[0x17] = 
0003e6d0  {
0003e6d0      [0x00] =  0xa861
0003e6d2      [0x01] =  0x0005
0003e6d4      [0x02] =  0x985c
0003e6d6      [0x03] =  0x0006
0003e6d8      [0x04] =  0x8837
0003e6da      [0x05] =  0x0007
0003e6dc      [0x06] =  0x7832
0003e6de      [0x07] =  0x0008
0003e6e0      [0x08] =  0x682e
0003e6e2      [0x09] =  0x0009
0003e6e4      [0x0a] =  0x641f
0003e6e6      [0x0b] =  0x001d
0003e6e8      [0x0c] =  0x541f
0003e6ea      [0x0d] =  0x001c
0003e6ec      [0x0e] =  0x341f
0003e6ee      [0x0f] =  0x001b
0003e6f0      [0x10] =  0x011f
0003e6f2      [0x11] =  0x0014
0003e6f4      [0x12] =  0xf018
0003e6f6      [0x13] =  0xe016
0003e6f8      [0x14] =  0xd014
0003e6fa      [0x15] =  0xc012
0003e6fc      [0x16] =  0x7010
0003e6fe  }

0003e6fe                                                                                            00 00                                ..

0003e700  struct UNWIND_INFO data_3e700 = 
0003e700  {
0003e700      uint8_t VersionAndFlag = 0x1
0003e701      uint8_t SizeOfProlog = 0x1c
0003e702      uint8_t CountOfUnwindCodes = 0xb
0003e703      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e704  }
0003e704  uint16_t data_3e704[0xb] = 
0003e704  {
0003e704      [0x0] =  0x741c
0003e706      [0x1] =  0x003b
0003e708      [0x2] =  0x641c
0003e70a      [0x3] =  0x003a
0003e70c      [0x4] =  0x541c
0003e70e      [0x5] =  0x0039
0003e710      [0x6] =  0x341c
0003e712      [0x7] =  0x0038
0003e714      [0x8] =  0x011c
0003e716      [0x9] =  0x0036
0003e718      [0xa] =  0xc015
0003e71a  }

0003e71a                                                                                00 00                                        ..

0003e71c  struct UNWIND_INFO data_3e71c = 
0003e71c  {
0003e71c      uint8_t VersionAndFlag = 0x1
0003e71d      uint8_t SizeOfProlog = 0x15
0003e71e      uint8_t CountOfUnwindCodes = 0x9
0003e71f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e720  }
0003e720  uint16_t data_3e720[0x9] = 
0003e720  {
0003e720      [0x0] =  0x3415
0003e722      [0x1] =  0x0047
0003e724      [0x2] =  0x0115
0003e726      [0x3] =  0x0040
0003e728      [0x4] =  0xe00e
0003e72a      [0x5] =  0xc00c
0003e72c      [0x6] =  0x700a
0003e72e      [0x7] =  0x6009
0003e730      [0x8] =  0x5008
0003e732  }

0003e732                                                        00 00                                                        ..

0003e734  struct UNWIND_INFO data_3e734 = 
0003e734  {
0003e734      uint8_t VersionAndFlag = 0x1
0003e735      uint8_t SizeOfProlog = 0xd
0003e736      uint8_t CountOfUnwindCodes = 0x5
0003e737      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e738  }
0003e738  uint16_t data_3e738[0x5] = 
0003e738  {
0003e738      [0x0] =  0x340d
0003e73a      [0x1] =  0x0068
0003e73c      [0x2] =  0x010d
0003e73e      [0x3] =  0x0066
0003e740      [0x4] =  0x7006
0003e742  }

0003e742        00 00                                                                                        ..

0003e744  struct UNWIND_INFO data_3e744 = 
0003e744  {
0003e744      uint8_t VersionAndFlag = 0x1
0003e745      uint8_t SizeOfProlog = 0x1d
0003e746      uint8_t CountOfUnwindCodes = 0xa
0003e747      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e748  }
0003e748  uint16_t data_3e748[0xa] = 
0003e748  {
0003e748      [0x0] =  0x341d
0003e74a      [0x1] =  0x0012
0003e74c      [0x2] =  0x721d
0003e74e      [0x3] =  0xf019
0003e750      [0x4] =  0xe017
0003e752      [0x5] =  0xd015
0003e754      [0x6] =  0xc013
0003e756      [0x7] =  0x7011
0003e758      [0x8] =  0x6010
0003e75a      [0x9] =  0x500f
0003e75c  }
0003e75c  struct UNWIND_INFO data_3e75c = 
0003e75c  {
0003e75c      uint8_t VersionAndFlag = 0x19
0003e75d      uint8_t SizeOfProlog = 0x1d
0003e75e      uint8_t CountOfUnwindCodes = 0x5
0003e75f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e760  }
0003e760  uint16_t data_3e760[0x5] = 
0003e760  {
0003e760      [0x0] =  0x010b
0003e762      [0x1] =  0x0018
0003e764      [0x2] =  0x7004
0003e766      [0x3] =  0x6003
0003e768      [0x4] =  0x3002
0003e76a  }

0003e76a                                00 00                                                                        ..

0003e76c  uint32_t data_3e76c = 0x2393c

0003e770                                                  b0 00 00 00                                                      ....

0003e774  struct UNWIND_INFO data_3e774 = 
0003e774  {
0003e774      uint8_t VersionAndFlag = 0x1
0003e775      uint8_t SizeOfProlog = 0x21
0003e776      uint8_t CountOfUnwindCodes = 0xc
0003e777      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e778  }
0003e778  uint16_t data_3e778[0xc] = 
0003e778  {
0003e778      [0x0] =  0x6821
0003e77a      [0x1] =  0x0014
0003e77c      [0x2] =  0x011a
0003e77e      [0x3] =  0x002b
0003e780      [0x4] =  0xf013
0003e782      [0x5] =  0xe011
0003e784      [0x6] =  0xd00f
0003e786      [0x7] =  0xc00d
0003e788      [0x8] =  0x700b
0003e78a      [0x9] =  0x600a
0003e78c      [0xa] =  0x5009
0003e78e      [0xb] =  0x3008
0003e790  }
0003e790  struct UNWIND_INFO data_3e790 = 
0003e790  {
0003e790      uint8_t VersionAndFlag = 0x1
0003e791      uint8_t SizeOfProlog = 0xf
0003e792      uint8_t CountOfUnwindCodes = 0x6
0003e793      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e794  }
0003e794  uint16_t data_3e794[0x6] = 
0003e794  {
0003e794      [0x0] =  0x640f
0003e796      [0x1] =  0x000b
0003e798      [0x2] =  0x340f
0003e79a      [0x3] =  0x000a
0003e79c      [0x4] =  0x720f
0003e79e      [0x5] =  0x700b
0003e7a0  }
0003e7a0  struct UNWIND_INFO data_3e7a0 = 
0003e7a0  {
0003e7a0      uint8_t VersionAndFlag = 0x1
0003e7a1      uint8_t SizeOfProlog = 0xe
0003e7a2      uint8_t CountOfUnwindCodes = 0x6
0003e7a3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e7a4  }
0003e7a4  uint16_t data_3e7a4[0x6] = 
0003e7a4  {
0003e7a4      [0x0] =  0x340e
0003e7a6      [0x1] =  0x000e
0003e7a8      [0x2] =  0x720e
0003e7aa      [0x3] =  0x700a
0003e7ac      [0x4] =  0x6009
0003e7ae      [0x5] =  0x5008
0003e7b0  }
0003e7b0  struct UNWIND_INFO data_3e7b0 = 
0003e7b0  {
0003e7b0      uint8_t VersionAndFlag = 0x1
0003e7b1      uint8_t SizeOfProlog = 0x12
0003e7b2      uint8_t CountOfUnwindCodes = 0x8
0003e7b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e7b4  }
0003e7b4  uint16_t data_3e7b4[0x8] = 
0003e7b4  {
0003e7b4      [0x0] =  0x5412
0003e7b6      [0x1] =  0x000b
0003e7b8      [0x2] =  0x3412
0003e7ba      [0x3] =  0x000a
0003e7bc      [0x4] =  0x5212
0003e7be      [0x5] =  0xc00e
0003e7c0      [0x6] =  0x700c
0003e7c2      [0x7] =  0x600b
0003e7c4  }
0003e7c4  struct UNWIND_INFO data_3e7c4 = 
0003e7c4  {
0003e7c4      uint8_t VersionAndFlag = 0x1
0003e7c5      uint8_t SizeOfProlog = 0x1d
0003e7c6      uint8_t CountOfUnwindCodes = 0x8
0003e7c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e7c8  }
0003e7c8  uint16_t data_3e7c8[0x8] = 
0003e7c8  {
0003e7c8      [0x0] =  0x641d
0003e7ca      [0x1] =  0x0008
0003e7cc      [0x2] =  0x541d
0003e7ce      [0x3] =  0x0007
0003e7d0      [0x4] =  0x341d
0003e7d2      [0x5] =  0x0006
0003e7d4      [0x6] =  0x321d
0003e7d6      [0x7] =  0x7019
0003e7d8  }
0003e7d8  struct UNWIND_INFO data_3e7d8 = 
0003e7d8  {
0003e7d8      uint8_t VersionAndFlag = 0x19
0003e7d9      uint8_t SizeOfProlog = 0x2b
0003e7da      uint8_t CountOfUnwindCodes = 0xb
0003e7db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e7dc  }
0003e7dc  uint16_t data_3e7dc[0xb] = 
0003e7dc  {
0003e7dc      [0x0] =  0x5419
0003e7de      [0x1] =  0x002a
0003e7e0      [0x2] =  0x3419
0003e7e2      [0x3] =  0x0029
0003e7e4      [0x4] =  0x0119
0003e7e6      [0x5] =  0x0022
0003e7e8      [0x6] =  0xe012
0003e7ea      [0x7] =  0xd010
0003e7ec      [0x8] =  0xc00e
0003e7ee      [0x9] =  0x700c
0003e7f0      [0xa] =  0x600b
0003e7f2  }

0003e7f2                                                        00 00                                                        ..

0003e7f4  uint32_t data_3e7f4 = 0x2393c

0003e7f8                                                                          00 01 00 00                                      ....

0003e7fc  struct UNWIND_INFO data_3e7fc = 
0003e7fc  {
0003e7fc      uint8_t VersionAndFlag = 0x19
0003e7fd      uint8_t SizeOfProlog = 0x26
0003e7fe      uint8_t CountOfUnwindCodes = 0x9
0003e7ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e800  }
0003e800  uint16_t data_3e800[0x9] = 
0003e800  {
0003e800      [0x0] =  0x3414
0003e802      [0x1] =  0x0090
0003e804      [0x2] =  0x0114
0003e806      [0x3] =  0x0088
0003e808      [0x4] =  0xe00d
0003e80a      [0x5] =  0xd00b
0003e80c      [0x6] =  0xc009
0003e80e      [0x7] =  0x7007
0003e810      [0x8] =  0x6006
0003e812  }

0003e812                                                        00 00                                                        ..

0003e814  uint32_t data_3e814 = 0x2393c

0003e818                                                                          30 04 00 00                                      0...

0003e81c  struct UNWIND_INFO data_3e81c = 
0003e81c  {
0003e81c      uint8_t VersionAndFlag = 0x19
0003e81d      uint8_t SizeOfProlog = 0x1b
0003e81e      uint8_t CountOfUnwindCodes = 0x6
0003e81f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e820  }
0003e820  uint16_t data_3e820[0x6] = 
0003e820  {
0003e820      [0x0] =  0x340c
0003e822      [0x1] =  0x000c
0003e824      [0x2] =  0x520c
0003e826      [0x3] =  0x7008
0003e828      [0x4] =  0x6007
0003e82a      [0x5] =  0x5006
0003e82c  }
0003e82c  uint32_t data_3e82c = 0x2393c

0003e830                                                  20 00 00 00                                                       ...

0003e834  struct UNWIND_INFO data_3e834 = 
0003e834  {
0003e834      uint8_t VersionAndFlag = 0x1
0003e835      uint8_t SizeOfProlog = 0x13
0003e836      uint8_t CountOfUnwindCodes = 0x8
0003e837      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e838  }
0003e838  uint16_t data_3e838[0x8] = 
0003e838  {
0003e838      [0x0] =  0x3413
0003e83a      [0x1] =  0x0016
0003e83c      [0x2] =  0xf213
0003e83e      [0x3] =  0xd00c
0003e840      [0x4] =  0xc00a
0003e842      [0x5] =  0x7008
0003e844      [0x6] =  0x6007
0003e846      [0x7] =  0x5006
0003e848  }
0003e848  struct UNWIND_INFO data_3e848 = 
0003e848  {
0003e848      uint8_t VersionAndFlag = 0x1
0003e849      uint8_t SizeOfProlog = 0x16
0003e84a      uint8_t CountOfUnwindCodes = 0xa
0003e84b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e84c  }
0003e84c  uint16_t data_3e84c[0xa] = 
0003e84c  {
0003e84c      [0x0] =  0x5416
0003e84e      [0x1] =  0x000e
0003e850      [0x2] =  0x3416
0003e852      [0x3] =  0x000d
0003e854      [0x4] =  0x5216
0003e856      [0x5] =  0xe012
0003e858      [0x6] =  0xd010
0003e85a      [0x7] =  0xc00e
0003e85c      [0x8] =  0x700c
0003e85e      [0x9] =  0x600b
0003e860  }
0003e860  struct UNWIND_INFO data_3e860 = 
0003e860  {
0003e860      uint8_t VersionAndFlag = 0x1
0003e861      uint8_t SizeOfProlog = 0x12
0003e862      uint8_t CountOfUnwindCodes = 0x8
0003e863      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e864  }
0003e864  uint16_t data_3e864[0x8] = 
0003e864  {
0003e864      [0x0] =  0x3412
0003e866      [0x1] =  0x0012
0003e868      [0x2] =  0x9212
0003e86a      [0x3] =  0xf00e
0003e86c      [0x4] =  0xc00c
0003e86e      [0x5] =  0x700a
0003e870      [0x6] =  0x6009
0003e872      [0x7] =  0x5008
0003e874  }
0003e874  struct UNWIND_INFO data_3e874 = 
0003e874  {
0003e874      uint8_t VersionAndFlag = 0x1
0003e875      uint8_t SizeOfProlog = 0x20
0003e876      uint8_t CountOfUnwindCodes = 0xc
0003e877      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e878  }
0003e878  uint16_t data_3e878[0xc] = 
0003e878  {
0003e878      [0x0] =  0x6420
0003e87a      [0x1] =  0x000e
0003e87c      [0x2] =  0x5420
0003e87e      [0x3] =  0x000d
0003e880      [0x4] =  0x3420
0003e882      [0x5] =  0x000c
0003e884      [0x6] =  0x5220
0003e886      [0x7] =  0xf01c
0003e888      [0x8] =  0xe01a
0003e88a      [0x9] =  0xd018
0003e88c      [0xa] =  0xc016
0003e88e      [0xb] =  0x7014
0003e890  }
0003e890  struct UNWIND_INFO $xdatasym = 
0003e890  {
0003e890      uint8_t VersionAndFlag = 0x1
0003e891      uint8_t SizeOfProlog = 0xd3
0003e892      uint8_t CountOfUnwindCodes = 0x18
0003e893      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e894  }
0003e894  uint16_t data_3e894[0x18] = 
0003e894  {
0003e894      [0x00] =  0xd8d3
0003e896      [0x01] =  0x0006
0003e898      [0x02] =  0xc8cd
0003e89a      [0x03] =  0x0007
0003e89c      [0x04] =  0xb8c7
0003e89e      [0x05] =  0x0008
0003e8a0      [0x06] =  0xa8bd
0003e8a2      [0x07] =  0x0009
0003e8a4      [0x08] =  0x98b4
0003e8a6      [0x09] =  0x000a
0003e8a8      [0x0a] =  0x8880
0003e8aa      [0x0b] =  0x000b
0003e8ac      [0x0c] =  0x7877
0003e8ae      [0x0d] =  0x000c
0003e8b0      [0x0e] =  0x686f
0003e8b2      [0x0f] =  0x000d
0003e8b4      [0x10] =  0x741f
0003e8b6      [0x11] =  0x001c
0003e8b8      [0x12] =  0x6417
0003e8ba      [0x13] =  0x001d
0003e8bc      [0x14] =  0x340f
0003e8be      [0x15] =  0x001e
0003e8c0      [0x16] =  0x0107
0003e8c2      [0x17] =  0x0021
0003e8c4  }
0003e8c4  struct UNWIND_INFO data_3e8c4 = 
0003e8c4  {
0003e8c4      uint8_t VersionAndFlag = 0x1
0003e8c5      uint8_t SizeOfProlog = 0xa
0003e8c6      uint8_t CountOfUnwindCodes = 0x1
0003e8c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e8c8  }
0003e8c8  uint16_t data_3e8c8[0x1] = 
0003e8c8  {
0003e8c8      [0x0] =  0xa20a
0003e8ca  }

0003e8ca                                00 00                                                                        ..

0003e8cc  struct UNWIND_INFO data_3e8cc = 
0003e8cc  {
0003e8cc      uint8_t VersionAndFlag = 0x1
0003e8cd      uint8_t SizeOfProlog = 0x18
0003e8ce      uint8_t CountOfUnwindCodes = 0xa
0003e8cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e8d0  }
0003e8d0  uint16_t data_3e8d0[0xa] = 
0003e8d0  {
0003e8d0      [0x0] =  0x6418
0003e8d2      [0x1] =  0x0011
0003e8d4      [0x2] =  0x5418
0003e8d6      [0x3] =  0x0010
0003e8d8      [0x4] =  0x3418
0003e8da      [0x5] =  0x000f
0003e8dc      [0x6] =  0x9218
0003e8de      [0x7] =  0xd014
0003e8e0      [0x8] =  0xc012
0003e8e2      [0x9] =  0x7010
0003e8e4  }
0003e8e4  struct UNWIND_INFO data_3e8e4 = 
0003e8e4  {
0003e8e4      uint8_t VersionAndFlag = 0x1
0003e8e5      uint8_t SizeOfProlog = 0x20
0003e8e6      uint8_t CountOfUnwindCodes = 0x6
0003e8e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e8e8  }
0003e8e8  uint16_t data_3e8e8[0x6] = 
0003e8e8  {
0003e8e8      [0x0] =  0x7820
0003e8ea      [0x1] =  0x0005
0003e8ec      [0x2] =  0x680b
0003e8ee      [0x3] =  0x0006
0003e8f0      [0x4] =  0xd206
0003e8f2      [0x5] =  0x3002
0003e8f4  }
0003e8f4  struct UNWIND_INFO data_3e8f4 = 
0003e8f4  {
0003e8f4      uint8_t VersionAndFlag = 0x1
0003e8f5      uint8_t SizeOfProlog = 0x76
0003e8f6      uint8_t CountOfUnwindCodes = 0x13
0003e8f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e8f8  }
0003e8f8  uint16_t data_3e8f8[0x13] = 
0003e8f8  {
0003e8f8      [0x00] =  0xa876
0003e8fa      [0x01] =  0x0005
0003e8fc      [0x02] =  0x9870
0003e8fe      [0x03] =  0x0006
0003e900      [0x04] =  0x8822
0003e902      [0x05] =  0x0007
0003e904      [0x06] =  0x781d
0003e906      [0x07] =  0x0008
0003e908      [0x08] =  0x6819
0003e90a      [0x09] =  0x0009
0003e90c      [0x0a] =  0x0115
0003e90e      [0x0b] =  0x0014
0003e910      [0x0c] =  0xf00e
0003e912      [0x0d] =  0xe00c
0003e914      [0x0e] =  0xd00a
0003e916      [0x0f] =  0xc008
0003e918      [0x10] =  0x7006
0003e91a      [0x11] =  0x6005
0003e91c      [0x12] =  0x3004
0003e91e  }

0003e91e                                                                                            00 00                                ..

0003e920  struct UNWIND_INFO data_3e920 = 
0003e920  {
0003e920      uint8_t VersionAndFlag = 0x1
0003e921      uint8_t SizeOfProlog = 0x19
0003e922      uint8_t CountOfUnwindCodes = 0x5
0003e923      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e924  }
0003e924  uint16_t data_3e924[0x5] = 
0003e924  {
0003e924      [0x0] =  0x7819
0003e926      [0x1] =  0x0000
0003e928      [0x2] =  0x6815
0003e92a      [0x3] =  0x0001
0003e92c      [0x4] =  0x4204
0003e92e  }

0003e92e                                            00 00                                                                ..

0003e930  struct UNWIND_INFO data_3e930 = 
0003e930  {
0003e930      uint8_t VersionAndFlag = 0x1
0003e931      uint8_t SizeOfProlog = 0x2b
0003e932      uint8_t CountOfUnwindCodes = 0x6
0003e933      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e934  }
0003e934  uint16_t data_3e934[0x6] = 
0003e934  {
0003e934      [0x0] =  0x782b
0003e936      [0x1] =  0x0005
0003e938      [0x2] =  0x6815
0003e93a      [0x3] =  0x0006
0003e93c      [0x4] =  0xd206
0003e93e      [0x5] =  0x7002
0003e940  }
0003e940  struct UNWIND_INFO data_3e940 = 
0003e940  {
0003e940      uint8_t VersionAndFlag = 0x1
0003e941      uint8_t SizeOfProlog = 0x29
0003e942      uint8_t CountOfUnwindCodes = 0x5
0003e943      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e944  }
0003e944  uint16_t data_3e944[0x5] = 
0003e944  {
0003e944      [0x0] =  0x7829
0003e946      [0x1] =  0x0005
0003e948      [0x2] =  0x681c
0003e94a      [0x3] =  0x0006
0003e94c      [0x4] =  0xe204
0003e94e  }

0003e94e                                            00 00                                                                ..

0003e950  struct UNWIND_INFO data_3e950 = 
0003e950  {
0003e950      uint8_t VersionAndFlag = 0x1
0003e951      uint8_t SizeOfProlog = 0x4a
0003e952      uint8_t CountOfUnwindCodes = 0xe
0003e953      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e954  }
0003e954  uint16_t data_3e954[0xe] = 
0003e954  {
0003e954      [0x0] =  0x784a
0003e956      [0x1] =  0x0005
0003e958      [0x2] =  0x6825
0003e95a      [0x3] =  0x0006
0003e95c      [0x4] =  0x3414
0003e95e      [0x5] =  0x0017
0003e960      [0x6] =  0xd214
0003e962      [0x7] =  0xf010
0003e964      [0x8] =  0xe00e
0003e966      [0x9] =  0xd00c
0003e968      [0xa] =  0xc00a
0003e96a      [0xb] =  0x7008
0003e96c      [0xc] =  0x6007
0003e96e      [0xd] =  0x5006
0003e970  }
0003e970  struct UNWIND_INFO data_3e970 = 
0003e970  {
0003e970      uint8_t VersionAndFlag = 0x1
0003e971      uint8_t SizeOfProlog = 0x29
0003e972      uint8_t CountOfUnwindCodes = 0x8
0003e973      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e974  }
0003e974  uint16_t data_3e974[0x8] = 
0003e974  {
0003e974      [0x0] =  0x8829
0003e976      [0x1] =  0x0005
0003e978      [0x2] =  0x7823
0003e97a      [0x3] =  0x0006
0003e97c      [0x4] =  0x680e
0003e97e      [0x5] =  0x0007
0003e980      [0x6] =  0xf209
0003e982      [0x7] =  0x7002
0003e984  }
0003e984  struct UNWIND_INFO data_3e984 = 
0003e984  {
0003e984      uint8_t VersionAndFlag = 0x1
0003e985      uint8_t SizeOfProlog = 0x1f
0003e986      uint8_t CountOfUnwindCodes = 0x5
0003e987      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e988  }
0003e988  uint16_t data_3e988[0x5] = 
0003e988  {
0003e988      [0x0] =  0x881f
0003e98a      [0x1] =  0x0005
0003e98c      [0x2] =  0x7816
0003e98e      [0x3] =  0x0006
0003e990      [0x4] =  0xe204
0003e992  }

0003e992                                                        00 00                                                        ..

0003e994  struct UNWIND_INFO data_3e994 = 
0003e994  {
0003e994      uint8_t VersionAndFlag = 0x1
0003e995      uint8_t SizeOfProlog = 0x14
0003e996      uint8_t CountOfUnwindCodes = 0x8
0003e997      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e998  }
0003e998  uint16_t data_3e998[0x8] = 
0003e998  {
0003e998      [0x0] =  0x7814
0003e99a      [0x1] =  0x0005
0003e99c      [0x2] =  0x680f
0003e99e      [0x3] =  0x0006
0003e9a0      [0x4] =  0x340a
0003e9a2      [0x5] =  0x0010
0003e9a4      [0x6] =  0xd20a
0003e9a6      [0x7] =  0x7006
0003e9a8  }
0003e9a8  struct UNWIND_INFO data_3e9a8 = 
0003e9a8  {
0003e9a8      uint8_t VersionAndFlag = 0x1
0003e9a9      uint8_t SizeOfProlog = 0x8
0003e9aa      uint8_t CountOfUnwindCodes = 0x2
0003e9ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e9ac  }
0003e9ac  uint16_t data_3e9ac[0x2] = 
0003e9ac  {
0003e9ac      [0x0] =  0x9208
0003e9ae      [0x1] =  0x3004
0003e9b0  }
0003e9b0  struct UNWIND_INFO data_3e9b0 = 
0003e9b0  {
0003e9b0      uint8_t VersionAndFlag = 0x19
0003e9b1      uint8_t SizeOfProlog = 0x24
0003e9b2      uint8_t CountOfUnwindCodes = 0x8
0003e9b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e9b4  }
0003e9b4  uint16_t data_3e9b4[0x8] = 
0003e9b4  {
0003e9b4      [0x0] =  0x6812
0003e9b6      [0x1] =  0x000e
0003e9b8      [0x2] =  0x010e
0003e9ba      [0x3] =  0x001f
0003e9bc      [0x4] =  0x7007
0003e9be      [0x5] =  0x6006
0003e9c0      [0x6] =  0x5005
0003e9c2      [0x7] =  0x3004
0003e9c4  }
0003e9c4  uint32_t data_3e9c4 = 0x2393c

0003e9c8                          d0 00 00 00                                                                      ....

0003e9cc  struct UNWIND_INFO data_3e9cc = 
0003e9cc  {
0003e9cc      uint8_t VersionAndFlag = 0x9
0003e9cd      uint8_t SizeOfProlog = 0x19
0003e9ce      uint8_t CountOfUnwindCodes = 0xa
0003e9cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003e9d0  }
0003e9d0  uint16_t data_3e9d0[0xa] = 
0003e9d0  {
0003e9d0      [0x0] =  0x7419
0003e9d2      [0x1] =  0x000b
0003e9d4      [0x2] =  0x6419
0003e9d6      [0x3] =  0x000a
0003e9d8      [0x4] =  0x3419
0003e9da      [0x5] =  0x0009
0003e9dc      [0x6] =  0x3219
0003e9de      [0x7] =  0xf015
0003e9e0      [0x8] =  0xe013
0003e9e2      [0x9] =  0xc011
0003e9e4  }
0003e9e4  uint32_t data_3e9e4 = 0x281f4

0003e9e8                          01 00 00 00 5f 77 02 00 68 77 02 00 9d 9c 02 00 68 77 02 00                      ...._w..hw......hw..

0003e9fc  struct UNWIND_INFO data_3e9fc = 
0003e9fc  {
0003e9fc      uint8_t VersionAndFlag = 0x1
0003e9fd      uint8_t SizeOfProlog = 0x2c
0003e9fe      uint8_t CountOfUnwindCodes = 0x13
0003e9ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea00  }
0003ea00  uint16_t data_3ea00[0x13] = 
0003ea00  {
0003ea00      [0x00] =  0x882c
0003ea02      [0x01] =  0x00fa
0003ea04      [0x02] =  0x7827
0003ea06      [0x03] =  0x00fb
0003ea08      [0x04] =  0x6823
0003ea0a      [0x05] =  0x00fc
0003ea0c      [0x06] =  0x641f
0003ea0e      [0x07] =  0x0203
0003ea10      [0x08] =  0x541f
0003ea12      [0x09] =  0x0202
0003ea14      [0x0a] =  0x341f
0003ea16      [0x0b] =  0x0201
0003ea18      [0x0c] =  0x011f
0003ea1a      [0x0d] =  0x01fa
0003ea1c      [0x0e] =  0xf018
0003ea1e      [0x0f] =  0xe016
0003ea20      [0x10] =  0xd014
0003ea22      [0x11] =  0xc012
0003ea24      [0x12] =  0x7010
0003ea26  }

0003ea26                    00 00                                                                                ..

0003ea28  struct UNWIND_INFO data_3ea28 = 
0003ea28  {
0003ea28      uint8_t VersionAndFlag = 0x1
0003ea29      uint8_t SizeOfProlog = 0x7
0003ea2a      uint8_t CountOfUnwindCodes = 0x2
0003ea2b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea2c  }
0003ea2c  uint16_t data_3ea2c[0x2] = 
0003ea2c  {
0003ea2c      [0x0] =  0x0107
0003ea2e      [0x1] =  0x0019
0003ea30  }
0003ea30  struct UNWIND_INFO data_3ea30 = 
0003ea30  {
0003ea30      uint8_t VersionAndFlag = 0x1
0003ea31      uint8_t SizeOfProlog = 0x17
0003ea32      uint8_t CountOfUnwindCodes = 0x8
0003ea33      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea34  }
0003ea34  uint16_t data_3ea34[0x8] = 
0003ea34  {
0003ea34      [0x0] =  0x5417
0003ea36      [0x1] =  0x000a
0003ea38      [0x2] =  0x3417
0003ea3a      [0x3] =  0x0009
0003ea3c      [0x4] =  0x3217
0003ea3e      [0x5] =  0xd013
0003ea40      [0x6] =  0x7011
0003ea42      [0x7] =  0x6010
0003ea44  }
0003ea44  struct UNWIND_INFO data_3ea44 = 
0003ea44  {
0003ea44      uint8_t VersionAndFlag = 0x1
0003ea45      uint8_t SizeOfProlog = 0x4
0003ea46      uint8_t CountOfUnwindCodes = 0x1
0003ea47      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea48  }
0003ea48  uint16_t data_3ea48[0x1] = 
0003ea48  {
0003ea48      [0x0] =  0x8204
0003ea4a  }

0003ea4a                                00 00                                                                        ..

0003ea4c  struct UNWIND_INFO data_3ea4c = 
0003ea4c  {
0003ea4c      uint8_t VersionAndFlag = 0x1
0003ea4d      uint8_t SizeOfProlog = 0x6
0003ea4e      uint8_t CountOfUnwindCodes = 0x2
0003ea4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea50  }
0003ea50  uint16_t data_3ea50[0x2] = 
0003ea50  {
0003ea50      [0x0] =  0x3206
0003ea52      [0x1] =  0x5002
0003ea54  }
0003ea54  struct UNWIND_INFO data_3ea54 = 
0003ea54  {
0003ea54      uint8_t VersionAndFlag = 0x9
0003ea55      uint8_t SizeOfProlog = 0xf
0003ea56      uint8_t CountOfUnwindCodes = 0x6
0003ea57      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea58  }
0003ea58  uint16_t data_3ea58[0x6] = 
0003ea58  {
0003ea58      [0x0] =  0x640f
0003ea5a      [0x1] =  0x0009
0003ea5c      [0x2] =  0x340f
0003ea5e      [0x3] =  0x0008
0003ea60      [0x4] =  0x320f
0003ea62      [0x5] =  0x700b
0003ea64  }
0003ea64  uint32_t data_3ea64 = 0x281f4

0003ea68                          01 00 00 00 62 81 02 00 69 81 02 00 9d 9c 02 00 69 81 02 00 00 00 00 00          ....b...i.......i.......

0003ea80  struct UNWIND_INFO data_3ea80 = 
0003ea80  {
0003ea80      uint8_t VersionAndFlag = 0x1
0003ea81      uint8_t SizeOfProlog = 0x4
0003ea82      uint8_t CountOfUnwindCodes = 0x1
0003ea83      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea84  }
0003ea84  uint16_t data_3ea84[0x1] = 
0003ea84  {
0003ea84      [0x0] =  0x0204
0003ea86  }

0003ea86                    00 00                                                                                ..

0003ea88  struct UNWIND_INFO data_3ea88 = 
0003ea88  {
0003ea88      uint8_t VersionAndFlag = 0x1
0003ea89      uint8_t SizeOfProlog = 0x20
0003ea8a      uint8_t CountOfUnwindCodes = 0xc
0003ea8b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003ea8c  }
0003ea8c  uint16_t data_3ea8c[0xc] = 
0003ea8c  {
0003ea8c      [0x0] =  0x6420
0003ea8e      [0x1] =  0x0011
0003ea90      [0x2] =  0x5420
0003ea92      [0x3] =  0x0010
0003ea94      [0x4] =  0x3420
0003ea96      [0x5] =  0x000e
0003ea98      [0x6] =  0x7220
0003ea9a      [0x7] =  0xf01c
0003ea9c      [0x8] =  0xe01a
0003ea9e      [0x9] =  0xd018
0003eaa0      [0xa] =  0xc016
0003eaa2      [0xb] =  0x7014
0003eaa4  }

0003eaa4              00 00 00 00                                                                              ....

0003eaa8  struct UNWIND_INFO data_3eaa8 = 
0003eaa8  {
0003eaa8      uint8_t VersionAndFlag = 0x1
0003eaa9      uint8_t SizeOfProlog = 0x0
0003eaaa      uint8_t CountOfUnwindCodes = 0x0
0003eaab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003eaac  }
0003eaac  struct UNWIND_INFO data_3eaac = 
0003eaac  {
0003eaac      uint8_t VersionAndFlag = 0x1
0003eaad      uint8_t SizeOfProlog = 0x0
0003eaae      uint8_t CountOfUnwindCodes = 0x0
0003eaaf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003eab0  }
0003eab0  struct UNWIND_INFO data_3eab0 = 
0003eab0  {
0003eab0      uint8_t VersionAndFlag = 0x1
0003eab1      uint8_t SizeOfProlog = 0x0
0003eab2      uint8_t CountOfUnwindCodes = 0x0
0003eab3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0003eab4  }
.rdata section ended  {0x3a000-0x3eab4}

.data section started  {0x3f000-0x40388}
0003f000  struct _PATCH_BUFFER HotPatchBuffer = 
0003f000  {
0003f000      uint16_t PointerIndex = 0x0
0003f002      uint16_t Fill1 = 0x0
0003f004      uint16_t BufferSize = 0x100
0003f006      uint16_t Fill2 = 0x0
0003f008      uint64_t Buffer[0x1f] = 
0003f008      {
0003f008          [0x00] =  0x0000000000000000
0003f010          [0x01] =  0x0000000000000000
0003f018          [0x02] =  0x0000000000000000
0003f020          [0x03] =  0x0000000000000000
0003f028          [0x04] =  0x0000000000000000
0003f030          [0x05] =  0x0000000000000000
0003f038          [0x06] =  0x0000000000000000
0003f040          [0x07] =  0x0000000000000000
0003f048          [0x08] =  0x0000000000000000
0003f050          [0x09] =  0x0000000000000000
0003f058          [0x0a] =  0x0000000000000000
0003f060          [0x0b] =  0x0000000000000000
0003f068          [0x0c] =  0x0000000000000000
0003f070          [0x0d] =  0x0000000000000000
0003f078          [0x0e] =  0x0000000000000000
0003f080          [0x0f] =  0x0000000000000000
0003f088          [0x10] =  0x0000000000000000
0003f090          [0x11] =  0x0000000000000000
0003f098          [0x12] =  0x0000000000000000
0003f0a0          [0x13] =  0x0000000000000000
0003f0a8          [0x14] =  0x0000000000000000
0003f0b0          [0x15] =  0x0000000000000000
0003f0b8          [0x16] =  0x0000000000000000
0003f0c0          [0x17] =  0x0000000000000000
0003f0c8          [0x18] =  0x0000000000000000
0003f0d0          [0x19] =  0x0000000000000000
0003f0d8          [0x1a] =  0x0000000000000000
0003f0e0          [0x1b] =  0x0000000000000000
0003f0e8          [0x1c] =  0x0000000000000000
0003f0f0          [0x1d] =  0x0000000000000000
0003f0f8          [0x1e] =  0x0000000000000000
0003f100      }
0003f100  }
0003f100  uint64_t __security_cookie = 0x2b992ddfa232
0003f108  uint64_t __security_cookie_complement = 0xffffd466d2205dcd
0003f110  uint32_t factoryTemp[0x4] = 
0003f110  {
0003f110      [0x0] =  0x000006f4
0003f114      [0x1] =  0x000006f4
0003f118      [0x2] =  0x000006f4
0003f11c      [0x3] =  0x000006f4
0003f120  }
0003f120  int32_t DebugPrintf_Enabled = 0x1
0003f124  uint8_t gCSFEnabled = 0x1

0003f125                 00 00 00 00 00 00 00 00 00 00 00                                                       ...........
0003f130  char* tv_ParentSymbols[0x29] = 
0003f130  {
0003f130      [0x00] = `string'::
0003f138      [0x01] = `string'::My {"My"}
0003f140      [0x02] = `string'::Panel {"Panel"}
0003f148      [0x03] = `string'::CAM0 {"CAM0"}
0003f150      [0x04] = `string'::CAM1 {"CAM1"}
0003f158      [0x05] = `string'::CAM2 {"CAM2"}
0003f160      [0x06] = `string'::CAM3 {"CAM3"}
0003f168      [0x07] = `string'::Calibration {"Calibration"}
0003f170      [0x08] = `string'::NearField {"NearField"}
0003f178      [0x09] = `string'::Border {"Border"}
0003f180      [0x0a] = `string'::Filters {"Filters"}
0003f188      [0x0b] = `string'::BackPropagation {"BackPropagation"}
0003f190      [0x0c] = `string'::Diameter_Threshold {"Diameter_Threshold"}
0003f198      [0x0d] = `string'::Drag_Threshold {"Drag_Threshold"}
0003f1a0      [0x0e] = `string'::Mouse {"Mouse"}
0003f1a8      [0x0f] = `string'::ID {"ID"}
0003f1b0      [0x10] = `string'::Production {"Production"}
0003f1b8      [0x11] = `string'::Protocol {"Protocol"}
0003f1c0      [0x12] = `string'::Sensor {"Sensor"}
0003f1c8      [0x13] = `string'::Buzzer {"Buzzer"}
0003f1d0      [0x14] = `string'::CSF {"CSF"}
0003f1d8      [0x15] = `string'::Seq0 {"Seq0"}
0003f1e0      [0x16] = `string'::Seq1 {"Seq1"}
0003f1e8      [0x17] = `string'::Seq2 {"Seq2"}
0003f1f0      [0x18] = `string'::Seq3 {"Seq3"}
0003f1f8      [0x19] = `string'::Seq4 {"Seq4"}
0003f200      [0x1a] = `string'::Seq5 {"Seq5"}
0003f208      [0x1b] = `string'::Seq6 {"Seq6"}
0003f210      [0x1c] = `string'::Seq7 {"Seq7"}
0003f218      [0x1d] = `string'::Seq8 {"Seq8"}
0003f220      [0x1e] = `string'::Seq9 {"Seq9"}
0003f228      [0x1f] = `string'::SysTemperature {"SysTemperature"}
0003f230      [0x20] = `string'::Pen {"Pen"}
0003f238      [0x21] = `string'::CamCtrl {"CamCtrl"}
0003f240      [0x22] = `string'::Bulk {"Bulk"}
0003f248      [0x23] = `string'::Podium {"Podium"}
0003f250      [0x24] = `string'::CAM4 {"CAM4"}
0003f258      [0x25] = `string'::CAM5 {"CAM5"}
0003f260      [0x26] = `string'::CAM6 {"CAM6"}
0003f268      [0x27] = `string'::CAM7 {"CAM7"}
0003f270      [0x28] = `string'::AutoCorrect {"AutoCorrect"}
0003f278  }

0003f278                                                                          00 00 00 00 00 00 00 00                          ........
0003f280  char* tv_ChildSymbols[0xe3] = 
0003f280  {
0003f280      [0x00] = `string'::
0003f288      [0x01] = `string'::
0003f290      [0x02] = `string'::
0003f298      [0x03] = `string'::
0003f2a0      [0x04] = `string'::
0003f2a8      [0x05] = `string'::
0003f2b0      [0x06] = `string'::
0003f2b8      [0x07] = `string'::
0003f2c0      [0x08] = `string'::
0003f2c8      [0x09] = `string'::
0003f2d0      [0x0a] = `string'::
0003f2d8      [0x0b] = `string'::
0003f2e0      [0x0c] = `string'::
0003f2e8      [0x0d] = `string'::
0003f2f0      [0x0e] = `string'::
0003f2f8      [0x0f] = `string'::
0003f300      [0x10] = `string'::
0003f308      [0x11] = `string'::SerialNumber {"SerialNumber"}
0003f310      [0x12] = `string'::ModelNumber {"ModelNumber"}
0003f318      [0x13] = `string'::FirmwareVersion {"FirmwareVersion"}
0003f320      [0x14] = `string'::FactoryDate {"FactoryDate"}
0003f328      [0x15] = `string'::ReworkDate {"ReworkDate"}
0003f330      [0x16] = `string'::ReworkCount {"ReworkCount"}
0003f338      [0x17] = `string'::Revision_Build {"Revision_Build"}
0003f340      [0x18] = `string'::UniqueID {"UniqueID"}
0003f348      [0x19] = `string'::Protocol {"Protocol"}
0003f350      [0x1a] = `string'::ThresholdRate {"ThresholdRate"}
0003f358      [0x1b] = `string'::thresholdUp {"thresholdUp"}
0003f360      [0x1c] = `string'::thresholdDown {"thresholdDown"}
0003f368      [0x1d] = `string'::DeadBand {"DeadBand"}
0003f370      [0x1e] = `string'::Integration {"Integration"}
0003f378      [0x1f] = `string'::InFill {"InFill"}
0003f380      [0x20] = `string'::HoldOff {"HoldOff"}
0003f388      [0x21] = `string'::Properties {"Properties"}
0003f390      [0x22] = `string'::X {u"X"}
0003f398      [0x23] = `string'::Y {u"Y"}
0003f3a0      [0x24] = `string'::Shutter0 {"Shutter0"}
0003f3a8      [0x25] = `string'::Shutter1 {"Shutter1"}
0003f3b0      [0x26] = `string'::Angle {"Angle"}
0003f3b8      [0x27] = `string'::startAperture {"startAperture"}
0003f3c0      [0x28] = `string'::stopAperture {"stopAperture"}
0003f3c8      [0x29] = `string'::Coeff0 {"Coeff0"}
0003f3d0      [0x2a] = `string'::Coeff1 {"Coeff1"}
0003f3d8      [0x2b] = `string'::Coeff2 {"Coeff2"}
0003f3e0      [0x2c] = `string'::Coeff3 {"Coeff3"}
0003f3e8      [0x2d] = `string'::Coeff4 {"Coeff4"}
0003f3f0      [0x2e] = `string'::Coeff5 {"Coeff5"}
0003f3f8      [0x2f] = `string'::Coeff6 {"Coeff6"}
0003f400      [0x30] = `string'::PixelMap0 {"PixelMap0"}
0003f408      [0x31] = `string'::PixelMap1 {"PixelMap1"}
0003f410      [0x32] = `string'::PixelMap2 {"PixelMap2"}
0003f418      [0x33] = `string'::PixelMap3 {"PixelMap3"}
0003f420      [0x34] = `string'::PixelMap4 {"PixelMap4"}
0003f428      [0x35] = `string'::PixelMap5 {"PixelMap5"}
0003f430      [0x36] = `string'::PixelMap6 {"PixelMap6"}
0003f438      [0x37] = `string'::PixelMap7 {"PixelMap7"}
0003f440      [0x38] = `string'::PixelMap8 {"PixelMap8"}
0003f448      [0x39] = `string'::PixelMap9 {"PixelMap9"}
0003f450      [0x3a] = `string'::NumberOfCalibrationPoints {"NumberOfCalibrationPoints"}
0003f458      [0x3b] = `string'::From0X {"From0X"}
0003f460      [0x3c] = `string'::From0Y {"From0Y"}
0003f468      [0x3d] = `string'::From1X {"From1X"}
0003f470      [0x3e] = `string'::From1Y {"From1Y"}
0003f478      [0x3f] = `string'::From2X {"From2X"}
0003f480      [0x40] = `string'::From2Y {"From2Y"}
0003f488      [0x41] = `string'::From3X {"From3X"}
0003f490      [0x42] = `string'::From3Y {"From3Y"}
0003f498      [0x43] = `string'::To0X {"To0X"}
0003f4a0      [0x44] = `string'::To0Y {"To0Y"}
0003f4a8      [0x45] = `string'::To1X {"To1X"}
0003f4b0      [0x46] = `string'::To1Y {"To1Y"}
0003f4b8      [0x47] = `string'::To2X {"To2X"}
0003f4c0      [0x48] = `string'::To2Y {"To2Y"}
0003f4c8      [0x49] = `string'::To3X {"To3X"}
0003f4d0      [0x4a] = `string'::To3Y {"To3Y"}
0003f4d8      [0x4b] = `string'::NumberOfCameras {"NumberOfCameras"}
0003f4e0      [0x4c] = `string'::focalLength {"focalLength"}
0003f4e8      [0x4d] = `string'::ThresholdPercent {"ThresholdPercent"}
0003f4f0      [0x4e] = `string'::spare {"spare"}
0003f4f8      [0x4f] = `string'::spare {"spare"}
0003f500      [0x50] = `string'::spare {"spare"}
0003f508      [0x51] = `string'::Version_Major {"Version_Major"}
0003f510      [0x52] = `string'::Version_Minor {"Version_Minor"}
0003f518      [0x53] = `string'::Gui_Flags {"Gui_Flags"}
0003f520      [0x54] = `string'::TotalPixels {"TotalPixels"}
0003f528      [0x55] = `string'::
0003f530      [0x56] = `string'::Cam_Edges {"Cam_Edges"}
0003f538      [0x57] = `string'::Hardware {"Hardware"}
0003f540      [0x58] = `string'::Serial_Mode {"Serial_Mode"}
0003f548      [0x59] = `string'::BaudRate {"BaudRate"}
0003f550      [0x5a] = `string'::CamOrientation {"CamOrientation"}
0003f558      [0x5b] = `string'::Cal_Key {"Cal_Key"}
0003f560      [0x5c] = `string'::Cal_Strokes {"Cal_Strokes"}
0003f568      [0x5d] = `string'::RightClickDelay {"RightClickDelay"}
0003f570      [0x5e] = `string'::DoubleClickTime {"DoubleClickTime"}
0003f578      [0x5f] = `string'::DragThreshold {"DragThreshold"}
0003f580      [0x60] = `string'::Buzzer_Time {"Buzzer_Time"}
0003f588      [0x61] = `string'::Buzzer_Tone {"Buzzer_Tone"}
0003f590      [0x62] = `string'::LowSpeedTime {"LowSpeedTime"}
0003f598      [0x63] = `string'::LowSpeedPeriod {"LowSpeedPeriod"}
0003f5a0      [0x64] = `string'::ReportType {"ReportType"}
0003f5a8      [0x65] = `string'::Mode {"Mode"}
0003f5b0      [0x66] = `string'::Hysteresis {"Hysteresis"}
0003f5b8      [0x67] = `string'::ReTouch {"ReTouch"}
0003f5c0      [0x68] = `string'::PostTouch {"PostTouch"}
0003f5c8      [0x69] = `string'::Shutter {"Shutter"}
0003f5d0      [0x6a] = `string'::Gain {"Gain"}
0003f5d8      [0x6b] = `string'::thresholdFloor {"thresholdFloor"}
0003f5e0      [0x6c] = `string'::Coeff7 {"Coeff7"}
0003f5e8      [0x6d] = `string'::Infill_Delay {"Infill_Delay"}
0003f5f0      [0x6e] = `string'::Infill_OnTime {"Infill_OnTime"}
0003f5f8      [0x6f] = `string'::Test_ID {"Test_ID"}
0003f600      [0x70] = `string'::LED0Separation {"LED0Separation"}
0003f608      [0x71] = `string'::LED1Separation {"LED1Separation"}
0003f610      [0x72] = `string'::CornerPixel {"CornerPixel"}
0003f618      [0x73] = `string'::ReportMode {"ReportMode"}
0003f620      [0x74] = `string'::spare {"spare"}
0003f628      [0x75] = `string'::spare {"spare"}
0003f630      [0x76] = `string'::spare {"spare"}
0003f638      [0x77] = `string'::spare {"spare"}
0003f640      [0x78] = `string'::Left {"Left"}
0003f648      [0x79] = `string'::Top {"Top"}
0003f650      [0x7a] = `string'::Right {"Right"}
0003f658      [0x7b] = `string'::Bottom {"Bottom"}
0003f660      [0x7c] = `string'::Min_Sample_Delay {"Min_Sample_Delay"}
0003f668      [0x7d] = `string'::Mid_Sample_Delay {"Mid_Sample_Delay"}
0003f670      [0x7e] = `string'::Max_Sample_Delay {"Max_Sample_Delay"}
0003f678      [0x7f] = `string'::Pen {"Pen"}
0003f680      [0x80] = `string'::SingleTouch {"SingleTouch"}
0003f688      [0x81] = `string'::DoubleTouch {"DoubleTouch"}
0003f690      [0x82] = `string'::MinPacketDelay {"MinPacketDelay"}
0003f698      [0x83] = `string'::PivotThreshold {"PivotThreshold"}
0003f6a0      [0x84] = `string'::Enabled {"Enabled"}
0003f6a8      [0x85] = `string'::TouchSplitThreshold {"TouchSplitThreshold"}
0003f6b0      [0x86] = `string'::TouchSplitRate {"TouchSplitRate"}
0003f6b8      [0x87] = `string'::VersionMajor {"VersionMajor"}
0003f6c0      [0x88] = `string'::VersionMinor {"VersionMinor"}
0003f6c8      [0x89] = `string'::VersionRelease {"VersionRelease"}
0003f6d0      [0x8a] = `string'::VersionBuild {"VersionBuild"}
0003f6d8      [0x8b] = `string'::StatusLED {"StatusLED"}
0003f6e0      [0x8c] = `string'::PixelMap {"PixelMap"}
0003f6e8      [0x8d] = `string'::AmbientRate {"AmbientRate"}
0003f6f0      [0x8e] = `string'::OffscreenMode {"OffscreenMode"}
0003f6f8      [0x8f] = `string'::Touch0 {"Touch0"}
0003f700      [0x90] = `string'::Touch1 {"Touch1"}
0003f708      [0x91] = `string'::AmbientSubtraction {"AmbientSubtraction"}
0003f710      [0x92] = `string'::USBVendorID {"USBVendorID"}
0003f718      [0x93] = `string'::USBProductID {"USBProductID"}
0003f720      [0x94] = `string'::USBRevision {"USBRevision"}
0003f728      [0x95] = `string'::R {u"R"}
0003f730      [0x96] = `string'::IntegrationDate {"IntegrationDate"}
0003f738      [0x97] = `string'::SystemDate {"SystemDate"}
0003f740      [0x98] = `string'::ActiveAreaX {"ActiveAreaX"}
0003f748      [0x99] = `string'::ActiveAreaY {"ActiveAreaY"}
0003f750      [0x9a] = `string'::ActiveOffsetX {"ActiveOffsetX"}
0003f758      [0x9b] = `string'::ActiveOffsetY {"ActiveOffsetY"}
0003f760      [0x9c] = `string'::DisplayResolutionX {"DisplayResolutionX"}
0003f768      [0x9d] = `string'::DisplayResolutionY {"DisplayResolutionY"}
0003f770      [0x9e] = `string'::RemoteWakeEnable {"RemoteWakeEnable"}
0003f778      [0x9f] = `string'::RemoteWakeTime {"RemoteWakeTime"}
0003f780      [0xa0] = `string'::FeatureReportMode {"FeatureReportMode"}
0003f788      [0xa1] = `string'::StreamingMode {"StreamingMode"}
0003f790      [0xa2] = `string'::BlackSubtraction {"BlackSubtraction"}
0003f798      [0xa3] = `string'::thresholdTimeFast {"thresholdTimeFast"}
0003f7a0      [0xa4] = `string'::thresholdTimeSlow {"thresholdTimeSlow"}
0003f7a8      [0xa5] = `string'::thresholdTouchSpeed {"thresholdTouchSpeed"}
0003f7b0      [0xa6] = `string'::SeqStep0 {"SeqStep0"}
0003f7b8      [0xa7] = `string'::SeqStep1 {"SeqStep1"}
0003f7c0      [0xa8] = `string'::SeqStep2 {"SeqStep2"}
0003f7c8      [0xa9] = `string'::SeqStep3 {"SeqStep3"}
0003f7d0      [0xaa] = `string'::SeqStep4 {"SeqStep4"}
0003f7d8      [0xab] = `string'::SeqStep5 {"SeqStep5"}
0003f7e0      [0xac] = `string'::SeqStep6 {"SeqStep6"}
0003f7e8      [0xad] = `string'::SeqStep7 {"SeqStep7"}
0003f7f0      [0xae] = `string'::SeqStep8 {"SeqStep8"}
0003f7f8      [0xaf] = `string'::SeqStep9 {"SeqStep9"}
0003f800      [0xb0] = `string'::SeqStep10 {"SeqStep10"}
0003f808      [0xb1] = `string'::SeqStep11 {"SeqStep11"}
0003f810      [0xb2] = `string'::SeqStep12 {"SeqStep12"}
0003f818      [0xb3] = `string'::SeqStep13 {"SeqStep13"}
0003f820      [0xb4] = `string'::SeqStep14 {"SeqStep14"}
0003f828      [0xb5] = `string'::SeqStep15 {"SeqStep15"}
0003f830      [0xb6] = `string'::NextSeq {"NextSeq"}
0003f838      [0xb7] = `string'::SeqCountDown {"SeqCountDown"}
0003f840      [0xb8] = `string'::NextSeqCountDown {"NextSeqCountDown"}
0003f848      [0xb9] = `string'::DefaultSeq {"DefaultSeq"}
0003f850      [0xba] = `string'::PenSeq {"PenSeq"}
0003f858      [0xbb] = `string'::SeqShutterOffset {"SeqShutterOffset"}
0003f860      [0xbc] = `string'::SVNRev {"SVNRev"}
0003f868      [0xbd] = `string'::FactoryTemp {"FactoryTemp"}
0003f870      [0xbe] = `string'::FactoryTestDate {"FactoryTestDate"}
0003f878      [0xbf] = `string'::FactoryTestStatus {"FactoryTestStatus"}
0003f880      [0xc0] = `string'::SyncPeriod {"SyncPeriod"}
0003f888      [0xc1] = `string'::SendDriverEnable {"SendDriverEnable"}
0003f890      [0xc2] = `string'::ProcessWaveformEnable {"ProcessWaveformEnable"}
0003f898      [0xc3] = `string'::ActiveSequence {"ActiveSequence"}
0003f8a0      [0xc4] = `string'::DriverScopesMode {"DriverScopesMode"}
0003f8a8      [0xc5] = `string'::DriverSettingsMode {"DriverSettingsMode"}
0003f8b0      [0xc6] = `string'::SeqStep16 {"SeqStep16"}
0003f8b8      [0xc7] = `string'::SeqStep17 {"SeqStep17"}
0003f8c0      [0xc8] = `string'::SeqStep18 {"SeqStep18"}
0003f8c8      [0xc9] = `string'::SeqStep19 {"SeqStep19"}
0003f8d0      [0xca] = `string'::PenShutter {"PenShutter"}
0003f8d8      [0xcb] = `string'::PenPixelMap {"PenPixelMap"}
0003f8e0      [0xcc] = `string'::PenGain {"PenGain"}
0003f8e8      [0xcd] = `string'::USBMode {"USBMode"}
0003f8f0      [0xce] = `string'::Timeout {"Timeout"}
0003f8f8      [0xcf] = `string'::Threshold {"Threshold"}
0003f900      [0xd0] = `string'::SettingsTime {"SettingsTime"}
0003f908      [0xd1] = `string'::BufferLength {"BufferLength"}
0003f910      [0xd2] = `string'::Rate {"Rate"}
0003f918      [0xd3] = `string'::Correction {"Correction"}
0003f920      [0xd4] = `string'::CamSysTemperatureOffset {"CamSysTemperatureOffset"}
0003f928      [0xd5] = `string'::DistancePower {"DistancePower"}
0003f930      [0xd6] = `string'::LuminanceScale {"LuminanceScale"}
0003f938      [0xd7] = `string'::ShutterUp {"ShutterUp"}
0003f940      [0xd8] = `string'::ShutterDown {"ShutterDown"}
0003f948      [0xd9] = `string'::ShutterMin {"ShutterMin"}
0003f950      [0xda] = `string'::ShutterMax {"ShutterMax"}
0003f958      [0xdb] = `string'::ShutterRate {"ShutterRate"}
0003f960      [0xdc] = `string'::Type {"Type"}
0003f968      [0xdd] = `string'::EdgeShift {"EdgeShift"}
0003f970      [0xde] = `string'::EdgeStretch {"EdgeStretch"}
0003f978      [0xdf] = `string'::Step {"Step"}
0003f980      [0xe0] = `string'::USBPower {"USBPower"}
0003f988      [0xe1] = `string'::end1 {"end1"}
0003f990      [0xe2] = `string'::end2 {"end2"}
0003f998  }

0003f998                                                                          00 00 00 00 00 00 00 00                          ........
0003f9a0  uint8_t ScopeData[0x40] = 
0003f9a0  {
0003f9a0      [0x00] =  0x47
0003f9a1      [0x01] =  0x3d
0003f9a2      [0x02] =  0x00
0003f9a3      [0x03] =  0x00
0003f9a4      [0x04] =  0x00
0003f9a5      [0x05] =  0x00
0003f9a6      [0x06] =  0x00
0003f9a7      [0x07] =  0x00
0003f9a8      [0x08] =  0x00
0003f9a9      [0x09] =  0x00
0003f9aa      [0x0a] =  0x00
0003f9ab      [0x0b] =  0x00
0003f9ac      [0x0c] =  0x00
0003f9ad      [0x0d] =  0x00
0003f9ae      [0x0e] =  0x00
0003f9af      [0x0f] =  0x00
0003f9b0      [0x10] =  0x00
0003f9b1      [0x11] =  0x00
0003f9b2      [0x12] =  0x00
0003f9b3      [0x13] =  0x00
0003f9b4      [0x14] =  0x00
0003f9b5      [0x15] =  0x00
0003f9b6      [0x16] =  0x00
0003f9b7      [0x17] =  0x00
0003f9b8      [0x18] =  0x00
0003f9b9      [0x19] =  0x00
0003f9ba      [0x1a] =  0x00
0003f9bb      [0x1b] =  0x00
0003f9bc      [0x1c] =  0x00
0003f9bd      [0x1d] =  0x00
0003f9be      [0x1e] =  0x00
0003f9bf      [0x1f] =  0x00
0003f9c0      [0x20] =  0x00
0003f9c1      [0x21] =  0x00
0003f9c2      [0x22] =  0x00
0003f9c3      [0x23] =  0x00
0003f9c4      [0x24] =  0x00
0003f9c5      [0x25] =  0x00
0003f9c6      [0x26] =  0x00
0003f9c7      [0x27] =  0x00
0003f9c8      [0x28] =  0x00
0003f9c9      [0x29] =  0x00
0003f9ca      [0x2a] =  0x00
0003f9cb      [0x2b] =  0x00
0003f9cc      [0x2c] =  0x00
0003f9cd      [0x2d] =  0x00
0003f9ce      [0x2e] =  0x00
0003f9cf      [0x2f] =  0x00
0003f9d0      [0x30] =  0x00
0003f9d1      [0x31] =  0x00
0003f9d2      [0x32] =  0x00
0003f9d3      [0x33] =  0x00
0003f9d4      [0x34] =  0x00
0003f9d5      [0x35] =  0x00
0003f9d6      [0x36] =  0x00
0003f9d7      [0x37] =  0x00
0003f9d8      [0x38] =  0x00
0003f9d9      [0x39] =  0x00
0003f9da      [0x3a] =  0x00
0003f9db      [0x3b] =  0x00
0003f9dc      [0x3c] =  0x00
0003f9dd      [0x3d] =  0x00
0003f9de      [0x3e] =  0x00
0003f9df      [0x3f] =  0x00
0003f9e0  }
0003f9e0  struct tv_item_t drv_tv_Items[0x20] = 
0003f9e0  {
0003f9e0      [0x00] = 
0003f9e0      {
0003f9e0          uint8_t treepath0 = 0x10
0003f9e1          uint8_t treepath1 = 0x87
0003f9e2          uint8_t typespec = 0x2
0003f9e3          uint8_t writecount = 0x1
0003f9e4      }
0003f9e4      [0x01] = 
0003f9e4      {
0003f9e4          uint8_t treepath0 = 0x10
0003f9e5          uint8_t treepath1 = 0x88
0003f9e6          uint8_t typespec = 0x2
0003f9e7          uint8_t writecount = 0x1
0003f9e8      }
0003f9e8      [0x02] = 
0003f9e8      {
0003f9e8          uint8_t treepath0 = 0x10
0003f9e9          uint8_t treepath1 = 0x89
0003f9ea          uint8_t typespec = 0x2
0003f9eb          uint8_t writecount = 0x1
0003f9ec      }
0003f9ec      [0x03] = 
0003f9ec      {
0003f9ec          uint8_t treepath0 = 0x10
0003f9ed          uint8_t treepath1 = 0x8a
0003f9ee          uint8_t typespec = 0x2
0003f9ef          uint8_t writecount = 0x1
0003f9f0      }
0003f9f0      [0x04] = 
0003f9f0      {
0003f9f0          uint8_t treepath0 = 0x10
0003f9f1          uint8_t treepath1 = 0x73
0003f9f2          uint8_t typespec = 0x2
0003f9f3          uint8_t writecount = 0x1
0003f9f4      }
0003f9f4      [0x05] = 
0003f9f4      {
0003f9f4          uint8_t treepath0 = 0x10
0003f9f5          uint8_t treepath1 = 0x57
0003f9f6          uint8_t typespec = 0x1
0003f9f7          uint8_t writecount = 0x1
0003f9f8      }
0003f9f8      [0x06] = 
0003f9f8      {
0003f9f8          uint8_t treepath0 = 0x10
0003f9f9          uint8_t treepath1 = 0x5a
0003f9fa          uint8_t typespec = 0x1
0003f9fb          uint8_t writecount = 0x1
0003f9fc      }
0003f9fc      [0x07] = 
0003f9fc      {
0003f9fc          uint8_t treepath0 = 0xc0
0003f9fd          uint8_t treepath1 = 0x7f
0003f9fe          uint8_t typespec = 0x7
0003f9ff          uint8_t writecount = 0x1
0003fa00      }
0003fa00      [0x08] = 
0003fa00      {
0003fa00          uint8_t treepath0 = 0xc0
0003fa01          uint8_t treepath1 = 0x80
0003fa02          uint8_t typespec = 0x7
0003fa03          uint8_t writecount = 0x1
0003fa04      }
0003fa04      [0x09] = 
0003fa04      {
0003fa04          uint8_t treepath0 = 0xc0
0003fa05          uint8_t treepath1 = 0x81
0003fa06          uint8_t typespec = 0x7
0003fa07          uint8_t writecount = 0x1
0003fa08      }
0003fa08      [0x0a] = 
0003fa08      {
0003fa08          uint8_t treepath0 = 0xe0
0003fa09          uint8_t treepath1 = 0x5d
0003fa0a          uint8_t typespec = 0x3
0003fa0b          uint8_t writecount = 0x1
0003fa0c      }
0003fa0c      [0x0b] = 
0003fa0c      {
0003fa0c          uint8_t treepath0 = 0xe0
0003fa0d          uint8_t treepath1 = 0x5e
0003fa0e          uint8_t typespec = 0x3
0003fa0f          uint8_t writecount = 0x1
0003fa10      }
0003fa10      [0x0c] = 
0003fa10      {
0003fa10          uint8_t treepath0 = 0xe0
0003fa11          uint8_t treepath1 = 0x5f
0003fa12          uint8_t typespec = 0x2
0003fa13          uint8_t writecount = 0x1
0003fa14      }
0003fa14      [0x0d] = 
0003fa14      {
0003fa14          uint8_t treepath0 = 0xe0
0003fa15          uint8_t treepath1 = 0x84
0003fa16          uint8_t typespec = 0x1
0003fa17          uint8_t writecount = 0x1
0003fa18      }
0003fa18      [0x0e] = 
0003fa18      {
0003fa18          uint8_t treepath0 = 0x20
0003fa19          uint8_t treepath1 = 0x22
0003fa1a          uint8_t typespec = 0x2
0003fa1b          uint8_t writecount = 0x1
0003fa1c      }
0003fa1c      [0x0f] = 
0003fa1c      {
0003fa1c          uint8_t treepath0 = 0x20
0003fa1d          uint8_t treepath1 = 0x23
0003fa1e          uint8_t typespec = 0x2
0003fa1f          uint8_t writecount = 0x1
0003fa20      }
0003fa20      [0x10] = 
0003fa20      {
0003fa20          uint8_t treepath0 = 0x70
0003fa21          uint8_t treepath1 = 0x3a
0003fa22          uint8_t typespec = 0x1
0003fa23          uint8_t writecount = 0x1
0003fa24      }
0003fa24      [0x11] = 
0003fa24      {
0003fa24          uint8_t treepath0 = 0x70
0003fa25          uint8_t treepath1 = 0x3b
0003fa26          uint8_t typespec = 0x7
0003fa27          uint8_t writecount = 0x1
0003fa28      }
0003fa28      [0x12] = 
0003fa28      {
0003fa28          uint8_t treepath0 = 0x70
0003fa29          uint8_t treepath1 = 0x3c
0003fa2a          uint8_t typespec = 0x7
0003fa2b          uint8_t writecount = 0x1
0003fa2c      }
0003fa2c      [0x13] = 
0003fa2c      {
0003fa2c          uint8_t treepath0 = 0x70
0003fa2d          uint8_t treepath1 = 0x3d
0003fa2e          uint8_t typespec = 0x7
0003fa2f          uint8_t writecount = 0x1
0003fa30      }
0003fa30      [0x14] = 
0003fa30      {
0003fa30          uint8_t treepath0 = 0x70
0003fa31          uint8_t treepath1 = 0x3e
0003fa32          uint8_t typespec = 0x7
0003fa33          uint8_t writecount = 0x1
0003fa34      }
0003fa34      [0x15] = 
0003fa34      {
0003fa34          uint8_t treepath0 = 0x70
0003fa35          uint8_t treepath1 = 0x3f
0003fa36          uint8_t typespec = 0x7
0003fa37          uint8_t writecount = 0x1
0003fa38      }
0003fa38      [0x16] = 
0003fa38      {
0003fa38          uint8_t treepath0 = 0x70
0003fa39          uint8_t treepath1 = 0x40
0003fa3a          uint8_t typespec = 0x7
0003fa3b          uint8_t writecount = 0x1
0003fa3c      }
0003fa3c      [0x17] = 
0003fa3c      {
0003fa3c          uint8_t treepath0 = 0x70
0003fa3d          uint8_t treepath1 = 0x41
0003fa3e          uint8_t typespec = 0x7
0003fa3f          uint8_t writecount = 0x1
0003fa40      }
0003fa40      [0x18] = 
0003fa40      {
0003fa40          uint8_t treepath0 = 0x70
0003fa41          uint8_t treepath1 = 0x42
0003fa42          uint8_t typespec = 0x7
0003fa43          uint8_t writecount = 0x1
0003fa44      }
0003fa44      [0x19] = 
0003fa44      {
0003fa44          uint8_t treepath0 = 0x10
0003fa45          uint8_t treepath1 = 0x91
0003fa46          uint8_t typespec = 0x1
0003fa47          uint8_t writecount = 0x1
0003fa48      }
0003fa48      [0x1a] = 
0003fa48      {
0003fa48          uint8_t treepath0 = 0x30
0003fa49          uint8_t treepath1 = 0x26
0003fa4a          uint8_t typespec = 0x7
0003fa4b          uint8_t writecount = 0x1
0003fa4c      }
0003fa4c      [0x1b] = 
0003fa4c      {
0003fa4c          uint8_t treepath0 = 0x40
0003fa4d          uint8_t treepath1 = 0x26
0003fa4e          uint8_t typespec = 0x7
0003fa4f          uint8_t writecount = 0x1
0003fa50      }
0003fa50      [0x1c] = 
0003fa50      {
0003fa50          uint8_t treepath0 = 0x50
0003fa51          uint8_t treepath1 = 0x26
0003fa52          uint8_t typespec = 0x7
0003fa53          uint8_t writecount = 0x1
0003fa54      }
0003fa54      [0x1d] = 
0003fa54      {
0003fa54          uint8_t treepath0 = 0x60
0003fa55          uint8_t treepath1 = 0x26
0003fa56          uint8_t typespec = 0x7
0003fa57          uint8_t writecount = 0x1
0003fa58      }
0003fa58      [0x1e] = 
0003fa58      {
0003fa58          uint8_t treepath0 = 0x10
0003fa59          uint8_t treepath1 = 0x6f
0003fa5a          uint8_t typespec = 0x3
0003fa5b          uint8_t writecount = 0x1
0003fa5c      }
0003fa5c      [0x1f] = 
0003fa5c      {
0003fa5c          uint8_t treepath0 = 0x0
0003fa5d          uint8_t treepath1 = 0x0
0003fa5e          uint8_t typespec = 0x0
0003fa5f          uint8_t writecount = 0x0
0003fa60      }
0003fa60  }
0003fa60  int32_t _fltused = 0x9875
0003fa64  int32_t _ldused = 0x9873

0003fa68                          00 00 00 00 00 00 00 00                                                          ........
0003fa70  uint64_t pibits[0xd] = 
0003fa70  {
0003fa70      [0x0] =  0x0000000000000000
0003fa78      [0x1] =  0x000000000000145f
0003fa80      [0x2] =  0x0000000306dc9c88
0003fa88      [0x3] =  0x00000002a53f84ea
0003fa90      [0x4] =  0x0000000fa3ea69bb
0003fa98      [0x5] =  0x000000081b6c52b3
0003faa0      [0x6] =  0x0000000278872083
0003faa8      [0x7] =  0x0000000fca2c757b
0003fab0      [0x8] =  0x0000000d778ac36e
0003fab8      [0x9] =  0x000000048dc74849
0003fac0      [0xa] =  0x0000000ba5c00c92
0003fac8      [0xb] =  0x00000005dd413a32
0003fad0      [0xc] =  0x0000000439fc3bd6
0003fad8  }
0003fad8  int64_t data_3fad8 = 0x400921fb54442d18
0003fae0  int64_t data_3fae0 = 0x3ff921fb54442d18
0003fae8  int64_t data_3fae8 = 0x3fe921fb54442d18
0003faf0  int64_t data_3faf0 = 0x4002d97c7f3321d2
0003faf8  double pi_head = 3.1415926218032837
0003fb00  double pi_tail = 3.1786509547056392e-08
0003fb08  double piby2_head = 1.5707963267948966
0003fb10  double piby2_tail = 6.123233995736766e-17
0003fb18  double pi = 3.1415926535897931
0003fb20  int64_t data_3fb20 = 0x3ff921fb54442d18
0003fb28  double piby4 = 0.78539816339744828
0003fb30  double three_piby4 = 2.3561944901923448

0003fb38                                                                          00 00 00 00 00 00 00 00                          ........
0003fb40  data_3fb40:
0003fb40  00 00 00 00 00 00 00 00 5f 14 00 00 00 00 00 00 88 9c dc 06 03 00 00 00 ea 84 3f a5 02 00 00 00  ........_.................?.....
0003fb60  bb 69 ea a3 0f 00 00 00 b3 52 6c 1b 08 00 00 00 83 20 87 78 02 00 00 00 7b 75 2c ca 0f 00 00 00  .i.......Rl...... .x....{u,.....
0003fb80  6e c3 8a 77 0d 00 00 00 49 48 c7 8d 04 00 00 00 92 0c c0 a5 0b 00 00 00 32 3a 41 dd 05 00 00 00  n..w....IH..............2:A.....
0003fba0  d6 3b fc 39 04 00 00 00                                                                          .;.9....

0003fba8  char _control87::dazSupported::~dazSupported = 0x1

0003fba9                             00 00 00 00 00 00 00                                                           .......
0003fbb0  data_3fbb0:
0003fbb0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
0003fbc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0003fbe0  a2 00 00 00 00 00 00 00 e6 03 00 00 00 00 00 00 36 00 00 00 00 00 00 00 93 03 00 00 00 00 00 00  ................6...............
0003fc00  44 02 00 00 00 00 00 00 54 00 00 00 00 00 00 00 9f 02 00 00 00 00 00 00 09 03 00 00 00 00 00 00  D.......T.......................
0003fc20  57 03 00 00 00 00 00 00 47 03 00 00 00 00 00 00 53 03 00 00 00 00 00 00 37 01 00 00 00 00 00 00  W.......G.......S.......7.......
0003fc40  c0 01 00 00 00 00 00 00 6d 03 00 00 00 00 00 00 29 02 00 00 00 00 00 00 66 01 00 00 00 00 00 00  ........m.......).......f.......
0003fc60  3c 01 00 00 00 00 00 00 0e 01 00 00 00 00 00 00 04 01 00 00 00 00 00 00 7f 00 00 00 00 00 00 00  <...............................
0003fc80  51 02 00 00 00 00 00 00 8e 01 00 00 00 00 00 00 bd 02 00 00 00 00 00 00 ae 03 00 00 00 00 00 00  Q...............................
0003fca0  c5 03 00 00 00 00 00 00 86 01 00 00 00 00 00 00 72 03 00 00 00 00 00 00 1b 01 00 00 00 00 00 00  ................r...............
0003fcc0  3a 02 00 00 00 00 00 00 09 01 00 00 00 00 00 00 dd 00 00 00 00 00 00 00 b8 00 00 00 00 00 00 00  :...............................
0003fce0  06 00 00 00 00 00 00 00 24 01 00 00 00 00 00 00 ee 02 00 00 00 00 00 00 82 02 00 00 00 00 00 00  ........$.......................
0003fd00  d1 01 00 00 00 00 00 00 48 02 00 00 00 00 00 00 cf 01 00 00 00 00 00 00 87 03 00 00 00 00 00 00  ........H.......................
0003fd20  eb 01 00 00 00 00 00 00 72 00 00 00 00 00 00 00 12 03 00 00 00 00 00 00 69 02 00 00 00 00 00 00  ........r...............i.......
0003fd40  3e 03 00 00 00 00 00 00 a2 03 00 00 00 00 00 00 23 00 00 00 00 00 00 00 7d 01 00 00 00 00 00 00  >...............#.......}.......
0003fd60  2e 01 00 00 00 00 00 00 ed 02 00 00 00 00 00 00 48 00 00 00 00 00 00 00 3a 01 00 00 00 00 00 00  ................H.......:.......
0003fd80  9c 01 00 00 00 00 00 00 c0 01 00 00 00 00 00 00 6b 02 00 00 00 00 00 00 17 01 00 00 00 00 00 00  ................k...............
0003fda0  7e 03 00 00 00 00 00 00 04 01 00 00 00 00 00 00 99 03 00 00 00 00 00 00 75 00 00 00 00 00 00 00  ~.......................u.......
0003fdc0  39 02 00 00 00 00 00 00 0d 02 00 00 00 00 00 00 33 01 00 00 00 00 00 00 7d 02 00 00 00 00 00 00  9...............3.......}.......
0003fde0  9c 00 00 00 00 00 00 00 11 02 00 00 00 00 00 00 f8 01 00 00 00 00 00 00 ef 02 00 00 00 00 00 00  ................................
0003fe00  f9 01 00 00 00 00 00 00 a0 00 00 00 00 00 00 00 b1 03 00 00 00 00 00 00 fe 03 00 00 00 00 00 00  ................................
0003fe20  97 00 00 00 00 00 00 00 ff 03 00 00 00 00 00 00 e0 01 00 00 00 00 00 00 66 01 00 00 00 00 00 00  ........................f.......
0003fe40  0f 00 00 00 00 00 00 00 bc 03 00 00 00 00 00 00 f1 02 00 00 00 00 00 00 62 00 00 00 00 00 00 00  ........................b.......
0003fe60  5a 03 00 00 00 00 00 00 29 00 00 00 00 00 00 00 d1 02 00 00 00 00 00 00 db 03 00 00 00 00 00 00  Z.......).......................
0003fe80  36 01 00 00 00 00 00 00 fb 01 00 00 00 00 00 00 f2 00 00 00 00 00 00 00 f2 01 00 00 00 00 00 00  6...............................
0003fea0  09 03 00 00 00 00 00 00 dd 02 00 00 00 00 00 00 f4 00 00 00 00 00 00 00 8f 01 00 00 00 00 00 00  ................................
0003fec0  66 03 00 00 00 00 00 00 79 02 00 00 00 00 00 00 fe 01 00 00 00 00 00 00 8b 02 00 00 00 00 00 00  f.......y.......................
0003fee0  75 01 00 00 00 00 00 00 9e 00 00 00 00 00 00 00 ac 03 00 00 00 00 00 00 fa 01 00 00 00 00 00 00  u...............................
0003ff00  e5 03 00 00 00 00 00 00 c5 03 00 00 00 00 00 00 b3 03 00 00 00 00 00 00 41 03 00 00 00 00 00 00  ........................A.......
0003ff20  39 03 00 00 00 00 00 00 de 03 00 00 00 00 00 00 a5 00 00 00 00 00 00 00 a4 00 00 00 00 00 00 00  9...............................
0003ff40  ea 02 00 00 00 00 00 00 af 01 00 00 00 00 00 00 b5 03 00 00 00 00 00 00 ec 03 00 00 00 00 00 00  ................................
0003ff60  1f 01 00 00 00 00 00 00 35 02 00 00 00 00 00 00 d0 01 00 00 00 00 00 00 15 02 00 00 00 00 00 00  ........5.......................
0003ff80  03 02 00 00 00 00 00 00 c1 00 00 00 00 00 00 00 6f 00 00 00 00 00 00 00 1e 03 00 00 00 00 00 00  ................o...............
0003ffa0  14 00 00 00 00 00 00 00                                                                          ........

0003ffa8  void* data_3ffa8 = `string'::exp {"exp"}

0003ffb0                                                  1d 00 00 00 00 00 00 00                                          ........

0003ffb8  void* data_3ffb8 = `string'::pow {"pow"}

0003ffc0  1a 00 00 00 00 00 00 00                                                                          ........

0003ffc8  void* data_3ffc8 = `string'::log {"log"}

0003ffd0                                                  1b 00 00 00 00 00 00 00                                          ........

0003ffd8  char const (* data_3ffd8)[0x6] = `string'::log10 {"log10"}

0003ffe0  1f 00 00 00 00 00 00 00                                                                          ........

0003ffe8  char const (* data_3ffe8)[0x5] = `string'::sinh {"sinh"}

0003fff0                                                  13 00 00 00 00 00 00 00                                          ........

0003fff8  char const (* data_3fff8)[0x5] = `string'::cosh {"cosh"}

00040000  21 00 00 00 00 00 00 00                                                                          !.......

00040008  char const (* data_40008)[0x5] = `string'::tanh {"tanh"}

00040010                                                  0e 00 00 00 00 00 00 00                                          ........

00040018  char const (* data_40018)[0x5] = `string'::asin {"asin"}

00040020  0d 00 00 00 00 00 00 00                                                                          ........

00040028  char const (* data_40028)[0x5] = `string'::acos {"acos"}

00040030                                                  0f 00 00 00 00 00 00 00                                          ........

00040038  char const (* data_40038)[0x5] = `string'::atan {"atan"}

00040040  10 00 00 00 00 00 00 00                                                                          ........

00040048  char const (* data_40048)[0x6] = `string'::atan2 {"atan2"}

00040050                                                  05 00 00 00 00 00 00 00                                          ........

00040058  char const (* data_40058)[0x5] = `string'::sqrt {"sqrt"}

00040060  1e 00 00 00 00 00 00 00                                                                          ........

00040068  char const (* data_40068)[0x4] = `string'::sin {"sin"}

00040070                                                  12 00 00 00 00 00 00 00                                          ........

00040078  void* data_40078 = `string'::cos {"cos"}

00040080  20 00 00 00 00 00 00 00                                                                           .......

00040088  void* data_40088 = `string'::tan {"tan"}

00040090                                                  0c 00 00 00 00 00 00 00                                          ........

00040098  char const (* data_40098)[0x5] = `string'::ceil {"ceil"}

000400a0  0b 00 00 00 00 00 00 00                                                                          ........

000400a8  char const (* data_400a8)[0x6] = `string'::floor {"floor"}

000400b0                                                  15 00 00 00 00 00 00 00                                          ........

000400b8  char const (* data_400b8)[0x5] = `string'::fabs {"fabs"}

000400c0  1c 00 00 00 00 00 00 00                                                                          ........

000400c8  char const (* data_400c8)[0x5] = `string'::modf {"modf"}

000400d0                                                  19 00 00 00 00 00 00 00                                          ........

000400d8  char const (* data_400d8)[0x6] = `string'::ldexp {"ldexp"}

000400e0  11 00 00 00 00 00 00 00                                                                          ........

000400e8  char const (* data_400e8)[0x6] = `string'::_cabs {"_cabs"}

000400f0                                                  18 00 00 00 00 00 00 00                                          ........

000400f8  char const (* data_400f8)[0x7] = `string'::_hypot {"_hypot"}

00040100  16 00 00 00 00 00 00 00                                                                          ........

00040108  char const (* data_40108)[0x5] = `string'::fmod {"fmod"}

00040110                                                  17 00 00 00 00 00 00 00                                          ........

00040118  char const (* data_40118)[0x6] = `string'::frexp {"frexp"}

00040120  22 00 00 00 00 00 00 00                                                                          ".......

00040128  void* data_40128 = `string'::_y0 {"_y0"}

00040130                                                  23 00 00 00 00 00 00 00                                          #.......

00040138  void* data_40138 = `string'::_y1 {"_y1"}

00040140  24 00 00 00 00 00 00 00                                                                          $.......

00040148  void* data_40148 = `string'::_yn {"_yn"}

00040150                                                  25 00 00 00 00 00 00 00                                          %.......

00040158  char const (* data_40158)[0x6] = `string'::_logb {"_logb"}

00040160  26 00 00 00 00 00 00 00                                                                          &.......

00040168  char const (* data_40168)[0xb] = `string'::_nextafter {"_nextafter"}
00040170  int32_t _matherr_flag = 0x2694
00040174  char data_40174 = 0x1

00040175                                                                 00 00 00 00 00 00 00 00 00 00 00                       ...........

00040180  union _dbl _d_inf = 
00040180  {
00040180      int32_t lng[0x2] = 
00040180      {
00040180          [0x0] =  0x00000000
00040184          [0x1] =  0x7ff00000
00040188      }
00040180      double dbl = inf
00040188  }
00040188  union _dbl _d_ind = 
00040188  {
00040188      int32_t lng[0x2] = 
00040188      {
00040188          [0x0] =  0x00000000
0004018c          [0x1] = -0x00080000
00040190      }
00040188      double dbl = nan
00040190  }
00040190  union _dbl _d_max = 
00040190  {
00040190      int32_t lng[0x2] = 
00040190      {
00040190          [0x0] = -0x00000001
00040194          [0x1] =  0x7fefffff
00040198      }
00040190      double dbl = 1.7976931348623157e+308
00040198  }
00040198  union _dbl _d_min = 
00040198  {
00040198      int32_t lng[0x2] = 
00040198      {
00040198          [0x0] =  0x00000000
0004019c          [0x1] =  0x00100000
000401a0      }
00040198      double dbl = 2.2250738585072014e-308
000401a0  }
000401a0  union _dbl _d_mzero = 
000401a0  {
000401a0      int32_t lng[0x2] = 
000401a0      {
000401a0          [0x0] =  0x00000000
000401a4          [0x1] = -0x80000000
000401a8      }
000401a0      double dbl = -0
000401a8  }

000401a8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

000401c0  int32_t (* TLCallbackFnc)(void*, uint32_t, void*, uint32_t) = 0x0
000401c8  void (* QueueConnectedCallback)(struct _TLIO_CONTEXT*) = 0x0
000401d0  void (* QueueDisconnectedCallback)(struct _TLIO_CONTEXT*) = 0x0
000401d8  uint32_t TLDebugFlags = 0x0
000401dc  uint32_t TLDebugLevel = 0x0
000401e0  uint32_t TLDebugSubsystem = 0x0
000401e4  uint32_t TLDbgLogRemainingLength = 0x0
000401e8  char* TLDbgCurrentBuffer = 0x0
000401f0  char* TLDbgBuffer = 0x0
000401f8  uint32_t TLDbgLogCounter = 0x0
000401fc  uint32_t TLDbgBufferLength = 0x0
00040200  uint32_t TLDbgLogFlags = 0x0
00040204  uint32_t TLDeviceAccessThreadTime = 0x0
00040208  uint32_t TLConsumerWorkerThreadTime = 0x0
0004020c  uint32_t TLReaderWorkerThreadTime = 0x0
00040210  uint32_t TLTimerWorkerThreadTime = 0x0
00040214  int32_t nDeviceInstances = 0x0
00040218  int32_t QueueCount = 0x0
0004021c  uint8_t gStreamStatus = 0x0

0004021d                                                                                         00 00 00                               ...

00040220  uint8_t (* SendInputReportCallback)(struct _NW_TRANSLIB_USERMODE_CONTEXT*, uint8_t*, int32_t) = 0x0
00040228  union _LARGE_INTEGER gStreamStatusTime = 
00040228  {
00040228      struct  = 
00040228      {
00040228          ULONG LowPart = 0x0
0004022c          LONG HighPart = 0x0
00040230      }
00040228      struct u = 
00040228      {
00040228          ULONG LowPart = 0x0
0004022c          LONG HighPart = 0x0
00040230      }
00040228      LONGLONG QuadPart = 0x0
00040230  }
00040230  int32_t __fastflag = 0x0
00040234  int32_t errno = 0x0

00040238                                                                          00 00 00 00 00 00 00 00                          ........

00040240  struct error_count_t Error_Count = 
00040240  {
00040240      int32_t cnt_verifies = 0x0
00040244      int32_t cnt_errors = 0x0
00040248      int32_t cnt_warnings = 0x0
0004024c      int32_t cnt_infos = 0x0
00040250      int32_t cnt_bugs = 0x0
00040254      int32_t cnt_BulkSyncErrors = 0x0
00040258  }

00040258                                                                          00 00 00 00 00 00 00 00                          ........

00040260  char loctempstr[0x64] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0

000402c4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

000402d0  struct _UNICODE_STRING TLRegistryPath = 
000402d0  {
000402d0      USHORT Length = 0x0
000402d2      USHORT MaximumLength = 0x0
000402d8      PWCH Buffer = 0x0
000402e0  }
000402e0  struct _NW_MEMORY_USAGE_CB TLMemoryUsage = 
000402e0  {
000402e0      uint32_t TotalNonPagedPool = 0x0
000402e4      uint32_t TotalPagedPool = 0x0
000402e8      uint32_t AllocationTable[0x7] = 
000402e8      {
000402e8          [0x0] =  0x00000000
000402ec          [0x1] =  0x00000000
000402f0          [0x2] =  0x00000000
000402f4          [0x3] =  0x00000000
000402f8          [0x4] =  0x00000000
000402fc          [0x5] =  0x00000000
00040300          [0x6] =  0x00000000
00040304      }
00040304  }

00040304              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

00040310  struct _UNICODE_STRING TLSettingsFolder = 
00040310  {
00040310      USHORT Length = 0x0
00040312      USHORT MaximumLength = 0x0
00040318      PWCH Buffer = 0x0
00040320  }
00040320  struct _ERESOURCE TLDbgLogLock = 
00040320  {
00040320      LIST_ENTRY SystemResourcesList = 
00040320      {
00040320          struct _LIST_ENTRY* Flink = 0x0
00040328          struct _LIST_ENTRY* Blink = 0x0
00040330      }
00040330      POWNER_ENTRY OwnerTable = 0x0
00040338      SHORT ActiveCount = 0x0
0004033a      union  = 
0004033a      {
0004033a          USHORT Flag = 0x0
0004033a          struct  = 
0004033a          {
0004033a              UCHAR ReservedLowFlags = 0x0
0004033b              UCHAR WaiterPriority = 0x0
0004033c          }
0004033c      }
00040340      PVOID SharedWaiters = 0x0
00040348      PVOID ExclusiveWaiters = 0x0
00040350      OWNER_ENTRY OwnerEntry = 
00040350      {
00040350          ERESOURCE_THREAD OwnerThread = 0x0
00040358          union  = 
00040358          {
00040358              struct  = 
00040358              {
00040358                  union bitfield_0 = 
00040358                  {
00040358                      uint8_t IoPriorityBoosted = 0x0
00040358                      uint8_t OwnerReferenced = 0x0
00040358                      uint8_t IoQoSPriorityBoosted = 0x0
00040358                      uint8_t OwnerCount = 0x0
00040359                  }
00040359                  union bitfield_1 = 
00040359                  {
00040359                      uint8_t OwnerCount = 0x0
0004035a                  }
0004035a                  union bitfield_2 = 
0004035a                  {
0004035a                      uint8_t OwnerCount = 0x0
0004035b                  }
0004035b                  union bitfield_3 = 
0004035b                  {
0004035b                      uint8_t OwnerCount = 0x0
0004035c                  }
0004035c              }
00040358              ULONG TableSize = 0x0
0004035c          }
00040360      }
00040360      ULONG ActiveEntries = 0x0
00040364      ULONG ContentionCount = 0x0
00040368      ULONG NumberOfSharedWaiters = 0x0
0004036c      ULONG NumberOfExclusiveWaiters = 0x0
00040370      PVOID Reserved2 = 0x0
00040378      union  = 
00040378      {
00040378          PVOID Address = 0x0
00040378          ULONG_PTR CreatorBackTraceIndex = 0x0
00040380      }
00040380      KSPIN_LOCK SpinLock = 0x0
00040388  }
.data section ended  {0x3f000-0x40388}

.pdata section started  {0x41000-0x41e88}
00041000  struct Exception_Directory_Entry __exception_directory_entries(0) = 
00041000  {
00041000      uint32_t beginAddress = 0x1008
00041004      uint32_t endAddress = 0x1518
00041008      uint32_t unwindInformation = 0x2e874
0004100c  }
0004100c  struct Exception_Directory_Entry __exception_directory_entries(1) = 
0004100c  {
0004100c      uint32_t beginAddress = 0x1520
00041010      uint32_t endAddress = 0x167e
00041014      uint32_t unwindInformation = 0x2d6f0
00041018  }
00041018  struct Exception_Directory_Entry __exception_directory_entries(2) = 
00041018  {
00041018      uint32_t beginAddress = 0x1684
0004101c      uint32_t endAddress = 0x16ad
00041020      uint32_t unwindInformation = 0x2d640
00041024  }
00041024  struct Exception_Directory_Entry __exception_directory_entries(3) = 
00041024  {
00041024      uint32_t beginAddress = 0x16b4
00041028      uint32_t endAddress = 0x1724
0004102c      uint32_t unwindInformation = 0x2dadc
00041030  }
00041030  struct Exception_Directory_Entry __exception_directory_entries(4) = 
00041030  {
00041030      uint32_t beginAddress = 0x172c
00041034      uint32_t endAddress = 0x1866
00041038      uint32_t unwindInformation = 0x2de04
0004103c  }
0004103c  struct Exception_Directory_Entry __exception_directory_entries(5) = 
0004103c  {
0004103c      uint32_t beginAddress = 0x189c
00041040      uint32_t endAddress = 0x18e7
00041044      uint32_t unwindInformation = 0x2dc90
00041048  }
00041048  struct Exception_Directory_Entry __exception_directory_entries(6) = 
00041048  {
00041048      uint32_t beginAddress = 0x18f0
0004104c      uint32_t endAddress = 0x194f
00041050      uint32_t unwindInformation = 0x2dc90
00041054  }
00041054  struct Exception_Directory_Entry __exception_directory_entries(7) = 
00041054  {
00041054      uint32_t beginAddress = 0x1958
00041058      uint32_t endAddress = 0x1998
0004105c      uint32_t unwindInformation = 0x2d640
00041060  }
00041060  struct Exception_Directory_Entry __exception_directory_entries(8) = 
00041060  {
00041060      uint32_t beginAddress = 0x19bc
00041064      uint32_t endAddress = 0x1a27
00041068      uint32_t unwindInformation = 0x2ddf8
0004106c  }
0004106c  struct Exception_Directory_Entry __exception_directory_entries(9) = 
0004106c  {
0004106c      uint32_t beginAddress = 0x1a30
00041070      uint32_t endAddress = 0x1a9d
00041074      uint32_t unwindInformation = 0x2ddf8
00041078  }
00041078  struct Exception_Directory_Entry __exception_directory_entries(10) = 
00041078  {
00041078      uint32_t beginAddress = 0x1ac4
0004107c      uint32_t endAddress = 0x1b29
00041080      uint32_t unwindInformation = 0x2d9ec
00041084  }
00041084  struct Exception_Directory_Entry __exception_directory_entries(11) = 
00041084  {
00041084      uint32_t beginAddress = 0x1b30
00041088      uint32_t endAddress = 0x1dc9
0004108c      uint32_t unwindInformation = 0x2dde4
00041090  }
00041090  struct Exception_Directory_Entry __exception_directory_entries(12) = 
00041090  {
00041090      uint32_t beginAddress = 0x1dd0
00041094      uint32_t endAddress = 0x1fd3
00041098      uint32_t unwindInformation = 0x2ddcc
0004109c  }
0004109c  struct Exception_Directory_Entry __exception_directory_entries(13) = 
0004109c  {
0004109c      uint32_t beginAddress = 0x1fdc
000410a0      uint32_t endAddress = 0x2204
000410a4      uint32_t unwindInformation = 0x2e1c0
000410a8  }
000410a8  struct Exception_Directory_Entry __exception_directory_entries(14) = 
000410a8  {
000410a8      uint32_t beginAddress = 0x220c
000410ac      uint32_t endAddress = 0x22e1
000410b0      uint32_t unwindInformation = 0x2dac4
000410b4  }
000410b4  struct Exception_Directory_Entry __exception_directory_entries(15) = 
000410b4  {
000410b4      uint32_t beginAddress = 0x22e8
000410b8      uint32_t endAddress = 0x2375
000410bc      uint32_t unwindInformation = 0x2dd48
000410c0  }
000410c0  struct Exception_Directory_Entry __exception_directory_entries(16) = 
000410c0  {
000410c0      uint32_t beginAddress = 0x237c
000410c4      uint32_t endAddress = 0x2453
000410c8      uint32_t unwindInformation = 0x2ddbc
000410cc  }
000410cc  struct Exception_Directory_Entry __exception_directory_entries(17) = 
000410cc  {
000410cc      uint32_t beginAddress = 0x245c
000410d0      uint32_t endAddress = 0x24c6
000410d4      uint32_t unwindInformation = 0x2ddf8
000410d8  }
000410d8  struct Exception_Directory_Entry __exception_directory_entries(18) = 
000410d8  {
000410d8      uint32_t beginAddress = 0x24cc
000410dc      uint32_t endAddress = 0x26fe
000410e0      uint32_t unwindInformation = 0x2e860
000410e4  }
000410e4  struct Exception_Directory_Entry __exception_directory_entries(19) = 
000410e4  {
000410e4      uint32_t beginAddress = 0x2704
000410e8      uint32_t endAddress = 0x28b3
000410ec      uint32_t unwindInformation = 0x2ddac
000410f0  }
000410f0  struct Exception_Directory_Entry __exception_directory_entries(20) = 
000410f0  {
000410f0      uint32_t beginAddress = 0x28bc
000410f4      uint32_t endAddress = 0x2a08
000410f8      uint32_t unwindInformation = 0x2dd98
000410fc  }
000410fc  struct Exception_Directory_Entry __exception_directory_entries(21) = 
000410fc  {
000410fc      uint32_t beginAddress = 0x2a10
00041100      uint32_t endAddress = 0x2a84
00041104      uint32_t unwindInformation = 0x2d7f8
00041108  }
00041108  struct Exception_Directory_Entry __exception_directory_entries(22) = 
00041108  {
00041108      uint32_t beginAddress = 0x2a8c
0004110c      uint32_t endAddress = 0x2afd
00041110      uint32_t unwindInformation = 0x2d7f8
00041114  }
00041114  struct Exception_Directory_Entry __exception_directory_entries(23) = 
00041114  {
00041114      uint32_t beginAddress = 0x2b04
00041118      uint32_t endAddress = 0x2c13
0004111c      uint32_t unwindInformation = 0x2e468
00041120  }
00041120  struct Exception_Directory_Entry __exception_directory_entries(24) = 
00041120  {
00041120      uint32_t beginAddress = 0x2c1c
00041124      uint32_t endAddress = 0x2d81
00041128      uint32_t unwindInformation = 0x2e17c
0004112c  }
0004112c  struct Exception_Directory_Entry __exception_directory_entries(25) = 
0004112c  {
0004112c      uint32_t beginAddress = 0x2d88
00041130      uint32_t endAddress = 0x2e39
00041134      uint32_t unwindInformation = 0x2d640
00041138  }
00041138  struct Exception_Directory_Entry __exception_directory_entries(26) = 
00041138  {
00041138      uint32_t beginAddress = 0x2e40
0004113c      uint32_t endAddress = 0x2fc1
00041140      uint32_t unwindInformation = 0x2daa8
00041144  }
00041144  struct Exception_Directory_Entry __exception_directory_entries(27) = 
00041144  {
00041144      uint32_t beginAddress = 0x2fc8
00041148      uint32_t endAddress = 0x312d
0004114c      uint32_t unwindInformation = 0x2da8c
00041150  }
00041150  struct Exception_Directory_Entry __exception_directory_entries(28) = 
00041150  {
00041150      uint32_t beginAddress = 0x3134
00041154      uint32_t endAddress = 0x3405
00041158      uint32_t unwindInformation = 0x2da6c
0004115c  }
0004115c  struct Exception_Directory_Entry __exception_directory_entries(29) = 
0004115c  {
0004115c      uint32_t beginAddress = 0x340c
00041160      uint32_t endAddress = 0x3569
00041164      uint32_t unwindInformation = 0x2da58
00041168  }
00041168  struct Exception_Directory_Entry __exception_directory_entries(30) = 
00041168  {
00041168      uint32_t beginAddress = 0x3570
0004116c      uint32_t endAddress = 0x3597
00041170      uint32_t unwindInformation = 0x2dd90
00041174  }
00041174  struct Exception_Directory_Entry __exception_directory_entries(31) = 
00041174  {
00041174      uint32_t beginAddress = 0x35a0
00041178      uint32_t endAddress = 0x35e3
0004117c      uint32_t unwindInformation = 0x2d640
00041180  }
00041180  struct Exception_Directory_Entry __exception_directory_entries(32) = 
00041180  {
00041180      uint32_t beginAddress = 0x35ec
00041184      uint32_t endAddress = 0x3611
00041188      uint32_t unwindInformation = 0x2d640
0004118c  }
0004118c  struct Exception_Directory_Entry __exception_directory_entries(33) = 
0004118c  {
0004118c      uint32_t beginAddress = 0x3618
00041190      uint32_t endAddress = 0x363c
00041194      uint32_t unwindInformation = 0x2d640
00041198  }
00041198  struct Exception_Directory_Entry __exception_directory_entries(34) = 
00041198  {
00041198      uint32_t beginAddress = 0x3644
0004119c      uint32_t endAddress = 0x367d
000411a0      uint32_t unwindInformation = 0x2d648
000411a4  }
000411a4  struct Exception_Directory_Entry __exception_directory_entries(35) = 
000411a4  {
000411a4      uint32_t beginAddress = 0x3684
000411a8      uint32_t endAddress = 0x36b3
000411ac      uint32_t unwindInformation = 0x2dc90
000411b0  }
000411b0  struct Exception_Directory_Entry __exception_directory_entries(36) = 
000411b0  {
000411b0      uint32_t beginAddress = 0x36bc
000411b4      uint32_t endAddress = 0x3700
000411b8      uint32_t unwindInformation = 0x2d640
000411bc  }
000411bc  struct Exception_Directory_Entry __exception_directory_entries(37) = 
000411bc  {
000411bc      uint32_t beginAddress = 0x372c
000411c0      uint32_t endAddress = 0x3796
000411c4      uint32_t unwindInformation = 0x2da48
000411c8  }
000411c8  struct Exception_Directory_Entry __exception_directory_entries(38) = 
000411c8  {
000411c8      uint32_t beginAddress = 0x379c
000411cc      uint32_t endAddress = 0x3bcb
000411d0      uint32_t unwindInformation = 0x2dd70
000411d4  }
000411d4  struct Exception_Directory_Entry __exception_directory_entries(39) = 
000411d4  {
000411d4      uint32_t beginAddress = 0x3bd4
000411d8      uint32_t endAddress = 0x3fd7
000411dc      uint32_t unwindInformation = 0x2dd50
000411e0  }
000411e0  struct Exception_Directory_Entry __exception_directory_entries(40) = 
000411e0  {
000411e0      uint32_t beginAddress = 0x3fe0
000411e4      uint32_t endAddress = 0x406b
000411e8      uint32_t unwindInformation = 0x2e1ac
000411ec  }
000411ec  struct Exception_Directory_Entry __exception_directory_entries(41) = 
000411ec  {
000411ec      uint32_t beginAddress = 0x4074
000411f0      uint32_t endAddress = 0x40fe
000411f4      uint32_t unwindInformation = 0x2e1ac
000411f8  }
000411f8  struct Exception_Directory_Entry __exception_directory_entries(42) = 
000411f8  {
000411f8      uint32_t beginAddress = 0x4104
000411fc      uint32_t endAddress = 0x414a
00041200      uint32_t unwindInformation = 0x2e17c
00041204  }
00041204  struct Exception_Directory_Entry __exception_directory_entries(43) = 
00041204  {
00041204      uint32_t beginAddress = 0x4150
00041208      uint32_t endAddress = 0x4197
0004120c      uint32_t unwindInformation = 0x2ddf8
00041210  }
00041210  struct Exception_Directory_Entry __exception_directory_entries(44) = 
00041210  {
00041210      uint32_t beginAddress = 0x41a0
00041214      uint32_t endAddress = 0x43ba
00041218      uint32_t unwindInformation = 0x2d7f8
0004121c  }
0004121c  struct Exception_Directory_Entry __exception_directory_entries(45) = 
0004121c  {
0004121c      uint32_t beginAddress = 0x43c0
00041220      uint32_t endAddress = 0x44bb
00041224      uint32_t unwindInformation = 0x2e468
00041228  }
00041228  struct Exception_Directory_Entry __exception_directory_entries(46) = 
00041228  {
00041228      uint32_t beginAddress = 0x44c4
0004122c      uint32_t endAddress = 0x461a
00041230      uint32_t unwindInformation = 0x2d7f8
00041234  }
00041234  struct Exception_Directory_Entry __exception_directory_entries(47) = 
00041234  {
00041234      uint32_t beginAddress = 0x4620
00041238      uint32_t endAddress = 0x46f6
0004123c      uint32_t unwindInformation = 0x2dc90
00041240  }
00041240  struct Exception_Directory_Entry __exception_directory_entries(48) = 
00041240  {
00041240      uint32_t beginAddress = 0x46fc
00041244      uint32_t endAddress = 0x4a24
00041248      uint32_t unwindInformation = 0x2e614
0004124c  }
0004124c  struct Exception_Directory_Entry __exception_directory_entries(49) = 
0004124c  {
0004124c      uint32_t beginAddress = 0x4af0
00041250      uint32_t endAddress = 0x4bd7
00041254      uint32_t unwindInformation = 0x2dce0
00041258  }
00041258  struct Exception_Directory_Entry __exception_directory_entries(50) = 
00041258  {
00041258      uint32_t beginAddress = 0x4be0
0004125c      uint32_t endAddress = 0x4f2e
00041260      uint32_t unwindInformation = 0x2e5f4
00041264  }
00041264  struct Exception_Directory_Entry __exception_directory_entries(51) = 
00041264  {
00041264      uint32_t beginAddress = 0x4f34
00041268      uint32_t endAddress = 0x4fc0
0004126c      uint32_t unwindInformation = 0x2dd48
00041270  }
00041270  struct Exception_Directory_Entry __exception_directory_entries(52) = 
00041270  {
00041270      uint32_t beginAddress = 0x4fc8
00041274      uint32_t endAddress = 0x52f0
00041278      uint32_t unwindInformation = 0x2da1c
0004127c  }
0004127c  struct Exception_Directory_Entry __exception_directory_entries(53) = 
0004127c  {
0004127c      uint32_t beginAddress = 0x52f8
00041280      uint32_t endAddress = 0x53b8
00041284      uint32_t unwindInformation = 0x2dc90
00041288  }
00041288  struct Exception_Directory_Entry __exception_directory_entries(54) = 
00041288  {
00041288      uint32_t beginAddress = 0x53c0
0004128c      uint32_t endAddress = 0x5634
00041290      uint32_t unwindInformation = 0x2dce0
00041294  }
00041294  struct Exception_Directory_Entry __exception_directory_entries(55) = 
00041294  {
00041294      uint32_t beginAddress = 0x563c
00041298      uint32_t endAddress = 0x5b30
0004129c      uint32_t unwindInformation = 0x2e198
000412a0  }
000412a0  struct Exception_Directory_Entry __exception_directory_entries(56) = 
000412a0  {
000412a0      uint32_t beginAddress = 0x5b38
000412a4      uint32_t endAddress = 0x5b63
000412a8      uint32_t unwindInformation = 0x2d640
000412ac  }
000412ac  struct Exception_Directory_Entry __exception_directory_entries(57) = 
000412ac  {
000412ac      uint32_t beginAddress = 0x5b6c
000412b0      uint32_t endAddress = 0x5baa
000412b4      uint32_t unwindInformation = 0x2d640
000412b8  }
000412b8  struct Exception_Directory_Entry __exception_directory_entries(58) = 
000412b8  {
000412b8      uint32_t beginAddress = 0x5bb0
000412bc      uint32_t endAddress = 0x5beb
000412c0      uint32_t unwindInformation = 0x2dc90
000412c4  }
000412c4  struct Exception_Directory_Entry __exception_directory_entries(59) = 
000412c4  {
000412c4      uint32_t beginAddress = 0x5bf4
000412c8      uint32_t endAddress = 0x5c2f
000412cc      uint32_t unwindInformation = 0x2dc90
000412d0  }
000412d0  struct Exception_Directory_Entry __exception_directory_entries(60) = 
000412d0  {
000412d0      uint32_t beginAddress = 0x5c38
000412d4      uint32_t endAddress = 0x5cc4
000412d8      uint32_t unwindInformation = 0x2e17c
000412dc  }
000412dc  struct Exception_Directory_Entry __exception_directory_entries(61) = 
000412dc  {
000412dc      uint32_t beginAddress = 0x5ccc
000412e0      uint32_t endAddress = 0x5d54
000412e4      uint32_t unwindInformation = 0x2dd38
000412e8  }
000412e8  struct Exception_Directory_Entry __exception_directory_entries(62) = 
000412e8  {
000412e8      uint32_t beginAddress = 0x5d5c
000412ec      uint32_t endAddress = 0x5d9f
000412f0      uint32_t unwindInformation = 0x2d6f0
000412f4  }
000412f4  struct Exception_Directory_Entry __exception_directory_entries(63) = 
000412f4  {
000412f4      uint32_t beginAddress = 0x5da8
000412f8      uint32_t endAddress = 0x5e4d
000412fc      uint32_t unwindInformation = 0x2e17c
00041300  }
00041300  struct Exception_Directory_Entry __exception_directory_entries(64) = 
00041300  {
00041300      uint32_t beginAddress = 0x5e54
00041304      uint32_t endAddress = 0x60f6
00041308      uint32_t unwindInformation = 0x2e188
0004130c  }
0004130c  struct Exception_Directory_Entry __exception_directory_entries(65) = 
0004130c  {
0004130c      uint32_t beginAddress = 0x60fc
00041310      uint32_t endAddress = 0x6286
00041314      uint32_t unwindInformation = 0x2dbac
00041318  }
00041318  struct Exception_Directory_Entry __exception_directory_entries(66) = 
00041318  {
00041318      uint32_t beginAddress = 0x628c
0004131c      uint32_t endAddress = 0x638e
00041320      uint32_t unwindInformation = 0x2e17c
00041324  }
00041324  struct Exception_Directory_Entry __exception_directory_entries(67) = 
00041324  {
00041324      uint32_t beginAddress = 0x6394
00041328      uint32_t endAddress = 0x64c6
0004132c      uint32_t unwindInformation = 0x2e170
00041330  }
00041330  struct Exception_Directory_Entry __exception_directory_entries(68) = 
00041330  {
00041330      uint32_t beginAddress = 0x6540
00041334      uint32_t endAddress = 0x66af
00041338      uint32_t unwindInformation = 0x2e158
0004133c  }
0004133c  struct Exception_Directory_Entry __exception_directory_entries(69) = 
0004133c  {
0004133c      uint32_t beginAddress = 0x66b8
00041340      uint32_t endAddress = 0x67d6
00041344      uint32_t unwindInformation = 0x2d640
00041348  }
00041348  struct Exception_Directory_Entry __exception_directory_entries(70) = 
00041348  {
00041348      uint32_t beginAddress = 0x67dc
0004134c      uint32_t endAddress = 0x6d08
00041350      uint32_t unwindInformation = 0x2da08
00041354  }
00041354  struct Exception_Directory_Entry __exception_directory_entries(71) = 
00041354  {
00041354      uint32_t beginAddress = 0x6d10
00041358      uint32_t endAddress = 0x6daa
0004135c      uint32_t unwindInformation = 0x2e144
00041360  }
00041360  struct Exception_Directory_Entry __exception_directory_entries(72) = 
00041360  {
00041360      uint32_t beginAddress = 0x6db0
00041364      uint32_t endAddress = 0x6eab
00041368      uint32_t unwindInformation = 0x2e7c4
0004136c  }
0004136c  struct Exception_Directory_Entry __exception_directory_entries(73) = 
0004136c  {
0004136c      uint32_t beginAddress = 0x6eb4
00041370      uint32_t endAddress = 0x7031
00041374      uint32_t unwindInformation = 0x2dd1c
00041378  }
00041378  struct Exception_Directory_Entry __exception_directory_entries(74) = 
00041378  {
00041378      uint32_t beginAddress = 0x70d4
0004137c      uint32_t endAddress = 0x7d14
00041380      uint32_t unwindInformation = 0x2e5d8
00041384  }
00041384  struct Exception_Directory_Entry __exception_directory_entries(75) = 
00041384  {
00041384      uint32_t beginAddress = 0x7d1c
00041388      uint32_t endAddress = 0x995b
0004138c      uint32_t unwindInformation = 0x2e71c
00041390  }
00041390  struct Exception_Directory_Entry __exception_directory_entries(76) = 
00041390  {
00041390      uint32_t beginAddress = 0x9964
00041394      uint32_t endAddress = 0x9e65
00041398      uint32_t unwindInformation = 0x2e700
0004139c  }
0004139c  struct Exception_Directory_Entry __exception_directory_entries(77) = 
0004139c  {
0004139c      uint32_t beginAddress = 0x9e6c
000413a0      uint32_t endAddress = 0xa016
000413a4      uint32_t unwindInformation = 0x2dd04
000413a8  }
000413a8  struct Exception_Directory_Entry __exception_directory_entries(78) = 
000413a8  {
000413a8      uint32_t beginAddress = 0xa01c
000413ac      uint32_t endAddress = 0xa141
000413b0      uint32_t unwindInformation = 0x2dce8
000413b4  }
000413b4  struct Exception_Directory_Entry __exception_directory_entries(79) = 
000413b4  {
000413b4      uint32_t beginAddress = 0xa148
000413b8      uint32_t endAddress = 0xa4b3
000413bc      uint32_t unwindInformation = 0x2e834
000413c0  }
000413c0  struct Exception_Directory_Entry __exception_directory_entries(80) = 
000413c0  {
000413c0      uint32_t beginAddress = 0xa4bc
000413c4      uint32_t endAddress = 0xa616
000413c8      uint32_t unwindInformation = 0x2e848
000413cc  }
000413cc  struct Exception_Directory_Entry __exception_directory_entries(81) = 
000413cc  {
000413cc      uint32_t beginAddress = 0xa61c
000413d0      uint32_t endAddress = 0xa74d
000413d4      uint32_t unwindInformation = 0x2d6f0
000413d8  }
000413d8  struct Exception_Directory_Entry __exception_directory_entries(82) = 
000413d8  {
000413d8      uint32_t beginAddress = 0xa754
000413dc      uint32_t endAddress = 0xa785
000413e0      uint32_t unwindInformation = 0x2d640
000413e4  }
000413e4  struct Exception_Directory_Entry __exception_directory_entries(83) = 
000413e4  {
000413e4      uint32_t beginAddress = 0xa78c
000413e8      uint32_t endAddress = 0xa7fe
000413ec      uint32_t unwindInformation = 0x2e5c8
000413f0  }
000413f0  struct Exception_Directory_Entry __exception_directory_entries(84) = 
000413f0  {
000413f0      uint32_t beginAddress = 0xa804
000413f4      uint32_t endAddress = 0xa842
000413f8      uint32_t unwindInformation = 0x2dc90
000413fc  }
000413fc  struct Exception_Directory_Entry __exception_directory_entries(85) = 
000413fc  {
000413fc      uint32_t beginAddress = 0xa848
00041400      uint32_t endAddress = 0xa92d
00041404      uint32_t unwindInformation = 0x2e5b4
00041408  }
00041408  struct Exception_Directory_Entry __exception_directory_entries(86) = 
00041408  {
00041408      uint32_t beginAddress = 0xa934
0004140c      uint32_t endAddress = 0xa957
00041410      uint32_t unwindInformation = 0x2d640
00041414  }
00041414  struct Exception_Directory_Entry __exception_directory_entries(87) = 
00041414  {
00041414      uint32_t beginAddress = 0xa960
00041418      uint32_t endAddress = 0xa9f2
0004141c      uint32_t unwindInformation = 0x2d640
00041420  }
00041420  struct Exception_Directory_Entry __exception_directory_entries(88) = 
00041420  {
00041420      uint32_t beginAddress = 0xa9f8
00041424      uint32_t endAddress = 0xab95
00041428      uint32_t unwindInformation = 0x2e7b0
0004142c  }
0004142c  struct Exception_Directory_Entry __exception_directory_entries(89) = 
0004142c  {
0004142c      uint32_t beginAddress = 0xab9c
00041430      uint32_t endAddress = 0xabff
00041434      uint32_t unwindInformation = 0x2d640
00041438  }
00041438  struct Exception_Directory_Entry __exception_directory_entries(90) = 
00041438  {
00041438      uint32_t beginAddress = 0xac08
0004143c      uint32_t endAddress = 0xad55
00041440      uint32_t unwindInformation = 0x2e7a0
00041444  }
00041444  struct Exception_Directory_Entry __exception_directory_entries(91) = 
00041444  {
00041444      uint32_t beginAddress = 0xad5c
00041448      uint32_t endAddress = 0xadda
0004144c      uint32_t unwindInformation = 0x2dce0
00041450  }
00041450  struct Exception_Directory_Entry __exception_directory_entries(92) = 
00041450  {
00041450      uint32_t beginAddress = 0xade0
00041454      uint32_t endAddress = 0xafbe
00041458      uint32_t unwindInformation = 0x2e790
0004145c  }
0004145c  struct Exception_Directory_Entry __exception_directory_entries(93) = 
0004145c  {
0004145c      uint32_t beginAddress = 0xafc4
00041460      uint32_t endAddress = 0xb0bb
00041464      uint32_t unwindInformation = 0x2da00
00041468  }
00041468  struct Exception_Directory_Entry __exception_directory_entries(94) = 
00041468  {
00041468      uint32_t beginAddress = 0xb0c4
0004146c      uint32_t endAddress = 0xb1f9
00041470      uint32_t unwindInformation = 0x2d9f8
00041474  }
00041474  struct Exception_Directory_Entry __exception_directory_entries(95) = 
00041474  {
00041474      uint32_t beginAddress = 0xb200
00041478      uint32_t endAddress = 0xb239
0004147c      uint32_t unwindInformation = 0x2d640
00041480  }
00041480  struct Exception_Directory_Entry __exception_directory_entries(96) = 
00041480  {
00041480      uint32_t beginAddress = 0xb240
00041484      uint32_t endAddress = 0xb547
00041488      uint32_t unwindInformation = 0x2e59c
0004148c  }
0004148c  struct Exception_Directory_Entry __exception_directory_entries(97) = 
0004148c  {
0004148c      uint32_t beginAddress = 0xb550
00041490      uint32_t endAddress = 0xb5b4
00041494      uint32_t unwindInformation = 0x2d9ec
00041498  }
00041498  struct Exception_Directory_Entry __exception_directory_entries(98) = 
00041498  {
00041498      uint32_t beginAddress = 0xb5bc
0004149c      uint32_t endAddress = 0xb636
000414a0      uint32_t unwindInformation = 0x2d640
000414a4  }
000414a4  struct Exception_Directory_Entry __exception_directory_entries(99) = 
000414a4  {
000414a4      uint32_t beginAddress = 0xb63c
000414a8      uint32_t endAddress = 0xb6c8
000414ac      uint32_t unwindInformation = 0x2d6f0
000414b0  }
000414b0  struct Exception_Directory_Entry __exception_directory_entries(100) = 
000414b0  {
000414b0      uint32_t beginAddress = 0xb6d0
000414b4      uint32_t endAddress = 0xb70c
000414b8      uint32_t unwindInformation = 0x2d640
000414bc  }
000414bc  struct Exception_Directory_Entry __exception_directory_entries(101) = 
000414bc  {
000414bc      uint32_t beginAddress = 0xb714
000414c0      uint32_t endAddress = 0xb942
000414c4      uint32_t unwindInformation = 0x2e480
000414c8  }
000414c8  struct Exception_Directory_Entry __exception_directory_entries(102) = 
000414c8  {
000414c8      uint32_t beginAddress = 0xb948
000414cc      uint32_t endAddress = 0xbba7
000414d0      uint32_t unwindInformation = 0x2e81c
000414d4  }
000414d4  struct Exception_Directory_Entry __exception_directory_entries(103) = 
000414d4  {
000414d4      uint32_t beginAddress = 0xbbb0
000414d8      uint32_t endAddress = 0xbeac
000414dc      uint32_t unwindInformation = 0x2e7fc
000414e0  }
000414e0  struct Exception_Directory_Entry __exception_directory_entries(104) = 
000414e0  {
000414e0      uint32_t beginAddress = 0xbeb4
000414e4      uint32_t endAddress = 0xc285
000414e8      uint32_t unwindInformation = 0x2e584
000414ec  }
000414ec  struct Exception_Directory_Entry __exception_directory_entries(105) = 
000414ec  {
000414ec      uint32_t beginAddress = 0xc28c
000414f0      uint32_t endAddress = 0xc49c
000414f4      uint32_t unwindInformation = 0x2dc90
000414f8  }
000414f8  struct Exception_Directory_Entry __exception_directory_entries(106) = 
000414f8  {
000414f8      uint32_t beginAddress = 0xc4a4
000414fc      uint32_t endAddress = 0xc707
00041500      uint32_t unwindInformation = 0x2e26c
00041504  }
00041504  struct Exception_Directory_Entry __exception_directory_entries(107) = 
00041504  {
00041504      uint32_t beginAddress = 0xc710
00041508      uint32_t endAddress = 0xc794
0004150c      uint32_t unwindInformation = 0x2e574
00041510  }
00041510  struct Exception_Directory_Entry __exception_directory_entries(108) = 
00041510  {
00041510      uint32_t beginAddress = 0xc79c
00041514      uint32_t endAddress = 0xc806
00041518      uint32_t unwindInformation = 0x2e560
0004151c  }
0004151c  struct Exception_Directory_Entry __exception_directory_entries(109) = 
0004151c  {
0004151c      uint32_t beginAddress = 0xc80c
00041520      uint32_t endAddress = 0xc8d8
00041524      uint32_t unwindInformation = 0x2e480
00041528  }
00041528  struct Exception_Directory_Entry __exception_directory_entries(110) = 
00041528  {
00041528      uint32_t beginAddress = 0xc8e0
0004152c      uint32_t endAddress = 0xc996
00041530      uint32_t unwindInformation = 0x2e558
00041534  }
00041534  struct Exception_Directory_Entry __exception_directory_entries(111) = 
00041534  {
00041534      uint32_t beginAddress = 0xc99c
00041538      uint32_t endAddress = 0xcafe
0004153c      uint32_t unwindInformation = 0x2e540
00041540  }
00041540  struct Exception_Directory_Entry __exception_directory_entries(112) = 
00041540  {
00041540      uint32_t beginAddress = 0xcb04
00041544      uint32_t endAddress = 0xcc03
00041548      uint32_t unwindInformation = 0x2e528
0004154c  }
0004154c  struct Exception_Directory_Entry __exception_directory_entries(113) = 
0004154c  {
0004154c      uint32_t beginAddress = 0xcc80
00041550      uint32_t endAddress = 0xce46
00041554      uint32_t unwindInformation = 0x2e508
00041558  }
00041558  struct Exception_Directory_Entry __exception_directory_entries(114) = 
00041558  {
00041558      uint32_t beginAddress = 0xce4c
0004155c      uint32_t endAddress = 0xced9
00041560      uint32_t unwindInformation = 0x2e26c
00041564  }
00041564  struct Exception_Directory_Entry __exception_directory_entries(115) = 
00041564  {
00041564      uint32_t beginAddress = 0xcee0
00041568      uint32_t endAddress = 0xd0ce
0004156c      uint32_t unwindInformation = 0x2e124
00041570  }
00041570  struct Exception_Directory_Entry __exception_directory_entries(116) = 
00041570  {
00041570      uint32_t beginAddress = 0xd0d4
00041574      uint32_t endAddress = 0xd298
00041578      uint32_t unwindInformation = 0x2e10c
0004157c  }
0004157c  struct Exception_Directory_Entry __exception_directory_entries(117) = 
0004157c  {
0004157c      uint32_t beginAddress = 0xd2a0
00041580      uint32_t endAddress = 0xd370
00041584      uint32_t unwindInformation = 0x2e4f8
00041588  }
00041588  struct Exception_Directory_Entry __exception_directory_entries(118) = 
00041588  {
00041588      uint32_t beginAddress = 0xd378
0004158c      uint32_t endAddress = 0xd44c
00041590      uint32_t unwindInformation = 0x2e4f8
00041594  }
00041594  struct Exception_Directory_Entry __exception_directory_entries(119) = 
00041594  {
00041594      uint32_t beginAddress = 0xd454
00041598      uint32_t endAddress = 0xd524
0004159c      uint32_t unwindInformation = 0x2e4f8
000415a0  }
000415a0  struct Exception_Directory_Entry __exception_directory_entries(120) = 
000415a0  {
000415a0      uint32_t beginAddress = 0xd52c
000415a4      uint32_t endAddress = 0xd5e8
000415a8      uint32_t unwindInformation = 0x2e4f8
000415ac  }
000415ac  struct Exception_Directory_Entry __exception_directory_entries(121) = 
000415ac  {
000415ac      uint32_t beginAddress = 0xd5f0
000415b0      uint32_t endAddress = 0xd65f
000415b4      uint32_t unwindInformation = 0x2d640
000415b8  }
000415b8  struct Exception_Directory_Entry __exception_directory_entries(122) = 
000415b8  {
000415b8      uint32_t beginAddress = 0xd668
000415bc      uint32_t endAddress = 0xd7a2
000415c0      uint32_t unwindInformation = 0x2ddf8
000415c4  }
000415c4  struct Exception_Directory_Entry __exception_directory_entries(123) = 
000415c4  {
000415c4      uint32_t beginAddress = 0xd83c
000415c8      uint32_t endAddress = 0xd8b1
000415cc      uint32_t unwindInformation = 0x2d9e0
000415d0  }
000415d0  struct Exception_Directory_Entry __exception_directory_entries(124) = 
000415d0  {
000415d0      uint32_t beginAddress = 0xd8b8
000415d4      uint32_t endAddress = 0xd8fa
000415d8      uint32_t unwindInformation = 0x2d640
000415dc  }
000415dc  struct Exception_Directory_Entry __exception_directory_entries(125) = 
000415dc  {
000415dc      uint32_t beginAddress = 0xd900
000415e0      uint32_t endAddress = 0xd954
000415e4      uint32_t unwindInformation = 0x2e17c
000415e8  }
000415e8  struct Exception_Directory_Entry __exception_directory_entries(126) = 
000415e8  {
000415e8      uint32_t beginAddress = 0xd994
000415ec      uint32_t endAddress = 0xda12
000415f0      uint32_t unwindInformation = 0x2d9d4
000415f4  }
000415f4  struct Exception_Directory_Entry __exception_directory_entries(127) = 
000415f4  {
000415f4      uint32_t beginAddress = 0xda18
000415f8      uint32_t endAddress = 0xdb93
000415fc      uint32_t unwindInformation = 0x2dcbc
00041600  }
00041600  struct Exception_Directory_Entry __exception_directory_entries(128) = 
00041600  {
00041600      uint32_t beginAddress = 0xdb9c
00041604      uint32_t endAddress = 0xdd84
00041608      uint32_t unwindInformation = 0x2d9a4
0004160c  }
0004160c  struct Exception_Directory_Entry __exception_directory_entries(129) = 
0004160c  {
0004160c      uint32_t beginAddress = 0xdd8c
00041610      uint32_t endAddress = 0xdeaa
00041614      uint32_t unwindInformation = 0x2d998
00041618  }
00041618  struct Exception_Directory_Entry __exception_directory_entries(130) = 
00041618  {
00041618      uint32_t beginAddress = 0xdeb0
0004161c      uint32_t endAddress = 0xdf67
00041620      uint32_t unwindInformation = 0x2dca4
00041624  }
00041624  struct Exception_Directory_Entry __exception_directory_entries(131) = 
00041624  {
00041624      uint32_t beginAddress = 0xdf70
00041628      uint32_t endAddress = 0xdfc4
0004162c      uint32_t unwindInformation = 0x2d640
00041630  }
00041630  struct Exception_Directory_Entry __exception_directory_entries(132) = 
00041630  {
00041630      uint32_t beginAddress = 0xdfcc
00041634      uint32_t endAddress = 0xe035
00041638      uint32_t unwindInformation = 0x2dc98
0004163c  }
0004163c  struct Exception_Directory_Entry __exception_directory_entries(133) = 
0004163c  {
0004163c      uint32_t beginAddress = 0xe054
00041640      uint32_t endAddress = 0xe097
00041644      uint32_t unwindInformation = 0x2dc90
00041648  }
00041648  struct Exception_Directory_Entry __exception_directory_entries(134) = 
00041648  {
00041648      uint32_t beginAddress = 0xe0a0
0004164c      uint32_t endAddress = 0xe0f9
00041650      uint32_t unwindInformation = 0x2e17c
00041654  }
00041654  struct Exception_Directory_Entry __exception_directory_entries(135) = 
00041654  {
00041654      uint32_t beginAddress = 0xe100
00041658      uint32_t endAddress = 0xe159
0004165c      uint32_t unwindInformation = 0x2e17c
00041660  }
00041660  struct Exception_Directory_Entry __exception_directory_entries(136) = 
00041660  {
00041660      uint32_t beginAddress = 0xe160
00041664      uint32_t endAddress = 0xe1b9
00041668      uint32_t unwindInformation = 0x2e17c
0004166c  }
0004166c  struct Exception_Directory_Entry __exception_directory_entries(137) = 
0004166c  {
0004166c      uint32_t beginAddress = 0xe1c0
00041670      uint32_t endAddress = 0xe444
00041674      uint32_t unwindInformation = 0x2d7f8
00041678  }
00041678  struct Exception_Directory_Entry __exception_directory_entries(138) = 
00041678  {
00041678      uint32_t beginAddress = 0xe44c
0004167c      uint32_t endAddress = 0xe672
00041680      uint32_t unwindInformation = 0x2e4e0
00041684  }
00041684  struct Exception_Directory_Entry __exception_directory_entries(139) = 
00041684  {
00041684      uint32_t beginAddress = 0xe678
00041688      uint32_t endAddress = 0xe6d7
0004168c      uint32_t unwindInformation = 0x2d640
00041690  }
00041690  struct Exception_Directory_Entry __exception_directory_entries(140) = 
00041690  {
00041690      uint32_t beginAddress = 0xe6e0
00041694      uint32_t endAddress = 0xe8f5
00041698      uint32_t unwindInformation = 0x2d8f4
0004169c  }
0004169c  struct Exception_Directory_Entry __exception_directory_entries(141) = 
0004169c  {
0004169c      uint32_t beginAddress = 0xe964
000416a0      uint32_t endAddress = 0xed53
000416a4      uint32_t unwindInformation = 0x2e0dc
000416a8  }
000416a8  struct Exception_Directory_Entry __exception_directory_entries(142) = 
000416a8  {
000416a8      uint32_t beginAddress = 0xed5c
000416ac      uint32_t endAddress = 0xeec7
000416b0      uint32_t unwindInformation = 0x2e4bc
000416b4  }
000416b4  struct Exception_Directory_Entry __exception_directory_entries(143) = 
000416b4  {
000416b4      uint32_t beginAddress = 0xeed0
000416b8      uint32_t endAddress = 0xf721
000416bc      uint32_t unwindInformation = 0x2e0b0
000416c0  }
000416c0  struct Exception_Directory_Entry __exception_directory_entries(144) = 
000416c0  {
000416c0      uint32_t beginAddress = 0xf728
000416c4      uint32_t endAddress = 0xf92f
000416c8      uint32_t unwindInformation = 0x2dc78
000416cc  }
000416cc  struct Exception_Directory_Entry __exception_directory_entries(145) = 
000416cc  {
000416cc      uint32_t beginAddress = 0xf938
000416d0      uint32_t endAddress = 0xfa5d
000416d4      uint32_t unwindInformation = 0x2e26c
000416d8  }
000416d8  struct Exception_Directory_Entry __exception_directory_entries(146) = 
000416d8  {
000416d8      uint32_t beginAddress = 0xfa64
000416dc      uint32_t endAddress = 0xfb9f
000416e0      uint32_t unwindInformation = 0x2d984
000416e4  }
000416e4  struct Exception_Directory_Entry __exception_directory_entries(147) = 
000416e4  {
000416e4      uint32_t beginAddress = 0xfba8
000416e8      uint32_t endAddress = 0x10018
000416ec      uint32_t unwindInformation = 0x2dc50
000416f0  }
000416f0  struct Exception_Directory_Entry __exception_directory_entries(148) = 
000416f0  {
000416f0      uint32_t beginAddress = 0x10180
000416f4      uint32_t endAddress = 0x1059d
000416f8      uint32_t unwindInformation = 0x2dc18
000416fc  }
000416fc  struct Exception_Directory_Entry __exception_directory_entries(149) = 
000416fc  {
000416fc      uint32_t beginAddress = 0x105a4
00041700      uint32_t endAddress = 0x10834
00041704      uint32_t unwindInformation = 0x2dd1c
00041708  }
00041708  struct Exception_Directory_Entry __exception_directory_entries(150) = 
00041708  {
00041708      uint32_t beginAddress = 0x1083c
0004170c      uint32_t endAddress = 0x11745
00041710      uint32_t unwindInformation = 0x2e070
00041714  }
00041714  struct Exception_Directory_Entry __exception_directory_entries(151) = 
00041714  {
00041714      uint32_t beginAddress = 0x1174c
00041718      uint32_t endAddress = 0x11924
0004171c      uint32_t unwindInformation = 0x2d960
00041720  }
00041720  struct Exception_Directory_Entry __exception_directory_entries(152) = 
00041720  {
00041720      uint32_t beginAddress = 0x1192c
00041724      uint32_t endAddress = 0x11b54
00041728      uint32_t unwindInformation = 0x2d934
0004172c  }
0004172c  struct Exception_Directory_Entry __exception_directory_entries(153) = 
0004172c  {
0004172c      uint32_t beginAddress = 0x11b5c
00041730      uint32_t endAddress = 0x11c62
00041734      uint32_t unwindInformation = 0x2d92c
00041738  }
00041738  struct Exception_Directory_Entry __exception_directory_entries(154) = 
00041738  {
00041738      uint32_t beginAddress = 0x11c68
0004173c      uint32_t endAddress = 0x11ec7
00041740      uint32_t unwindInformation = 0x2d910
00041744  }
00041744  struct Exception_Directory_Entry __exception_directory_entries(155) = 
00041744  {
00041744      uint32_t beginAddress = 0x11ed0
00041748      uint32_t endAddress = 0x12066
0004174c      uint32_t unwindInformation = 0x2d8f4
00041750  }
00041750  struct Exception_Directory_Entry __exception_directory_entries(156) = 
00041750  {
00041750      uint32_t beginAddress = 0x1206c
00041754      uint32_t endAddress = 0x1240f
00041758      uint32_t unwindInformation = 0x2d8d8
0004175c  }
0004175c  struct Exception_Directory_Entry __exception_directory_entries(157) = 
0004175c  {
0004175c      uint32_t beginAddress = 0x12418
00041760      uint32_t endAddress = 0x12536
00041764      uint32_t unwindInformation = 0x2d8d0
00041768  }
00041768  struct Exception_Directory_Entry __exception_directory_entries(158) = 
00041768  {
00041768      uint32_t beginAddress = 0x1253c
0004176c      uint32_t endAddress = 0x126fb
00041770      uint32_t unwindInformation = 0x2e4a4
00041774  }
00041774  struct Exception_Directory_Entry __exception_directory_entries(159) = 
00041774  {
00041774      uint32_t beginAddress = 0x12704
00041778      uint32_t endAddress = 0x128d2
0004177c      uint32_t unwindInformation = 0x2e498
00041780  }
00041780  struct Exception_Directory_Entry __exception_directory_entries(160) = 
00041780  {
00041780      uint32_t beginAddress = 0x128d8
00041784      uint32_t endAddress = 0x129f7
00041788      uint32_t unwindInformation = 0x2e480
0004178c  }
0004178c  struct Exception_Directory_Entry __exception_directory_entries(161) = 
0004178c  {
0004178c      uint32_t beginAddress = 0x12a00
00041790      uint32_t endAddress = 0x12b5b
00041794      uint32_t unwindInformation = 0x2e468
00041798  }
00041798  struct Exception_Directory_Entry __exception_directory_entries(162) = 
00041798  {
00041798      uint32_t beginAddress = 0x12b64
0004179c      uint32_t endAddress = 0x12f0f
000417a0      uint32_t unwindInformation = 0x2e480
000417a4  }
000417a4  struct Exception_Directory_Entry __exception_directory_entries(163) = 
000417a4  {
000417a4      uint32_t beginAddress = 0x12f18
000417a8      uint32_t endAddress = 0x1342f
000417ac      uint32_t unwindInformation = 0x2dd1c
000417b0  }
000417b0  struct Exception_Directory_Entry __exception_directory_entries(164) = 
000417b0  {
000417b0      uint32_t beginAddress = 0x13438
000417b4      uint32_t endAddress = 0x13503
000417b8      uint32_t unwindInformation = 0x2d8b4
000417bc  }
000417bc  struct Exception_Directory_Entry __exception_directory_entries(165) = 
000417bc  {
000417bc      uint32_t beginAddress = 0x1350c
000417c0      uint32_t endAddress = 0x136a5
000417c4      uint32_t unwindInformation = 0x2e454
000417c8  }
000417c8  struct Exception_Directory_Entry __exception_directory_entries(166) = 
000417c8  {
000417c8      uint32_t beginAddress = 0x136ac
000417cc      uint32_t endAddress = 0x1374f
000417d0      uint32_t unwindInformation = 0x2e444
000417d4  }
000417d4  struct Exception_Directory_Entry __exception_directory_entries(167) = 
000417d4  {
000417d4      uint32_t beginAddress = 0x13758
000417d8      uint32_t endAddress = 0x13a2c
000417dc      uint32_t unwindInformation = 0x2e424
000417e0  }
000417e0  struct Exception_Directory_Entry __exception_directory_entries(168) = 
000417e0  {
000417e0      uint32_t beginAddress = 0x13a34
000417e4      uint32_t endAddress = 0x13c49
000417e8      uint32_t unwindInformation = 0x2d890
000417ec  }
000417ec  struct Exception_Directory_Entry __exception_directory_entries(169) = 
000417ec  {
000417ec      uint32_t beginAddress = 0x13c50
000417f0      uint32_t endAddress = 0x13dd5
000417f4      uint32_t unwindInformation = 0x2e400
000417f8  }
000417f8  struct Exception_Directory_Entry __exception_directory_entries(170) = 
000417f8  {
000417f8      uint32_t beginAddress = 0x13ddc
000417fc      uint32_t endAddress = 0x13fd6
00041800      uint32_t unwindInformation = 0x2d878
00041804  }
00041804  struct Exception_Directory_Entry __exception_directory_entries(171) = 
00041804  {
00041804      uint32_t beginAddress = 0x13fdc
00041808      uint32_t endAddress = 0x140da
0004180c      uint32_t unwindInformation = 0x2de04
00041810  }
00041810  struct Exception_Directory_Entry __exception_directory_entries(172) = 
00041810  {
00041810      uint32_t beginAddress = 0x140e0
00041814      uint32_t endAddress = 0x1424f
00041818      uint32_t unwindInformation = 0x2d858
0004181c  }
0004181c  struct Exception_Directory_Entry __exception_directory_entries(173) = 
0004181c  {
0004181c      uint32_t beginAddress = 0x14258
00041820      uint32_t endAddress = 0x1436d
00041824      uint32_t unwindInformation = 0x2d84c
00041828  }
00041828  struct Exception_Directory_Entry __exception_directory_entries(174) = 
00041828  {
00041828      uint32_t beginAddress = 0x14374
0004182c      uint32_t endAddress = 0x14570
00041830      uint32_t unwindInformation = 0x2dbec
00041834  }
00041834  struct Exception_Directory_Entry __exception_directory_entries(175) = 
00041834  {
00041834      uint32_t beginAddress = 0x14578
00041838      uint32_t endAddress = 0x1467c
0004183c      uint32_t unwindInformation = 0x2d83c
00041840  }
00041840  struct Exception_Directory_Entry __exception_directory_entries(176) = 
00041840  {
00041840      uint32_t beginAddress = 0x14684
00041844      uint32_t endAddress = 0x147a6
00041848      uint32_t unwindInformation = 0x2dbe4
0004184c  }
0004184c  struct Exception_Directory_Entry __exception_directory_entries(177) = 
0004184c  {
0004184c      uint32_t beginAddress = 0x147ac
00041850      uint32_t endAddress = 0x14854
00041854      uint32_t unwindInformation = 0x2d82c
00041858  }
00041858  struct Exception_Directory_Entry __exception_directory_entries(178) = 
00041858  {
00041858      uint32_t beginAddress = 0x1485c
0004185c      uint32_t endAddress = 0x14bdc
00041860      uint32_t unwindInformation = 0x2dbb8
00041864  }
00041864  struct Exception_Directory_Entry __exception_directory_entries(179) = 
00041864  {
00041864      uint32_t beginAddress = 0x14be4
00041868      uint32_t endAddress = 0x14e95
0004186c      uint32_t unwindInformation = 0x2e054
00041870  }
00041870  struct Exception_Directory_Entry __exception_directory_entries(180) = 
00041870  {
00041870      uint32_t beginAddress = 0x14e9c
00041874      uint32_t endAddress = 0x14fc2
00041878      uint32_t unwindInformation = 0x2d80c
0004187c  }
0004187c  struct Exception_Directory_Entry __exception_directory_entries(181) = 
0004187c  {
0004187c      uint32_t beginAddress = 0x14fc8
00041880      uint32_t endAddress = 0x15132
00041884      uint32_t unwindInformation = 0x2dbac
00041888  }
00041888  struct Exception_Directory_Entry __exception_directory_entries(182) = 
00041888  {
00041888      uint32_t beginAddress = 0x15138
0004188c      uint32_t endAddress = 0x1524f
00041890      uint32_t unwindInformation = 0x2d6f0
00041894  }
00041894  struct Exception_Directory_Entry __exception_directory_entries(183) = 
00041894  {
00041894      uint32_t beginAddress = 0x15258
00041898      uint32_t endAddress = 0x15348
0004189c      uint32_t unwindInformation = 0x2e17c
000418a0  }
000418a0  struct Exception_Directory_Entry __exception_directory_entries(184) = 
000418a0  {
000418a0      uint32_t beginAddress = 0x15350
000418a4      uint32_t endAddress = 0x1558f
000418a8      uint32_t unwindInformation = 0x2e3e0
000418ac  }
000418ac  struct Exception_Directory_Entry __exception_directory_entries(185) = 
000418ac  {
000418ac      uint32_t beginAddress = 0x15598
000418b0      uint32_t endAddress = 0x15d4e
000418b4      uint32_t unwindInformation = 0x2e774
000418b8  }
000418b8  struct Exception_Directory_Entry __exception_directory_entries(186) = 
000418b8  {
000418b8      uint32_t beginAddress = 0x15d54
000418bc      uint32_t endAddress = 0x15f48
000418c0      uint32_t unwindInformation = 0x2e26c
000418c4  }
000418c4  struct Exception_Directory_Entry __exception_directory_entries(187) = 
000418c4  {
000418c4      uint32_t beginAddress = 0x15fe0
000418c8      uint32_t endAddress = 0x1613b
000418cc      uint32_t unwindInformation = 0x2e75c
000418d0  }
000418d0  struct Exception_Directory_Entry __exception_directory_entries(188) = 
000418d0  {
000418d0      uint32_t beginAddress = 0x16144
000418d4      uint32_t endAddress = 0x169dd
000418d8      uint32_t unwindInformation = 0x2e3b8
000418dc  }
000418dc  struct Exception_Directory_Entry __exception_directory_entries(189) = 
000418dc  {
000418dc      uint32_t beginAddress = 0x169e4
000418e0      uint32_t endAddress = 0x16a40
000418e4      uint32_t unwindInformation = 0x2e048
000418e8  }
000418e8  struct Exception_Directory_Entry __exception_directory_entries(190) = 
000418e8  {
000418e8      uint32_t beginAddress = 0x16a48
000418ec      uint32_t endAddress = 0x16cf2
000418f0      uint32_t unwindInformation = 0x2e390
000418f4  }
000418f4  struct Exception_Directory_Entry __exception_directory_entries(191) = 
000418f4  {
000418f4      uint32_t beginAddress = 0x16cf8
000418f8      uint32_t endAddress = 0x16e46
000418fc      uint32_t unwindInformation = 0x2d7f8
00041900  }
00041900  struct Exception_Directory_Entry __exception_directory_entries(192) = 
00041900  {
00041900      uint32_t beginAddress = 0x16e4c
00041904      uint32_t endAddress = 0x16f65
00041908      uint32_t unwindInformation = 0x2db90
0004190c  }
0004190c  struct Exception_Directory_Entry __exception_directory_entries(193) = 
0004190c  {
0004190c      uint32_t beginAddress = 0x16f6c
00041910      uint32_t endAddress = 0x17202
00041914      uint32_t unwindInformation = 0x2e468
00041918  }
00041918  struct Exception_Directory_Entry __exception_directory_entries(194) = 
00041918  {
00041918      uint32_t beginAddress = 0x17208
0004191c      uint32_t endAddress = 0x172e4
00041920      uint32_t unwindInformation = 0x2d7f8
00041924  }
00041924  struct Exception_Directory_Entry __exception_directory_entries(195) = 
00041924  {
00041924      uint32_t beginAddress = 0x172ec
00041928      uint32_t endAddress = 0x1854b
0004192c      uint32_t unwindInformation = 0x2e030
00041930  }
00041930  struct Exception_Directory_Entry __exception_directory_entries(196) = 
00041930  {
00041930      uint32_t beginAddress = 0x18554
00041934      uint32_t endAddress = 0x185e9
00041938      uint32_t unwindInformation = 0x2d7e8
0004193c  }
0004193c  struct Exception_Directory_Entry __exception_directory_entries(197) = 
0004193c  {
0004193c      uint32_t beginAddress = 0x185f0
00041940      uint32_t endAddress = 0x1894a
00041944      uint32_t unwindInformation = 0x2e01c
00041948  }
00041948  struct Exception_Directory_Entry __exception_directory_entries(198) = 
00041948  {
00041948      uint32_t beginAddress = 0x189b4
0004194c      uint32_t endAddress = 0x1934e
00041950      uint32_t unwindInformation = 0x2e6cc
00041954  }
00041954  struct Exception_Directory_Entry __exception_directory_entries(199) = 
00041954  {
00041954      uint32_t beginAddress = 0x194d8
00041958      uint32_t endAddress = 0x19716
0004195c      uint32_t unwindInformation = 0x2e6ac
00041960  }
00041960  struct Exception_Directory_Entry __exception_directory_entries(200) = 
00041960  {
00041960      uint32_t beginAddress = 0x1971c
00041964      uint32_t endAddress = 0x19a20
00041968      uint32_t unwindInformation = 0x2e36c
0004196c  }
0004196c  struct Exception_Directory_Entry __exception_directory_entries(201) = 
0004196c  {
0004196c      uint32_t beginAddress = 0x19a28
00041970      uint32_t endAddress = 0x19d9f
00041974      uint32_t unwindInformation = 0x2e340
00041978  }
00041978  struct Exception_Directory_Entry __exception_directory_entries(202) = 
00041978  {
00041978      uint32_t beginAddress = 0x19da8
0004197c      uint32_t endAddress = 0x1a083
00041980      uint32_t unwindInformation = 0x2dff4
00041984  }
00041984  struct Exception_Directory_Entry __exception_directory_entries(203) = 
00041984  {
00041984      uint32_t beginAddress = 0x1a08c
00041988      uint32_t endAddress = 0x1a42a
0004198c      uint32_t unwindInformation = 0x2e31c
00041990  }
00041990  struct Exception_Directory_Entry __exception_directory_entries(204) = 
00041990  {
00041990      uint32_t beginAddress = 0x1a430
00041994      uint32_t endAddress = 0x1a53f
00041998      uint32_t unwindInformation = 0x2d7dc
0004199c  }
0004199c  struct Exception_Directory_Entry __exception_directory_entries(205) = 
0004199c  {
0004199c      uint32_t beginAddress = 0x1a548
000419a0      uint32_t endAddress = 0x1a716
000419a4      uint32_t unwindInformation = 0x2e3e0
000419a8  }
000419a8  struct Exception_Directory_Entry __exception_directory_entries(206) = 
000419a8  {
000419a8      uint32_t beginAddress = 0x1a770
000419ac      uint32_t endAddress = 0x1a81a
000419b0      uint32_t unwindInformation = 0x2d7f8
000419b4  }
000419b4  struct Exception_Directory_Entry __exception_directory_entries(207) = 
000419b4  {
000419b4      uint32_t beginAddress = 0x1a820
000419b8      uint32_t endAddress = 0x1aa5d
000419bc      uint32_t unwindInformation = 0x2d7c4
000419c0  }
000419c0  struct Exception_Directory_Entry __exception_directory_entries(208) = 
000419c0  {
000419c0      uint32_t beginAddress = 0x1aa64
000419c4      uint32_t endAddress = 0x1ac02
000419c8      uint32_t unwindInformation = 0x2e744
000419cc  }
000419cc  struct Exception_Directory_Entry __exception_directory_entries(209) = 
000419cc  {
000419cc      uint32_t beginAddress = 0x1ac08
000419d0      uint32_t endAddress = 0x1aed2
000419d4      uint32_t unwindInformation = 0x2e2fc
000419d8  }
000419d8  struct Exception_Directory_Entry __exception_directory_entries(210) = 
000419d8  {
000419d8      uint32_t beginAddress = 0x1aed8
000419dc      uint32_t endAddress = 0x1b0c9
000419e0      uint32_t unwindInformation = 0x2db78
000419e4  }
000419e4  struct Exception_Directory_Entry __exception_directory_entries(211) = 
000419e4  {
000419e4      uint32_t beginAddress = 0x1b0d0
000419e8      uint32_t endAddress = 0x1b175
000419ec      uint32_t unwindInformation = 0x2dc90
000419f0  }
000419f0  struct Exception_Directory_Entry __exception_directory_entries(212) = 
000419f0  {
000419f0      uint32_t beginAddress = 0x1b17c
000419f4      uint32_t endAddress = 0x1b488
000419f8      uint32_t unwindInformation = 0x2d7a8
000419fc  }
000419fc  struct Exception_Directory_Entry __exception_directory_entries(213) = 
000419fc  {
000419fc      uint32_t beginAddress = 0x1b5dc
00041a00      uint32_t endAddress = 0x1b69e
00041a04      uint32_t unwindInformation = 0x2e21c
00041a08  }
00041a08  struct Exception_Directory_Entry __exception_directory_entries(214) = 
00041a08  {
00041a08      uint32_t beginAddress = 0x1b6a4
00041a0c      uint32_t endAddress = 0x1bdc0
00041a10      uint32_t unwindInformation = 0x2e68c
00041a14  }
00041a14  struct Exception_Directory_Entry __exception_directory_entries(215) = 
00041a14  {
00041a14      uint32_t beginAddress = 0x1bdc8
00041a18      uint32_t endAddress = 0x1becc
00041a1c      uint32_t unwindInformation = 0x2e734
00041a20  }
00041a20  struct Exception_Directory_Entry __exception_directory_entries(216) = 
00041a20  {
00041a20      uint32_t beginAddress = 0x1bed4
00041a24      uint32_t endAddress = 0x1c2df
00041a28      uint32_t unwindInformation = 0x2e2c8
00041a2c  }
00041a2c  struct Exception_Directory_Entry __exception_directory_entries(217) = 
00041a2c  {
00041a2c      uint32_t beginAddress = 0x1c2e8
00041a30      uint32_t endAddress = 0x1c49d
00041a34      uint32_t unwindInformation = 0x2dfdc
00041a38  }
00041a38  struct Exception_Directory_Entry __exception_directory_entries(218) = 
00041a38  {
00041a38      uint32_t beginAddress = 0x1c4a4
00041a3c      uint32_t endAddress = 0x1c6a0
00041a40      uint32_t unwindInformation = 0x2d78c
00041a44  }
00041a44  struct Exception_Directory_Entry __exception_directory_entries(219) = 
00041a44  {
00041a44      uint32_t beginAddress = 0x1c6a8
00041a48      uint32_t endAddress = 0x1c9b4
00041a4c      uint32_t unwindInformation = 0x2d768
00041a50  }
00041a50  struct Exception_Directory_Entry __exception_directory_entries(220) = 
00041a50  {
00041a50      uint32_t beginAddress = 0x1c9bc
00041a54      uint32_t endAddress = 0x1cb0f
00041a58      uint32_t unwindInformation = 0x2d758
00041a5c  }
00041a5c  struct Exception_Directory_Entry __exception_directory_entries(221) = 
00041a5c  {
00041a5c      uint32_t beginAddress = 0x1cb18
00041a60      uint32_t endAddress = 0x1cdfa
00041a64      uint32_t unwindInformation = 0x2db34
00041a68  }
00041a68  struct Exception_Directory_Entry __exception_directory_entries(222) = 
00041a68  {
00041a68      uint32_t beginAddress = 0x1cf34
00041a6c      uint32_t endAddress = 0x1d0f2
00041a70      uint32_t unwindInformation = 0x2db20
00041a74  }
00041a74  struct Exception_Directory_Entry __exception_directory_entries(223) = 
00041a74  {
00041a74      uint32_t beginAddress = 0x1d0f8
00041a78      uint32_t endAddress = 0x1d227
00041a7c      uint32_t unwindInformation = 0x2e26c
00041a80  }
00041a80  struct Exception_Directory_Entry __exception_directory_entries(224) = 
00041a80  {
00041a80      uint32_t beginAddress = 0x1d230
00041a84      uint32_t endAddress = 0x1d73a
00041a88      uint32_t unwindInformation = 0x2e2a4
00041a8c  }
00041a8c  struct Exception_Directory_Entry __exception_directory_entries(225) = 
00041a8c  {
00041a8c      uint32_t beginAddress = 0x1d740
00041a90      uint32_t endAddress = 0x1d874
00041a94      uint32_t unwindInformation = 0x2e284
00041a98  }
00041a98  struct Exception_Directory_Entry __exception_directory_entries(226) = 
00041a98  {
00041a98      uint32_t beginAddress = 0x1d87c
00041a9c      uint32_t endAddress = 0x1dacc
00041aa0      uint32_t unwindInformation = 0x2dfb8
00041aa4  }
00041aa4  struct Exception_Directory_Entry __exception_directory_entries(227) = 
00041aa4  {
00041aa4      uint32_t beginAddress = 0x1dad4
00041aa8      uint32_t endAddress = 0x1dde7
00041aac      uint32_t unwindInformation = 0x2df98
00041ab0  }
00041ab0  struct Exception_Directory_Entry __exception_directory_entries(228) = 
00041ab0  {
00041ab0      uint32_t beginAddress = 0x1ddf0
00041ab4      uint32_t endAddress = 0x1e53c
00041ab8      uint32_t unwindInformation = 0x2df5c
00041abc  }
00041abc  struct Exception_Directory_Entry __exception_directory_entries(229) = 
00041abc  {
00041abc      uint32_t beginAddress = 0x1e544
00041ac0      uint32_t endAddress = 0x1e58a
00041ac4      uint32_t unwindInformation = 0x2d640
00041ac8  }
00041ac8  struct Exception_Directory_Entry __exception_directory_entries(230) = 
00041ac8  {
00041ac8      uint32_t beginAddress = 0x1e590
00041acc      uint32_t endAddress = 0x1e73e
00041ad0      uint32_t unwindInformation = 0x2e26c
00041ad4  }
00041ad4  struct Exception_Directory_Entry __exception_directory_entries(231) = 
00041ad4  {
00041ad4      uint32_t beginAddress = 0x1e744
00041ad8      uint32_t endAddress = 0x1e912
00041adc      uint32_t unwindInformation = 0x2d740
00041ae0  }
00041ae0  struct Exception_Directory_Entry __exception_directory_entries(232) = 
00041ae0  {
00041ae0      uint32_t beginAddress = 0x1e918
00041ae4      uint32_t endAddress = 0x1ec8d
00041ae8      uint32_t unwindInformation = 0x2e7d8
00041aec  }
00041aec  struct Exception_Directory_Entry __exception_directory_entries(233) = 
00041aec  {
00041aec      uint32_t beginAddress = 0x1ec94
00041af0      uint32_t endAddress = 0x1ee68
00041af4      uint32_t unwindInformation = 0x2df3c
00041af8  }
00041af8  struct Exception_Directory_Entry __exception_directory_entries(234) = 
00041af8  {
00041af8      uint32_t beginAddress = 0x1ee70
00041afc      uint32_t endAddress = 0x1f540
00041b00      uint32_t unwindInformation = 0x2df0c
00041b04  }
00041b04  struct Exception_Directory_Entry __exception_directory_entries(235) = 
00041b04  {
00041b04      uint32_t beginAddress = 0x1f548
00041b08      uint32_t endAddress = 0x1f8be
00041b0c      uint32_t unwindInformation = 0x2d724
00041b10  }
00041b10  struct Exception_Directory_Entry __exception_directory_entries(236) = 
00041b10  {
00041b10      uint32_t beginAddress = 0x1f8c4
00041b14      uint32_t endAddress = 0x1faeb
00041b18      uint32_t unwindInformation = 0x2d8f4
00041b1c  }
00041b1c  struct Exception_Directory_Entry __exception_directory_entries(237) = 
00041b1c  {
00041b1c      uint32_t beginAddress = 0x1faf4
00041b20      uint32_t endAddress = 0x1fc42
00041b24      uint32_t unwindInformation = 0x2d714
00041b28  }
00041b28  struct Exception_Directory_Entry __exception_directory_entries(238) = 
00041b28  {
00041b28      uint32_t beginAddress = 0x1fc48
00041b2c      uint32_t endAddress = 0x1fcac
00041b30      uint32_t unwindInformation = 0x2d700
00041b34  }
00041b34  struct Exception_Directory_Entry __exception_directory_entries(239) = 
00041b34  {
00041b34      uint32_t beginAddress = 0x1fcb4
00041b38      uint32_t endAddress = 0x1fe98
00041b3c      uint32_t unwindInformation = 0x2d7e8
00041b40  }
00041b40  struct Exception_Directory_Entry __exception_directory_entries(240) = 
00041b40  {
00041b40      uint32_t beginAddress = 0x1fea0
00041b44      uint32_t endAddress = 0x1ff1c
00041b48      uint32_t unwindInformation = 0x2defc
00041b4c  }
00041b4c  struct Exception_Directory_Entry __exception_directory_entries(241) = 
00041b4c  {
00041b4c      uint32_t beginAddress = 0x1ff24
00041b50      uint32_t endAddress = 0x1ffa9
00041b54      uint32_t unwindInformation = 0x2e048
00041b58  }
00041b58  struct Exception_Directory_Entry __exception_directory_entries(242) = 
00041b58  {
00041b58      uint32_t beginAddress = 0x1ffb0
00041b5c      uint32_t endAddress = 0x2004a
00041b60      uint32_t unwindInformation = 0x2d6f0
00041b64  }
00041b64  struct Exception_Directory_Entry __exception_directory_entries(243) = 
00041b64  {
00041b64      uint32_t beginAddress = 0x20050
00041b68      uint32_t endAddress = 0x200eb
00041b6c      uint32_t unwindInformation = 0x2e260
00041b70  }
00041b70  struct Exception_Directory_Entry __exception_directory_entries(244) = 
00041b70  {
00041b70      uint32_t beginAddress = 0x200f4
00041b74      uint32_t endAddress = 0x20381
00041b78      uint32_t unwindInformation = 0x2e248
00041b7c  }
00041b7c  struct Exception_Directory_Entry __exception_directory_entries(245) = 
00041b7c  {
00041b7c      uint32_t beginAddress = 0x20388
00041b80      uint32_t endAddress = 0x20461
00041b84      uint32_t unwindInformation = 0x2d6f0
00041b88  }
00041b88  struct Exception_Directory_Entry __exception_directory_entries(246) = 
00041b88  {
00041b88      uint32_t beginAddress = 0x20468
00041b8c      uint32_t endAddress = 0x208f0
00041b90      uint32_t unwindInformation = 0x2dafc
00041b94  }
00041b94  struct Exception_Directory_Entry __exception_directory_entries(247) = 
00041b94  {
00041b94      uint32_t beginAddress = 0x208f8
00041b98      uint32_t endAddress = 0x209a0
00041b9c      uint32_t unwindInformation = 0x2daec
00041ba0  }
00041ba0  struct Exception_Directory_Entry __exception_directory_entries(248) = 
00041ba0  {
00041ba0      uint32_t beginAddress = 0x209a8
00041ba4      uint32_t endAddress = 0x20b39
00041ba8      uint32_t unwindInformation = 0x2d6d4
00041bac  }
00041bac  struct Exception_Directory_Entry __exception_directory_entries(249) = 
00041bac  {
00041bac      uint32_t beginAddress = 0x20b40
00041bb0      uint32_t endAddress = 0x20bd0
00041bb4      uint32_t unwindInformation = 0x2d6b8
00041bb8  }
00041bb8  struct Exception_Directory_Entry __exception_directory_entries(250) = 
00041bb8  {
00041bb8      uint32_t beginAddress = 0x20bd8
00041bbc      uint32_t endAddress = 0x20c43
00041bc0      uint32_t unwindInformation = 0x2e17c
00041bc4  }
00041bc4  struct Exception_Directory_Entry __exception_directory_entries(251) = 
00041bc4  {
00041bc4      uint32_t beginAddress = 0x20c4c
00041bc8      uint32_t endAddress = 0x21325
00041bcc      uint32_t unwindInformation = 0x2e668
00041bd0  }
00041bd0  struct Exception_Directory_Entry __exception_directory_entries(252) = 
00041bd0  {
00041bd0      uint32_t beginAddress = 0x21380
00041bd4      uint32_t endAddress = 0x21452
00041bd8      uint32_t unwindInformation = 0x2d6a4
00041bdc  }
00041bdc  struct Exception_Directory_Entry __exception_directory_entries(253) = 
00041bdc  {
00041bdc      uint32_t beginAddress = 0x21458
00041be0      uint32_t endAddress = 0x214ef
00041be4      uint32_t unwindInformation = 0x2dee4
00041be8  }
00041be8  struct Exception_Directory_Entry __exception_directory_entries(254) = 
00041be8  {
00041be8      uint32_t beginAddress = 0x214f8
00041bec      uint32_t endAddress = 0x21573
00041bf0      uint32_t unwindInformation = 0x2d6f0
00041bf4  }
00041bf4  struct Exception_Directory_Entry __exception_directory_entries(255) = 
00041bf4  {
00041bf4      uint32_t beginAddress = 0x2157c
00041bf8      uint32_t endAddress = 0x218a3
00041bfc      uint32_t unwindInformation = 0x2e628
00041c00  }
00041c00  struct Exception_Directory_Entry __exception_directory_entries(256) = 
00041c00  {
00041c00      uint32_t beginAddress = 0x218ac
00041c04      uint32_t endAddress = 0x21bf4
00041c08      uint32_t unwindInformation = 0x2dec4
00041c0c  }
00041c0c  struct Exception_Directory_Entry __exception_directory_entries(257) = 
00041c0c  {
00041c0c      uint32_t beginAddress = 0x21bfc
00041c10      uint32_t endAddress = 0x21f53
00041c14      uint32_t unwindInformation = 0x2dea4
00041c18  }
00041c18  struct Exception_Directory_Entry __exception_directory_entries(258) = 
00041c18  {
00041c18      uint32_t beginAddress = 0x21f5c
00041c1c      uint32_t endAddress = 0x2204f
00041c20      uint32_t unwindInformation = 0x2de88
00041c24  }
00041c24  struct Exception_Directory_Entry __exception_directory_entries(259) = 
00041c24  {
00041c24      uint32_t beginAddress = 0x22058
00041c28      uint32_t endAddress = 0x220b1
00041c2c      uint32_t unwindInformation = 0x2e17c
00041c30  }
00041c30  struct Exception_Directory_Entry __exception_directory_entries(260) = 
00041c30  {
00041c30      uint32_t beginAddress = 0x220b8
00041c34      uint32_t endAddress = 0x221e2
00041c38      uint32_t unwindInformation = 0x2d684
00041c3c  }
00041c3c  struct Exception_Directory_Entry __exception_directory_entries(261) = 
00041c3c  {
00041c3c      uint32_t beginAddress = 0x221e8
00041c40      uint32_t endAddress = 0x223a4
00041c44      uint32_t unwindInformation = 0x2de58
00041c48  }
00041c48  struct Exception_Directory_Entry __exception_directory_entries(262) = 
00041c48  {
00041c48      uint32_t beginAddress = 0x223ac
00041c4c      uint32_t endAddress = 0x22556
00041c50      uint32_t unwindInformation = 0x2d674
00041c54  }
00041c54  struct Exception_Directory_Entry __exception_directory_entries(263) = 
00041c54  {
00041c54      uint32_t beginAddress = 0x2255c
00041c58      uint32_t endAddress = 0x225c4
00041c5c      uint32_t unwindInformation = 0x2e234
00041c60  }
00041c60  struct Exception_Directory_Entry __exception_directory_entries(264) = 
00041c60  {
00041c60      uint32_t beginAddress = 0x225cc
00041c64      uint32_t endAddress = 0x22655
00041c68      uint32_t unwindInformation = 0x2e21c
00041c6c  }
00041c6c  struct Exception_Directory_Entry __exception_directory_entries(265) = 
00041c6c  {
00041c6c      uint32_t beginAddress = 0x2265c
00041c70      uint32_t endAddress = 0x22861
00041c74      uint32_t unwindInformation = 0x2e1f8
00041c78  }
00041c78  struct Exception_Directory_Entry __exception_directory_entries(266) = 
00041c78  {
00041c78      uint32_t beginAddress = 0x22868
00041c7c      uint32_t endAddress = 0x22c3f
00041c80      uint32_t unwindInformation = 0x2e1d8
00041c84  }
00041c84  struct Exception_Directory_Entry __exception_directory_entries(267) = 
00041c84  {
00041c84      uint32_t beginAddress = 0x22c48
00041c88      uint32_t endAddress = 0x22d2d
00041c8c      uint32_t unwindInformation = 0x2de4c
00041c90  }
00041c90  struct Exception_Directory_Entry __exception_directory_entries(268) = 
00041c90  {
00041c90      uint32_t beginAddress = 0x22d90
00041c94      uint32_t endAddress = 0x22f6e
00041c98      uint32_t unwindInformation = 0x2e26c
00041c9c  }
00041c9c  struct Exception_Directory_Entry __exception_directory_entries(269) = 
00041c9c  {
00041c9c      uint32_t beginAddress = 0x22f74
00041ca0      uint32_t endAddress = 0x23031
00041ca4      uint32_t unwindInformation = 0x2d65c
00041ca8  }
00041ca8  struct Exception_Directory_Entry __exception_directory_entries(270) = 
00041ca8  {
00041ca8      uint32_t beginAddress = 0x23038
00041cac      uint32_t endAddress = 0x23224
00041cb0      uint32_t unwindInformation = 0x2de20
00041cb4  }
00041cb4  struct Exception_Directory_Entry __exception_directory_entries(271) = 
00041cb4  {
00041cb4      uint32_t beginAddress = 0x2322c
00041cb8      uint32_t endAddress = 0x2327e
00041cbc      uint32_t unwindInformation = 0x2d650
00041cc0  }
00041cc0  struct Exception_Directory_Entry __exception_directory_entries(272) = 
00041cc0  {
00041cc0      uint32_t beginAddress = 0x23348
00041cc4      uint32_t endAddress = 0x2336f
00041cc8      uint32_t unwindInformation = 0x2d648
00041ccc  }
00041ccc  struct Exception_Directory_Entry __exception_directory_entries(273) = 
00041ccc  {
00041ccc      uint32_t beginAddress = 0x238d0
00041cd0      uint32_t endAddress = 0x23933
00041cd4      uint32_t unwindInformation = 0x2dc90
00041cd8  }
00041cd8  struct Exception_Directory_Entry __exception_directory_entries(274) = 
00041cd8  {
00041cd8      uint32_t beginAddress = 0x2393c
00041cdc      uint32_t endAddress = 0x23959
00041ce0      uint32_t unwindInformation = 0x2d640
00041ce4  }
00041ce4  struct Exception_Directory_Entry __exception_directory_entries(275) = 
00041ce4  {
00041ce4      uint32_t beginAddress = 0x23960
00041ce8      uint32_t endAddress = 0x24760
00041cec      uint32_t unwindInformation = 0x2e890
00041cf0  }
00041cf0  struct Exception_Directory_Entry __exception_directory_entries(276) = 
00041cf0  {
00041cf0      uint32_t beginAddress = 0x24768
00041cf4      uint32_t endAddress = 0x24872
00041cf8      uint32_t unwindInformation = 0x2e8c4
00041cfc  }
00041cfc  struct Exception_Directory_Entry __exception_directory_entries(277) = 
00041cfc  {
00041cfc      uint32_t beginAddress = 0x24878
00041d00      uint32_t endAddress = 0x24adb
00041d04      uint32_t unwindInformation = 0x2e8cc
00041d08  }
00041d08  struct Exception_Directory_Entry __exception_directory_entries(278) = 
00041d08  {
00041d08      uint32_t beginAddress = 0x24ae4
00041d0c      uint32_t endAddress = 0x24e85
00041d10      uint32_t unwindInformation = 0x2e8e4
00041d14  }
00041d14  struct Exception_Directory_Entry __exception_directory_entries(279) = 
00041d14  {
00041d14      uint32_t beginAddress = 0x24e8c
00041d18      uint32_t endAddress = 0x25689
00041d1c      uint32_t unwindInformation = 0x2e8f4
00041d20  }
00041d20  struct Exception_Directory_Entry __exception_directory_entries(280) = 
00041d20  {
00041d20      uint32_t beginAddress = 0x25690
00041d24      uint32_t endAddress = 0x2576c
00041d28      uint32_t unwindInformation = 0x2e8c4
00041d2c  }
00041d2c  struct Exception_Directory_Entry __exception_directory_entries(281) = 
00041d2c  {
00041d2c      uint32_t beginAddress = 0x2581c
00041d30      uint32_t endAddress = 0x258cb
00041d34      uint32_t unwindInformation = 0x2e920
00041d38  }
00041d38  struct Exception_Directory_Entry __exception_directory_entries(282) = 
00041d38  {
00041d38      uint32_t beginAddress = 0x258d4
00041d3c      uint32_t endAddress = 0x25bec
00041d40      uint32_t unwindInformation = 0x2e930
00041d44  }
00041d44  struct Exception_Directory_Entry __exception_directory_entries(283) = 
00041d44  {
00041d44      uint32_t beginAddress = 0x25bf4
00041d48      uint32_t endAddress = 0x25ef4
00041d4c      uint32_t unwindInformation = 0x2e940
00041d50  }
00041d50  struct Exception_Directory_Entry __exception_directory_entries(284) = 
00041d50  {
00041d50      uint32_t beginAddress = 0x25efc
00041d54      uint32_t endAddress = 0x263c9
00041d58      uint32_t unwindInformation = 0x2e950
00041d5c  }
00041d5c  struct Exception_Directory_Entry __exception_directory_entries(285) = 
00041d5c  {
00041d5c      uint32_t beginAddress = 0x263d0
00041d60      uint32_t endAddress = 0x26633
00041d64      uint32_t unwindInformation = 0x2e8cc
00041d68  }
00041d68  struct Exception_Directory_Entry __exception_directory_entries(286) = 
00041d68  {
00041d68      uint32_t beginAddress = 0x2663c
00041d6c      uint32_t endAddress = 0x26a7d
00041d70      uint32_t unwindInformation = 0x2e970
00041d74  }
00041d74  struct Exception_Directory_Entry __exception_directory_entries(287) = 
00041d74  {
00041d74      uint32_t beginAddress = 0x26a84
00041d78      uint32_t endAddress = 0x26ea5
00041d7c      uint32_t unwindInformation = 0x2e984
00041d80  }
00041d80  struct Exception_Directory_Entry __exception_directory_entries(288) = 
00041d80  {
00041d80      uint32_t beginAddress = 0x26eac
00041d84      uint32_t endAddress = 0x271ba
00041d88      uint32_t unwindInformation = 0x2e994
00041d8c  }
00041d8c  struct Exception_Directory_Entry __exception_directory_entries(289) = 
00041d8c  {
00041d8c      uint32_t beginAddress = 0x271c0
00041d90      uint32_t endAddress = 0x27225
00041d94      uint32_t unwindInformation = 0x2e9a8
00041d98  }
00041d98  struct Exception_Directory_Entry __exception_directory_entries(290) = 
00041d98  {
00041d98      uint32_t beginAddress = 0x2722c
00041d9c      uint32_t endAddress = 0x272e5
00041da0      uint32_t unwindInformation = 0x2d6f0
00041da4  }
00041da4  struct Exception_Directory_Entry __exception_directory_entries(291) = 
00041da4  {
00041da4      uint32_t beginAddress = 0x272ec
00041da8      uint32_t endAddress = 0x2744a
00041dac      uint32_t unwindInformation = 0x2e9b0
00041db0  }
00041db0  struct Exception_Directory_Entry __exception_directory_entries(292) = 
00041db0  {
00041db0      uint32_t beginAddress = 0x27450
00041db4      uint32_t endAddress = 0x2759f
00041db8      uint32_t unwindInformation = 0x2e9b0
00041dbc  }
00041dbc  struct Exception_Directory_Entry __exception_directory_entries(293) = 
00041dbc  {
00041dbc      uint32_t beginAddress = 0x275a8
00041dc0      uint32_t endAddress = 0x27842
00041dc4      uint32_t unwindInformation = 0x2e9cc
00041dc8  }
00041dc8  struct Exception_Directory_Entry __exception_directory_entries(294) = 
00041dc8  {
00041dc8      uint32_t beginAddress = 0x27858
00041dcc      uint32_t endAddress = 0x27d59
00041dd0      uint32_t unwindInformation = 0x2e9fc
00041dd4  }
00041dd4  struct Exception_Directory_Entry __exception_directory_entries(295) = 
00041dd4  {
00041dd4      uint32_t beginAddress = 0x27d60
00041dd8      uint32_t endAddress = 0x27dc9
00041ddc      uint32_t unwindInformation = 0x2ea28
00041de0  }
00041de0  struct Exception_Directory_Entry __exception_directory_entries(296) = 
00041de0  {
00041de0      uint32_t beginAddress = 0x27dd0
00041de4      uint32_t endAddress = 0x2804a
00041de8      uint32_t unwindInformation = 0x2ea30
00041dec  }
00041dec  struct Exception_Directory_Entry __exception_directory_entries(297) = 
00041dec  {
00041dec      uint32_t beginAddress = 0x28050
00041df0      uint32_t endAddress = 0x28077
00041df4      uint32_t unwindInformation = 0x2ea44
00041df8  }
00041df8  struct Exception_Directory_Entry __exception_directory_entries(298) = 
00041df8  {
00041df8      uint32_t beginAddress = 0x28080
00041dfc      uint32_t endAddress = 0x280aa
00041e00      uint32_t unwindInformation = 0x2ea44
00041e04  }
00041e04  struct Exception_Directory_Entry __exception_directory_entries(299) = 
00041e04  {
00041e04      uint32_t beginAddress = 0x280e4
00041e08      uint32_t endAddress = 0x280f5
00041e0c      uint32_t unwindInformation = 0x2d640
00041e10  }
00041e10  struct Exception_Directory_Entry __exception_directory_entries(300) = 
00041e10  {
00041e10      uint32_t beginAddress = 0x280fc
00041e14      uint32_t endAddress = 0x28119
00041e18      uint32_t unwindInformation = 0x2dc90
00041e1c  }
00041e1c  struct Exception_Directory_Entry __exception_directory_entries(301) = 
00041e1c  {
00041e1c      uint32_t beginAddress = 0x28120
00041e20      uint32_t endAddress = 0x2819c
00041e24      uint32_t unwindInformation = 0x2ea54
00041e28  }
00041e28  struct Exception_Directory_Entry __exception_directory_entries(302) = 
00041e28  {
00041e28      uint32_t beginAddress = 0x281a4
00041e2c      uint32_t endAddress = 0x281c3
00041e30      uint32_t unwindInformation = 0x2dc90
00041e34  }
00041e34  struct Exception_Directory_Entry __exception_directory_entries(303) = 
00041e34  {
00041e34      uint32_t beginAddress = 0x281f4
00041e38      uint32_t endAddress = 0x28362
00041e3c      uint32_t unwindInformation = 0x2ea88
00041e40  }
00041e40  struct Exception_Directory_Entry __exception_directory_entries(304) = 
00041e40  {
00041e40      uint32_t beginAddress = 0x28380
00041e44      uint32_t endAddress = 0x28398
00041e48      uint32_t unwindInformation = 0x2eaa8
00041e4c  }
00041e4c  struct Exception_Directory_Entry __exception_directory_entries(305) = 
00041e4c  {
00041e4c      uint32_t beginAddress = 0x283a0
00041e50      uint32_t endAddress = 0x283a1
00041e54      uint32_t unwindInformation = 0x2eaac
00041e58  }
00041e58  struct Exception_Directory_Entry __exception_directory_entries(306) = 
00041e58  {
00041e58      uint32_t beginAddress = 0x283b0
00041e5c      uint32_t endAddress = 0x283b1
00041e60      uint32_t unwindInformation = 0x2eab0
00041e64  }
00041e64  struct Exception_Directory_Entry __exception_directory_entries(307) = 
00041e64  {
00041e64      uint32_t beginAddress = 0x28410
00041e68      uint32_t endAddress = 0x28420
00041e6c      uint32_t unwindInformation = 0x2ea80
00041e70  }
00041e70  struct Exception_Directory_Entry __exception_directory_entries(308) = 
00041e70  {
00041e70      uint32_t beginAddress = 0x29c9d
00041e74      uint32_t endAddress = 0x29cc8
00041e78      uint32_t unwindInformation = 0x2ea4c
00041e7c  }
00041e7c  struct Exception_Directory_Entry __exception_directory_entries(309) = 
00041e7c  {
00041e7c      uint32_t beginAddress = 0x33064
00041e80      uint32_t endAddress = 0x33082
00041e84      uint32_t unwindInformation = 0x2d640
00041e88  }
.pdata section ended  {0x41000-0x41e88}

.edata section started  {0x42000-0x4229f}
00042000  struct Export_Directory_Table __export_directory_table = 
00042000  {
00042000      uint32_t exportFlags = 0x0
00042004      uint32_t timeDateStamp = 0x510f14d0
00042008      uint16_t majorVersion = 0x0
0004200a      uint16_t minorVersion = 0x0
0004200c      uint32_t nameRva = 0x320f0
00042010      uint32_t ordinalBase = 0x1
00042014      uint32_t addressTableEntries = 0x14
00042018      uint32_t numberOfNamePointers = 0x14
0004201c      uint32_t exportAddressTableRva = 0x32028
00042020      uint32_t namePointerRva = 0x32078
00042024      uint32_t ordinalTableRva = 0x320c8
00042028  }
00042028  uint32_t __pe_NWTransLibV_export_address_table[0x14] = 
00042028  {
00042028      [0x00] =  0x000280d8
0004202c      [0x01] =  0x000280d8
00042030      [0x02] =  0x00001fdc
00042034      [0x03] =  0x00001b30
00042038      [0x04] =  0x00001dd0
0004203c      [0x05] =  0x0000220c
00042040      [0x06] =  0x00001884
00042044      [0x07] =  0x0000186c
00042048      [0x08] =  0x000018f0
0004204c      [0x09] =  0x000036bc
00042050      [0x0a] =  0x00001aa4
00042054      [0x0b] =  0x0000189c
00042058      [0x0c] =  0x00001a30
0004205c      [0x0d] =  0x00001008
00042060      [0x0e] =  0x00001958
00042064      [0x0f] =  0x000019bc
00042068      [0x10] =  0x0000172c
0004206c      [0x11] =  0x00001ab4
00042070      [0x12] =  0x00001520
00042074      [0x13] =  0x00003708
00042078  }
00042078  uint32_t __pe_NWTransLibV_export_name_pointer_table[0x14] = 
00042078  {
00042078      [0x00] =  0x00032100
0004207c      [0x01] =  0x0003210e
00042080      [0x02] =  0x00032118
00042084      [0x03] =  0x00032129
00042088      [0x04] =  0x00032135
0004208c      [0x05] =  0x00032145
00042090      [0x06] =  0x00032156
00042094      [0x07] =  0x0003216b
00042098      [0x08] =  0x00032180
0004209c      [0x09] =  0x0003219a
000420a0      [0x0a] =  0x000321b1
000420a4      [0x0b] =  0x000321cb
000420a8      [0x0c] =  0x000321e2
000420ac      [0x0d] =  0x000321fb
000420b0      [0x0e] =  0x0003220e
000420b4      [0x0f] =  0x00032228
000420b8      [0x10] =  0x00032242
000420bc      [0x11] =  0x0003225c
000420c0      [0x12] =  0x00032276
000420c4      [0x13] =  0x00032287
000420c8  }
000420c8  uint16_t __pe_NWTransLibV_export_ordinal_table[0x14] = 
000420c8  {
000420c8      [0x00] =  0x0000
000420ca      [0x01] =  0x0001
000420cc      [0x02] =  0x0002
000420ce      [0x03] =  0x0003
000420d0      [0x04] =  0x0004
000420d2      [0x05] =  0x0005
000420d4      [0x06] =  0x0006
000420d6      [0x07] =  0x0007
000420d8      [0x08] =  0x0008
000420da      [0x09] =  0x0009
000420dc      [0x0a] =  0x000a
000420de      [0x0b] =  0x000b
000420e0      [0x0c] =  0x000c
000420e2      [0x0d] =  0x000d
000420e4      [0x0e] =  0x000e
000420e6      [0x0f] =  0x000f
000420e8      [0x10] =  0x0010
000420ea      [0x11] =  0x0011
000420ec      [0x12] =  0x0012
000420ee      [0x13] =  0x0013
000420f0  }
000420f0  char __pe_NWTransLibV_export_dll_name[0x10] = "NWTransLibV.sys", 0
00042100  char __export_name(DllInitialize)[0xe] = "DllInitialize", 0
0004210e  char __export_name(DllUnload)[0xa] = "DllUnload", 0
00042118  char __export_name(TLConfigureTrace)[0x11] = "TLConfigureTrace", 0
00042129  char __export_name(TLDbgLogMsg)[0xc] = "TLDbgLogMsg", 0
00042135  char __export_name(TLDbgLogRawData)[0x10] = "TLDbgLogRawData", 0
00042145  char __export_name(TLGetTraceBuffer)[0x11] = "TLGetTraceBuffer", 0
00042156  char __export_name(TLGetTranslationMode)[0x15] = "TLGetTranslationMode", 0
0004216b  char __export_name(TLSetTranslationMode)[0x15] = "TLSetTranslationMode", 0
00042180  char __export_name(TransLibEnterWorkingState)[0x1a] = "TransLibEnterWorkingState", 0
0004219a  char __export_name(TransLibGetMemoryUsage)[0x17] = "TransLibGetMemoryUsage", 0
000421b1  char __export_name(TransLibGetParsedTransfer)[0x1a] = "TransLibGetParsedTransfer", 0
000421cb  char __export_name(TransLibGetThreadTimes)[0x17] = "TransLibGetThreadTimes", 0
000421e2  char __export_name(TransLibHardwareReadSync)[0x19] = "TransLibHardwareReadSync", 0
000421fb  char __export_name(TransLibInitialize)[0x13] = "TransLibInitialize", 0
0004220e  char __export_name(TransLibLeaveWorkingState)[0x1a] = "TransLibLeaveWorkingState", 0
00042228  char __export_name(TransLibProcessStreamSync)[0x1a] = "TransLibProcessStreamSync", 0
00042242  char __export_name(TransLibProcessUserReport)[0x1a] = "TransLibProcessUserReport", 0
0004225c  char __export_name(TransLibSetParsedTransfer)[0x1a] = "TransLibSetParsedTransfer", 0
00042276  char __export_name(TransLibShutdown)[0x11] = "TransLibShutdown", 0
00042287  char __export_name(TransLibUpdateInputMode)[0x18] = "TransLibUpdateInputMode", 0
.edata section ended  {0x42000-0x4229f}

INIT section started  {0x43000-0x4361a}
00043000  00 00 00 00 00 00 00 00                                                                          ........

00043008    void __security_init_cookie()

00043008  {
00043008      uint64_t __security_cookie_1 = __security_cookie;
00043008      
00043021      if (!__security_cookie_1 || __security_cookie_1 == 0x2b992ddfa232)
00043021      {
00043044          __security_cookie_1 =
00043044              (*(uint64_t*)-0xfffff78000000320 ^ &__security_cookie) & 0xffffffffffff;
00043044          
00043047          if (!__security_cookie_1)
00043047              __security_cookie_1 = 0x2b992ddfa232;
00043047          
0004304b          __security_cookie = __security_cookie_1;
00043021      }
00043021      
00043055      __security_cookie_complement = ~__security_cookie_1;
00043008  }

0004305d                                                                                         cc cc cc                               ...
00043060  cc cc cc cc                                                                                      ....

00043064    int32_t GsDriverEntry(struct _DRIVER_OBJECT* DriverObject, struct _UNICODE_STRING* RegistryPath)

00043064  {
0004306e      __security_init_cookie();
0004307d      /* tailcall */
0004307d      return DllInitialize(DriverObject, RegistryPath);
00043064  }

00043082        cc cc                                                                                        ..
00043084  struct Import_Directory_Table __IMPORT_DESCRIPTOR_ntoskrnl[0x3] = 
00043084  {
00043084      [0x0] = 
00043084      {
00043084          uint32_t importLookupTableRva = 0x330d0
00043088          uint32_t timeDateStamp = 0x0
0004308c          uint32_t forwarderChain = 0x0
00043090          uint32_t nameRva = 0x33596
00043094          uint32_t importAddressTableRva = 0x2a010
00043098      }
00043098      [0x1] = 
00043098      {
00043098          uint32_t importLookupTableRva = 0x330c0
0004309c          uint32_t timeDateStamp = 0x0
000430a0          uint32_t forwarderChain = 0x0
000430a4          uint32_t nameRva = 0x335c0
000430a8          uint32_t importAddressTableRva = 0x2a000
000430ac      }
000430ac      [0x2] = 
000430ac      {
000430ac          uint32_t importLookupTableRva = 0x0
000430b0          uint32_t timeDateStamp = 0x0
000430b4          uint32_t forwarderChain = 0x0
000430b8          uint32_t nameRva = 0x0
000430bc          uint32_t importAddressTableRva = 0x0
000430c0      }
000430c0  }
000430c0  uint64_t __import_lookup_table_1(HAL:KeQueryPerformanceCounter) = 0x335a4
000430c8  uint64_t data_430c8 = 0x0
000430d0  uint64_t __import_lookup_table_0(ntoskrnl:KeSetEvent) = 0x3326c
000430d8  uint64_t __import_lookup_table_0(ntoskrnl:KeInitializeDpc) = 0x3327a
000430e0  uint64_t __import_lookup_table_0(ntoskrnl:KeInitializeTimer) = 0x3328c
000430e8  uint64_t __import_lookup_table_0(ntoskrnl:KeSetTimerEx) = 0x332a0
000430f0  uint64_t __import_lookup_table_0(ntoskrnl:KeQueryTimeIncrement) = 0x332b0
000430f8  uint64_t __import_lookup_table_0(ntoskrnl:KeCancelTimer) = 0x332c8
00043100  uint64_t __import_lookup_table_0(ntoskrnl:DbgPrint) = 0x332d8
00043108  uint64_t __import_lookup_table_0(ntoskrnl:RtlInitUnicodeString) = 0x332e4
00043110  uint64_t __import_lookup_table_0(ntoskrnl:ExSystemTimeToLocalTime) = 0x332fc
00043118  uint64_t __import_lookup_table_0(ntoskrnl:_vsnprintf) = 0x33316
00043120  uint64_t __import_lookup_table_0(ntoskrnl:RtlTimeToTimeFields) = 0x33324
00043128  uint64_t __import_lookup_table_0(ntoskrnl:ExDeleteResourceLite) = 0x3333a
00043130  uint64_t __import_lookup_table_0(ntoskrnl:ExInitializeResourceLite) = 0x33352
00043138  uint64_t __import_lookup_table_0(ntoskrnl:KeQueryRuntimeThread) = 0x3336e
00043140  uint64_t __import_lookup_table_0(ntoskrnl:KeResetEvent) = 0x33386
00043148  uint64_t __import_lookup_table_0(ntoskrnl:KeInitializeEvent) = 0x33396
00043150  uint64_t __import_lookup_table_0(ntoskrnl:KeReleaseSpinLock) = 0x333aa
00043158  uint64_t __import_lookup_table_0(ntoskrnl:KeDelayExecutionThread) = 0x333be
00043160  uint64_t __import_lookup_table_0(ntoskrnl:PsCreateSystemThread) = 0x333d8
00043168  uint64_t __import_lookup_table_0(ntoskrnl:ExFreePoolWithTag) = 0x33258
00043170  uint64_t __import_lookup_table_0(ntoskrnl:ZwClose) = 0x3340a
00043178  uint64_t __import_lookup_table_0(ntoskrnl:ObReferenceObjectByHandle) = 0x33414
00043180  uint64_t __import_lookup_table_0(ntoskrnl:KeWaitForSingleObject) = 0x33430
00043188  uint64_t __import_lookup_table_0(ntoskrnl:ObfDereferenceObject) = 0x33448
00043190  uint64_t __import_lookup_table_0(ntoskrnl:KeWaitForMultipleObjects) = 0x33460
00043198  uint64_t __import_lookup_table_0(ntoskrnl:KeAcquireSpinLockRaiseToDpc) = 0x3347c
000431a0  uint64_t __import_lookup_table_0(ntoskrnl:RtlQueryRegistryValues) = 0x3349a
000431a8  uint64_t __import_lookup_table_0(ntoskrnl:ZwSetValueKey) = 0x334b4
000431b0  uint64_t __import_lookup_table_0(ntoskrnl:ZwOpenKey) = 0x334c4
000431b8  uint64_t __import_lookup_table_0(ntoskrnl:ExAcquireResourceExclusiveLite) = 0x334d0
000431c0  uint64_t __import_lookup_table_0(ntoskrnl:KeLeaveCriticalRegion) = 0x334f2
000431c8  uint64_t __import_lookup_table_0(ntoskrnl:KeEnterCriticalRegion) = 0x3350a
000431d0  uint64_t __import_lookup_table_0(ntoskrnl:ExAcquireResourceSharedLite) = 0x33522
000431d8  uint64_t __import_lookup_table_0(ntoskrnl:ExReleaseResourceLite) = 0x33540
000431e0  uint64_t __import_lookup_table_0(ntoskrnl:ZwCreateKey) = 0x33558
000431e8  uint64_t __import_lookup_table_0(ntoskrnl:ZwQueryValueKey) = 0x33566
000431f0  uint64_t __import_lookup_table_0(ntoskrnl:_vsnwprintf) = 0x33578
000431f8  uint64_t __import_lookup_table_0(ntoskrnl:KeBugCheckEx) = 0x33586
00043200  uint64_t __import_lookup_table_0(ntoskrnl:PsTerminateSystemThread) = 0x333f0
00043208  uint64_t __import_lookup_table_0(ntoskrnl:ExAllocatePoolWithTag) = 0x33240
00043210  uint64_t __import_lookup_table_0(ntoskrnl:KeInitializeMutex) = 0x335c8
00043218  uint64_t __import_lookup_table_0(ntoskrnl:KeReleaseMutex) = 0x335dc
00043220  uint64_t __import_lookup_table_0(ntoskrnl:strrchr) = 0x335ee
00043228  uint64_t __import_lookup_table_0(ntoskrnl:RtlRaiseException) = 0x335f8
00043230  uint64_t __import_lookup_table_0(ntoskrnl:RtlUnwindEx) = 0x3360c
00043238  uint64_t data_43238 = 0x0
00043240  uint16_t __export_name_ptr_table_0(ntoskrnl:ExAllocatePoolWithTag) = 0x46
00043242  char __import_name_0(ntoskrnl:ExAllocatePoolWithTag)[0x16] = "ExAllocatePoolWithTag", 0
00043258  uint16_t __export_name_ptr_table_0(ntoskrnl:ExFreePoolWithTag) = 0x58
0004325a  char __import_name_0(ntoskrnl:ExFreePoolWithTag)[0x12] = "ExFreePoolWithTag", 0
0004326c  uint16_t __export_name_ptr_table_0(ntoskrnl:KeSetEvent) = 0x278
0004326e  char __import_name_0(ntoskrnl:KeSetEvent)[0xb] = "KeSetEvent", 0

00043279                                                                             00                                             .

0004327a  uint16_t __export_name_ptr_table_0(ntoskrnl:KeInitializeDpc) = 0x22d
0004327c  char __import_name_0(ntoskrnl:KeInitializeDpc)[0x10] = "KeInitializeDpc", 0
0004328c  uint16_t __export_name_ptr_table_0(ntoskrnl:KeInitializeTimer) = 0x236
0004328e  char __import_name_0(ntoskrnl:KeInitializeTimer)[0x12] = "KeInitializeTimer", 0
000432a0  uint16_t __export_name_ptr_table_0(ntoskrnl:KeSetTimerEx) = 0x283
000432a2  char __import_name_0(ntoskrnl:KeSetTimerEx)[0xd] = "KeSetTimerEx", 0

000432af                                               00                                                                 .

000432b0  uint16_t __export_name_ptr_table_0(ntoskrnl:KeQueryTimeIncrement) = 0x24f
000432b2  char __import_name_0(ntoskrnl:KeQueryTimeIncrement)[0x15] = "KeQueryTimeIncrement", 0

000432c7                       00                                                                                 .

000432c8  uint16_t __export_name_ptr_table_0(ntoskrnl:KeCancelTimer) = 0x214
000432ca  char __import_name_0(ntoskrnl:KeCancelTimer)[0xe] = "KeCancelTimer", 0
000432d8  uint16_t __export_name_ptr_table_0(ntoskrnl:DbgPrint) = 0x31
000432da  char __import_name_0(ntoskrnl:DbgPrint)[0x9] = "DbgPrint", 0

000432e3           00                                                                                         .

000432e4  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlInitUnicodeString) = 0x43e
000432e6  char __import_name_0(ntoskrnl:RtlInitUnicodeString)[0x15] = "RtlInitUnicodeString", 0

000432fb                                                                                   00                                         .

000432fc  uint16_t __export_name_ptr_table_0(ntoskrnl:ExSystemTimeToLocalTime) = 0x8f
000432fe  char __import_name_0(ntoskrnl:ExSystemTimeToLocalTime)[0x18] = "ExSystemTimeToLocalTime", 0
00043316  uint16_t __export_name_ptr_table_0(ntoskrnl:_vsnprintf) = 0x5a8
00043318  char __import_name_0(ntoskrnl:_vsnprintf)[0xb] = "_vsnprintf", 0

00043323           00                                                                                         .

00043324  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlTimeToTimeFields) = 0x4a8
00043326  char __import_name_0(ntoskrnl:RtlTimeToTimeFields)[0x14] = "RtlTimeToTimeFields", 0
0004333a  uint16_t __export_name_ptr_table_0(ntoskrnl:ExDeleteResourceLite) = 0x4c
0004333c  char __import_name_0(ntoskrnl:ExDeleteResourceLite)[0x15] = "ExDeleteResourceLite", 0

00043351                                                     00                                                             .

00043352  uint16_t __export_name_ptr_table_0(ntoskrnl:ExInitializeResourceLite) = 0x61
00043354  char __import_name_0(ntoskrnl:ExInitializeResourceLite)[0x19] = "ExInitializeResourceLite", 0

0004336d                                         00                                                                     .

0004336e  uint16_t __export_name_ptr_table_0(ntoskrnl:KeQueryRuntimeThread) = 0x24e
00043370  char __import_name_0(ntoskrnl:KeQueryRuntimeThread)[0x15] = "KeQueryRuntimeThread", 0

00043385                 00                                                                                     .

00043386  uint16_t __export_name_ptr_table_0(ntoskrnl:KeResetEvent) = 0x26f
00043388  char __import_name_0(ntoskrnl:KeResetEvent)[0xd] = "KeResetEvent", 0

00043395                                                                 00                                                     .

00043396  uint16_t __export_name_ptr_table_0(ntoskrnl:KeInitializeEvent) = 0x22e
00043398  char __import_name_0(ntoskrnl:KeInitializeEvent)[0x12] = "KeInitializeEvent", 0
000433aa  uint16_t __export_name_ptr_table_0(ntoskrnl:KeReleaseSpinLock) = 0x265
000433ac  char __import_name_0(ntoskrnl:KeReleaseSpinLock)[0x12] = "KeReleaseSpinLock", 0
000433be  uint16_t __export_name_ptr_table_0(ntoskrnl:KeDelayExecutionThread) = 0x218
000433c0  char __import_name_0(ntoskrnl:KeDelayExecutionThread)[0x17] = "KeDelayExecutionThread", 0

000433d7                                                                       00                                                 .

000433d8  uint16_t __export_name_ptr_table_0(ntoskrnl:PsCreateSystemThread) = 0x36e
000433da  char __import_name_0(ntoskrnl:PsCreateSystemThread)[0x15] = "PsCreateSystemThread", 0

000433ef                                               00                                                                 .

000433f0  uint16_t __export_name_ptr_table_0(ntoskrnl:PsTerminateSystemThread) = 0x3c4
000433f2  char __import_name_0(ntoskrnl:PsTerminateSystemThread)[0x18] = "PsTerminateSystemThread", 0
0004340a  uint16_t __export_name_ptr_table_0(ntoskrnl:ZwClose) = 0x525
0004340c  char __import_name_0(ntoskrnl:ZwClose)[0x8] = "ZwClose", 0
00043414  uint16_t __export_name_ptr_table_0(ntoskrnl:ObReferenceObjectByHandle) = 0x34a
00043416  char __import_name_0(ntoskrnl:ObReferenceObjectByHandle)[0x1a] = "ObReferenceObjectByHandle", 0
00043430  uint16_t __export_name_ptr_table_0(ntoskrnl:KeWaitForSingleObject) = 0x294
00043432  char __import_name_0(ntoskrnl:KeWaitForSingleObject)[0x16] = "KeWaitForSingleObject", 0
00043448  uint16_t __export_name_ptr_table_0(ntoskrnl:ObfDereferenceObject) = 0x352
0004344a  char __import_name_0(ntoskrnl:ObfDereferenceObject)[0x15] = "ObfDereferenceObject", 0

0004345f                                                                                               00                                 .

00043460  uint16_t __export_name_ptr_table_0(ntoskrnl:KeWaitForMultipleObjects) = 0x292
00043462  char __import_name_0(ntoskrnl:KeWaitForMultipleObjects)[0x19] = "KeWaitForMultipleObjects", 0

0004347b                                                                                   00                                         .

0004347c  uint16_t __export_name_ptr_table_0(ntoskrnl:KeAcquireSpinLockRaiseToDpc) = 0x20c
0004347e  char __import_name_0(ntoskrnl:KeAcquireSpinLockRaiseToDpc)[0x1c] = "KeAcquireSpinLockRaiseToDpc", 0
0004349a  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlQueryRegistryValues) = 0x486
0004349c  char __import_name_0(ntoskrnl:RtlQueryRegistryValues)[0x17] = "RtlQueryRegistryValues", 0

000434b3                                                           00                                                         .

000434b4  uint16_t __export_name_ptr_table_0(ntoskrnl:ZwSetValueKey) = 0x58a
000434b6  char __import_name_0(ntoskrnl:ZwSetValueKey)[0xe] = "ZwSetValueKey", 0
000434c4  uint16_t __export_name_ptr_table_0(ntoskrnl:ZwOpenKey) = 0x54f
000434c6  char __import_name_0(ntoskrnl:ZwOpenKey)[0xa] = "ZwOpenKey", 0
000434d0  uint16_t __export_name_ptr_table_0(ntoskrnl:ExAcquireResourceExclusiveLite) = 0x39
000434d2  char __import_name_0(ntoskrnl:ExAcquireResourceExclusiveLite)[0x1f] = "ExAcquireResourceExclusiveLite", 0

000434f1                                                     00                                                             .

000434f2  uint16_t __export_name_ptr_table_0(ntoskrnl:KeLeaveCriticalRegion) = 0x243
000434f4  char __import_name_0(ntoskrnl:KeLeaveCriticalRegion)[0x16] = "KeLeaveCriticalRegion", 0
0004350a  uint16_t __export_name_ptr_table_0(ntoskrnl:KeEnterCriticalRegion) = 0x21e
0004350c  char __import_name_0(ntoskrnl:KeEnterCriticalRegion)[0x16] = "KeEnterCriticalRegion", 0
00043522  uint16_t __export_name_ptr_table_0(ntoskrnl:ExAcquireResourceSharedLite) = 0x3a
00043524  char __import_name_0(ntoskrnl:ExAcquireResourceSharedLite)[0x1c] = "ExAcquireResourceSharedLite", 0
00043540  uint16_t __export_name_ptr_table_0(ntoskrnl:ExReleaseResourceLite) = 0x83
00043542  char __import_name_0(ntoskrnl:ExReleaseResourceLite)[0x16] = "ExReleaseResourceLite", 0
00043558  uint16_t __export_name_ptr_table_0(ntoskrnl:ZwCreateKey) = 0x52c
0004355a  char __import_name_0(ntoskrnl:ZwCreateKey)[0xc] = "ZwCreateKey", 0
00043566  uint16_t __export_name_ptr_table_0(ntoskrnl:ZwQueryValueKey) = 0x570
00043568  char __import_name_0(ntoskrnl:ZwQueryValueKey)[0x10] = "ZwQueryValueKey", 0
00043578  uint16_t __export_name_ptr_table_0(ntoskrnl:_vsnwprintf) = 0x5a9
0004357a  char __import_name_0(ntoskrnl:_vsnwprintf)[0xc] = "_vsnwprintf", 0
00043586  uint16_t __export_name_ptr_table_0(ntoskrnl:KeBugCheckEx) = 0x213
00043588  char __import_name_0(ntoskrnl:KeBugCheckEx)[0xd] = "KeBugCheckEx", 0

00043595                                                                 00                                                     .

00043596  char __import_dll_name(ntoskrnl)[0xd] = "ntoskrnl.exe", 0

000435a3           00                                                                                         .

000435a4  uint16_t __export_name_ptr_table_1(HAL:KeQueryPerformanceCounter) = 0x3a
000435a6  char __import_name_1(HAL:KeQueryPerformanceCounter)[0x1a] = "KeQueryPerformanceCounter", 0
000435c0  char __import_dll_name(HAL)[0x8] = "HAL.dll", 0
000435c8  uint16_t __export_name_ptr_table_0(ntoskrnl:KeInitializeMutex) = 0x232
000435ca  char __import_name_0(ntoskrnl:KeInitializeMutex)[0x12] = "KeInitializeMutex", 0
000435dc  uint16_t __export_name_ptr_table_0(ntoskrnl:KeReleaseMutex) = 0x262
000435de  char __import_name_0(ntoskrnl:KeReleaseMutex)[0xf] = "KeReleaseMutex", 0

000435ed                                         00                                                                     .

000435ee  uint16_t __export_name_ptr_table_0(ntoskrnl:strrchr) = 0x5cc
000435f0  char __import_name_0(ntoskrnl:strrchr)[0x8] = "strrchr", 0
000435f8  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlRaiseException) = 0x616
000435fa  char __import_name_0(ntoskrnl:RtlRaiseException)[0x12] = "RtlRaiseException", 0
0004360c  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlUnwindEx) = 0x657
0004360e  char __import_name_0(ntoskrnl:RtlUnwindEx)[0xc] = "RtlUnwindEx", 0
INIT section ended  {0x43000-0x4361a}

.rsrc section started  {0x44000-0x442d0}
00044000  struct Resource_Directory_Table __resource_directory_table_0 = 
00044000  {
00044000      uint32_t characteristics = 0x0
00044004      uint32_t timeDateStamp = 0x0
00044008      uint16_t majorVersion = 0x0
0004400a      uint16_t minorVersion = 0x0
0004400c      uint16_t numNameEntries = 0x0
0004400e      uint16_t numIdEntries = 0x1
00044010  }
00044010  struct Resource_Directory_Table_Entry __resource_directory_table_0_entries[0x1] = 
00044010  {
00044010      [0x0] = 
00044010      {
00044010          uint32_t id = 0x10
00044014          uint32_t offset = 0x80000018
00044018      }
00044018  }
00044018  struct Resource_Directory_Table __resource_directory_table_1 = 
00044018  {
00044018      uint32_t characteristics = 0x0
0004401c      uint32_t timeDateStamp = 0x0
00044020      uint16_t majorVersion = 0x0
00044022      uint16_t minorVersion = 0x0
00044024      uint16_t numNameEntries = 0x0
00044026      uint16_t numIdEntries = 0x1
00044028  }
00044028  struct Resource_Directory_Table_Entry __resource_directory_table_1_entries[0x1] = 
00044028  {
00044028      [0x0] = 
00044028      {
00044028          uint32_t id = 0x1
0004402c          uint32_t offset = 0x80000030
00044030      }
00044030  }
00044030  struct Resource_Directory_Table __resource_directory_table_2 = 
00044030  {
00044030      uint32_t characteristics = 0x0
00044034      uint32_t timeDateStamp = 0x0
00044038      uint16_t majorVersion = 0x0
0004403a      uint16_t minorVersion = 0x0
0004403c      uint16_t numNameEntries = 0x0
0004403e      uint16_t numIdEntries = 0x1
00044040  }
00044040  struct Resource_Directory_Table_Entry __resource_directory_table_2_entries[0x1] = 
00044040  {
00044040      [0x0] = 
00044040      {
00044040          uint32_t id = 0x409
00044044          uint32_t offset = 0x48
00044048      }
00044048  }
00044048  struct Resource_Data_Entry __resource_directory_table_2_data_entry_0 = 
00044048  {
00044048      uint32_t dataRva = 0x34060
0004404c      uint32_t dataSize = 0x26c
00044050      uint32_t codepage = 0x0
00044054      uint32_t reserved = 0x0
00044058  }

00044058                                                                          00 00 00 00 00 00 00 00                          ........

00044060  char data_44060[0x26c] = "l\x024\x00\x00\x00V\x00S\x00_\x00V\x00E\x00R\x00S\x00I\x00O\x00N\x00_\x00I\x00N\x00F\x00O\x00\x00\x00\x00\x00\xbd\x04\xef\xfe\x00\x00\x01\x00\x01\x00\x03\x00\x07\x00\x0c\x00\x01\x00\x03\x00\x07\x00\x0c\x00\x17\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\x01\x00\x00\x01\x00S\x00t\x00r\x00i\x00n\x00g\x00F\x00i\x00l\x00e\x00I\x00n\x00f\x00o\x00\x00\x00\xa8\x01\x00\x00\x01\x000\x004\x000\x009\x000\x004\x00b\x000\x00\x00\x006\x00\x07\x00\x01\x00F\x00i\x00l\x00e\x00D\x00e\x00s\x00c\x00r\x00i\x00p\x00t\x00i\x00o\x00n\x00\x00\x00\x00\x00K\x00e\x00r\x00n\x00e\x00l\x00\x00\x00\x00\x008\x00\x0c\x00\x01\x00F\x00i\x00l\x00e\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00\x00\x00\x00\x003\x00,\x00 \x001\x00,\x00 \x001\x002\x00,\x00 \x007\x00\x00\x00.\x00\x07\x00\x01\x00I\x00n\x00t\x00e\x00r\x00n\x00a\x00l\x00N\x00a\x00m\x00e\x00\x00\x00K\x00e\x00r\x00n\x00e\x00l\x00\x00\x00\x00\x00J\x00\x13\x00\x01\x00L\x00e\x00g\x00a\x00l\x00C\x00o\x00p\x00y\x00r\x00i\x00g\x00h\x00t\x00\x00\x00C\x00o\x00p\x00y\x00r\x00i\x00g\x00h\x00t\x00 \x00(\x00C\x00)\x00 \x002\x000\x001\x000\x00\x00\x00\x00\x006\x00\x07\x00\x01\x00O\x00r\x00i\x00g\x00i\x00n\x00a\x00l\x00F\x00i\x00l\x00e\x00n\x00a\x00m\x00e\x00\x00\x00K\x00e\x00r\x00n\x00e\x00l\x00\x00\x00\x00\x00.\x00\x07\x00\x01\x00P\x00r\x00o\x00d\x00u\x00c\x00t\x00N\x00a\x00m\x00e\x00\x00\x00\x00\x00K\x00e\x00r\x00n\x00e\x00l\x00\x00\x00\x00\x00<\x00\x0c\x00\x01\x00P\x00r\x00o\x00d\x00u\x00c\x00t\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00\x00\x003\x00,\x00 \x001\x00,\x00 \x001\x002\x00,\x00 \x007\x00\x00\x00D\x00\x00\x00\x01\x00V\x00a\x00r\x00F\x00i\x00l\x00e\x00I\x00n\x00f\x00o\x00\x00\x00\x00\x00$\x00\x04\x00\x00\x00T\x00r\x00a\x00n\x00s\x00l\x00a\x00t\x00i\x00o\x00n\x00\x00\x00\x00\x00\t\x04\xb0\x04"

000442cc                                      00 00 00 00                                                              ....
.rsrc section ended  {0x44000-0x442d0}

.reloc section started  {0x45000-0x45460}
00045000  00 f0 02 00 2c 02 00 00 30 a1 38 a1 40 a1 48 a1 50 a1 58 a1 60 a1 68 a1 70 a1 78 a1 80 a1 88 a1  ....,...0.8.@.H.P.X.`.h.p.x.....
00045020  90 a1 98 a1 a0 a1 a8 a1 b0 a1 b8 a1 c0 a1 c8 a1 d0 a1 d8 a1 e0 a1 e8 a1 f0 a1 f8 a1 00 a2 08 a2  ................................
00045040  10 a2 18 a2 20 a2 28 a2 30 a2 38 a2 40 a2 48 a2 50 a2 58 a2 60 a2 68 a2 70 a2 80 a2 88 a2 90 a2  .... .(.0.8.@.H.P.X.`.h.p.......
00045060  98 a2 a0 a2 a8 a2 b0 a2 b8 a2 c0 a2 c8 a2 d0 a2 d8 a2 e0 a2 e8 a2 f0 a2 f8 a2 00 a3 08 a3 10 a3  ................................
00045080  18 a3 20 a3 28 a3 30 a3 38 a3 40 a3 48 a3 50 a3 58 a3 60 a3 68 a3 70 a3 78 a3 80 a3 88 a3 90 a3  .. .(.0.8.@.H.P.X.`.h.p.x.......
000450a0  98 a3 a0 a3 a8 a3 b0 a3 b8 a3 c0 a3 c8 a3 d0 a3 d8 a3 e0 a3 e8 a3 f0 a3 f8 a3 00 a4 08 a4 10 a4  ................................
000450c0  18 a4 20 a4 28 a4 30 a4 38 a4 40 a4 48 a4 50 a4 58 a4 60 a4 68 a4 70 a4 78 a4 80 a4 88 a4 90 a4  .. .(.0.8.@.H.P.X.`.h.p.x.......
000450e0  98 a4 a0 a4 a8 a4 b0 a4 b8 a4 c0 a4 c8 a4 d0 a4 d8 a4 e0 a4 e8 a4 f0 a4 f8 a4 00 a5 08 a5 10 a5  ................................
00045100  18 a5 20 a5 28 a5 30 a5 38 a5 40 a5 48 a5 50 a5 58 a5 60 a5 68 a5 70 a5 78 a5 80 a5 88 a5 90 a5  .. .(.0.8.@.H.P.X.`.h.p.x.......
00045120  98 a5 a0 a5 a8 a5 b0 a5 b8 a5 c0 a5 c8 a5 d0 a5 d8 a5 e0 a5 e8 a5 f0 a5 f8 a5 00 a6 08 a6 10 a6  ................................
00045140  18 a6 20 a6 28 a6 30 a6 38 a6 40 a6 48 a6 50 a6 58 a6 60 a6 68 a6 70 a6 78 a6 80 a6 88 a6 90 a6  .. .(.0.8.@.H.P.X.`.h.p.x.......
00045160  98 a6 a0 a6 a8 a6 b0 a6 b8 a6 c0 a6 c8 a6 d0 a6 d8 a6 e0 a6 e8 a6 f0 a6 f8 a6 00 a7 08 a7 10 a7  ................................
00045180  18 a7 20 a7 28 a7 30 a7 38 a7 40 a7 48 a7 50 a7 58 a7 60 a7 68 a7 70 a7 78 a7 80 a7 88 a7 90 a7  .. .(.0.8.@.H.P.X.`.h.p.x.......
000451a0  98 a7 a0 a7 a8 a7 b0 a7 b8 a7 c0 a7 c8 a7 d0 a7 d8 a7 e0 a7 e8 a7 f0 a7 f8 a7 00 a8 08 a8 10 a8  ................................
000451c0  18 a8 20 a8 28 a8 30 a8 38 a8 40 a8 48 a8 50 a8 58 a8 60 a8 68 a8 70 a8 78 a8 80 a8 88 a8 90 a8  .. .(.0.8.@.H.P.X.`.h.p.x.......
000451e0  98 a8 a0 a8 a8 a8 b0 a8 b8 a8 c0 a8 c8 a8 d0 a8 d8 a8 e0 a8 e8 a8 f0 a8 f8 a8 00 a9 08 a9 10 a9  ................................
00045200  18 a9 20 a9 28 a9 30 a9 38 a9 40 a9 48 a9 50 a9 58 a9 60 a9 68 a9 70 a9 78 a9 80 a9 88 a9 90 a9  .. .(.0.8.@.H.P.X.`.h.p.x.......
00045220  a8 af b8 af c8 af d8 af e8 af f8 af 00 00 03 00 38 00 00 00 08 a0 18 a0 28 a0 38 a0 48 a0 58 a0  ................8.......(.8.H.X.
00045240  68 a0 78 a0 88 a0 98 a0 a8 a0 b8 a0 c8 a0 d8 a0 e8 a0 f8 a0 08 a1 18 a1 28 a1 38 a1 48 a1 58 a1  h.x.....................(.8.H.X.
00045260  68 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  h...............................
00045280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000452a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000452c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000452e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000453a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000453c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000453e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00045440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
.reloc section ended  {0x45000-0x45460}

.extern section started  {0x45460-0x455d0}
00045460  extern uint32_t DbgPrint(char* Format, ...)
00045468  extern BOOLEAN ExAcquireResourceExclusiveLite(ERESOURCE* Resource, BOOLEAN Wait)
00045470  extern BOOLEAN ExAcquireResourceSharedLite(ERESOURCE* Resource, BOOLEAN Wait)
00045478  extern void* ExAllocatePoolWithTag(POOL_TYPE PoolType, uint64_t NumberOfBytes, uint32_t Tag)
00045480  extern NTSTATUS ExDeleteResourceLite(ERESOURCE* Resource)
00045488  extern void ExFreePoolWithTag(void* P, uint32_t Tag)
00045490  extern NTSTATUS ExInitializeResourceLite(ERESOURCE* Resource)
00045498  extern void ExReleaseResourceLite(ERESOURCE* Resource)
000454a0  extern void ExSystemTimeToLocalTime(int64_t* SystemTime, int64_t* LocalTime)
000454a8  extern uint64_t KeAcquireSpinLockRaiseToDpc(void* SpinLock)
000454b0  extern void KeBugCheckEx(enum BUGCHECK_ERROR BugCheckCode, uint64_t BugCheckParameter1, uint64_t BugCheckParameter2, uint64_t BugCheckParameter3, uint64_t BugCheckParameter4)
000454b8  extern BOOLEAN KeCancelTimer(KTIMER* param0)
000454c0  extern NTSTATUS KeDelayExecutionThread(char WaitMode, BOOLEAN Alertable, int64_t* Interval)
000454c8  extern void KeEnterCriticalRegion()
000454d0  extern void KeInitializeDpc(KDPC* Dpc, PKDEFERRED_ROUTINE DeferredRoutine, void* DeferredContext)
000454d8  extern void KeInitializeEvent(KEVENT* Event, EVENT_TYPE Type, BOOLEAN State)
000454e0  extern void KeInitializeMutex(KMUTANT* Mutex, uint32_t Level)
000454e8  extern void KeInitializeTimer(KTIMER* Timer)
000454f0  extern void KeLeaveCriticalRegion()
000454f8  extern int64_t KeQueryPerformanceCounter(int64_t* PerformanceFrequency)
00045500  extern uint32_t KeQueryRuntimeThread(PKTHREAD Thread, uint32_t* UserTime)
00045508  extern uint32_t KeQueryTimeIncrement()
00045510  extern int32_t KeReleaseMutex(KMUTANT* Mutex, BOOLEAN Wait)
00045518  extern void KeReleaseSpinLock(void* SpinLock, uint64_t NewIrql)
00045520  extern int32_t KeResetEvent(KEVENT* Event)
00045528  extern int32_t KeSetEvent(KEVENT* Event, int32_t Increment, BOOLEAN Wait)
00045530  extern BOOLEAN KeSetTimerEx(KTIMER* Timer, int64_t DueTime, int32_t Period, KDPC* Dpc)
00045538  extern NTSTATUS KeWaitForMultipleObjects(uint32_t Count, void** Object, WAIT_TYPE WaitType, KWAIT_REASON WaitReason, char WaitMode, BOOLEAN Alertable, int64_t* Timeout, KWAIT_BLOCK* WaitBlockArray)
00045540  extern NTSTATUS KeWaitForSingleObject(void* Object, KWAIT_REASON WaitReason, char WaitMode, BOOLEAN Alertable, int64_t* Timeout)
00045548  extern NTSTATUS ObReferenceObjectByHandle(HANDLE Handle, uint32_t DesiredAccess, POBJECT_TYPE ObjectType, char AccessMode, void** Object, OBJECT_HANDLE_INFORMATION* HandleInformation)
00045550  extern int64_t ObfDereferenceObject(void* Object)
00045558  extern NTSTATUS PsCreateSystemThread(HANDLE* ThreadHandle, uint32_t DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, HANDLE ProcessHandle, CLIENT_ID* ClientId, PKSTART_ROUTINE StartRoutine, void* StartContext)
00045560  extern NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus)
00045568  extern void RtlInitUnicodeString(UNICODE_STRING* DestinationString, wchar16* SourceString)
00045570  extern NTSTATUS RtlQueryRegistryValues(uint32_t RelativeTo, wchar16* Path, RTL_QUERY_REGISTRY_TABLE* QueryTable, void* Context, void* Environment)
00045578  extern RtlRaiseException
00045580  extern void RtlTimeToTimeFields(int64_t* Time, TIME_FIELDS* TimeFields)
00045588  extern RtlUnwindEx
00045590  extern NTSTATUS ZwClose(HANDLE Handle)
00045598  extern NTSTATUS ZwCreateKey(HANDLE* KeyHandle, uint32_t DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, uint32_t TitleIndex, UNICODE_STRING* Class, uint32_t CreateOptions, uint32_t* Disposition)
000455a0  extern NTSTATUS ZwOpenKey(HANDLE* KeyHandle, uint32_t DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes)
000455a8  extern NTSTATUS ZwQueryValueKey(HANDLE KeyHandle, UNICODE_STRING* ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, void* KeyValueInformation, uint32_t Length, uint32_t* ResultLength)
000455b0  extern NTSTATUS ZwSetValueKey(HANDLE KeyHandle, UNICODE_STRING* ValueName, uint32_t TitleIndex, uint32_t Type, void* Data, uint32_t DataSize)
000455b8  extern _vsnprintf
000455c0  extern int32_t _vsnwprintf(wchar16* _Buffer, uint64_t _BufferCount, wchar16* _Format, void* _ArgList)
000455c8  extern strrchr
.extern section ended  {0x45460-0x455d0}

.synthetic_builtins section started  {0x455d0-0x45600}
000455d0  extern void* __builtin_memcpy(void* dest, void const* src, uint64_t count)
000455d8  extern void* __builtin_memset(void* dest, int32_t ch, uint64_t count)
000455e0  extern char* __builtin_strcpy(char* dest, char const* src)
000455e8  extern char* __builtin_strncpy(char* dest, char const* src, uint64_t count)
000455f0  extern wchar16* __builtin_wcscpy(wchar16* dest, wchar16 const* src)
000455f8  extern wchar16* __builtin_wmemcpy(wchar16* dest, wchar16 const* src, uint64_t count)
.synthetic_builtins section ended  {0x455d0-0x45600}

