/*
Type: PE
Platform: windows-kernel-x86_64
Architecture: x86_64

Libraries: 
  ntoskrnl.exe
  NWTransLibV.sys
  WDFLDR.SYS

Compiler(s) Used: 
  Imported Functions (33 objects)
  VS2008 v9.0 SP1 build 30729 (20 objects)
  Windows Server 2003 SP1 DDK (for AMD64) (6 objects)

Segments:
r--  0x00010000-0x00010400 
r-x  0x00011000-0x000141a2  {Code}
r--  0x00015000-0x000153d4  {Data}
rw-  0x00016000-0x00016600  {Data}
rw-  0x00016600-0x00017310  {Data}
r--  0x00018000-0x000181d4  {Data}
rwx  0x00019000-0x000194d8  {Code}
r--  0x0001a000-0x0001a2e0  {Data}
r--  0x0001b000-0x0001b06c  {Data}
---  0x0001b070-0x0001b178 
---  0x0001b180-0x0001b1b0 

Sections:
0x00011000-0x000141a2  .text  {Code}
0x00015000-0x000153d4  .rdata  {Read-only data}
0x00016000-0x00017310  .data  {Writable data}
0x00018000-0x000181d4  .pdata  {Read-only data}
0x00019000-0x000194d8  INIT
0x0001a000-0x0001a2e0  .rsrc  {Read-only data}
0x0001b000-0x0001b06c  .reloc  {Read-only data}
0x0001b070-0x0001b178  .extern  {External}
0x0001b180-0x0001b1b0  .synthetic_builtins  {External}
*/
00010000  struct DOS_Header __dos_header = 
00010000  {
00010000      char e_magic[0x2] = "MZ"
00010002      uint16_t e_cblp = 0x90
00010004      uint16_t e_cp = 0x3
00010006      uint16_t e_crlc = 0x0
00010008      uint16_t e_cparhdr = 0x4
0001000a      uint16_t e_minalloc = 0x0
0001000c      uint16_t e_maxalloc = 0xffff
0001000e      uint16_t e_ss = 0x0
00010010      uint16_t e_sp = 0xb8
00010012      uint16_t e_csum = 0x0
00010014      uint16_t e_ip = 0x0
00010016      uint16_t e_cs = 0x0
00010018      uint16_t e_lfarlc = 0x40
0001001a      uint16_t e_ovno = 0x0
0001001c      char e_res1[0x8] = "\x00\x00\x00\x00\x00\x00\x00", 0
00010024      uint16_t e_oemid = 0x0
00010026      uint16_t e_oeminfo = 0x0
00010028      char e_res2[0x14] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
0001003c      uint32_t e_lfanew = 0x100
00010040  }

00010040  __dos_stub:
00010040  0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  ........!..L.!This program canno
00010060  74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  t be run in DOS mode....$.......

00010080  struct Rich_Header __rich_header = 
00010080  {
00010080      uint32_t e_magic__DanS = 0xbba7c72f
00010084      uint32_t e_align[0x3] = 
00010084      {
00010084          [0x0] =  0xe8c9a66b
00010088          [0x1] =  0xe8c9a66b
0001008c          [0x2] =  0xe8c9a66b
00010090      }
00010090      uint32_t e_entry_id0__00887809 = 0xe841de62
00010094      uint32_t e_entry_count0__3 = 0xe8c9a668
00010098      uint32_t e_entry_id1__00937809 = 0xe85ade62
0001009c      uint32_t e_entry_count1__4 = 0xe8c9a66f
000100a0      uint32_t e_entry_id2__00010000 = 0xe8c8a66b
000100a4      uint32_t e_entry_count2__33 = 0xe8c9a64a
000100a8      uint32_t e_entry_id3__007b9d76 = 0xe8b23b1d
000100ac      uint32_t e_entry_count3__3 = 0xe8c9a668
000100b0      uint32_t e_entry_id4__007d9d76 = 0xe8b43b1d
000100b4      uint32_t e_entry_count4__2 = 0xe8c9a669
000100b8      uint32_t e_entry_id5__00837809 = 0xe84ade62
000100bc      uint32_t e_entry_count5__3 = 0xe8c9a668
000100c0      uint32_t e_entry_id6__00957809 = 0xe85cde62
000100c4      uint32_t e_entry_count6__1 = 0xe8c9a66a
000100c8      uint32_t e_entry_id7__006d9d76 = 0xe8a43b1d
000100cc      uint32_t e_entry_count7__1 = 0xe8c9a66a
000100d0      uint32_t e_entry_id8__00897809 = 0xe840de62
000100d4      uint32_t e_entry_count8__7 = 0xe8c9a66c
000100d8      uint32_t e_entry_id9__00947809 = 0xe85dde62
000100dc      uint32_t e_entry_count9__1 = 0xe8c9a66a
000100e0      uint32_t e_entry_id10__00917809 = 0xe858de62
000100e4      uint32_t e_entry_count10__1 = 0xe8c9a66a
000100e8      char e_magic[0x4] = "Rich"
000100ec      uint32_t e_checksum = 0xe8c9a66b
000100f0  }

000100f0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

00010100  struct COFF_Header __coff_header = 
00010100  {
00010100      char magic[0x4] = "PE\x00", 0
00010104      enum coff_machine machine = IMAGE_FILE_MACHINE_AMD64
00010106      uint16_t numberOfSections = 0x7
00010108      uint32_t timeDateStamp = 0x510f14d5
0001010c      uint32_t pointerToSymbolTable = 0x0
00010110      uint32_t numberOfSymbols = 0x0
00010114      uint16_t sizeOfOptionalHeader = 0xf0
00010116      enum coff_characteristics characteristics = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LARGE_ADDRESS_AWARE
00010118  }
00010118  struct PE64_Optional_Header __pe64_optional_header = 
00010118  {
00010118      enum pe_magic magic = PE_64BIT
0001011a      uint8_t majorLinkerVersion = 0x9
0001011b      uint8_t minorLinkerVersion = 0x0
0001011c      uint32_t sizeOfCode = 0x3800
00010120      uint32_t sizeOfInitializedData = 0x2000
00010124      uint32_t sizeOfUninitializedData = 0x0
00010128      uint32_t addressOfEntryPoint = 0x381c
0001012c      uint32_t baseOfCode = 0x1000
00010130      uint64_t imageBase = 0x10000
00010138      uint32_t sectionAlignment = 0x1000
0001013c      uint32_t fileAlignment = 0x200
00010140      uint16_t majorOperatingSystemVersion = 0x6
00010142      uint16_t minorOperatingSystemVersion = 0x1
00010144      uint16_t majorImageVersion = 0x6
00010146      uint16_t minorImageVersion = 0x1
00010148      uint16_t majorSubsystemVersion = 0x5
0001014a      uint16_t minorSubsystemVersion = 0x2
0001014c      uint32_t win32VersionValue = 0x0
00010150      uint32_t sizeOfImage = 0xc000
00010154      uint32_t sizeOfHeaders = 0x400
00010158      uint32_t checkSum = 0x9c71
0001015c      enum pe_subsystem subsystem = IMAGE_SUBSYSTEM_NATIVE
0001015e      enum pe_dll_characteristics dllCharacteristics = 0
00010160      uint64_t sizeOfStackReserve = 0x40000
00010168      uint64_t sizeOfStackCommit = 0x1000
00010170      uint64_t sizeOfHeapReserve = 0x100000
00010178      uint64_t sizeOfHeapCommit = 0x1000
00010180      uint32_t loaderFlags = 0x0
00010184      uint32_t numberOfRvaAndSizes = 0x10
00010188      struct PE_Data_Directory_Entry exportTableEntry = 
00010188      {
00010188          uint32_t virtualAddress = 0x0
0001018c          uint32_t size = 0x0
00010190      }
00010190      struct PE_Data_Directory_Entry importTableEntry = 
00010190      {
00010190          uint32_t virtualAddress = 0x9060
00010194          uint32_t size = 0x50
00010198      }
00010198      struct PE_Data_Directory_Entry resourceTableEntry = 
00010198      {
00010198          uint32_t virtualAddress = 0xa000
0001019c          uint32_t size = 0x2e0
000101a0      }
000101a0      struct PE_Data_Directory_Entry exceptionTableEntry = 
000101a0      {
000101a0          uint32_t virtualAddress = 0x8000
000101a4          uint32_t size = 0x1d4
000101a8      }
000101a8      struct PE_Data_Directory_Entry certificateTableEntry = 
000101a8      {
000101a8          uint32_t virtualAddress = 0x4e00
000101ac          uint32_t size = 0x22f8
000101b0      }
000101b0      struct PE_Data_Directory_Entry baseRelocationTableEntry = 
000101b0      {
000101b0          uint32_t virtualAddress = 0xb000
000101b4          uint32_t size = 0x1c
000101b8      }
000101b8      struct PE_Data_Directory_Entry debugEntry = 
000101b8      {
000101b8          uint32_t virtualAddress = 0x5120
000101bc          uint32_t size = 0x1c
000101c0      }
000101c0      struct PE_Data_Directory_Entry architectureEntry = 
000101c0      {
000101c0          uint32_t virtualAddress = 0x0
000101c4          uint32_t size = 0x0
000101c8      }
000101c8      struct PE_Data_Directory_Entry globalPtrEntry = 
000101c8      {
000101c8          uint32_t virtualAddress = 0x0
000101cc          uint32_t size = 0x0
000101d0      }
000101d0      struct PE_Data_Directory_Entry tlsTableEntry = 
000101d0      {
000101d0          uint32_t virtualAddress = 0x0
000101d4          uint32_t size = 0x0
000101d8      }
000101d8      struct PE_Data_Directory_Entry loadConfigTableEntry = 
000101d8      {
000101d8          uint32_t virtualAddress = 0x0
000101dc          uint32_t size = 0x0
000101e0      }
000101e0      struct PE_Data_Directory_Entry boundImportEntry = 
000101e0      {
000101e0          uint32_t virtualAddress = 0x0
000101e4          uint32_t size = 0x0
000101e8      }
000101e8      struct PE_Data_Directory_Entry iatEntry = 
000101e8      {
000101e8          uint32_t virtualAddress = 0x5000
000101ec          uint32_t size = 0x120
000101f0      }
000101f0      struct PE_Data_Directory_Entry delayImportDescriptorEntry = 
000101f0      {
000101f0          uint32_t virtualAddress = 0x0
000101f4          uint32_t size = 0x0
000101f8      }
000101f8      struct PE_Data_Directory_Entry clrRuntimeHeaderEntry = 
000101f8      {
000101f8          uint32_t virtualAddress = 0x0
000101fc          uint32_t size = 0x0
00010200      }
00010200      struct PE_Data_Directory_Entry reservedEntry = 
00010200      {
00010200          uint32_t virtualAddress = 0x0
00010204          uint32_t size = 0x0
00010208      }
00010208  }
00010208  struct Section_Header __section_headers[0x7] = 
00010208  {
00010208      [0x0] = 
00010208      {
00010208          char name[0x8] = ".text\x00\x00", 0
00010210          uint32_t virtualSize = 0x31a2
00010214          uint32_t virtualAddress = 0x1000
00010218          uint32_t sizeOfRawData = 0x3200
0001021c          uint32_t pointerToRawData = 0x400
00010220          uint32_t pointerToRelocations = 0x0
00010224          uint32_t pointerToLineNumbers = 0x0
00010228          uint16_t numberOfRelocations = 0x0
0001022a          uint16_t numberOfLineNumbers = 0x0
0001022c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
00010230      }
00010230      [0x1] = 
00010230      {
00010230          char name[0x8] = ".rdata\x00", 0
00010238          uint32_t virtualSize = 0x3d4
0001023c          uint32_t virtualAddress = 0x5000
00010240          uint32_t sizeOfRawData = 0x400
00010244          uint32_t pointerToRawData = 0x3600
00010248          uint32_t pointerToRelocations = 0x0
0001024c          uint32_t pointerToLineNumbers = 0x0
00010250          uint16_t numberOfRelocations = 0x0
00010252          uint16_t numberOfLineNumbers = 0x0
00010254          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_READ
00010258      }
00010258      [0x2] = 
00010258      {
00010258          char name[0x8] = ".data\x00\x00", 0
00010260          uint32_t virtualSize = 0x1310
00010264          uint32_t virtualAddress = 0x6000
00010268          uint32_t sizeOfRawData = 0x600
0001026c          uint32_t pointerToRawData = 0x3a00
00010270          uint32_t pointerToRelocations = 0x0
00010274          uint32_t pointerToLineNumbers = 0x0
00010278          uint16_t numberOfRelocations = 0x0
0001027a          uint16_t numberOfLineNumbers = 0x0
0001027c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
00010280      }
00010280      [0x3] = 
00010280      {
00010280          char name[0x8] = ".pdata\x00", 0
00010288          uint32_t virtualSize = 0x1d4
0001028c          uint32_t virtualAddress = 0x8000
00010290          uint32_t sizeOfRawData = 0x200
00010294          uint32_t pointerToRawData = 0x4000
00010298          uint32_t pointerToRelocations = 0x0
0001029c          uint32_t pointerToLineNumbers = 0x0
000102a0          uint16_t numberOfRelocations = 0x0
000102a2          uint16_t numberOfLineNumbers = 0x0
000102a4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_READ
000102a8      }
000102a8      [0x4] = 
000102a8      {
000102a8          char name[0x8] = "INIT\x00\x00\x00", 0
000102b0          uint32_t virtualSize = 0x4d8
000102b4          uint32_t virtualAddress = 0x9000
000102b8          uint32_t sizeOfRawData = 0x600
000102bc          uint32_t pointerToRawData = 0x4200
000102c0          uint32_t pointerToRelocations = 0x0
000102c4          uint32_t pointerToLineNumbers = 0x0
000102c8          uint16_t numberOfRelocations = 0x0
000102ca          uint16_t numberOfLineNumbers = 0x0
000102cc          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
000102d0      }
000102d0      [0x5] = 
000102d0      {
000102d0          char name[0x8] = ".rsrc\x00\x00", 0
000102d8          uint32_t virtualSize = 0x2e0
000102dc          uint32_t virtualAddress = 0xa000
000102e0          uint32_t sizeOfRawData = 0x400
000102e4          uint32_t pointerToRawData = 0x4800
000102e8          uint32_t pointerToRelocations = 0x0
000102ec          uint32_t pointerToLineNumbers = 0x0
000102f0          uint16_t numberOfRelocations = 0x0
000102f2          uint16_t numberOfLineNumbers = 0x0
000102f4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
000102f8      }
000102f8      [0x6] = 
000102f8      {
000102f8          char name[0x8] = ".reloc\x00", 0
00010300          uint32_t virtualSize = 0x6c
00010304          uint32_t virtualAddress = 0xb000
00010308          uint32_t sizeOfRawData = 0x200
0001030c          uint32_t pointerToRawData = 0x4c00
00010310          uint32_t pointerToRelocations = 0x0
00010314          uint32_t pointerToLineNumbers = 0x0
00010318          uint16_t numberOfRelocations = 0x0
0001031a          uint16_t numberOfLineNumbers = 0x0
0001031c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
00010320      }
00010320  }

00010320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00010340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00010360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00010380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000103a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000103c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000103e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

.text section started  {0x11000-0x141a2}
00011000  00 00 00 00 00 00 00 00                                                                          ........

00011008    int32_t DriverEntry(struct _DRIVER_OBJECT* DriverObject, struct _UNICODE_STRING* RegistryPath)

00011008  {
00011027      j_TLDbgLogMsg(4, 3, "NW1950 DriverEntry Initialization of NextWindow 1950 driver\n");
0001102f      NWDriverObject = DriverObject;
00011036      __builtin_memset(&NWMemoryUsage, 0, 0x14);
00011053      uint16_t r8 = RegistryPath->Length + 2;
00011058      NWRegistryPath.MaximumLength = r8;
0001106d      NWRegistryPath.Length = RegistryPath->Length;
00011074      WCHAR* rax_1 = ExAllocatePoolWithTag(PagedPool, (uint64_t)r8, 0x4147574e);
0001107d      NWRegistryPath.Buffer = rax_1;
0001107d      
00011087      if (!rax_1)
00011089          return -0x3fffff66;
00011089      
00011093      uint32_t Length = (uint32_t)NWRegistryPath.Length;
0001109a      uint64_t MaximumLength = (uint64_t)NWRegistryPath.MaximumLength;
000110a4      NWMemoryUsage.TotalPagedPool += Length;
000110aa      NWMemoryUsage.AllocationTable[0] += Length;
000110b0      memset(rax_1, 0, MaximumLength);
000110c4      memmove(NWRegistryPath.Buffer, RegistryPath->Buffer, (uint64_t)RegistryPath->Length);
000110d4      int32_t var_28;
000110d4      memset(&var_28, 0, 0x20);
000110d9      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
000110f3      int32_t (* var_20_1)(struct WDFDRIVER__* Driver, struct WDFDEVICE_INIT* DeviceInit) =
000110f3          NWAddDevice;
00011102      void (* var_18_1)(struct WDFDRIVER__* DriverObject) = NWDriverUnload;
0001110c      var_28 = 0x20;
00011119      int32_t result = data_167c0(WdfDriverGlobals_1, DriverObject, RegistryPath, 0, 
00011119          &var_28, 0, var_28, var_20_1, var_18_1);
00011119      
00011123      if (result < 0)
00011123      {
00011125          uint32_t Length_1 = (uint32_t)NWRegistryPath.Length;
0001112e          NWMemoryUsage.TotalPagedPool -= Length_1;
00011134          NWMemoryUsage.AllocationTable[0] -= Length_1;
00011141          ExFreePoolWithTag(NWRegistryPath.Buffer, 0);
00011123      }
00011123      
00011153      return result;
00011008  }

00011154                                                              cc cc cc cc cc cc cc cc                                  ........

0001115c    void NWDriverUnload(struct WDFDRIVER__* DriverObject)

0001115c  {
00011160      WCHAR* Buffer = NWRegistryPath.Buffer;
00011160      
0001116a      if (!Buffer)
0001116a          return;
0001116a      
0001116c      uint32_t Length = (uint32_t)NWRegistryPath.Length;
00011175      NWMemoryUsage.TotalPagedPool -= Length;
0001117b      NWMemoryUsage.AllocationTable[0] -= Length;
00011181      ExFreePoolWithTag(Buffer, 0);
00011187      NWRegistryPath.Buffer = nullptr;
0001115c  }

00011194                                                              cc cc cc cc cc cc cc cc                                  ........

0001119c    int32_t NWAddDevice(struct WDFDRIVER__* Driver, struct WDFDEVICE_INIT* DeviceInit)

0001119c  {
000111bf      void var_3c8;
000111bf      int64_t rax_1 = __security_cookie ^ &var_3c8;
000111ca      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
000111d1      struct WDFDEVICE_INIT* DeviceInit_1 = DeviceInit;
000111d6      data_16828(WdfDriverGlobals_1);
000111ee      int32_t var_1d8;
000111ee      memset(&var_1d8, 0, 0x88);
000111f3      struct WDFDEVICE_INIT* DeviceInit_2 = DeviceInit_1;
000111f8      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
0001120e      var_1d8 = 0x88;
00011215      int32_t (* var_1b0)(struct WDFDEVICE__* Device, struct WDFCMRESLIST__* ResourceList, 
00011215          struct WDFCMRESLIST__* ResourceListTranslated) = NWPrepareHardware;
00011224      int32_t (* var_1a8)(struct WDFDEVICE__* Device, 
00011224          struct WDFCMRESLIST__* ResourceListTranslated) = NWReleaseHardware;
00011233      int32_t (* var_1d0)(struct WDFDEVICE__* Device, 
00011233          enum _WDF_POWER_DEVICE_STATE PreviousState) = NWEnterWorkingState;
00011242      int32_t (* var_1c0)(struct WDFDEVICE__* Device, 
00011242          enum _WDF_POWER_DEVICE_STATE TargetState) = NWLeaveWorkingState;
0001124a      data_165d8(WdfDriverGlobals_2, DeviceInit_2, &var_1d8);
00011261      int32_t var_280;
00011261      memset(&var_280, 0, 0x38);
0001126d      struct WDFDEVICE_INIT* DeviceInit_3 = DeviceInit_1;
00011272      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_3 = WdfDriverGlobals;
00011286      struct _WDF_OBJECT_CONTEXT_TYPE_INFO* UniqueType =
00011286          _WDF_NW_REQUEST_CONTEXT_TYPE_INFO.UniqueType;
0001128e      var_280 = 0x38;
00011296      int32_t var_268 = 1;
0001129d      int32_t var_264 = 1;
000112a4      data_16660(WdfDriverGlobals_3, DeviceInit_3, &var_280);
000112b7      int32_t var_248;
000112b7      memset(&var_248, 0, 0x38);
000112c3      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_4 = WdfDriverGlobals;
000112dc      struct _WDF_OBJECT_CONTEXT_TYPE_INFO* UniqueType_1 =
000112dc          _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType;
000112e4      var_248 = 0x38;
000112ec      int32_t var_230 = 1;
000112f3      int32_t var_22c = 1;
000112fa      int64_t var_390;
000112fa      int32_t result_1 = data_16678(WdfDriverGlobals_4, &DeviceInit_1, &var_248, &var_390);
00011300      int32_t result = result_1;
00011300      
00011304      if (result_1 >= 0)
00011304      {
0001131d          void* rax_4 = data_16a70(WdfDriverGlobals, var_390, 
0001131d              _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00011333          int32_t var_380;
00011333          memset(&var_380, 0, 0x30);
00011338          int64_t rdx_2 = var_390;
0001133d          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_5 = WdfDriverGlobals;
00011349          __builtin_memcpy(&var_380, 
00011349              "\x30\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00"
00011349          "02\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x
00011349                  00", 
00011349              0x28);
00011381          int32_t var_358_1 = 0xffffffff;
00011385          int32_t var_354_1 = 0xffffffff;
00011389          data_166b8(WdfDriverGlobals_5, rdx_2, &var_380);
000113a1          int32_t var_2e8;
000113a1          memset(&var_2e8, 0, 0x58);
000113a6          int64_t rdx_3 = var_390;
000113ab          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_6 = WdfDriverGlobals;
000113c4          void (* var_2d0_1)(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, 
000113c4              uint64_t Length) = NWDispatchRead;
000113d3          var_2e8 = 0x58;
000113db          void (* var_2c8_1)(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, 
000113db              uint64_t Length) = NWDispatchRead;
000113ea          int32_t var_2e0_1 = 2;
000113f2          void (* var_2c0_1)(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, 
000113f2              uint64_t OutputBufferLength, uint64_t InputBufferLength, 
000113f2              uint32_t IoControlCode) = NWDispatchDeviceControl;
00011401          char var_2db_1 = 1;
00011409          void (* var_2b8_1)(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, 
00011409              uint64_t OutputBufferLength, uint64_t InputBufferLength, 
00011409              uint32_t IoControlCode) = NWDispatchInternalDeviceControl;
00011419          int32_t var_2e4_1 = 2;
00011426          int32_t var_298_1 = 0xffffffff;
0001142d          void var_288;
0001142d          int32_t result_2 = data_168e0(WdfDriverGlobals_6, rdx_3, &var_2e8, 0, &var_288);
00011433          result = result_2;
00011433          
00011437          if (result_2 >= 0)
00011437          {
0001144a              memset(&var_2e8, 0, 0x58);
0001144f              int64_t rdx_4 = var_390;
00011454              struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_7 = WdfDriverGlobals;
0001146a              var_2e8 = 0x58;
00011472              int32_t var_2e0_2 = 2;
0001147a              int32_t var_2e4_2 = 3;
0001148a              int32_t result_3 =
0001148a                  data_168e0(WdfDriverGlobals_7, rdx_4, &var_2e8, 0, (char*)rax_4 + 0x40);
00011490              result = result_3;
00011490              
00011494              if (result_3 >= 0)
00011494              {
000114a7                  int32_t var_320;
000114a7                  memset(&var_320, 0, 0x38);
000114b1                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_8 = WdfDriverGlobals;
000114c7                  int64_t var_300_1 = var_390;
000114cf                  var_320 = 0x38;
000114d7                  int32_t var_308_1 = 1;
000114de                  int32_t var_304_1 = 1;
000114e5                  int32_t result_4 =
000114e5                      data_16de0(WdfDriverGlobals_8, &var_320, (char*)rax_4 + 0xa8);
000114eb                  result = result_4;
000114eb                  
000114ef                  if (result_4 >= 0)
000114ef                  {
000114f5                      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_9 = WdfDriverGlobals;
000114fc                      int64_t var_398 = 0;
00011502                      *(uint32_t*)((char*)rax_4 + 0xc0) = 1;
00011529                      UNICODE_STRING DestinationString;
00011529                      
00011529                      if (data_167d8(WdfDriverGlobals_9, WdfDriverGlobals_9->Driver, 
00011529                          0x20019, 0, &var_398) >= 0)
00011529                      {
00011537                          RtlInitUnicodeString(&DestinationString, u"BulkReset");
00011555                          data_16ba0(WdfDriverGlobals, var_398, &DestinationString, 
00011555                              (char*)rax_4 + 0xc0);
00011529                      }
00011529                      
0001155b                      int64_t rdx_8 = var_398;
0001155b                      
00011563                      if (rdx_8)
0001156c                          data_16b58(WdfDriverGlobals, rdx_8);
0001156c                      
00011584                      *(uint8_t*)((char*)rax_4 + 0xbc) = 0;
0001158b                      int32_t var_340;
0001158b                      memset(&var_340, 0, 0x20);
00011590                      int32_t var_328_1 = 0;
000115ac                      int32_t (* var_338_1)(struct WDFTIMER__* Timer) =
000115ac                          NWBulkWatchdogTimerEvt;
000115b4                      var_340 = 0x20;
000115bb                      int32_t var_330_1 = 0x1388;
000115c6                      char var_32c_1 = 1;
000115ce                      int32_t var_210;
000115ce                      memset(&var_210, 0, 0x38);
000115d8                      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_10 = WdfDriverGlobals;
000115f6                      int64_t var_1f0_1 = var_390;
000115fe                      var_210 = 0x38;
00011606                      int32_t var_1f8_1 = 1;
0001160d                      int32_t var_1f4_1 = 1;
00011614                      int32_t result_5 = data_16e10(WdfDriverGlobals_10, &var_340, 
00011614                          &var_210, (char*)rax_4 + 0xb0);
0001161a                      result = result_5;
0001161a                      
0001161e                      if (result_5 >= 0)
0001161e                      {
00011624                          *(uint8_t*)((char*)rax_4 + 0x48) = 0;
00011628                          *(uint8_t*)((char*)rax_4 + 0x49) = 0;
00011634                          OSVERSIONINFOW versionInformation;
00011634                          versionInformation.dwOSVersionInfoSize = 0x114;
0001163f                          RtlGetVersion(&versionInformation);
0001163f                          
0001164d                          if (versionInformation.dwMajorVersion >= 6)
0001164f                              *(uint8_t*)((char*)rax_4 + 0x49) = 1;
0001164f                          
0001165c                          KeInitializeEvent((char*)rax_4 + 0x50, NotificationEvent, 0);
0001166f                          memset(&var_320, 0, 0x38);
00011679                          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_11 =
00011679                              WdfDriverGlobals;
0001168c                          int64_t var_300_2 = var_390;
00011694                          var_320 = 0x38;
0001169c                          int32_t var_308_2 = 1;
000116a3                          int32_t var_304_2 = 1;
000116aa                          int32_t result_6 = data_16df8(WdfDriverGlobals_11, &var_320, 
000116aa                              (char*)rax_4 + 0x68);
000116b0                          result = result_6;
000116b0                          
000116b4                          if (result_6 >= 0)
000116b4                          {
000116ba                              struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_12 =
000116ba                                  WdfDriverGlobals;
000116c1                              var_398 = 0;
000116c1                              
000116e2                              if (data_167d8(WdfDriverGlobals_12, 
000116e2                                  WdfDriverGlobals_12->Driver, 0x20019, 0, &var_398) >= 0)
000116e2                              {
000116f0                                  RtlInitUnicodeString(&DestinationString, 
000116f0                                      UsePenDescriptor");
0001170e                                  data_16ba0(WdfDriverGlobals, var_398, &DestinationString, 
0001170e                                      (char*)rax_4 + 0xc4);
000116e2                              }
000116e2                              
00011714                              int64_t rdx_13 = var_398;
00011714                              
0001171c                              if (rdx_13)
00011725                                  data_16b58(WdfDriverGlobals, rdx_13);
00011725                              
0001172b                              *(uint32_t*)((char*)rax_4 + 0xa0) = 0;
00011732                              *(uint64_t*)((char*)rax_4 + 0xc8) = 0;
0001173a                              *(uint8_t*)((char*)rax_4 + 0xa4) = 0;
000116b4                          }
0001161e                      }
000114ef                  }
00011494              }
00011437          }
00011304      }
00011304      
0001174e      __security_check_cookie(rax_1 ^ &var_3c8);
00011770      return result;
0001119c  }

00011771                                                     cc cc cc cc cc cc cc                                           .......

00011778    void NWDispatchDeviceControl(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, uint64_t OutputBufferLength, uint64_t InputBufferLength, uint32_t IoControlCode)

00011778  {
0001178b      int64_t rax = data_16908(WdfDriverGlobals, Queue);
000117a2      data_16a70(WdfDriverGlobals, rax, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
000117a8      WdfDriverGlobals;
000117c0      /* jump -> data_16c68 */
00011778  }

000117c7                       cc cc cc cc cc cc cc cc cc                                                         .........

000117d0    void NWDispatchRead(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, uint64_t Length)

000117d0  {
000117d0      WdfDriverGlobals;
000117e0      /* jump -> data_16c68 */
000117d0  }

000117e7                       cc cc cc cc cc cc cc cc cc                                                         .........

000117f0    void NWDispatchInternalDeviceControl(struct WDFQUEUE__* Queue, struct WDFREQUEST__* Request, uint64_t OutputBufferLength, uint64_t InputBufferLength, uint32_t IoControlCode)

000117f0  {
00011819      int32_t rbx = 0;
0001181c      char rsi = 1;
00011821      struct WDFDEVICE__* Device = data_16908(WdfDriverGlobals, Queue);
0001183b      struct _NW_DEVICE_CONTEXT* DevContext =
0001183b          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00011852      int32_t rax_7;
00011852      int32_t rax_8;
00011852      
00011852      if (IoControlCode > 0xb0023)
000118eb          switch (IoControlCode)
000118eb          {
000118e6              case 0xb0027:
000118e6              {
000119d0                  rax_7 = NWGetDeviceAttributes(Request);
000119d5              label_119d5:
000119d5                  
000119da                  if (rsi)
000119e9                      data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_7);
000118e6                  break;
000118e6              }
000118f1              case 0xb002b:
000118f1              {
000119e9                  data_16c58(WdfDriverGlobals, Request, (uint64_t)rbx);
000118f1                  break;
000118f1              }
000118fa              case 0xb0191:
000118fa              {
000119c3                  rax_8 = NWHIDSetFeature(DevContext, Request);
000119e9                  data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_8);
000118fa                  break;
000118fa              }
00011905              case 0xb0192:
00011905              {
000119b6                  rax_8 = NWHIDGetFeature(DevContext, Request);
000119e9                  data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_8);
00011905                  break;
00011905              }
0001190d              case 0xb0195:
0001190d              {
000119a9              label_119a9:
000119a9                  rax_8 = NWHIDWriteReport(DevContext, Request);
000119e9                  data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_8);
0001190d                  break;
0001190d              }
00011916              case 0xb01a2:
00011916              {
0001192f                  int64_t rax_14 = data_16cf0(WdfDriverGlobals, Request);
0001193f                  data_16908(WdfDriverGlobals, rax_14);
00011954                  int16_t var_38;
00011954                  memset(&var_38, 0, 0x28);
00011959                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
00011968                  var_38 = 0x28;
0001196d                  data_16c70(WdfDriverGlobals_1, Request, &var_38);
00011979                  int64_t var_30;
00011979                  
00011979                  if (var_30 >= 0x10)
00011979                  {
00011996                      if (*(uint64_t*)(data_16d08(WdfDriverGlobals, Request) + 0x70))
0001199f                          rbx = -0x3ffffff3;
00011996                      else
00011998                          rbx = -0x3ffffff0;
00011979                  }
00011979                  else
0001197b                      rbx = -0x3fffffdd;
0001197b                  
000119e9                  data_16c58(WdfDriverGlobals, Request, (uint64_t)rbx);
00011916                  break;
00011916              }
000118eb              default:
000118eb              {
000119e9                  data_16c58(WdfDriverGlobals, Request, -0x3fffff45);
000118eb              }
000118eb          }
00011852      else if (IoControlCode == 0xb0023)
000119e9          data_16c58(WdfDriverGlobals, Request, (uint64_t)rbx);
00011858      else if (IoControlCode == 0xb0003)
00011863      {
000118df          rax_8 = NWGetDeviceDescriptor(Device, Request);
000119e9          data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_8);
00011863      }
00011863      else if (IoControlCode == 0xb0007)
00011868      {
000118cd          rax_8 = NWGetReportDescriptor(Device, Request);
000119e9          data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_8);
00011868      }
00011868      else
00011868      {
0001186d          if (IoControlCode == 0xb000b)
0001186d          {
000118b1              rax_7 = data_16ce8(WdfDriverGlobals, Request, DevContext->ReportQueue);
000118b7              rsi = 1;
000118b7              
000118be              if (rax_7 >= 0)
000118be                  rsi = 0;
000118be              
000118be              goto label_119d5;
0001186d          }
0001186d          
00011872          if (IoControlCode == 0xb000f)
00011872              goto label_119a9;
00011872          
0001187b          if (IoControlCode == 0xb0013)
0001187b          {
0001188e              int32_t rax_6 = NWHIDGetString(DevContext, Request);
0001188e              
00011898              if (rax_6 < 0)
000119e9                  data_16c58(WdfDriverGlobals, Request, (uint64_t)rax_6);
0001187b          }
0001187b          else if (IoControlCode == 0xb001f)
000119e9              data_16c58(WdfDriverGlobals, Request, (uint64_t)rbx);
00011880          else
000119e9              data_16c58(WdfDriverGlobals, Request, -0x3fffff45);
00011868      }
000117f0  }

00011a0a                                cc cc cc cc cc cc                                                            ......

00011a10    int32_t NWPrepareHardware(struct WDFDEVICE__* Device, struct WDFCMRESLIST__* ResourceList, struct WDFCMRESLIST__* ResourceListTranslated)

00011a10  {
00011a3f      uint32_t MaxResponseLen = 0x1000;
00011a47      uint32_t NumPendingReads = 0xa;
00011a4f      void* rax =
00011a4f          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00011a69      void* rax_1 =
00011a69          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00011a79      int32_t result_1;
00011a79      int32_t result;
00011a79      
00011a79      if (!*(uint64_t*)((char*)rax_1 + 0x18))
00011a79      {
00011a8c          result_1 = data_16e30(WdfDriverGlobals, Device, 0, (char*)rax_1 + 0x18);
00011a95          result = result_1;
00011a79      }
00011a79      
00011a97      if (*(uint64_t*)((char*)rax_1 + 0x18) || result_1 >= 0)
00011a97      {
00011aa8          data_16e40(WdfDriverGlobals, *(uint64_t*)((char*)rax_1 + 0x18), rax_1);
00011aae          struct _WDF_OBJECT_CONTEXT_TYPE_INFO* UniqueType =
00011aae              _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType;
00011ab5          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
00011abf          int16_t arg_20 = 0;
00011ac8          void* rax_2 = data_16a70(WdfDriverGlobals_1, Device, UniqueType);
00011ae4          result_1 =
00011ae4              data_16e48(WdfDriverGlobals, *(uint64_t*)((char*)rax_2 + 0x18), 0, &arg_20);
00011aea          result = result_1;
00011aea          
00011af1          if (result_1 == 0xc0000023)
00011afb              result = NWSelectInterfaces(Device);
00011a97      }
00011a97      
00011b00      if (result >= 0)
00011b00      {
00011b15          (uint8_t)result_1 = *(uint16_t*)((char*)rax + 0xc) == 0x10;
00011b1d          *(uint8_t*)((char*)rax + 0x48) = (uint8_t)result_1;
00011b20          int32_t var_80;
00011b20          memset(&var_80, 0, 0x14);
00011b25          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
00011b2c          var_80 = 0x14;
00011b42          int32_t var_70;
00011b42          
00011b42          if (data_16e38(WdfDriverGlobals_2, *(uint64_t*)((char*)rax + 0x18), &var_80) < 0)
00011b52              *(uint8_t*)((char*)rax + 0x24) = 0;
00011b42          else
00011b4d              *(uint8_t*)((char*)rax + 0x24) = (char)(var_70 >> 2) & 1;
00011b4d          
00011b67          *(uint32_t*)((char*)rax + 0x20) = var_70 & 2;
00011b6a          NWReadParameters(&MaxResponseLen, &NumPendingReads);
00011b7e          int32_t var_68;
00011b7e          memset(&var_68, 0, 0x48);
00011b83          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_3 = WdfDriverGlobals;
00011b91          void (* var_38_1)(struct WDFUSBPIPE__* Pipe, struct WDFMEMORY__* Buffer, 
00011b91              uint64_t NumBytesTransferred, void* Context) = NWBulkReadCompletion;
00011b99          uint64_t MaxResponseLen_1 = (uint64_t)MaxResponseLen;
00011b9d          var_68 = 0x48;
00011ba1          uint64_t MaxResponseLen_2 = MaxResponseLen_1;
00011ba6          (uint8_t)MaxResponseLen_1 = (uint8_t)NumPendingReads;
00011baa          void* var_30_1 = rax;
00011bb2          char var_48_1 = (uint8_t)MaxResponseLen_1;
00011bc5          uint8_t (* var_28_1)(struct WDFUSBPIPE__* Pipe, int32_t Status, 
00011bc5              int32_t UsbdStatus) = NWBulkReadFailure;
00011bd1          int32_t result_2 =
00011bd1              data_16f10(WdfDriverGlobals_3, *(uint64_t*)((char*)rax + 0x28), &var_68);
00011bda          result = result_2;
00011bda          
00011bdc          if (result_2 >= 0)
00011bdc          {
00011bec              memset(&var_68, 0, 0x48);
00011bf1              struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_4 = WdfDriverGlobals;
00011bff              void (* var_38_2)(struct WDFUSBPIPE__* Pipe, struct WDFMEMORY__* Buffer, 
00011bff                  uint64_t NumBytesTransferred, void* Context) = NWIntReadCompletion;
00011c07              var_68 = 0x48;
00011c0b              void* var_30_2 = rax;
00011c13              int64_t var_60_1 = 0x40;
00011c25              int32_t result_3 =
00011c25                  data_16f10(WdfDriverGlobals_4, *(uint64_t*)((char*)rax + 0x30), &var_68);
00011c2e              result = result_3;
00011c2e              
00011c30              if (result_3 >= 0)
00011c30              {
00011c3d                  if (!(*(uint8_t*)((char*)rax + 0xa0) & 1))
00011c3d                  {
00011c3f                      struct _DRIVER_OBJECT* NWDriverObject_1 = NWDriverObject;
00011c46                      *(uint32_t*)((char*)rax + 0xa0) |= 1;
00011c59                      char rax_8 = *(uint8_t*)((char*)rax + 0x49);
00011c67                      int16_t rax_9 = *(uint16_t*)((char*)rax + 0xa);
00011c77                      int16_t rax_10 = *(uint16_t*)((char*)rax + 8);
00011c83                      *(uint64_t*)((char*)rax + 0xc8) = 0;
00011c83                      
00011c92                      if (j_TransLibInitialize(NWDriverObject_1, &NWRegistryPath, rax, 
00011c92                          (char*)rax + 0xc8, rax_10, rax_9, rax_8, NWTransLibCallbackFnc) < 0)
00011c92                      {
00011c94                          *(uint32_t*)((char*)rax + 0xa0) &= 0xfffffffe;
00011c9d                          j_TransLibShutdown(0);
00011ca2                          *(uint64_t*)((char*)rax + 0xc8) = 0;
00011c92                      }
00011c3d                  }
00011c3d                  
00011cbe                  data_16e18(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0xb0), -0x2faf080);
00011c30              }
00011bdc          }
00011b00      }
00011b00      
00011ce2      return result;
00011a10  }

00011ce3           cc cc cc cc cc cc cc cc cc                                                                 .........

00011cec    int32_t NWReleaseHardware(struct WDFDEVICE__* Device, struct WDFCMRESLIST__* ResourceListTranslated)

00011cec  {
00011d09      void* rax =
00011d09          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00011d09      
00011d19      if (*(uint8_t*)((char*)rax + 0xa0) & 1)
00011d19      {
00011d1b          int64_t rcx_1 = *(uint64_t*)((char*)rax + 0xc8);
00011d22          *(uint32_t*)((char*)rax + 0xa0) &= 0xfffffffe;
00011d29          j_TransLibShutdown(rcx_1);
00011d19      }
00011d19      
00011d2e      int64_t rdx_1 = *(uint64_t*)((char*)rax + 0xb0);
00011d2e      
00011d38      if (rdx_1)
00011d44          data_16e20(WdfDriverGlobals, rdx_1, 0);
00011d44      
00011d4e      if (!*(uint64_t*)((char*)rax + 0x18))
00011d97          return 0;
00011d97      
00011d5f      int32_t var_28;
00011d5f      memset(&var_28, 0, 0x20);
00011d64      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
00011d6b      var_28 = 0x20;
00011d6f      int32_t var_24_1 = 1;
00011d89      return data_16e70(WdfDriverGlobals_1, *(uint64_t*)((char*)rax + 0x18), 0, &var_28, 
00011d89          var_28);
00011cec  }

00011d98                                                                          cc cc cc cc cc cc cc cc                          ........

00011da0    int32_t NWSelectInterfaces(struct WDFDEVICE__* Device)

00011da0  {
00011da5      int64_t rbp;
00011da5      int64_t arg_10 = rbp;
00011db4      int64_t r14;
00011db4      int64_t var_20 = r14;
00011dcd      void* rax =
00011dcd          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00011df6      int64_t r13;
00011df6      (uint8_t)r13 = data_16e68(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0x18));
00011df9      int32_t var_50;
00011df9      memset(&var_50, 0, 0x20);
00011e05      var_50 = 0x20;
00011e09      int32_t var_4c = 3;
00011e1d      int32_t result;
00011e1d      int64_t r8_1;
00011e1d      result = data_16e70(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0x18), 0, &var_50);
00011e1d      
00011e28      if (result >= 0)
00011e28      {
00011e2e          char i = 0;
00011e2e          
00011e34          if ((uint8_t)r13)
00011e34          {
00011eff              do
00011eff              {
00011e45                  (uint8_t)r8_1 = i;
00011e48                  int64_t rax_2 =
00011e48                      data_16f70(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0x18), r8_1);
00011e5b                  char rax_3;
00011e5b                  rax_3 = data_16f80(WdfDriverGlobals, rax_2);
00011e61                  (uint8_t)rbp = 0;
00011e64                  (uint8_t)r14 = rax_3;
00011e64                  
00011e69                  if (rax_3)
00011e69                  {
00011ef3                      do
00011ef3                      {
00011e7a                          int32_t var_68;
00011e7a                          memset(&var_68, 0, 0x14);
00011e7f                          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
00011e8b                          int64_t r8_2;
00011e8b                          (uint8_t)r8_2 = (uint8_t)rbp;
00011e91                          var_68 = 0x14;
00011e99                          int64_t rax_4;
00011e99                          rax_4 =
00011e99                              data_16f88(WdfDriverGlobals_1, rax_2, r8_2, &var_68, var_68);
00011ea9                          int32_t var_5c;
00011ea9                          
00011ea9                          if (var_5c == 3)
00011ea9                          {
00011edf                              char rax_8;
00011edf                              rax_8 = data_16ed0(WdfDriverGlobals, rax_4);
00011edf                              
00011ee7                              if (rax_8)
00011ee9                                  *(uint64_t*)((char*)rax + 0x28) = rax_4;
00011ea9                          }
00011ea9                          else if (var_5c == 4 && i == (var_5c - 3))
00011eb3                          {
00011ebf                              char rax_7;
00011ebf                              rax_7 = data_16ed0(WdfDriverGlobals, rax_4);
00011ebf                              
00011ec7                              if (!rax_7)
00011ecf                                  *(uint64_t*)((char*)rax + 0x38) = rax_4;
00011ec7                              else
00011ec9                                  *(uint64_t*)((char*)rax + 0x30) = rax_4;
00011eb3                          }
00011eb3                          
00011eed                          (uint8_t)rbp += 1;
00011ef3                      } while ((uint8_t)rbp < (uint8_t)r14);
00011e69                  }
00011e69                  
00011ef9                  i += 1;
00011eff              } while (i < (uint8_t)r13);
00011e34          }
00011e34          
00011f18          if (!*(uint64_t*)((char*)rax + 0x28) || !*(uint64_t*)((char*)rax + 0x30)
00011f18                  || !*(uint64_t*)((char*)rax + 0x38))
00011f1a              return -0x3ffffe7e;
00011e28      }
00011e28      
00011f40      return result;
00011da0  }

00011f41     cc cc cc cc cc cc cc                                                                           .......

00011f48    void NWStartIo(struct _NW_DEVICE_CONTEXT* pDevContext, uint8_t bResetPort)

00011f48  {
00011f52      int64_t arg_8 = 0;
00011f58      int64_t rdi;
00011f58      (uint8_t)rdi = bResetPort;
00011f71      int32_t rax = data_16de8(WdfDriverGlobals, pDevContext->StartIoLock, &arg_8);
00011f71      
00011f79      if (rax)
00011f79          return;
00011f79      
00011f92      if (pDevContext->PoweredUp != (uint8_t)rax && pDevContext->TransLibFlags & 1)
00011f92      {
00011fac          if (data_16988(WdfDriverGlobals, pDevContext->BulkReadPipe) == 1)
00011fac          {
00011fb5              j_DbgPrint("
00011fb5                  pDevContext->BulkReadPipe is WdfIoTargetStarted need to stop io\n");
00011fcb              data_16980(WdfDriverGlobals, pDevContext->BulkReadPipe, 1);
00011fac          }
00011fac          
00011fe5          if (data_16988(WdfDriverGlobals, pDevContext->IntReadPipe) == 1)
00011fe5          {
00011fee              j_DbgPrint("
00011fee                  pDevContext->IntReadPipe is WdfIoTargetStarted need to stop io\n");
00012004              data_16980(WdfDriverGlobals, pDevContext->IntReadPipe, 1);
00011fe5          }
00011fe5          
0001200d          if ((uint8_t)rdi)
0001201a              data_16ea0(WdfDriverGlobals, pDevContext->WdfUsbTargetDevice);
0001201a          
0001202b          data_16978(WdfDriverGlobals, pDevContext->BulkReadPipe);
0001203c          data_16978(WdfDriverGlobals, pDevContext->IntReadPipe);
00011f92      }
00011f92      
00012050      data_16df0(WdfDriverGlobals, pDevContext->StartIoLock);
00011f48  }

00012061     cc cc cc cc cc cc cc                                                                           .......

00012068    int32_t NWEnterWorkingState(struct WDFDEVICE__* Device, enum _WDF_POWER_DEVICE_STATE PreviousState)

00012068  {
0001207f      struct _NW_DEVICE_CONTEXT* pDevContext =
0001207f          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
0001208d      pDevContext->PoweredUp = 1;
00012094      NWStartIo(pDevContext, 0);
000120a0      j_TransLibEnterWorkingState(pDevContext->TransLibContext);
000120ac      return 0;
00012068  }

000120ad                                         cc cc cc cc cc cc cc                                                   .......

000120b4    int32_t NWLeaveWorkingState(struct WDFDEVICE__* Device, enum _WDF_POWER_DEVICE_STATE TargetState)

000120b4  {
000120cb      void* rax =
000120cb          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
000120e5      int32_t rax_1 = data_16de8(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0xa8), 0);
000120e5      
000120ed      if (!rax_1)
000120ed      {
000120ef          int64_t rdx_2 = *(uint64_t*)((char*)rax + 0xa8);
000120f6          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
000120fd          *(uint8_t*)((char*)rax + 0xa4) = (uint8_t)rax_1;
00012103          data_16df0(WdfDriverGlobals_1, rdx_2);
000120ed      }
000120ed      
0001211a      data_16980(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0x28), 1);
00012131      data_16980(WdfDriverGlobals, *(uint64_t*)((char*)rax + 0x30), 1);
00012131      
0001213e      if (*(uint8_t*)((char*)rax + 0xa0) & 1)
00012147          j_TransLibLeaveWorkingState(*(uint64_t*)((char*)rax + 0xc8));
00012147      
00012153      return 0;
000120b4  }

00012154                                                              cc cc cc cc cc cc cc cc                                  ........

0001215c    uint32_t __convention("sysv") NWReadParameters(uint32_t* MaxResponseLen @ rcx, uint32_t* NumPendingReads @ rdx)

0001215c  {
00012179      struct WDFDRIVER__* Driver = WdfDriverGlobals->Driver;
0001217c      int64_t var_30 = 0;
00012180      int64_t var_38 = 0;
00012184      int64_t arg_20 = 0;
00012188      uint32_t arg_18 = 0;
00012198      int32_t result = 0;
000121a7      int512_t entry_zmm0;
000121a7      
000121a7      if (data_167d8(entry_zmm0, Driver, 0xf003f, 0, &var_30) >= 0)
000121a7      {
000121b9          UNICODE_STRING DestinationString;
000121b9          RtlInitUnicodeString(&DestinationString, u"Queue Parameters");
000121ea          int64_t* var_58;
000121ea          (uint32_t)var_58 = 0;
000121ea          
000121f6          if (data_16b50(WdfDriverGlobals, var_30, &DestinationString, 0xf003f, var_58, 0, 
000121f6              0, &var_38) >= 0)
000121f6          {
00012208              RtlInitUnicodeString(&DestinationString, u"ConsumerQueue");
00012208              
00012248              if (data_16b50(WdfDriverGlobals, var_38, &DestinationString, 0xf003f, 0, 0, 
00012248                  0, &arg_20) >= 0)
00012248              {
0001225a                  RtlInitUnicodeString(&DestinationString, u"MaxResponseLength");
00012260                  int64_t rdx_2 = arg_20;
00012268                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
0001227c                  arg_18 = 0;
0001227c                  
0001228b                  if (data_16ba0(WdfDriverGlobals_1, rdx_2, &DestinationString, &arg_18)
0001228b                      >= 0)
0001228b                  {
0001228d                      uint32_t rax_4 = arg_18;
0001228d                      
00012296                      if (rax_4 > 0)
00012298                          *(uint32_t*)MaxResponseLen = rax_4;
0001228b                  }
0001228b                  
000122a6                  RtlInitUnicodeString(&DestinationString, u"NumPendingReads");
000122ac                  int64_t rdx_3 = arg_20;
000122b4                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
000122c8                  arg_18 = 0;
000122c8                  
000122d7                  if (data_16ba0(WdfDriverGlobals_2, rdx_3, &DestinationString, &arg_18)
000122d7                      >= 0)
000122d7                  {
000122d9                      uint32_t rax_6 = arg_18;
000122d9                      
000122e2                      if (rax_6 > 0)
000122e4                          *(uint32_t*)NumPendingReads = rax_6;
000122d7                  }
000122d7                  
000122e6                  result = 3;
00012248              }
000121f6          }
000121a7      }
000121a7      
000122eb      int64_t rdx_4 = arg_20;
000122eb      
000122f6      if (rdx_4)
000122ff          data_16b58(WdfDriverGlobals, rdx_4);
000122ff      
00012305      int64_t rdx_5 = var_38;
00012305      
0001230d      if (rdx_5)
00012316          data_16b58(WdfDriverGlobals, rdx_5);
00012316      
0001231c      int64_t rdx_6 = var_30;
0001231c      
00012324      if (rdx_6)
0001232d          data_16b58(WdfDriverGlobals, rdx_6);
0001232d      
00012344      return result;
0001215c  }

00012345                 cc cc cc cc cc cc cc                                                                   .......

0001234c    int32_t NWTransLibCallbackFnc(void* pContext, uint32_t RequestType, void* Context, uint32_t Length)

0001234c  {
0001235e      void var_c8;
0001235e      int64_t rax_1 = __security_cookie ^ &var_c8;
00012369      int32_t result = 0;
00012369      
00012374      if (RequestType == 4)
000124e7          result = NWProcessReport(pContext, Context, Length);
00012374      else if (RequestType == 8)
0001237d      {
0001246b          if (KeReadStateEvent((char*)pContext + 0x50))
0001246b          {
0001247f              data_16e00(WdfDriverGlobals, *(uint64_t*)((char*)pContext + 0x68));
0001247f              
0001248f              if (*(uint32_t*)((char*)pContext + 0x80) <= 0x3e8)
0001248f              {
000124ad                  if (*(uint64_t*)((char*)pContext + 0x70))
000124b9                      **(uint64_t**)((char*)pContext + 0x78) = Context;
000124ad                  else
000124af                      *(uint64_t*)((char*)pContext + 0x70) = Context;
000124af                  
000124bc                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
000124c3                  *(uint64_t*)((char*)pContext + 0x78) = Context;
000124c7                  *(uint64_t*)Context = 0;
000124ca                  int64_t rdx_7 = *(uint64_t*)((char*)pContext + 0x68);
000124ce                  *(uint32_t*)((char*)pContext + 0x80) += 1;
000124d4                  data_16e08(WdfDriverGlobals_2, rdx_7);
0001248f              }
0001248f              else
0001248f              {
0001249c                  data_16e08(WdfDriverGlobals, *(uint64_t*)((char*)pContext + 0x68));
000124a2                  result = -0x3fffffff;
0001248f              }
0001246b          }
0001246b          else
0001246d              result = -0x3fffff5d;
0001237d      }
0001237d      else if (RequestType == 0x14)
00012386      {
00012453          int32_t rdx_2;
00012453          (uint8_t)rdx_2 = 1;
00012455          NWStartIo(pContext, (uint8_t)rdx_2);
00012386      }
00012386      else if (RequestType == 0x15)
0001238f      {
000123a0          int64_t var_98 = 0;
000123a5          int64_t var_90_1 = 0;
000123aa          (uint32_t)var_98 = 0x10;
000123b2          *(uint32_t*)((char*)var_98)[4] = 1;
000123ba          int64_t var_90_2 = -0x5f5e100;
000123c7          char var_68;
000123c7          char* rcx;
000123c7          uint64_t Length_2;
000123c7          
000123c7          if (!*(uint8_t*)((char*)pContext + 0x48))
000123c7          {
000123e4              Length_2 = 0x40;
000123ea              rcx = &var_68;
000123ea              
000123f2              if (Length < 0x40)
000123f2                  Length_2 = (uint64_t)Length;
000123c7          }
000123c7          else
000123c7          {
000123c9              uint32_t Length_1 = 0x3f;
000123ce              var_68 = 9;
000123d3              void var_67;
000123d3              rcx = &var_67;
000123d3              
000123db              if (Length < 0x3f)
000123db                  Length_1 = Length;
000123db              
000123df              Length_2 = (uint64_t)Length_1;
000123c7          }
000123c7          
000123f6          memmove(rcx, Context, Length_2);
000123fb          int64_t rdx_4 = *(uint64_t*)((char*)pContext + 0x38);
000123ff          struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
00012410          int64_t var_88;
00012410          __builtin_memset(&var_88, 0, 0x18);
00012429          (uint32_t)var_88 = 1;
00012431          char* var_80_1 = &var_68;
0001243b          int64_t var_78;
0001243b          (uint32_t)var_78 = 0x40;
000124e7          result = data_16ef0(WdfDriverGlobals_1, rdx_4, 0, &var_98, &var_88, 0);
0001238f      }
0001238f      else
00012391          result = -0x3ffffff3;
00012391      
000124f6      __security_check_cookie(rax_1 ^ &var_c8);
00012505      return result;
0001234c  }

00012506                    cc cc cc cc cc cc                                                                    ......

0001250c    int32_t NWGetPerformanceStats(struct _NW_DEVICE_CONTEXT* pDevContext, struct _NW_PERFORMANCE_REPORT_CB* PerformanceReport, struct WDFREQUEST__* Request)

0001250c  {
00012520      int64_t arg_10 = 0;
00012528      uint64_t MemoryUsageReport = PerformanceReport->MemoryUsageReport;
0001253f      int32_t result;
0001253f      
0001253f      if (!MemoryUsageReport || !PerformanceReport->KernelThreadTimes)
00012665          result = -0x3ffffff3;
0001253f      else
0001253f      {
0001255d          int32_t result_1 =
0001255d              data_16cd8(WdfDriverGlobals, Request, MemoryUsageReport, 0x40, &arg_10);
00012563          result = result_1;
00012563          
00012567          if (result_1 >= 0)
00012567          {
0001257c              void* rax_1 = data_16a30(WdfDriverGlobals, arg_10, 0);
00012582              int32_t* rbx_1 = rax_1;
00012582              
00012588              if (!rax_1)
00012665                  result = -0x3ffffff3;
00012588              else
00012588              {
00012597                  memset(rax_1, 0, 0x40);
000125a6                  j_TransLibGetMemoryUsage(pDevContext->TransLibContext, rbx_1);
000125b2                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
000125b9                  *(uint32_t*)rbx_1 += NWMemoryUsage.TotalNonPagedPool;
000125c2                  rbx_1[1] += NWMemoryUsage.TotalPagedPool;
000125cb                  rbx_1[2] = NWMemoryUsage.TotalNonPagedPool;
000125d4                  rbx_1[3] = NWMemoryUsage.TotalPagedPool;
000125dd                  rbx_1[4] = NWMemoryUsage.AllocationTable[0];
000125e6                  rbx_1[5] = (*(uint96_t*)NWMemoryUsage.AllocationTable)[1];
000125ef                  rbx_1[6] = (*(uint96_t*)NWMemoryUsage.AllocationTable)[2];
000125f7                  data_16aa0(WdfDriverGlobals_1, arg_10);
000125fd                  uint64_t KernelThreadTimes = PerformanceReport->KernelThreadTimes;
00012601                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
00012608                  arg_10 = 0;
00012623                  int32_t result_2 = data_16cd8(WdfDriverGlobals_2, Request, 
00012623                      KernelThreadTimes, 0x20, &arg_10);
00012629                  result = result_2;
00012629                  
0001262d                  if (result_2 >= 0)
0001262d                  {
0001263e                      void* rax_8 = data_16a30(WdfDriverGlobals, arg_10, 0);
0001263e                      
0001264a                      if (!rax_8)
00012665                          result = -0x3ffffff3;
0001264a                      else
0001264a                      {
00012654                          memset(rax_8, 0, 0x20);
00012661                          result = j_TransLibGetThreadTimes(rax_8);
0001264a                      }
0001262d                  }
00012588              }
00012567          }
0001253f      }
0001253f      
0001266a      int64_t rdx_6 = arg_10;
0001266a      
00012672      if (rdx_6)
0001267b          data_16aa0(WdfDriverGlobals, rdx_6);
0001267b      
00012697      return result;
0001250c  }

00012698                                                                          cc cc cc cc cc cc cc cc                          ........

000126a0    void NWStartIoWorkItem(struct WDFWORKITEM__* WorkItem)

000126a0  {
000126ba      int64_t* rax = data_16a70(WdfDriverGlobals, WorkItem, 
000126ba          _WDF_NW_WORKITEM_CONTEXT_TYPE_INFO.UniqueType);
000126d1      struct _NW_DEVICE_CONTEXT* pDevContext = data_16a70(WdfDriverGlobals, 
000126d1          *(uint64_t*)rax, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
000126d1      
000126da      if (pDevContext)
000126e1          NWStartIo(pDevContext, 1);
000126e1      
000126e6      WdfDriverGlobals;
000126f5      /* jump -> data_16aa0 */
000126a0  }

000126fc                                                                                      cc cc cc cc                              ....
00012700  cc cc cc cc                                                                                      ....

00012704    int32_t NWCreateStartIoWorkItem(struct WDFDEVICE__* Device)

00012704  {
00012718      int32_t var_40;
00012718      memset(&var_40, 0, 0x38);
00012729      struct _WDF_OBJECT_CONTEXT_TYPE_INFO* UniqueType =
00012729          _WDF_NW_WORKITEM_CONTEXT_TYPE_INFO.UniqueType;
00012730      int32_t var_28 = 1;
00012739      int64_t var_58;
00012739      __builtin_memset(&var_58, 0, 0x18);
00012743      int64_t var_48;
00012743      (uint8_t)var_48 = 1;
00012747      int32_t var_24 = 1;
0001274b      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
0001276b      var_40 = 0x38;
00012773      struct WDFDEVICE__* Device_1 = Device;
00012778      (uint32_t)var_58 = 0x18;
00012785      int64_t arg_8;
00012785      int32_t result = data_16ff8(WdfDriverGlobals_1, &var_58, &var_40, &arg_8, var_58, 
00012785          NWStartIoWorkItem, var_48, var_40);
00012785      
0001278d      if (result < 0)
000127ca          return result;
000127ca      
000127a5      struct WDFDEVICE__** rax_1 = data_16a70(WdfDriverGlobals, arg_8, 
000127a5          _WDF_NW_WORKITEM_CONTEXT_TYPE_INFO.UniqueType);
000127ab      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
000127b2      *(uint64_t*)rax_1 = Device;
000127bd      data_17000(WdfDriverGlobals_2, arg_8);
000127c3      return 0;
00012704  }

000127cb                                   cc cc cc cc cc cc cc cc cc                                                 .........

000127d4    int32_t NWBulkWatchdogTimerEvt(struct WDFTIMER__* Timer)

000127d4  {
000127e8      struct WDFDEVICE__* Device = data_16e28(WdfDriverGlobals, Timer);
00012802      void* rax =
00012802          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00012812      char rax_1;
00012812      
00012812      if (*(uint8_t*)((char*)rax + 0xbc))
0001281b          rax_1 = j_TransLibGetParsedTransfer(*(uint64_t*)((char*)rax + 0xc8));
0001281b      
00012822      if (*(uint8_t*)((char*)rax + 0xbc) && rax_1)
00012822      {
00012824          int64_t rcx_3 = *(uint64_t*)((char*)rax + 0xc8);
0001282d          *(uint8_t*)((char*)rax + 0xbc) = 0;
00012834          j_TransLibSetParsedTransfer(rcx_3, 0);
00012822      }
00012822      else if (*(uint32_t*)((char*)rax + 0xc0))
00012847          NWCreateStartIoWorkItem(Device);
00012847      
00012858      return 0;
000127d4  }

00012859                                                                             cc cc cc cc cc cc cc                           .......

00012860    int32_t NWGetDeviceDescriptor(struct WDFDEVICE__* Device, struct WDFREQUEST__* Request)

00012860  {
00012883      int64_t rax =
00012883          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
000128a7      int64_t* arg_18;
000128a7      int32_t result_1 = data_16c90(WdfDriverGlobals, Request, 9, &arg_18, 0);
000128ad      int32_t result = result_1;
000128ad      
000128b1      if (result_1 >= 0)
000128b1      {
000128ba          int64_t* rdx_2 = arg_18;
000128c6          char rax_1;
000128c6          
000128c6          if (!*(uint8_t*)(rax + 0xc4))
000128c6          {
000128e1              *(uint64_t*)rdx_2 = -0x3cddfefffeffdef7;
000128e4              rax_1 = 1;
000128c6          }
000128c6          else
000128c6          {
000128cf              *(uint64_t*)rdx_2 = 0x422010001002109;
000128d2              rax_1 = 2;
000128c6          }
000128c6          
000128f1          result = 0;
000128f3          rdx_2[1] = rax_1;
000128fd          data_16cb8(WdfDriverGlobals, Request, 9);
000128b1      }
000128b1      
00012914      return result;
00012860  }

00012915                                                                 cc cc cc cc cc cc cc                                   .......

0001291c    int32_t NWGetDeviceAttributes(struct WDFREQUEST__* Request)

0001291c  {
0001292b      int32_t* arg_10 = nullptr;
0001293e      int64_t rax = data_16cf0(WdfDriverGlobals, Request);
0001294e      int64_t rax_1 = data_16908(WdfDriverGlobals, rax);
00012965      void* rax_2 =
00012965          data_16a70(WdfDriverGlobals, rax_1, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00012989      int32_t result = data_16c90(WdfDriverGlobals, Request, 0x20, &arg_10, 0);
00012989      
00012993      if (result >= 0)
00012993      {
000129a0          *(uint32_t*)arg_10 = 0x20;
000129af          arg_10[1] = *(uint16_t*)((char*)rax_2 + 8);
000129bc          *(uint16_t*)((char*)arg_10 + 6) = *(uint16_t*)((char*)rax_2 + 0xa);
000129c9          arg_10[2] = *(uint16_t*)((char*)rax_2 + 0xc);
000129d7          data_16cb8(WdfDriverGlobals, Request, 0x20);
00012993      }
00012993      
000129ee      return result;
0001291c  }

000129ef                                               cc cc cc cc cc cc cc cc cc                                         .........

000129f8    int32_t NWGetReportDescriptor(struct WDFDEVICE__* Device, struct WDFREQUEST__* Request)

000129f8  {
00012a19      void* rax =
00012a19          data_16a70(WdfDriverGlobals, Device, _WDF_NW_DEVICE_CONTEXT_TYPE_INFO.UniqueType);
00012a28      int64_t Interval = -0x989680;
00012a34      int64_t r8_2 = KeDelayExecutionThread(0, 0, &Interval);
00012a67      char* arg_20;
00012a67      int32_t result_1;
00012a67      int64_t rdx_2;
00012a67      int64_t r8_6;
00012a67      result_1 = data_16c90(WdfDriverGlobals, Request, 
00012a67          ((uint64_t)(uint32_t)(r8_2 - r8_2) & 0x41) + 0x1c3, &arg_20, 0);
00012a6d      int32_t result = result_1;
00012a6d      
00012a71      if (result_1 >= 0)
00012a71      {
00012a77          char rcx_3 = *(uint8_t*)((char*)rax + 0xc4);
00012a7d          char* rbx = arg_20;
00012a82          (uint8_t)result_1 = rcx_3;
00012a84          char temp1_1 = (uint8_t)result_1;
00012a84          (uint8_t)result_1 = -((uint8_t)result_1);
00012a86          (uint8_t)result_1 = rcx_3;
00012a91          char temp2_1 = (uint8_t)result_1;
00012a91          (uint8_t)result_1 = -((uint8_t)result_1);
00012a9f          void* rcx_6;
00012a9f          
00012a9f          if (!rcx_3)
00012a9f          {
00012ae3              if (((uint64_t)(uint32_t)(r8_6 - r8_6) & 0x41) + 0x1c3
00012ae3                      > ((uint64_t)(uint32_t)(rdx_2 - rdx_2) & 0x41) + 0x1c3)
00012b39                  return -0x3fffffdd;
00012b39              
00012af5              memmove(rbx, &HIDInputDescriptor, 0x14f);
00012afa              rcx_6 = &rbx[0x14f];
00012a9f          }
00012a9f          else
00012a9f          {
00012aa4              if (((uint64_t)(uint32_t)(r8_6 - r8_6) & 0x41) + 0x1c3
00012aa4                      > ((uint64_t)(uint32_t)(rdx_2 - rdx_2) & 0x41) + 0x1c3)
00012b39                  return -0x3fffffdd;
00012b39              
00012ab9              memmove(rbx, &HIDInputDescriptor, 0x14f);
00012ad2              memmove(&rbx[0x14f], &HIDPenDescriptor, 0x41);
00012ad7              rcx_6 = &rbx[0x190];
00012a9f          }
00012a9f          
00012b0e          int64_t r8_10 = memmove(rcx_6, &HIDVendorDescriptor, 0x74);
00012b20          result = 0;
00012b31          data_16cb8(WdfDriverGlobals, Request, 
00012b31              ((uint64_t)(uint32_t)(r8_10 - r8_10) & 0x41) + 0x1c3);
00012a71      }
00012a71      
00012b4d      return result;
000129f8  }

00012b4e                                            cc cc cc cc cc cc                                                    ......

00012b54    int32_t NWHIDWriteReport(struct _NW_DEVICE_CONTEXT* DevContext, struct WDFREQUEST__* Request)

00012b54  {
00012b74      void var_118;
00012b74      int64_t rax_1 = __security_cookie ^ &var_118;
00012b8c      int32_t result = 0;
00012b8e      int64_t rax_2 = data_16cf0(WdfDriverGlobals);
00012b9e      data_16908(WdfDriverGlobals, rax_2);
00012bb1      int16_t var_a8;
00012bb1      memset(&var_a8, 0, 0x28);
00012bb6      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
00012bc5      var_a8 = 0x28;
00012bca      data_16c70(WdfDriverGlobals_1, Request, &var_a8);
00012bd9      int64_t var_98;
00012bd9      
00012bd9      if (var_98 >= 0x10)
00012bd9      {
00012bf5          int64_t* rsi_1 = *(uint64_t*)(data_16d08(WdfDriverGlobals, Request) + 0x70);
00012bf5          
00012bfc          if (!rsi_1)
00012bfe              result = -0x3ffffff0;
00012bfc          else
00012bfc          {
00012c0c              char* var_e8;
00012c0c              char* var_e0;
00012c0c              int64_t var_d0;
00012c0c              
00012c0c              if (*(uint8_t*)((char*)rsi_1 + 0xc) == 5)
00012c0c              {
00012dc1                  void* rbp_1 = *(uint64_t*)rsi_1;
00012dc4                  int32_t rax_8 = *(uint32_t*)((char*)rbp_1 + 4);
00012dc4                  
00012dca                  if (rax_8 == 2)
00012dca                  {
00013031                      KeSetEvent(&DevContext->ConsumerConnected, 0, 0);
00013043                      j_TLSetTranslationMode(DevContext->TransLibContext, 1);
00012dca                  }
00012dca                  else if (rax_8 == 3)
00012dd3                  {
00012fd7                      j_TLSetTranslationMode(DevContext->TransLibContext, 0);
00012fe0                      KeClearEvent(&DevContext->ConsumerConnected);
00012ff1                      data_16e00(WdfDriverGlobals, DevContext->UserTranslationQueueLock);
00012ff1                      
00013008                      while (true)
00013008                      {
00013008                          char* UserTranslationQueueHead =
00013008                              DevContext->UserTranslationQueueHead;
00013008                          
0001300f                          if (!UserTranslationQueueHead)
0001300f                              break;
0001300f                          
00012ff9                          struct _TL_WORK_ITEM* rax_21;
00012ff9                          (uint8_t)rax_21 = *(uint8_t*)UserTranslationQueueHead;
00012ff9                          *(uint8_t*)((char*)rax_21)[1] = UserTranslationQueueHead[1];
00012ff9                          *(uint16_t*)((char*)rax_21)[2] =
00012ff9                              *(uint16_t*)(UserTranslationQueueHead + 2);
00012ff9                          *(uint8_t*)((char*)rax_21)[4] = UserTranslationQueueHead[4];
00012ff9                          *(uint8_t*)((char*)rax_21)[5] = UserTranslationQueueHead[5];
00012ff9                          *(uint8_t*)((char*)rax_21)[6] = UserTranslationQueueHead[6];
00012ff9                          *(uint8_t*)((char*)rax_21)[7] = UserTranslationQueueHead[7];
00012ffe                          DevContext->UserTranslationQueueHead = rax_21;
00013002                          ExFreePoolWithTag(UserTranslationQueueHead, 0);
00013008                      }
00013008                      
00013011                      struct WDFSPINLOCK__* UserTranslationQueueLock =
00013011                          DevContext->UserTranslationQueueLock;
00013015                      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_5 = WdfDriverGlobals;
0001301c                      DevContext->UserTranslationQueueTail = nullptr;
00013020                      data_16e08(WdfDriverGlobals_5, UserTranslationQueueLock);
00012dd3                  }
00012dd3                  else if (rax_8 == 4)
00012dba                      result = NWProcessReport(DevContext, (char*)rbp_1 + 0xc, 
00012dba                          *(uint32_t*)((char*)rbp_1 + 8));
00012ddc                  else if (rax_8 == 7)
00012dba                      result =
00012dba                          NWGetPerformanceStats(DevContext, (char*)rbp_1 + 0xc, Request);
00012de5                  else if (rax_8 == 9)
00012dee                  {
00012e95                      int32_t r13_1 = 0;
00012e95                      
00012e9c                      if (rsi_1[1] >= 0x1c)
00012e9c                      {
00012ec8                          int32_t result_5 = data_16cd8(WdfDriverGlobals, Request, 
00012ec8                              *(uint64_t*)((char*)rbp_1 + 0x14), 
00012ec8                              (uint64_t)*(uint32_t*)((char*)rbp_1 + 0xc) + 4, &var_e8);
00012ece                          result = result_5;
00012ece                          
00012ed2                          if (result_5 >= 0)
00012ed2                          {
00012ee7                              int32_t* rax_16 = data_16a30(WdfDriverGlobals, var_e8, 0);
00012eed                              struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_3 =
00012eed                                  WdfDriverGlobals;
00012eed                              
00012efa                              if (rax_16)
00012efa                              {
00012f11                                  int32_t r12_1 = *(uint32_t*)((char*)rbp_1 + 0xc);
00012f15                                  *(uint32_t*)rax_16 = 0;
00012f1c                                  char* r14_1 = &rax_16[1];
00012f20                                  data_16e00(WdfDriverGlobals_3, 
00012f20                                      DevContext->UserTranslationQueueLock);
00012f26                                  struct _TL_WORK_ITEM* UserTranslationQueueHead_1 =
00012f26                                      DevContext->UserTranslationQueueHead;
00012f26                                  
00012f2d                                  if (UserTranslationQueueHead_1)
00012f2d                                  {
00012f38                                      while (r12_1 - r13_1
00012f38                                          >= UserTranslationQueueHead_1->Size)
00012f38                                      {
00012f3a                                          DevContext->UserQueueCount -= 1;
00012f4b                                          memmove(r14_1, &UserTranslationQueueHead_1[1], 
00012f4b                                              (uint64_t)UserTranslationQueueHead_1->Size);
00012f50                                          uint64_t Size =
00012f50                                              (uint64_t)UserTranslationQueueHead_1->Size;
00012f5d                                          r13_1 += (uint32_t)Size;
00012f60                                          r14_1 = &r14_1[Size];
00012f63                                          DevContext->UserTranslationQueueHead =
00012f63                                              UserTranslationQueueHead_1->next;
00012f67                                          ExFreePoolWithTag(UserTranslationQueueHead_1, 0);
00012f6d                                          UserTranslationQueueHead_1 =
00012f6d                                              DevContext->UserTranslationQueueHead;
00012f6d                                          
00012f74                                          if (!UserTranslationQueueHead_1)
00012f74                                          {
00012f76                                              DevContext->UserTranslationQueueTail &=
00012f76                                                  UserTranslationQueueHead_1;
00012f76                                              break;
00012f74                                          }
00012f38                                      }
00012f2d                                  }
00012f2d                                  
00012f85                                  data_16e08(WdfDriverGlobals, 
00012f85                                      DevContext->UserTranslationQueueLock);
00012f8b                                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_4 =
00012f8b                                      WdfDriverGlobals;
00012f92                                  *(uint32_t*)rax_16 = r13_1;
00012f9a                                  data_16aa0(WdfDriverGlobals_4, var_e8);
00012efa                              }
00012efa                              else
00012efa                              {
00012f01                                  data_16aa0(WdfDriverGlobals_3, var_e8);
00012f07                                  result = -0x3fffff66;
00012efa                              }
00012ed2                          }
00012e9c                      }
00012e9c                      else
00012e9e                          result = -0x3ffffff3;
00012dee                  }
00012dee                  else if (rax_8 == 0xa)
00012df7                  {
00012e85                      if (rsi_1[1] < 0x1c)
00012e9e                          result = -0x3ffffff3;
00012e85                      else
00012dba                          result = j_TLConfigureTrace((char*)rbp_1 + 0xc);
00012df7                  }
00012df7                  else if (rax_8 != 0xb)
00012e9e                      result = -0x3ffffff3;
00012e00                  else
00012e00                  {
00012e06                      var_d0 = 0;
00012e06                      
00012e0f                      if (rsi_1[1] < 0x1c)
00012e9e                          result = -0x3ffffff3;
00012e0f                      else
00012e0f                      {
00012e31                          int32_t result_4 = data_16cd8(WdfDriverGlobals, Request, 
00012e31                              *(uint64_t*)((char*)rbp_1 + 0x14), 
00012e31                              (uint64_t)*(uint32_t*)((char*)rbp_1 + 0xc), &var_e0);
00012e37                          result = result_4;
00012e37                          
00012e3b                          if (result_4 >= 0)
00012e3b                          {
00012e50                              int64_t rax_15 = data_16a30(WdfDriverGlobals, var_e0, 0);
00012e50                              
00012e59                              if (rax_15)
00012dba                                  result = j_TLGetTraceBuffer(
00012dba                                      (uint64_t)*(uint32_t*)((char*)rbp_1 + 0xc), rax_15, 
00012dba                                      &var_d0);
00012e59                              else
00012e59                              {
00012f01                                  data_16aa0(WdfDriverGlobals, var_e0);
00012f07                                  result = -0x3fffff66;
00012e59                              }
00012e3b                          }
00012e0f                      }
00012e00                  }
00012c0c              }
00012c0c              else if (*(uint8_t*)((char*)rsi_1 + 0xc) == 8)
00012c16              {
00012cfa                  int64_t rdx_9 = *(uint64_t*)rsi_1;
00012cff                  bool cond:0_1 = !DevContext->IsHollyDevice;
00012d02                  var_e0 = nullptr;
00012d07                  int64_t var_d8_1 = 0;
00012d0f                  int32_t rax_5 = rsi_1[1];
00012d12                  (uint32_t)var_e0 = 0x10;
00012d1a                  *(uint32_t*)((char*)var_e0)[4] = 1;
00012d22                  int64_t var_d8_2 = -0x5f5e100;
00012d2b                  char var_78;
00012d2b                  char* rcx_10;
00012d2b                  uint64_t r8_6;
00012d2b                  
00012d2b                  if (cond:0_1)
00012d2b                  {
00012d4e                      r8_6 = 0x40;
00012d51                      rcx_10 = &var_78;
00012d51                      
00012d5b                      if (rax_5 - 1 < 0x40)
00012d5b                          r8_6 = (uint64_t)(rax_5 - 1);
00012d2b                  }
00012d2b                  else
00012d2b                  {
00012d2d                      int32_t rcx_9 = 0x3f;
00012d32                      var_78 = 9;
00012d32                      
00012d3c                      if (rax_5 - 1 < 0x3f)
00012d3c                          rcx_9 = rax_5 - 1;
00012d3c                      
00012d3f                      r8_6 = (uint64_t)rcx_9;
00012d42                      void var_77;
00012d42                      rcx_10 = &var_77;
00012d2b                  }
00012d2b                  
00012d62                  memmove(rcx_10, rdx_9 + 1, r8_6);
00012d67                  int64_t var_f0_1 = 0;
00012d6d                  struct WDFUSBPIPE__* IntWritePipe = DevContext->IntWritePipe;
00012d71                  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_2 = WdfDriverGlobals;
00012d7f                  int64_t var_c0;
00012d7f                  __builtin_memset(&var_c0, 0, 0x18);
00012d99                  (uint32_t)var_c0 = 1;
00012da1                  char* var_b8_1 = &var_78;
00012dab                  int64_t var_b0;
00012dab                  (uint32_t)var_b0 = 0x40;
00012dba                  result = data_16ef0(WdfDriverGlobals_2, IntWritePipe, 0, &var_e0, 
00012dba                      &var_c0, var_f0_1);
00012c16              }
00012c16              else
00012c16              {
00012c1c                  struct _NW_TRANSLIB_DEVICE_CONTEXT* TransLibContext =
00012c1c                      DevContext->TransLibContext;
00012c23                  var_e8 = nullptr;
00012c2d                  int32_t var_c8;
00012c2d                  int32_t result_1 = j_TLGetTranslationMode(TransLibContext, &var_c8);
00012c32                  result = result_1;
00012c32                  
00012c36                  if (result_1 >= 0)
00012c36                  {
00012c41                      if (var_c8 != 1)
00012dba                          result = j_TransLibProcessUserReport(DevContext->TransLibContext, 
00012dba                              *(uint64_t*)rsi_1, (uint64_t)rsi_1[1]);
00012c41                      else
00012c41                      {
00012c57                          int32_t result_2 = data_16910(WdfDriverGlobals, 
00012c57                              DevContext->ReportQueue, &var_e0);
00012c5d                          result = result_2;
00012c5d                          
00012c61                          if (result_2 >= 0)
00012c61                          {
00012c86                              int32_t result_3 = data_16c90(WdfDriverGlobals, var_e0, 
00012c86                                  (uint64_t)rsi_1[1], &var_e8, &var_d0);
00012c8c                              result = result_3;
00012c8c                              
00012c90                              if (result_3 >= 0)
00012c90                              {
00012ca3                                  memmove(var_e8, *(uint64_t*)rsi_1, var_d0);
00012ca8                                  char* r11_1 = var_e8;
00012ca8                                  
00012cb1                                  if (*(uint8_t*)r11_1 == 6)
00012cb3                                      *(uint8_t*)r11_1 = 7;
00012cb1                                  else if (*(uint8_t*)r11_1 == 7)
00012cbf                                      *(uint8_t*)r11_1 = 6;
00012cbf                                  
00012cd7                                  data_16c68(WdfDriverGlobals, var_e0, (uint64_t)result, 
00012cd7                                      var_d0);
00012c90                              }
00012c61                          }
00012c41                      }
00012c36                  }
00012c16              }
00012bfc          }
00012bd9      }
00012bd9      else
00012bdb          result = -0x3fffffdd;
00012bdb      
00013055      __security_check_cookie(rax_1 ^ &var_118);
00013075      return result;
00012b54  }

00013076                                                                    cc cc cc cc cc cc                                    ......

0001307c    int32_t NWProcessReport(struct _NW_DEVICE_CONTEXT* pDevContext, void* ReportBuffer, uint32_t ReportBufferLen)

0001307c  {
0001308c      uint64_t ReportBufferLen_3 = 0;
00013091      char* arg_20 = nullptr;
000130a4      uint64_t ReportBufferLen_1 = (uint64_t)ReportBufferLen;
000130ab      int64_t var_18;
000130ab      int32_t result_1 = data_16910(WdfDriverGlobals, pDevContext->ReportQueue, &var_18);
000130b1      int32_t result = result_1;
000130b1      
000130b5      if (result_1 >= 0)
000130b5      {
000130d5          int32_t result_2 = data_16c90(WdfDriverGlobals, var_18, ReportBufferLen_1, 
000130d5              &arg_20, &ReportBufferLen_3);
000130db          result = result_2;
000130db          
000130df          if (result_2 >= 0)
000130df          {
000130e1              uint64_t ReportBufferLen_2 = ReportBufferLen_3;
000130e6              char* rcx_2 = arg_20;
000130e6              
000130f1              if (ReportBufferLen_2 > ReportBufferLen_1)
000130f1                  ReportBufferLen_2 = ReportBufferLen_1;
000130f1              
000130f5              ReportBufferLen_3 = ReportBufferLen_2;
000130fa              memmove(rcx_2, ReportBuffer, ReportBufferLen_2);
00013113              data_16c68(WdfDriverGlobals, var_18, (uint64_t)result, ReportBufferLen_3);
000130df          }
000130b5      }
000130b5      
0001312a      return result;
0001307c  }

0001312b                                   cc cc cc cc cc cc cc cc cc                                                 .........

00013134    int32_t NWHIDGetString(struct _NW_DEVICE_CONTEXT* DevContext, struct WDFREQUEST__* Request)

00013134  {
00013144      char* arg_20 = nullptr;
0001315a      int16_t var_38;
0001315a      memset(&var_38, 0, 0x28);
0001315f      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
0001316e      var_38 = 0x28;
00013173      data_16c70(WdfDriverGlobals_1, Request, &var_38);
00013179      int16_t var_18;
00013179      uint64_t rax = (uint64_t)var_18;
00013182      wchar16* const rbx;
00013182      int64_t r8_1;
00013182      
00013182      if (rax == 0xe)
00013182      {
000131a9          rbx = u"NextWindow";
000131b0      label_131b0:
000131b0          int64_t i = -1;
000131b6          wchar16* const rdi_1 = rbx;
000131b6          
000131b9          while (i)
000131b9          {
000131b9              bool cond:0_1 = 0 != *(uint16_t*)rdi_1;
000131b9              rdi_1 = &rdi_1[1];
000131b9              i -= 1;
000131b9              
000131b9              if (!cond:0_1)
000131b9                  break;
000131b9          }
000131b9          
000131bf          r8_1 = ~i * 2;
00013182      }
00013182      else
00013182      {
00013188          if (rax == 0xf)
00013188          {
000131a0              rbx = u"NW Dev";
000131a7              goto label_131b0;
00013188          }
00013188          
0001318e          if (rax == 0x10)
0001318e          {
00013197              rbx = u"1231212";
0001319e              goto label_131b0;
0001318e          }
0001318e          
00013190          rbx = nullptr;
00013192          r8_1 = 0;
00013182      }
00013182      
000131c3      int64_t arg_18 = r8_1;
000131c3      
000131ce      if (!rbx)
000131d0          return -0x3ffffff3;
000131d0      
000131f6      int32_t result = data_16c90(WdfDriverGlobals, Request, r8_1, &arg_20, &arg_18);
000131f6      
00013200      if (result >= 0)
00013200      {
00013215          memmove(arg_20, rbx, arg_18);
0001322f          data_16c68(WdfDriverGlobals, Request, (uint64_t)result, arg_18);
00013200      }
00013200      
00013246      return result;
00013134  }

00013247                       cc cc cc cc cc cc cc cc cc                                                         .........

00013250    int32_t NWHIDGetFeature(struct _NW_DEVICE_CONTEXT* DevContext, struct WDFREQUEST__* Request)

00013250  {
00013271      int32_t result = 0;
00013273      int64_t rax = data_16cf0(WdfDriverGlobals);
00013283      data_16908(WdfDriverGlobals, rax);
00013296      int16_t var_38;
00013296      memset(&var_38, 0, 0x28);
0001329b      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
000132aa      var_38 = 0x28;
000132af      data_16c70(WdfDriverGlobals_1, Request, &var_38);
000132bb      int64_t var_30;
000132bb      
000132bb      if (var_30 >= 0x10)
000132bb      {
000132d4          int64_t* rax_2 = *(uint64_t*)(data_16d08(WdfDriverGlobals, Request) + 0x70);
000132d4          
000132db          if (!rax_2)
000132dd              return -0x3ffffff0;
000132dd          
000132e8          if (*(uint8_t*)((char*)rax_2 + 0xc) != 2)
000132e8          {
000132ff              if (*(uint8_t*)((char*)rax_2 + 0xc) != 1)
00013310                  return -0x3ffffff3;
00013310              
00013305              if (rax_2[1] >= 2)
00013305              {
0001330a                  *(uint8_t*)(*(uint64_t*)rax_2 + 1) = 2;
0001332b                  return result;
00013305              }
000132e8          }
000132e8          else if (rax_2[1] >= 3)
000132ee          {
000132f0              void* rcx_4 = *(uint64_t*)rax_2;
000132f3              (uint8_t)rax_2 = DevContext->InputMode;
000132f6              *(uint8_t*)((char*)rcx_4 + 1) = (uint8_t)rax_2;
0001332b              return result;
000132ee          }
000132bb      }
000132bb      
000132bd      return -0x3fffffdd;
00013250  }

0001332c                                      cc cc cc cc cc cc cc cc                                                  ........

00013334    int32_t NWHIDSetFeature(struct _NW_DEVICE_CONTEXT* DevContext, struct WDFREQUEST__* Request)

00013334  {
00013357      int64_t rax = data_16cf0(WdfDriverGlobals);
00013367      data_16908(WdfDriverGlobals, rax);
0001337a      int16_t var_38;
0001337a      memset(&var_38, 0, 0x28);
0001337f      struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
0001338e      var_38 = 0x28;
00013393      data_16c70(WdfDriverGlobals_1, Request, &var_38);
0001339f      int64_t var_28;
0001339f      
0001339f      if (var_28 >= 0x10)
0001339f      {
000133b8          char* rcx_4 = *(uint64_t*)(data_16d08(WdfDriverGlobals, Request) + 0x70);
000133b8          
000133bf          if (!rcx_4)
000133c1              return -0x3ffffff0;
000133c1          
000133cc          if (*(uint32_t*)(rcx_4 + 8) >= 3)
000133cc          {
000133d2              if (rcx_4[0xc] != 2)
000133d4                  return -0x3ffffff3;
000133d4              
000133db              bool cond:0_1 = !(DevContext->TransLibFlags & 1);
000133e2              void* rdx_3;
000133e2              (uint8_t)rdx_3 = *(uint8_t*)rcx_4;
000133e2              *(uint8_t*)((char*)rdx_3)[1] = rcx_4[1];
000133e2              *(uint16_t*)((char*)rdx_3)[2] = *(uint16_t*)(rcx_4 + 2);
000133e2              *(uint8_t*)((char*)rdx_3)[4] = rcx_4[4];
000133e2              *(uint8_t*)((char*)rdx_3)[5] = rcx_4[5];
000133e2              *(uint8_t*)((char*)rdx_3)[6] = rcx_4[6];
000133e2              *(uint8_t*)((char*)rdx_3)[7] = rcx_4[7];
000133e5              void* rax_1;
000133e5              (uint8_t)rax_1 = *(uint8_t*)((char*)rdx_3 + 1);
000133e8              DevContext->InputMode = (uint8_t)rax_1;
000133e8              
000133eb              if (cond:0_1)
00013414                  return 0;
00013414              
000133ed              (uint8_t)rdx_3 = *(uint8_t*)((char*)rdx_3 + 1);
000133fc              return j_TransLibUpdateInputMode(DevContext->TransLibContext, rdx_3);
000133cc          }
0001339f      }
0001339f      
000133a1      return -0x3fffffdd;
00013334  }

00013415                                                                 cc cc cc cc cc cc cc                                   .......

0001341c    void NWBulkReadCompletion(struct WDFUSBPIPE__* Pipe, struct WDFMEMORY__* Buffer, uint64_t NumBytesTransferred, void* Context)

0001341c  {
00013439      if (!*(uint8_t*)((char*)Context + 0xa4) || !NumBytesTransferred)
00013439          return;
00013439      
00013445      int64_t rax_1 = data_16a30(WdfDriverGlobals, Buffer, 0);
00013445      
0001344e      if (rax_1)
0001345d          j_TransLibProcessStreamSync(*(uint64_t*)((char*)Context + 0xc8), rax_1, 
0001345d              (uint64_t)(uint32_t)NumBytesTransferred);
0001345d      
00013462      *(uint8_t*)((char*)Context + 0xbc) = 1;
0001341c  }

00013474                                                              cc cc cc cc cc cc cc cc                                  ........

0001347c    uint8_t NWBulkReadFailure(struct WDFUSBPIPE__* Pipe, int32_t Status, int32_t UsbdStatus)

0001347c  {
00013482      int64_t rbx;
00013482      (uint8_t)rbx = 1;
00013487      struct WDFDEVICE__* Device;
00013487      
00013487      if (Pipe)
00013487      {
00013493          Device = data_16990(WdfDriverGlobals, Pipe);
00013493          
0001349c          if (Device)
0001349c          {
000134a1              NWCreateStartIoWorkItem(Device);
000134a6              (uint8_t)rbx = 0;
0001349c          }
00013487      }
00013487      
000134a8      (uint8_t)Device = (uint8_t)rbx;
000134af      return (uint8_t)Device;
0001347c  }

000134b0                                                  cc cc cc cc cc cc cc cc                                          ........

000134b8    int32_t NWCompleteHardwareReads(struct _NW_DEVICE_CONTEXT* pDevContext, void* pBuffer, uint64_t BufferSize)

000134b8  {
000134dd      int64_t arg_8;
000134dd      int32_t result_1 = data_16910(WdfDriverGlobals, pDevContext->ReportQueue, &arg_8);
000134e3      int32_t result = result_1;
000134e3      
000134e7      if (result_1 >= 0)
000134e7      {
0001350a          char* arg_20;
0001350a          int32_t result_2 = data_16c90(WdfDriverGlobals, arg_8, 0x41, &arg_20, 0);
00013510          result = result_2;
00013510          
00013514          if (result_2 >= 0)
00013514          {
00013532              uint64_t BufferSize_1 = 0x40;
0001353e              *(uint8_t*)arg_20 = 8;
0001353e              
00013549              if (BufferSize < 0x40)
00013549                  BufferSize_1 = BufferSize;
00013549              
0001354d              memmove(&arg_20[1], pBuffer, BufferSize_1);
00013567              data_16c68(WdfDriverGlobals, arg_8, (uint64_t)result, 0x41);
00013514          }
00013514          else
00013525              data_16c58(WdfDriverGlobals, arg_8, (uint64_t)result_2);
000134e7      }
000134e7      
0001357e      return result;
000134b8  }

0001357f                                                                                               cc                                 .
00013580  cc cc cc cc cc cc cc cc                                                                          ........

00013588    void NWIntReadCompletion(struct WDFUSBPIPE__* Pipe, struct WDFMEMORY__* Buffer, uint64_t NumBytesTransferred, void* Context)

00013588  {
000135aa      if (!*(uint8_t*)((char*)Context + 0xa4) || !NumBytesTransferred)
000135aa          return;
000135aa      
000135b6      char* pBuffer = data_16a30(WdfDriverGlobals, Buffer, 0);
000135b6      
000135c2      if (!pBuffer)
000135c2          return;
000135c2      
000135c8      if (!*(uint8_t*)((char*)Context + 0x48))
000135c8      {
000135de          NWCompleteHardwareReads(Context, pBuffer, NumBytesTransferred);
000135f0          j_TransLibHardwareReadSync(*(uint64_t*)((char*)Context + 0xc8), pBuffer, 
000135f0              (uint64_t)(uint32_t)NumBytesTransferred);
000135c8      }
000135c8      else if (*(uint8_t*)pBuffer == 9)
000135cd      {
000135cf          char* pBuffer_1 = &pBuffer[1];
000135d2          uint64_t BufferSize = NumBytesTransferred - 1;
000135de          NWCompleteHardwareReads(Context, pBuffer_1, BufferSize);
000135f0          j_TransLibHardwareReadSync(*(uint64_t*)((char*)Context + 0xc8), pBuffer_1, 
000135f0              (uint64_t)(uint32_t)BufferSize);
000135cd      }
00013588  }

00013605                 cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00       .................ff........

00013620    int64_t __security_check_cookie(int64_t arg1)

00013620  {
00013627      if (arg1 == __security_cookie)
00013627      {
00013629          int64_t rcx = ROLQ(arg1, 0x10);
00013629          
00013632          if (!((uint16_t)rcx & 0xffff))
00013634              return;
00013634          
00013637          arg1 = RORQ(rcx, 0x10);
00013627      }
00013627      
0001363b      /* tailcall */
0001363b      return __report_gsfailure(arg1);
00013620  }

00013640  cc cc cc cc cc cc cc cc                                                                          ........

00013648    void __report_gsfailure(uint64_t StackCookie) __noreturn

00013648  {
00013668      KeBugCheckEx(DRIVER_OVERRAN_STACK_BUFFER, StackCookie, __security_cookie, 
00013668          __security_cookie_complement, 0);
0001366e      breakpoint();
00013648  }

0001366f                                               cc cc cc cc cc cc cc                                               .......

00013676    uint32_t j_DbgPrint(char* Format, ...)

00013676  {
00013676      /* tailcall */
00013676      return DbgPrint(Format);
00013676  }

0001367c                                                                                      cc cc cc cc                              ....
00013680  cc cc cc cc                                                                                      ....

00013684    void FxStubDriverUnloadCommon()

00013684  {
0001368f      FxStubUnbindClasses(&WdfBindInfo);
000136ad      /* tailcall */
000136ad      return j_WdfVersionUnbind(&WdfDriverStubRegistryPath, &WdfBindInfo, WdfDriverGlobals);
00013684  }

000136b2                                                        cc cc cc cc cc cc                                            ......

000136b8    void FxStubDriverMiniportUnload(struct _WDF_DRIVER_GLOBALS* DriverGlobals, struct WDFDRIVER__* Driver)

000136b8  {
000136b8      /* tailcall */
000136b8      return FxStubDriverUnloadCommon();
000136b8  }

000136bd                                                                                         cc cc cc                               ...
000136c0  cc cc cc cc                                                                                      ....

000136c4    void FxStubDriverUnload(struct _DRIVER_OBJECT* DriverObject)

000136c4  {
000136c8      void (* WdfDriverStubDisplacedDriverUnload_1)(struct _DRIVER_OBJECT*) =
000136c8          WdfDriverStubDisplacedDriverUnload;
000136c8      
000136de      if (WdfDriverStubDisplacedDriverUnload_1
000136de              && WdfDriverStubDisplacedDriverUnload_1 != FxStubDriverUnload)
000136e0          WdfDriverStubDisplacedDriverUnload_1(DriverObject);
000136e0      
000136e6      /* tailcall */
000136e6      return FxStubDriverUnloadCommon();
000136c4  }

000136eb                                   cc cc cc cc cc cc cc cc cc                                                 .........

000136f4    int32_t __convention("sysv") FxDriverEntryWorker(struct _DRIVER_OBJECT* DriverObject @ rcx, struct _UNICODE_STRING* RegistryPath @ rdx)

000136f4  {
00013713      if (!DriverObject)
00013717          return DriverEntry(nullptr, RegistryPath);
00013717      
00013726      WdfDriverStubDriverObject = DriverObject;
00013734      WdfDriverStubRegistryPath.MaximumLength = 0x208;
00013742      WdfDriverStubRegistryPath.Length = 0;
00013749      WdfDriverStubRegistryPath.Buffer = &WdfDriverStubRegistryPathBuffer;
00013750      RtlCopyUnicodeString(&WdfDriverStubRegistryPath, RegistryPath);
0001376e      int64_t entry_rdi;
0001376e      int32_t rax = j_WdfVersionBind(DriverObject, &WdfDriverStubRegistryPath, 
0001376e          &WdfBindInfo, &WdfDriverGlobals, entry_rdi);
0001376e      
00013775      if (rax < 0)
00013815          return rax;
00013815      
00013782      int32_t rax_1 = FxStubBindClasses(&WdfBindInfo);
00013789      int32_t rbx_1 = rax_1;
00013789      
0001378b      if (rax_1 >= 0)
0001378b      {
0001378d          FxStubInitTypes();
00013798          int32_t rax_2 = DriverEntry(DriverObject, RegistryPath);
0001379f          rbx_1 = rax_2;
0001379f          
000137a1          if (rax_2 >= 0)
000137a1          {
000137a3              struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals_1 = WdfDriverGlobals;
000137a3              
000137ae              if (WdfDriverGlobals_1->DisplaceDriverUnload)
000137ae              {
000137b0                  DRIVER_UNLOAD* rax_3 = WdfDriverStubDisplacedDriverUnload;
000137b0                  
000137bb                  if (DriverObject->DriverUnload)
000137bb                      rax_3 = DriverObject->DriverUnload;
000137bb                  
000137c0                  WdfDriverStubDisplacedDriverUnload = rax_3;
000137ce                  DriverObject->DriverUnload = FxStubDriverUnload;
000137ae              }
000137ae              else if (WdfDriverGlobals_1->DriverFlags & 2)
000137d8              {
000137e1                  WdfDriverStubOriginalWdfDriverMiniportUnload = data_16a68;
000137ef                  data_16a68 = FxStubDriverMiniportUnload;
000137d8              }
000137d8              
000137f6              return 0;
000137a1          }
0001378b      }
0001378b      
000137fa      FxStubDriverUnloadCommon();
000137ff      return rbx_1;
000136f4  }

00013816                                                                    cc cc cc cc cc cc                                    ......

0001381c    int32_t FxDriverEntry(struct _DRIVER_OBJECT* DriverObject, struct _UNICODE_STRING* RegistryPath)

0001381c  {
0001382c      __security_init_cookie();
00013841      /* tailcall */
00013841      return FxDriverEntryWorker(DriverObject, RegistryPath);
0001381c  }

00013846                    cc cc cc cc cc cc                                                                    ......

0001384c    void __convention("sysv") FxStubUnbindClasses(struct _WDF_BIND_INFO* WdfBindInfo @ rcx)

0001384c  {
00013856      struct _WDF_CLASS_BIND_INFO* __KMDF_CLASS_BIND_LAST_BOUND_1 =
00013856          __KMDF_CLASS_BIND_LAST_BOUND;
00013867      void** i = &__KMDF_CLASS_BIND_END;
00013867      
00013876      if (__KMDF_CLASS_BIND_LAST_BOUND_1 == &__KMDF_CLASS_BIND_START
00013876              || &__KMDF_CLASS_BIND_END > __KMDF_CLASS_BIND_LAST_BOUND_1)
00013876          return;
00013876      
000138b6      do
000138b6      {
00013878          int64_t rax = i[8];
0001387f          int64_t entry_rdi;
0001387f          
0001387f          if (!rax)
000138a6              j_WdfVersionUnbindClass(WdfBindInfo, WdfDriverGlobals, i);
0001387f          else
00013895              rax(j_WdfVersionUnbindClass, WdfBindInfo, WdfDriverGlobals, i, entry_rdi);
000138ab          i = &i[0xa];
000138b6      } while (i <= __KMDF_CLASS_BIND_LAST_BOUND);
0001384c  }

000138c3           cc cc cc cc cc cc cc cc cc                                                                 .........

000138cc    int32_t __convention("sysv") FxStubBindClasses(struct _WDF_BIND_INFO* WdfBindInfo @ rcx)

000138cc  {
000138de      int32_t result = 0;
000138e0      void** rbx = &__KMDF_CLASS_BIND_END;
000138e0      
000138f1      while (true)
000138f1      {
000138f1          if (rbx < &__KMDF_CLASS_BIND_END)
000138f1          {
000138f6              if (*(uint32_t*)rbx != 0x50)
000138f6                  break;
000138f6              
000138f8              int64_t rax = rbx[7];
000138fc              __KMDF_CLASS_BIND_LAST_BOUND = rbx;
00013906              int64_t entry_rdi;
00013906              
00013906              if (!rax)
0001392d                  result = j_WdfVersionBindClass(WdfBindInfo, WdfDriverGlobals, rbx);
00013906              else
0001391c                  result = rax(j_WdfVersionBindClass, WdfBindInfo, WdfDriverGlobals, rbx, 
0001391c                      entry_rdi);
0001391c              
00013934              if (result >= 0)
00013934              {
00013936                  rbx = &rbx[0xa];
0001393a                  continue;
00013934              }
000138f1          }
000138f1          
00013950          return result;
000138f1      }
000138f1      
0001393c      return -0x3ffffffc;
000138cc  }

00013951                                                     cc cc cc cc cc cc cc                                           .......

00013958    void FxStubInitTypes()

00013958  {
000139bb      return;
00013958  }

000139bc                                                                                      cc cc cc cc                              ....
000139c0  cc cc                                                                                            ..

000139c2    int64_t j_TLDbgLogMsg()

000139c2  {
000139c2      /* tailcall */
000139c2      return TLDbgLogMsg();
000139c2  }

000139c8                          cc cc cc cc cc cc                                                                ......

000139ce    int64_t j_TransLibGetParsedTransfer()

000139ce  {
000139ce      /* tailcall */
000139ce      return TransLibGetParsedTransfer();
000139ce  }

000139d4                                                              cc cc cc cc cc cc                                        ......

000139da    int64_t j_TransLibInitialize()

000139da  {
000139da      /* tailcall */
000139da      return TransLibInitialize();
000139da  }

000139e0  cc cc cc cc cc cc                                                                                ......

000139e6    int64_t j_TransLibShutdown()

000139e6  {
000139e6      /* tailcall */
000139e6      return TransLibShutdown();
000139e6  }

000139ec                                      cc cc cc cc cc cc                                                        ......

000139f2    int64_t j_TransLibGetMemoryUsage()

000139f2  {
000139f2      /* tailcall */
000139f2      return TransLibGetMemoryUsage();
000139f2  }

000139f8                                                                          cc cc cc cc cc cc                                ......

000139fe    int64_t j_TransLibLeaveWorkingState()

000139fe  {
000139fe      /* tailcall */
000139fe      return TransLibLeaveWorkingState();
000139fe  }

00013a04              cc cc cc cc cc cc                                                                        ......

00013a0a    int64_t j_TransLibEnterWorkingState()

00013a0a  {
00013a0a      /* tailcall */
00013a0a      return TransLibEnterWorkingState();
00013a0a  }

00013a10                                                  cc cc cc cc cc cc                                                ......

00013a16    int64_t j_TransLibGetThreadTimes()

00013a16  {
00013a16      /* tailcall */
00013a16      return TransLibGetThreadTimes();
00013a16  }

00013a1c                                                                                      cc cc cc cc                              ....
00013a20  cc cc                                                                                            ..

00013a22    int64_t j_TransLibSetParsedTransfer()

00013a22  {
00013a22      /* tailcall */
00013a22      return TransLibSetParsedTransfer();
00013a22  }

00013a28                          cc cc cc cc cc cc                                                                ......

00013a2e    int64_t j_TransLibProcessUserReport()

00013a2e  {
00013a2e      /* tailcall */
00013a2e      return TransLibProcessUserReport();
00013a2e  }

00013a34                                                              cc cc cc cc cc cc                                        ......

00013a3a    int64_t j_TransLibUpdateInputMode()

00013a3a  {
00013a3a      /* tailcall */
00013a3a      return TransLibUpdateInputMode();
00013a3a  }

00013a40  cc cc cc cc cc cc                                                                                ......

00013a46    int64_t j_TLSetTranslationMode()

00013a46  {
00013a46      /* tailcall */
00013a46      return TLSetTranslationMode();
00013a46  }

00013a4c                                      cc cc cc cc cc cc                                                        ......

00013a52    int64_t j_TLGetTranslationMode()

00013a52  {
00013a52      /* tailcall */
00013a52      return TLGetTranslationMode();
00013a52  }

00013a58                                                                          cc cc cc cc cc cc                                ......

00013a5e    int64_t j_TLGetTraceBuffer()

00013a5e  {
00013a5e      /* tailcall */
00013a5e      return TLGetTraceBuffer();
00013a5e  }

00013a64              cc cc cc cc cc cc                                                                        ......

00013a6a    int64_t j_TLConfigureTrace()

00013a6a  {
00013a6a      /* tailcall */
00013a6a      return TLConfigureTrace();
00013a6a  }

00013a70                                                  cc cc cc cc cc cc                                                ......

00013a76    int64_t j_TransLibHardwareReadSync()

00013a76  {
00013a76      /* tailcall */
00013a76      return TransLibHardwareReadSync();
00013a76  }

00013a7c                                                                                      cc cc cc cc                              ....
00013a80  cc cc                                                                                            ..

00013a82    int64_t j_TransLibProcessStreamSync()

00013a82  {
00013a82      /* tailcall */
00013a82      return TransLibProcessStreamSync();
00013a82  }

00013a88                          cc cc cc cc cc cc                                                                ......

00013a8e    int64_t j_WdfVersionUnbind()

00013a8e  {
00013a8e      /* tailcall */
00013a8e      return WdfVersionUnbind();
00013a8e  }

00013a94                                                              cc cc cc cc cc cc                                        ......

00013a9a    int64_t j_WdfVersionBind()

00013a9a  {
00013a9a      /* tailcall */
00013a9a      return WdfVersionBind();
00013a9a  }

00013aa0  cc cc cc cc cc cc                                                                                ......

00013aa6    int64_t j_WdfVersionBindClass()

00013aa6  {
00013aa6      /* tailcall */
00013aa6      return WdfVersionBindClass();
00013aa6  }

00013aac                                      cc cc cc cc cc cc                                                        ......

00013ab2    int64_t j_WdfVersionUnbindClass()

00013ab2  {
00013ab2      /* tailcall */
00013ab2      return WdfVersionUnbindClass();
00013ab2  }

00013ab8                                                                          cc cc cc cc cc cc cc cc                          ........
00013ac0  cc cc cc cc cc cc 66 66 66 90 66 66 66 90 66 90                                                  ......fff.fff.f.

00013ad0    int64_t* memset(void* arg1, int64_t arg2, int64_t arg3)

00013ad0  {
00013ad0      int64_t* result = arg1;
00013ad0      
00013ad7      if (arg3 >= 8)
00013ad7      {
00013ae6          arg2 = (uint64_t)(uint8_t)arg2 * 0x101010101010101;
00013ae6          
00013aee          if (arg3 >= 0x40)
00013aee          {
00013af3              uint64_t rcx_1 = (uint64_t)(uint32_t)-(arg1) & 7;
00013af3              
00013af6              if ((uint32_t)rcx_1)
00013af6              {
00013af8                  arg3 -= rcx_1;
00013afb                  *(uint64_t*)result = arg2;
00013af6              }
00013af6              
00013afe              arg1 = rcx_1 + result;
00013b01              int64_t r9_1 = arg3;
00013b04              arg3 &= 0x3f;
00013b08              uint64_t i_4 = r9_1 >> 6;
00013b08              
00013b0c              if (i_4)
00013b0c              {
00013b4e                  if (i_4 >= 0x400)
00013b4e                  {
00013bae                      uint64_t i;
00013bae                      
00013bae                      do
00013bae                      {
00013b80                          *(uint64_t*)arg1 = arg2;
00013b84                          *(uint64_t*)((char*)arg1 + 8) = arg2;
00013b89                          *(uint64_t*)((char*)arg1 + 0x10) = arg2;
00013b8e                          arg1 += 0x40;
00013b92                          *(uint64_t*)((char*)arg1 - 0x28) = arg2;
00013b97                          *(uint64_t*)((char*)arg1 - 0x20) = arg2;
00013b9c                          i = i_4;
00013b9c                          i_4 -= 1;
00013b9f                          *(uint64_t*)((char*)arg1 - 0x18) = arg2;
00013ba4                          *(uint64_t*)((char*)arg1 - 0x10) = arg2;
00013ba9                          *(uint64_t*)((char*)arg1 - 8) = arg2;
00013bae                      } while (i != 1);
00013bb0                      (uint8_t)__return_addr = (uint8_t)__return_addr;
00013b4e                  }
00013b4e                  else
00013b4e                  {
00013b76                      uint64_t i_1;
00013b76                      
00013b76                      do
00013b76                      {
00013b50                          *(uint64_t*)arg1 = arg2;
00013b53                          *(uint64_t*)((char*)arg1 + 8) = arg2;
00013b57                          *(uint64_t*)((char*)arg1 + 0x10) = arg2;
00013b5b                          arg1 += 0x40;
00013b5f                          *(uint64_t*)((char*)arg1 - 0x28) = arg2;
00013b63                          *(uint64_t*)((char*)arg1 - 0x20) = arg2;
00013b67                          i_1 = i_4;
00013b67                          i_4 -= 1;
00013b6a                          *(uint64_t*)((char*)arg1 - 0x18) = arg2;
00013b6e                          *(uint64_t*)((char*)arg1 - 0x10) = arg2;
00013b72                          *(uint64_t*)((char*)arg1 - 8) = arg2;
00013b76                      } while (i_1 != 1);
00013b4e                  }
00013b0c              }
00013aee          }
00013aee          
00013b0e          int64_t r9_2 = arg3;
00013b11          arg3 &= 7;
00013b15          uint64_t i_5 = r9_2 >> 3;
00013b15          
00013b19          if (i_5)
00013b19          {
00013b2a              uint64_t i_2;
00013b2a              
00013b2a              do
00013b2a              {
00013b20                  *(uint64_t*)arg1 = arg2;
00013b23                  arg1 += 8;
00013b27                  i_2 = i_5;
00013b27                  i_5 -= 1;
00013b2a              } while (i_2 != 1);
00013b19          }
00013ad7      }
00013ad7      
00013b2f      if (arg3)
00013b2f      {
00013b39          int64_t i_3;
00013b39          
00013b39          do
00013b39          {
00013b31              *(uint8_t*)arg1 = (uint8_t)arg2;
00013b33              arg1 += 1;
00013b36              i_3 = arg3;
00013b36              arg3 -= 1;
00013b39          } while (i_3 != 1);
00013b2f      }
00013b2f      
00013b3b      return result;
00013ad0  }

00013b3c                                                                                      66 66 66 90                              fff.
00013b40  66 66 66 90 66 66 90                                                                             fff.ff.
00013b7a                                                                                66 66 90 66 66 90                            ff.ff.
00013bba                                                                                cc cc cc cc cc cc                            ......
00013bc0  cc cc cc cc cc cc 66 66 66 90 66 66 66 90 66 90                                                  ......fff.fff.f.

00013bd0    char* memmove(char* arg1, int64_t arg2, int64_t arg3)

00013bd0  {
00013bd0      char* result = arg1;
00013bd3      char* rdx = arg2 - arg1;
00013bd6      uint64_t rax;
00013bd6      
00013bd6      if (arg2 > arg1)
00013bd6      {
00013be0          if (arg3 >= 8)
00013be0          {
00013be5              if ((uint8_t)arg1 & 7)
00013be5              {
00013bea                  if ((uint8_t)arg1 & 1)
00013bea                  {
00013bec                      (uint8_t)rax = *(uint8_t*)(rdx + arg1);
00013bef                      arg3 -= 1;
00013bf2                      *(uint8_t*)arg1 = (uint8_t)rax;
00013bf4                      arg1 = &arg1[1];
00013bea                  }
00013bea                  
00013bfb                  if ((uint8_t)arg1 & 2)
00013bfb                  {
00013bfd                      (uint16_t)rax = *(uint16_t*)(rdx + arg1);
00013c01                      arg3 -= 2;
00013c05                      *(uint16_t*)arg1 = (uint16_t)rax;
00013c08                      arg1 = &arg1[2];
00013bfb                  }
00013bfb                  
00013c0f                  if ((uint8_t)arg1 & 4)
00013c0f                  {
00013c14                      arg3 -= 4;
00013c18                      *(uint32_t*)arg1 = *(uint32_t*)(rdx + arg1);
00013c1a                      arg1 = &arg1[4];
00013c0f                  }
00013be5              }
00013be5              
00013c21              while (true)
00013c21              {
00013c21                  uint64_t i_6 = arg3 >> 5;
00013c21                  
00013c25                  if (!i_6)
00013c25                      break;
00013c25                  
00013cc9                  if (i_6 < 0x800 || rdx < 0x1000)
00013cc9                  {
00013caa                      uint64_t i;
00013caa                      
00013caa                      do
00013caa                      {
00013c80                          int64_t rax_3 = *(uint64_t*)(rdx + arg1);
00013c84                          int64_t r10_1 = *(uint64_t*)(rdx + arg1 + 8);
00013c89                          arg1 = &arg1[0x20];
00013c8d                          *(uint64_t*)(arg1 - 0x20) = rax_3;
00013c91                          *(uint64_t*)(arg1 - 0x18) = r10_1;
00013c9a                          int64_t r10_2 = *(uint64_t*)(rdx + arg1 - 8);
00013c9f                          i = i_6;
00013c9f                          i_6 -= 1;
00013ca2                          *(uint64_t*)(arg1 - 0x10) = *(uint64_t*)(rdx + arg1 - 0x10);
00013ca6                          *(uint64_t*)(arg1 - 8) = r10_2;
00013caa                      } while (i != 1);
00013cac                      arg3 &= 0x1f;
00013cb0                      break;
00013cc9                  }
00013cc9                  
00013d54                  do
00013d54                  {
00013ccb                      int32_t j_4 = 0x20;
00013ce2                      int32_t j;
00013ce2                      
00013ce2                      do
00013ce2                      {
00013cd9                          arg1 = &arg1[0x80];
00013ce0                          j = j_4;
00013ce0                          j_4 -= 1;
00013ce2                      } while (j != 1);
00013ce4                      arg1 -= 0x1000;
00013ceb                      rax = 0x40;
00013d44                      int32_t j_1;
00013d44                      
00013d44                      do
00013d44                      {
00013cf4                          int64_t r10_3 = *(uint64_t*)(rdx + arg1 + 8);
00013cf9                          *(uint64_t*)arg1 = *(uint64_t*)(rdx + arg1);
00013cfd                          *(uint64_t*)(arg1 + 8) = r10_3;
00013d07                          int64_t r10_4 = *(uint64_t*)(rdx + arg1 + 0x18);
00013d0c                          *(uint64_t*)(arg1 + 0x10) = *(uint64_t*)(rdx + arg1 + 0x10);
00013d11                          *(uint64_t*)(arg1 + 0x18) = r10_4;
00013d16                          int64_t r9_5 = *(uint64_t*)(rdx + arg1 + 0x20);
00013d1b                          int64_t r10_5 = *(uint64_t*)(rdx + arg1 + 0x28);
00013d20                          arg1 = &arg1[0x40];
00013d24                          *(uint64_t*)(arg1 - 0x20) = r9_5;
00013d29                          *(uint64_t*)(arg1 - 0x18) = r10_5;
00013d33                          int64_t r10_6 = *(uint64_t*)(rdx + arg1 - 8);
00013d38                          j_1 = (uint32_t)rax;
00013d38                          rax = (uint64_t)((uint32_t)rax - 1);
00013d3a                          *(uint64_t*)(arg1 - 0x10) = *(uint64_t*)(rdx + arg1 - 0x10);
00013d3f                          *(uint64_t*)(arg1 - 8) = r10_6;
00013d44                      } while (j_1 != 1);
00013d46                      arg3 -= 0x1000;
00013d54                  } while (arg3 >= 0x1000);
00013d54                  
00013d5a                  (uint8_t)__return_addr = (uint8_t)__return_addr;
00013d5f                  continue;
00013c21              }
00013c21              
00013c2a              uint64_t i_7 = arg3 >> 3;
00013c2a              
00013c2e              if (i_7)
00013c2e              {
00013c3e                  uint64_t i_1;
00013c3e                  
00013c3e                  do
00013c3e                  {
00013c34                      *(uint64_t*)arg1 = *(uint64_t*)(rdx + arg1);
00013c37                      arg1 = &arg1[8];
00013c3b                      i_1 = i_7;
00013c3b                      i_7 -= 1;
00013c3e                  } while (i_1 != 1);
00013c40                  arg3 &= 7;
00013c2e              }
00013be0          }
00013be0          
00013c47          if (arg3)
00013c47          {
00013c5b              int64_t i_2;
00013c5b              
00013c5b              do
00013c5b              {
00013c50                  (uint8_t)rax = *(uint8_t*)(rdx + arg1);
00013c53                  *(uint8_t*)arg1 = (uint8_t)rax;
00013c55                  arg1 = &arg1[1];
00013c58                  i_2 = arg3;
00013c58                  arg3 -= 1;
00013c5b              } while (i_2 != 1);
00013c47          }
00013c47          
00013c4c          return result;
00013bd6      }
00013bd6      
00013d78      if (arg2 != arg1)
00013d78      {
00013d7a          int32_t* rcx = &arg1[arg3];
00013d7a          
00013d81          if (arg3 >= 8)
00013d81          {
00013d86              if ((uint8_t)rcx & 7)
00013d86              {
00013d8b                  if ((uint8_t)rcx & 1)
00013d8b                  {
00013d8d                      rcx -= 1;
00013d90                      (uint8_t)rax = *(uint8_t*)(rdx + rcx);
00013d93                      arg3 -= 1;
00013d96                      *(uint8_t*)rcx = (uint8_t)rax;
00013d8b                  }
00013d8b                  
00013d9b                  if ((uint8_t)rcx & 2)
00013d9b                  {
00013d9d                      rcx -= 2;
00013da1                      (uint16_t)rax = *(uint16_t*)(rdx + rcx);
00013da5                      arg3 -= 2;
00013da9                      *(uint16_t*)rcx = (uint16_t)rax;
00013d9b                  }
00013d9b                  
00013daf                  if ((uint8_t)rcx & 4)
00013daf                  {
00013db1                      rcx -= 4;
00013db8                      arg3 -= 4;
00013dbc                      *(uint32_t*)rcx = *(uint32_t*)(rdx + rcx);
00013daf                  }
00013d86              }
00013d86              
00013dc1              while (true)
00013dc1              {
00013dc1                  uint64_t i_8 = arg3 >> 5;
00013dc1                  
00013dc5                  if (!i_8)
00013dc5                      break;
00013dc5                  
00013e69                  if (i_8 < 0x800 || rdx > -0x1000)
00013e69                  {
00013e49                      uint64_t i_3;
00013e49                      
00013e49                      do
00013e49                      {
00013e20                          int64_t rax_6 = *(uint64_t*)(rdx + rcx - 8);
00013e25                          int64_t r10_7 = *(uint64_t*)(rdx + rcx - 0x10);
00013e2a                          rcx -= 0x20;
00013e2e                          *(uint64_t*)((char*)rcx + 0x18) = rax_6;
00013e32                          *(uint64_t*)((char*)rcx + 0x10) = r10_7;
00013e3b                          int64_t r10_8 = *(uint64_t*)(rdx + rcx);
00013e3f                          i_3 = i_8;
00013e3f                          i_8 -= 1;
00013e42                          *(uint64_t*)((char*)rcx + 8) = *(uint64_t*)(rdx + rcx + 8);
00013e46                          *(uint64_t*)rcx = r10_8;
00013e49                      } while (i_3 != 1);
00013e4b                      arg3 &= 0x1f;
00013e4f                      break;
00013e69                  }
00013e69                  
00013ef4                  do
00013ef4                  {
00013e6b                      int32_t j_5 = 0x20;
00013e82                      int32_t j_2;
00013e82                      
00013e82                      do
00013e82                      {
00013e70                          rcx -= 0x80;
00013e80                          j_2 = j_5;
00013e80                          j_5 -= 1;
00013e82                      } while (j_2 != 1);
00013e84                      rcx = &rcx[0x400];
00013e8b                      rax = 0x40;
00013ee4                      int32_t j_3;
00013ee4                      
00013ee4                      do
00013ee4                      {
00013e95                          int64_t r10_9 = *(uint64_t*)(rdx + rcx - 0x10);
00013e9a                          *(uint64_t*)((char*)rcx - 8) = *(uint64_t*)(rdx + rcx - 8);
00013e9f                          *(uint64_t*)((char*)rcx - 0x10) = r10_9;
00013ea9                          int64_t r10_10 = *(uint64_t*)(rdx + rcx - 0x20);
00013eae                          *(uint64_t*)((char*)rcx - 0x18) = *(uint64_t*)(rdx + rcx - 0x18);
00013eb3                          *(uint64_t*)((char*)rcx - 0x20) = r10_10;
00013eb8                          int64_t r9_11 = *(uint64_t*)(rdx + rcx - 0x28);
00013ebd                          int64_t r10_11 = *(uint64_t*)(rdx + rcx - 0x30);
00013ec2                          rcx -= 0x40;
00013ec6                          *(uint64_t*)((char*)rcx + 0x18) = r9_11;
00013ecb                          *(uint64_t*)((char*)rcx + 0x10) = r10_11;
00013ed5                          int64_t r10_12 = *(uint64_t*)(rdx + rcx);
00013ed9                          j_3 = (uint32_t)rax;
00013ed9                          rax = (uint64_t)((uint32_t)rax - 1);
00013edb                          *(uint64_t*)((char*)rcx + 8) = *(uint64_t*)(rdx + rcx + 8);
00013ee0                          *(uint64_t*)rcx = r10_12;
00013ee4                      } while (j_3 != 1);
00013ee6                      arg3 -= 0x1000;
00013ef4                  } while (arg3 >= 0x1000);
00013ef4                  
00013efa                  (uint8_t)__return_addr = (uint8_t)__return_addr;
00013eff                  continue;
00013dc1              }
00013dc1              
00013dca              uint64_t i_9 = arg3 >> 3;
00013dca              
00013dce              if (i_9)
00013dce              {
00013dde                  uint64_t i_4;
00013dde                  
00013dde                  do
00013dde                  {
00013dd0                      rcx -= 8;
00013dd8                      i_4 = i_9;
00013dd8                      i_9 -= 1;
00013ddb                      *(uint64_t*)rcx = *(uint64_t*)(rdx + rcx);
00013dde                  } while (i_4 != 1);
00013de0                  arg3 &= 7;
00013dce              }
00013d81          }
00013d81          
00013de7          if (arg3)
00013de7          {
00013dfb              int64_t i_5;
00013dfb              
00013dfb              do
00013dfb              {
00013df0                  rcx -= 1;
00013df3                  (uint8_t)rax = *(uint8_t*)(rdx + rcx);
00013df6                  i_5 = arg3;
00013df6                  arg3 -= 1;
00013df9                  *(uint8_t*)rcx = (uint8_t)rax;
00013dfb              } while (i_5 != 1);
00013de7          }
00013d78      }
00013d78      
00013dec      return result;
00013bd0  }

00013c4d                                         66 66 90                                                               ff.
00013c61     66 66 66 90 66 66 66 90 66 66 66 90 66 66 90 66 66 66 90 66 66 90                              fff.fff.fff.ff.fff.ff.
00013cb5                                                                 66 66 66 90 66 66 66 90 66 66 90                       fff.fff.ff.
00013cc0  66 90                                                                                            f.
00013d64              66 66 66 90 66 66 66 90 66 66 66 90 66 66 66 90 66 66 66 90                              fff.fff.fff.fff.fff.
00013ded                                         66 66 90                                                               ff.
00013e01     66 66 66 90 66 66 66 90 66 66 66 90 66 66 90 66 66 66 90 66 66 90                              fff.fff.fff.ff.fff.ff.
00013e54                                                              66 66 66 90 66 66 66 90 66 66 66 90                      fff.fff.fff.
00013e60  66 90                                                                                            f.
00013f04              cc cc cc cc cc cc cc cc                                                                  ........

00013f0c    void __GSHandlerCheckCommon(void* EstablisherFrame, struct _DISPATCHER_CONTEXT* DispatcherContext, struct _GS_HANDLER_DATA* GSHandlerData)

00013f0c  {
00013f18      void* EstablisherFrame_1 = EstablisherFrame;
00013f23      void* EstablisherFrame_2 = EstablisherFrame;
00013f23      
00013f26      if (*(uint8_t*)((char*)GSHandlerData->u + 0) & 4)
00013f38          EstablisherFrame_2 = ((int64_t)GSHandlerData->AlignedBaseOffset
00013f38              + EstablisherFrame) & (int64_t)-(GSHandlerData->Alignment);
00013f38      
00013f49      void* rcx_2 = (uint64_t)*(uint32_t*)(*(int64_t*)((char*)DispatcherContext + 0x10) + 8)
00013f49          + *(int64_t*)((char*)DispatcherContext + 8);
00013f49      
00013f51      if (*(uint8_t*)((char*)rcx_2 + 3) & 0xf)
00013f5c          EstablisherFrame_1 +=
00013f5c              (int64_t)((uint32_t)*(uint8_t*)((char*)rcx_2 + 3) & 0xfffffff0);
00013f5c      
00013f6a      /* tailcall */
00013f6a      return __security_check_cookie(EstablisherFrame_1 ^ *(uint64_t*)(
00013f6a          (int64_t)(*(uint32_t*)((char*)GSHandlerData->u + 0) & 0xfffffff8)
00013f6a          + EstablisherFrame_2));
00013f0c  }

00013f6f                                               cc cc cc cc cc cc cc cc cc                                         .........

00013f78    enum _EXCEPTION_DISPOSITION __GSHandlerCheck(struct _EXCEPTION_RECORD* ExceptionRecord, void* EstablisherFrame, struct _CONTEXT* ContextRecord, struct _DISPATCHER_CONTEXT* DispatcherContext)

00013f78  {
00013f86      __GSHandlerCheckCommon(EstablisherFrame, DispatcherContext, 
00013f86          *(int64_t*)((char*)DispatcherContext + 0x38));
00013f94      return 1;
00013f78  }

00013f95                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

00013fa0  char `string'::NW1950 DriverEntry Initializatio...[0x3d] = "NW1950 DriverEntry Initialization of NextWindow 1950 driver\n", 0

00013fdd                                                                                         cc cc cc                               ...

00013fe0  char `string'::pDevContext->BulkReadPipe is Wdf...[0x41] = "pDevContext->BulkReadPipe is WdfIoTargetStarted need to stop io\n", 0

00014021     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                   ...............

00014030  char `string'::pDevContext->IntReadPipe is WdfI...[0x40] = "pDevContext->IntReadPipe is WdfIoTargetStarted need to stop io\n", 0
00014070  wchar16 `string'::Queue Parameters[0x11] = "Queue Parameters", 0

00014092                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

000140a0  wchar16 `string'::ConsumerQueue[0xe] = "ConsumerQueue", 0

000140bc                                                                                      cc cc cc cc                              ....

000140c0  wchar16 `string'::MaxResponseLength[0x12] = "MaxResponseLength", 0

000140e4              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

000140f0  wchar16 `string'::NumPendingReads[0x10] = "NumPendingReads", 0
00014110  wchar16 `string'::BulkReset[0xa] = "BulkReset", 0

00014124              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

00014130  wchar16 `string'::UsePenDescriptor[0x11] = "UsePenDescriptor", 0

00014152                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

00014160  wchar16 `string'::NextWindow[0xc] = "NextWindow\x00", 0

00014178                                                                          cc cc cc cc cc cc cc cc                          ........

00014180  wchar16 `string'::NW Dev[0x8] = "NW Dev\x00", 0
00014190  wchar16 `string'::1231212[0x9] = "1231212\x00", 0
.text section ended  {0x11000-0x141a2}

.rdata section started  {0x15000-0x153d4}
00015000  int64_t (* const NWTransLibV:TransLibEnterWorkingState)() = TransLibEnterWorkingState
00015008  int64_t (* const NWTransLibV:TransLibProcessUserReport)() = TransLibProcessUserReport
00015010  int64_t (* const NWTransLibV:TransLibSetParsedTransfer)() = TransLibSetParsedTransfer
00015018  int64_t (* const NWTransLibV:TransLibGetThreadTimes)() = TransLibGetThreadTimes
00015020  int64_t (* const NWTransLibV:TransLibLeaveWorkingState)() = TransLibLeaveWorkingState
00015028  int64_t (* const NWTransLibV:TransLibProcessStreamSync)() = TransLibProcessStreamSync
00015030  int64_t (* const NWTransLibV:TransLibHardwareReadSync)() = TransLibHardwareReadSync
00015038  int64_t (* const NWTransLibV:TLConfigureTrace)() = TLConfigureTrace
00015040  int64_t (* const NWTransLibV:TLGetTraceBuffer)() = TLGetTraceBuffer
00015048  int64_t (* const NWTransLibV:TLGetTranslationMode)() = TLGetTranslationMode
00015050  int64_t (* const NWTransLibV:TLSetTranslationMode)() = TLSetTranslationMode
00015058  int64_t (* const NWTransLibV:TLDbgLogMsg)() = TLDbgLogMsg
00015060  int64_t (* const NWTransLibV:TransLibGetParsedTransfer)() = TransLibGetParsedTransfer
00015068  int64_t (* const NWTransLibV:TransLibInitialize)() = TransLibInitialize
00015070  int64_t (* const NWTransLibV:TransLibShutdown)() = TransLibShutdown
00015078  int64_t (* const NWTransLibV:TransLibGetMemoryUsage)() = TransLibGetMemoryUsage
00015080  int64_t (* const NWTransLibV:TransLibUpdateInputMode)() = TransLibUpdateInputMode

00015088  NWTransLibV_NULL_THUNK_DATA:
00015088                          00 00 00 00 00 00 00 00                                                          ........

00015090  int64_t (* const WDFLDR:WdfVersionBind)() = WdfVersionBind
00015098  int64_t (* const WDFLDR:WdfVersionBindClass)() = WdfVersionBindClass
000150a0  int64_t (* const WDFLDR:WdfVersionUnbindClass)() = WdfVersionUnbindClass
000150a8  int64_t (* const WDFLDR:WdfVersionUnbind)() = WdfVersionUnbind

000150b0  WDFLDR_NULL_THUNK_DATA:
000150b0                                                  00 00 00 00 00 00 00 00                                          ........

000150b8  void (* const ntoskrnl:KeBugCheckEx)(enum BUGCHECK_ERROR BugCheckCode, uint64_t BugCheckParameter1, uint64_t BugCheckParameter2, uint64_t BugCheckParameter3, uint64_t BugCheckParameter4) = KeBugCheckEx
000150c0  NTSTATUS (* const ntoskrnl:KeDelayExecutionThread)(char WaitMode, BOOLEAN Alertable, int64_t* Interval) = KeDelayExecutionThread
000150c8  int32_t (* const ntoskrnl:KeSetEvent)(KEVENT* Event, int32_t Increment, BOOLEAN Wait) = KeSetEvent
000150d0  void (* const ntoskrnl:KeClearEvent)(KEVENT* Event) = KeClearEvent
000150d8  uint32_t (* const ntoskrnl:DbgPrint)(char* Format, ...) = DbgPrint
000150e0  void (* const ntoskrnl:RtlInitUnicodeString)(UNICODE_STRING* DestinationString, wchar16* SourceString) = RtlInitUnicodeString
000150e8  void (* const ntoskrnl:RtlCopyUnicodeString)(UNICODE_STRING* DestinationString, UNICODE_STRING* SourceString) = RtlCopyUnicodeString
000150f0  int32_t (* const ntoskrnl:KeReadStateEvent)(KEVENT* Event) = KeReadStateEvent
000150f8  NTSTATUS (* const ntoskrnl:RtlGetVersion)(OSVERSIONINFOW* lpVersionInformation) = RtlGetVersion
00015100  void (* const ntoskrnl:KeInitializeEvent)(KEVENT* Event, EVENT_TYPE Type, BOOLEAN State) = KeInitializeEvent
00015108  void (* const ntoskrnl:ExFreePoolWithTag)(void* P, uint32_t Tag) = ExFreePoolWithTag
00015110  void* (* const ntoskrnl:ExAllocatePoolWithTag)(POOL_TYPE PoolType, uint64_t NumberOfBytes, uint32_t Tag) = ExAllocatePoolWithTag

00015118  ntoskrnl_NULL_THUNK_DATA:
00015118                                                                          00 00 00 00 00 00 00 00                          ........
00015120  struct Debug_Directory_Table __debug_directory_entries[0x1] = 
00015120  {
00015120      [0x0] = 
00015120      {
00015120          uint32_t characteristics = 0x0
00015124          uint32_t timeDateStamp = 0x510f14d5
00015128          uint16_t majorVersion = 0x0
0001512a          uint16_t minorVersion = 0x0
0001512c          enum type = IMAGE_DEBUG_TYPE_CODEVIEW
00015130          uint32_t sizeOfData = 0x5a
00015134          uint32_t addressOfRawData = 0x51bc
00015138          uint32_t pointerToRawData = 0x37bc
0001513c      }
0001513c  }

0001513c                                                                                      00 00 00 00                              ....

00015140  wchar16 `string'::KmdfLibrary[0xc] = "KmdfLibrary", 0
00015158  char `string'::NW_WORKITEM_CONTEXT[0x14] = "NW_WORKITEM_CONTEXT", 0

0001516c                                      00 00 00 00                                                              ....

00015170  char `string'::NW_REQUEST_CONTEXT[0x13] = "NW_REQUEST_CONTEXT", 0

00015183           00 00 00 00 00                                                                             .....

00015188  char `string'::NW_DEVICE_CONTEXT[0x12] = "NW_DEVICE_CONTEXT", 0

0001519a                                                                                00 00 00 00 00 00                            ......

000151a0  struct _HID_DESCRIPTOR NWHIDDeviceDescriptor = 
000151a0  {
000151a0  09 21 00 01 00 01 22 c3 01                                                                       .!...."..
000151a9  }

000151a9                             00 00 00 00 00 00 00                                                           .......

000151b0  struct _HID_DESCRIPTOR NWHIDDeviceDescriptorWithPen = 
000151b0  {
000151b0                                                  09 21 00 01 00 01 22 04 02                                       .!...."..
000151b9  }

000151b9                                                                             00 00 00                                       ...

000151bc  uint32_t debugInfoType = 'RSDS'
000151c0  uint8_t PDBGuid[0x10] = 
000151c0  {
000151c0      [0x0] =  0xdc
000151c1      [0x1] =  0xb0
000151c2      [0x2] =  0xe5
000151c3      [0x3] =  0xc5
000151c4      [0x4] =  0x32
000151c5      [0x5] =  0x8b
000151c6      [0x6] =  0x5d
000151c7      [0x7] =  0x4a
000151c8      [0x8] =  0xac
000151c9      [0x9] =  0xcf
000151ca      [0xa] =  0x5e
000151cb      [0xb] =  0xe8
000151cc      [0xc] =  0x68
000151cd      [0xd] =  0x49
000151ce      [0xe] =  0xad
000151cf      [0xf] =  0x41
000151d0  }
000151d0  uint32_t PDBAge = 0x1
000151d4  char PDBFileName[0x42] = "c:\\development_work\\csf_release_hp\\driver\\bin\\amd64\\NWVoltron.pdb", 0

00015216                                                                    00 00                                                ..

00015218  struct UNWIND_INFO data_15218 = 
00015218  {
00015218      uint8_t VersionAndFlag = 0x1
00015219      uint8_t SizeOfProlog = 0x4
0001521a      uint8_t CountOfUnwindCodes = 0x1
0001521b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0001521c  }
0001521c  uint16_t data_1521c[0x1] = 
0001521c  {
0001521c      [0x0] =  0x6204
0001521e  }

0001521e                                                                                            00 00                                ..

00015220  struct UNWIND_INFO data_15220 = 
00015220  {
00015220      uint8_t VersionAndFlag = 0x1
00015221      uint8_t SizeOfProlog = 0x14
00015222      uint8_t CountOfUnwindCodes = 0x8
00015223      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015224  }
00015224  uint16_t data_15224[0x8] = 
00015224  {
00015224      [0x0] =  0x6414
00015226      [0x1] =  0x0008
00015228      [0x2] =  0x5414
0001522a      [0x3] =  0x0007
0001522c      [0x4] =  0x3414
0001522e      [0x5] =  0x0006
00015230      [0x6] =  0x3214
00015232      [0x7] =  0x7010
00015234  }
00015234  struct UNWIND_INFO data_15234 = 
00015234  {
00015234      uint8_t VersionAndFlag = 0x1
00015235      uint8_t SizeOfProlog = 0xa
00015236      uint8_t CountOfUnwindCodes = 0x4
00015237      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015238  }
00015238  uint16_t data_15238[0x4] = 
00015238  {
00015238      [0x0] =  0x340a
0001523a      [0x1] =  0x0006
0001523c      [0x2] =  0x320a
0001523e      [0x3] =  0x7006
00015240  }
00015240  struct UNWIND_INFO data_15240 = 
00015240  {
00015240      uint8_t VersionAndFlag = 0x1
00015241      uint8_t SizeOfProlog = 0xf
00015242      uint8_t CountOfUnwindCodes = 0x6
00015243      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015244  }
00015244  uint16_t data_15244[0x6] = 
00015244  {
00015244      [0x0] =  0x640f
00015246      [0x1] =  0x000a
00015248      [0x2] =  0x340f
0001524a      [0x3] =  0x0009
0001524c      [0x4] =  0x520f
0001524e      [0x5] =  0x700b
00015250  }
00015250  struct UNWIND_INFO data_15250 = 
00015250  {
00015250      uint8_t VersionAndFlag = 0x1
00015251      uint8_t SizeOfProlog = 0x14
00015252      uint8_t CountOfUnwindCodes = 0x8
00015253      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015254  }
00015254  uint16_t data_15254[0x8] = 
00015254  {
00015254      [0x0] =  0x6414
00015256      [0x1] =  0x000e
00015258      [0x2] =  0x5414
0001525a      [0x3] =  0x000d
0001525c      [0x4] =  0x3414
0001525e      [0x5] =  0x000c
00015260      [0x6] =  0x9214
00015262      [0x7] =  0x7010
00015264  }
00015264  struct UNWIND_INFO data_15264 = 
00015264  {
00015264      uint8_t VersionAndFlag = 0x1
00015265      uint8_t SizeOfProlog = 0x10
00015266      uint8_t CountOfUnwindCodes = 0x6
00015267      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015268  }
00015268  uint16_t data_15268[0x6] = 
00015268  {
00015268      [0x0] =  0x6410
0001526a      [0x1] =  0x000f
0001526c      [0x2] =  0x3410
0001526e      [0x3] =  0x000e
00015270      [0x4] =  0xb210
00015272      [0x5] =  0x700c
00015274  }
00015274  struct UNWIND_INFO data_15274 = 
00015274  {
00015274      uint8_t VersionAndFlag = 0x1
00015275      uint8_t SizeOfProlog = 0x10
00015276      uint8_t CountOfUnwindCodes = 0x6
00015277      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015278  }
00015278  uint16_t data_15278[0x6] = 
00015278  {
00015278      [0x0] =  0x6410
0001527a      [0x1] =  0x000c
0001527c      [0x2] =  0x3410
0001527e      [0x3] =  0x000b
00015280      [0x4] =  0x7210
00015282      [0x5] =  0x700c
00015284  }
00015284  struct UNWIND_INFO data_15284 = 
00015284  {
00015284      uint8_t VersionAndFlag = 0x1
00015285      uint8_t SizeOfProlog = 0x14
00015286      uint8_t CountOfUnwindCodes = 0x8
00015287      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015288  }
00015288  uint16_t data_15288[0x8] = 
00015288  {
00015288      [0x0] =  0x6414
0001528a      [0x1] =  0x000b
0001528c      [0x2] =  0x5414
0001528e      [0x3] =  0x000a
00015290      [0x4] =  0x3414
00015292      [0x5] =  0x0008
00015294      [0x6] =  0x5214
00015296      [0x7] =  0x7010
00015298  }
00015298  struct UNWIND_INFO data_15298 = 
00015298  {
00015298      uint8_t VersionAndFlag = 0x1
00015299      uint8_t SizeOfProlog = 0xe
0001529a      uint8_t CountOfUnwindCodes = 0x6
0001529b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0001529c  }
0001529c  uint16_t data_1529c[0x6] = 
0001529c  {
0001529c      [0x0] =  0x340e
0001529e      [0x1] =  0x0010
000152a0      [0x2] =  0xb20e
000152a2      [0x3] =  0x700a
000152a4      [0x4] =  0x6009
000152a6      [0x5] =  0x5008
000152a8  }
000152a8  struct UNWIND_INFO data_152a8 = 
000152a8  {
000152a8      uint8_t VersionAndFlag = 0x1
000152a9      uint8_t SizeOfProlog = 0xa
000152aa      uint8_t CountOfUnwindCodes = 0x4
000152ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000152ac  }
000152ac  uint16_t data_152ac[0x4] = 
000152ac  {
000152ac      [0x0] =  0x340a
000152ae      [0x1] =  0x0007
000152b0      [0x2] =  0x320a
000152b2      [0x3] =  0x7006
000152b4  }
000152b4  struct UNWIND_INFO data_152b4 = 
000152b4  {
000152b4      uint8_t VersionAndFlag = 0x1
000152b5      uint8_t SizeOfProlog = 0xf
000152b6      uint8_t CountOfUnwindCodes = 0x6
000152b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000152b8  }
000152b8  uint16_t data_152b8[0x6] = 
000152b8  {
000152b8      [0x0] =  0x640f
000152ba      [0x1] =  0x0007
000152bc      [0x2] =  0x340f
000152be      [0x3] =  0x0006
000152c0      [0x4] =  0x320f
000152c2      [0x5] =  0x700b
000152c4  }
000152c4  struct UNWIND_INFO data_152c4 = 
000152c4  {
000152c4      uint8_t VersionAndFlag = 0x19
000152c5      uint8_t SizeOfProlog = 0x2b
000152c6      uint8_t CountOfUnwindCodes = 0xb
000152c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000152c8  }
000152c8  uint16_t data_152c8[0xb] = 
000152c8  {
000152c8      [0x0] =  0x5419
000152ca      [0x1] =  0x0027
000152cc      [0x2] =  0x3419
000152ce      [0x3] =  0x0026
000152d0      [0x4] =  0x0119
000152d2      [0x5] =  0x001e
000152d4      [0x6] =  0xe012
000152d6      [0x7] =  0xd010
000152d8      [0x8] =  0xc00e
000152da      [0x9] =  0x700c
000152dc      [0xa] =  0x600b
000152de  }

000152de                                                                                            00 00                                ..

000152e0  uint32_t data_152e0 = 0x3f78

000152e4              e0 00 00 00                                                                              ....

000152e8  struct UNWIND_INFO data_152e8 = 
000152e8  {
000152e8      uint8_t VersionAndFlag = 0x1
000152e9      uint8_t SizeOfProlog = 0xd
000152ea      uint8_t CountOfUnwindCodes = 0x6
000152eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000152ec  }
000152ec  uint16_t data_152ec[0x6] = 
000152ec  {
000152ec      [0x0] =  0x340d
000152ee      [0x1] =  0x000a
000152f0      [0x2] =  0x520d
000152f2      [0x3] =  0xc009
000152f4      [0x4] =  0x7007
000152f6      [0x5] =  0x6006
000152f8  }
000152f8  struct UNWIND_INFO data_152f8 = 
000152f8  {
000152f8      uint8_t VersionAndFlag = 0x1
000152f9      uint8_t SizeOfProlog = 0xf
000152fa      uint8_t CountOfUnwindCodes = 0x6
000152fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000152fc  }
000152fc  uint16_t data_152fc[0x6] = 
000152fc  {
000152fc      [0x0] =  0x640f
000152fe      [0x1] =  0x000a
00015300      [0x2] =  0x340f
00015302      [0x3] =  0x0008
00015304      [0x4] =  0x520f
00015306      [0x5] =  0x700b
00015308  }
00015308  struct UNWIND_INFO data_15308 = 
00015308  {
00015308      uint8_t VersionAndFlag = 0x1
00015309      uint8_t SizeOfProlog = 0xf
0001530a      uint8_t CountOfUnwindCodes = 0x6
0001530b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0001530c  }
0001530c  uint16_t data_1530c[0x6] = 
0001530c  {
0001530c      [0x0] =  0x640f
0001530e      [0x1] =  0x0009
00015310      [0x2] =  0x340f
00015312      [0x3] =  0x0008
00015314      [0x4] =  0x520f
00015316      [0x5] =  0x700b
00015318  }
00015318  struct UNWIND_INFO data_15318 = 
00015318  {
00015318      uint8_t VersionAndFlag = 0x19
00015319      uint8_t SizeOfProlog = 0x1d
0001531a      uint8_t CountOfUnwindCodes = 0x5
0001531b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0001531c  }
0001531c  uint16_t data_1531c[0x5] = 
0001531c  {
0001531c      [0x0] =  0x010b
0001531e      [0x1] =  0x0016
00015320      [0x2] =  0x7004
00015322      [0x3] =  0x6003
00015324      [0x4] =  0x3002
00015326  }

00015326                    00 00                                                                                ..

00015328  uint32_t data_15328 = 0x3f78

0001532c                                      a0 00 00 00                                                              ....

00015330  struct UNWIND_INFO data_15330 = 
00015330  {
00015330      uint8_t VersionAndFlag = 0x1
00015331      uint8_t SizeOfProlog = 0x6
00015332      uint8_t CountOfUnwindCodes = 0x2
00015333      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015334  }
00015334  uint16_t data_15334[0x2] = 
00015334  {
00015334      [0x0] =  0x3206
00015336      [0x1] =  0x3002
00015338  }
00015338  struct UNWIND_INFO data_15338 = 
00015338  {
00015338      uint8_t VersionAndFlag = 0x1
00015339      uint8_t SizeOfProlog = 0x1c
0001533a      uint8_t CountOfUnwindCodes = 0xc
0001533b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0001533c  }
0001533c  uint16_t data_1533c[0xc] = 
0001533c  {
0001533c      [0x0] =  0x641c
0001533e      [0x1] =  0x0014
00015340      [0x2] =  0x541c
00015342      [0x3] =  0x0013
00015344      [0x4] =  0x341c
00015346      [0x5] =  0x0012
00015348      [0x6] =  0xb21c
0001534a      [0x7] =  0xf018
0001534c      [0x8] =  0xe016
0001534e      [0x9] =  0xd014
00015350      [0xa] =  0xc012
00015352      [0xb] =  0x7010
00015354  }
00015354  struct UNWIND_INFO data_15354 = 
00015354  {
00015354      uint8_t VersionAndFlag = 0x1
00015355      uint8_t SizeOfProlog = 0xa
00015356      uint8_t CountOfUnwindCodes = 0x4
00015357      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015358  }
00015358  uint16_t data_15358[0x4] = 
00015358  {
00015358      [0x0] =  0x340a
0001535a      [0x1] =  0x000a
0001535c      [0x2] =  0x720a
0001535e      [0x3] =  0x7006
00015360  }
00015360  struct UNWIND_INFO data_15360 = 
00015360  {
00015360      uint8_t VersionAndFlag = 0x1
00015361      uint8_t SizeOfProlog = 0x19
00015362      uint8_t CountOfUnwindCodes = 0xa
00015363      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015364  }
00015364  uint16_t data_15364[0xa] = 
00015364  {
00015364      [0x0] =  0x7419
00015366      [0x1] =  0x000f
00015368      [0x2] =  0x6419
0001536a      [0x3] =  0x000e
0001536c      [0x4] =  0x5419
0001536e      [0x5] =  0x000d
00015370      [0x6] =  0x3419
00015372      [0x7] =  0x000c
00015374      [0x8] =  0x9219
00015376      [0x9] =  0xc015
00015378  }
00015378  struct UNWIND_INFO data_15378 = 
00015378  {
00015378      uint8_t VersionAndFlag = 0x1
00015379      uint8_t SizeOfProlog = 0x6
0001537a      uint8_t CountOfUnwindCodes = 0x2
0001537b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
0001537c  }
0001537c  uint16_t data_1537c[0x2] = 
0001537c  {
0001537c      [0x0] =  0xd206
0001537e      [0x1] =  0x3002
00015380  }
00015380  struct UNWIND_INFO data_15380 = 
00015380  {
00015380      uint8_t VersionAndFlag = 0x1
00015381      uint8_t SizeOfProlog = 0x1b
00015382      uint8_t CountOfUnwindCodes = 0xb
00015383      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
00015384  }
00015384  uint16_t data_15384[0xb] = 
00015384  {
00015384      [0x0] =  0x641b
00015386      [0x1] =  0x001c
00015388      [0x2] =  0x541b
0001538a      [0x3] =  0x001b
0001538c      [0x4] =  0x341b
0001538e      [0x5] =  0x001a
00015390      [0x6] =  0x011b
00015392      [0x7] =  0x0016
00015394      [0x8] =  0xd014
00015396      [0x9] =  0xc012
00015398      [0xa] =  0x7010
0001539a  }

0001539a                                                                                00 00                                        ..

0001539c  struct UNWIND_INFO data_1539c = 
0001539c  {
0001539c      uint8_t VersionAndFlag = 0x19
0001539d      uint8_t SizeOfProlog = 0x2e
0001539e      uint8_t CountOfUnwindCodes = 0xb
0001539f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000153a0  }
000153a0  uint16_t data_153a0[0xb] = 
000153a0  {
000153a0      [0x0] =  0x741c
000153a2      [0x1] =  0x007d
000153a4      [0x2] =  0x541c
000153a6      [0x3] =  0x007c
000153a8      [0x4] =  0x341c
000153aa      [0x5] =  0x007a
000153ac      [0x6] =  0x011c
000153ae      [0x7] =  0x0076
000153b0      [0x8] =  0xe015
000153b2      [0x9] =  0xd013
000153b4      [0xa] =  0xc011
000153b6  }

000153b6                                                                    00 00                                                ..

000153b8  uint32_t data_153b8 = 0x3f78

000153bc                                                                                      a0 03 00 00                              ....

000153c0  struct UNWIND_INFO data_153c0 = 
000153c0  {
000153c0      uint8_t VersionAndFlag = 0x1
000153c1      uint8_t SizeOfProlog = 0xa
000153c2      uint8_t CountOfUnwindCodes = 0x4
000153c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000153c4  }
000153c4  uint16_t data_153c4[0x4] = 
000153c4  {
000153c4      [0x0] =  0x340a
000153c6      [0x1] =  0x000c
000153c8      [0x2] =  0x920a
000153ca      [0x3] =  0x7006
000153cc  }
000153cc  struct UNWIND_INFO data_153cc = 
000153cc  {
000153cc      uint8_t VersionAndFlag = 0x1
000153cd      uint8_t SizeOfProlog = 0x4
000153ce      uint8_t CountOfUnwindCodes = 0x1
000153cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
000153d0  }
000153d0  uint16_t data_153d0[0x1] = 
000153d0  {
000153d0      [0x0] =  0x4204
000153d2  }

000153d2                                                        00 00                                                        ..
.rdata section ended  {0x15000-0x153d4}

.data section started  {0x16000-0x17310}
00016000  struct _PATCH_BUFFER HotPatchBuffer = 
00016000  {
00016000      uint16_t PointerIndex = 0x0
00016002      uint16_t Fill1 = 0x0
00016004      uint16_t BufferSize = 0x100
00016006      uint16_t Fill2 = 0x0
00016008      uint64_t Buffer[0x1f] = 
00016008      {
00016008          [0x00] =  0x0000000000000000
00016010          [0x01] =  0x0000000000000000
00016018          [0x02] =  0x0000000000000000
00016020          [0x03] =  0x0000000000000000
00016028          [0x04] =  0x0000000000000000
00016030          [0x05] =  0x0000000000000000
00016038          [0x06] =  0x0000000000000000
00016040          [0x07] =  0x0000000000000000
00016048          [0x08] =  0x0000000000000000
00016050          [0x09] =  0x0000000000000000
00016058          [0x0a] =  0x0000000000000000
00016060          [0x0b] =  0x0000000000000000
00016068          [0x0c] =  0x0000000000000000
00016070          [0x0d] =  0x0000000000000000
00016078          [0x0e] =  0x0000000000000000
00016080          [0x0f] =  0x0000000000000000
00016088          [0x10] =  0x0000000000000000
00016090          [0x11] =  0x0000000000000000
00016098          [0x12] =  0x0000000000000000
000160a0          [0x13] =  0x0000000000000000
000160a8          [0x14] =  0x0000000000000000
000160b0          [0x15] =  0x0000000000000000
000160b8          [0x16] =  0x0000000000000000
000160c0          [0x17] =  0x0000000000000000
000160c8          [0x18] =  0x0000000000000000
000160d0          [0x19] =  0x0000000000000000
000160d8          [0x1a] =  0x0000000000000000
000160e0          [0x1b] =  0x0000000000000000
000160e8          [0x1c] =  0x0000000000000000
000160f0          [0x1d] =  0x0000000000000000
000160f8          [0x1e] =  0x0000000000000000
00016100      }
00016100  }
00016100  uint64_t __security_cookie = 0x2b992ddfa232
00016108  uint64_t __security_cookie_complement = 0xffffd466d2205dcd
00016110  struct _WDF_BIND_INFO WdfBindInfo = 
00016110  {
00016110      uint32_t Size = 0x30
00016118      wchar16* Component = `string'::KmdfLibrary {u"KmdfLibrary"}
00016120      struct _WDF_VERSION Version = 
00016120      {
00016120          uint32_t Major = 0x1
00016124          uint32_t Minor = 0x9
00016128          uint32_t Build = 0x1db0
0001612c      }
0001612c      uint32_t FuncCount = 0x18c
00016130      void (** FuncTable)() = WdfFunctions
00016138      struct _LIBRARY_MODULE* Module = 0x0
00016140  }
00016140  struct _WDF_OBJECT_CONTEXT_TYPE_INFO _WDF_NW_DEVICE_CONTEXT_TYPE_INFO = 
00016140  {
00016140      uint32_t Size = 0x28
00016148      char* ContextName = `string'::NW_DEVICE_CONTEXT {"NW_DEVICE_CONTEXT"}
00016150      uint64_t ContextSize = 0xd0
00016158      struct _WDF_OBJECT_CONTEXT_TYPE_INFO const* UniqueType = _WDF_NW_DEVICE_CONTEXT_TYPE_INFO
00016160      struct _WDF_OBJECT_CONTEXT_TYPE_INFO const* (* EvtDriverGetUniqueContextType)() = 0x0
00016168  }
00016168  struct _WDF_OBJECT_CONTEXT_TYPE_INFO _WDF_NW_REQUEST_CONTEXT_TYPE_INFO = 
00016168  {
00016168      uint32_t Size = 0x28
00016170      char* ContextName = `string'::NW_REQUEST_CONTEXT {"NW_REQUEST_CONTEXT"}
00016178      uint64_t ContextSize = 0x4
00016180      struct _WDF_OBJECT_CONTEXT_TYPE_INFO const* UniqueType = _WDF_NW_REQUEST_CONTEXT_TYPE_INFO
00016188      struct _WDF_OBJECT_CONTEXT_TYPE_INFO const* (* EvtDriverGetUniqueContextType)() = 0x0
00016190  }
00016190  struct _WDF_OBJECT_CONTEXT_TYPE_INFO _WDF_NW_WORKITEM_CONTEXT_TYPE_INFO = 
00016190  {
00016190      uint32_t Size = 0x28
00016198      char* ContextName = `string'::NW_WORKITEM_CONTEXT {"NW_WORKITEM_CONTEXT"}
000161a0      uint64_t ContextSize = 0x10
000161a8      struct _WDF_OBJECT_CONTEXT_TYPE_INFO const* UniqueType = _WDF_NW_WORKITEM_CONTEXT_TYPE_INFO
000161b0      struct _WDF_OBJECT_CONTEXT_TYPE_INFO const* (* EvtDriverGetUniqueContextType)() = 0x0
000161b8  }

000161b8                                                                          00 00 00 00 00 00 00 00                          ........
000161c0  uint8_t HIDInputDescriptor[0x14f] = 
000161c0  {
000161c0      [0x000] =  0x05
000161c1      [0x001] =  0x0d
000161c2      [0x002] =  0x09
000161c3      [0x003] =  0x04
000161c4      [0x004] =  0xa1
000161c5      [0x005] =  0x01
000161c6      [0x006] =  0x85
000161c7      [0x007] =  0x01
000161c8      [0x008] =  0x09
000161c9      [0x009] =  0x22
000161ca      [0x00a] =  0xa1
000161cb      [0x00b] =  0x02
000161cc      [0x00c] =  0x09
000161cd      [0x00d] =  0x42
000161ce      [0x00e] =  0x15
000161cf      [0x00f] =  0x00
000161d0      [0x010] =  0x25
000161d1      [0x011] =  0x01
000161d2      [0x012] =  0x75
000161d3      [0x013] =  0x01
000161d4      [0x014] =  0x95
000161d5      [0x015] =  0x01
000161d6      [0x016] =  0x81
000161d7      [0x017] =  0x02
000161d8      [0x018] =  0x09
000161d9      [0x019] =  0x32
000161da      [0x01a] =  0x81
000161db      [0x01b] =  0x02
000161dc      [0x01c] =  0x09
000161dd      [0x01d] =  0x47
000161de      [0x01e] =  0x81
000161df      [0x01f] =  0x02
000161e0      [0x020] =  0x95
000161e1      [0x021] =  0x05
000161e2      [0x022] =  0x81
000161e3      [0x023] =  0x03
000161e4      [0x024] =  0x75
000161e5      [0x025] =  0x08
000161e6      [0x026] =  0x09
000161e7      [0x027] =  0x51
000161e8      [0x028] =  0x95
000161e9      [0x029] =  0x01
000161ea      [0x02a] =  0x81
000161eb      [0x02b] =  0x02
000161ec      [0x02c] =  0x05
000161ed      [0x02d] =  0x01
000161ee      [0x02e] =  0x26
000161ef      [0x02f] =  0xff
000161f0      [0x030] =  0x7f
000161f1      [0x031] =  0x75
000161f2      [0x032] =  0x10
000161f3      [0x033] =  0x55
000161f4      [0x034] =  0x0f
000161f5      [0x035] =  0x65
000161f6      [0x036] =  0x11
000161f7      [0x037] =  0x09
000161f8      [0x038] =  0x30
000161f9      [0x039] =  0x35
000161fa      [0x03a] =  0x00
000161fb      [0x03b] =  0x46
000161fc      [0x03c] =  0xfe
000161fd      [0x03d] =  0x01
000161fe      [0x03e] =  0x81
000161ff      [0x03f] =  0x02
00016200      [0x040] =  0x09
00016201      [0x041] =  0x31
00016202      [0x042] =  0x46
00016203      [0x043] =  0x1d
00016204      [0x044] =  0x01
00016205      [0x045] =  0x81
00016206      [0x046] =  0x02
00016207      [0x047] =  0x05
00016208      [0x048] =  0x0d
00016209      [0x049] =  0x09
0001620a      [0x04a] =  0x48
0001620b      [0x04b] =  0x81
0001620c      [0x04c] =  0x02
0001620d      [0x04d] =  0x09
0001620e      [0x04e] =  0x49
0001620f      [0x04f] =  0x81
00016210      [0x050] =  0x02
00016211      [0x051] =  0xc0
00016212      [0x052] =  0xa1
00016213      [0x053] =  0x02
00016214      [0x054] =  0x05
00016215      [0x055] =  0x0d
00016216      [0x056] =  0x09
00016217      [0x057] =  0x42
00016218      [0x058] =  0x15
00016219      [0x059] =  0x00
0001621a      [0x05a] =  0x25
0001621b      [0x05b] =  0x01
0001621c      [0x05c] =  0x75
0001621d      [0x05d] =  0x01
0001621e      [0x05e] =  0x95
0001621f      [0x05f] =  0x01
00016220      [0x060] =  0x81
00016221      [0x061] =  0x02
00016222      [0x062] =  0x09
00016223      [0x063] =  0x32
00016224      [0x064] =  0x81
00016225      [0x065] =  0x02
00016226      [0x066] =  0x09
00016227      [0x067] =  0x47
00016228      [0x068] =  0x81
00016229      [0x069] =  0x02
0001622a      [0x06a] =  0x95
0001622b      [0x06b] =  0x05
0001622c      [0x06c] =  0x81
0001622d      [0x06d] =  0x03
0001622e      [0x06e] =  0x75
0001622f      [0x06f] =  0x08
00016230      [0x070] =  0x09
00016231      [0x071] =  0x51
00016232      [0x072] =  0x95
00016233      [0x073] =  0x01
00016234      [0x074] =  0x81
00016235      [0x075] =  0x02
00016236      [0x076] =  0x05
00016237      [0x077] =  0x01
00016238      [0x078] =  0x26
00016239      [0x079] =  0xff
0001623a      [0x07a] =  0x7f
0001623b      [0x07b] =  0x75
0001623c      [0x07c] =  0x10
0001623d      [0x07d] =  0x55
0001623e      [0x07e] =  0x0f
0001623f      [0x07f] =  0x65
00016240      [0x080] =  0x11
00016241      [0x081] =  0x09
00016242      [0x082] =  0x30
00016243      [0x083] =  0x35
00016244      [0x084] =  0x00
00016245      [0x085] =  0x46
00016246      [0x086] =  0xfe
00016247      [0x087] =  0x01
00016248      [0x088] =  0x81
00016249      [0x089] =  0x02
0001624a      [0x08a] =  0x09
0001624b      [0x08b] =  0x31
0001624c      [0x08c] =  0x46
0001624d      [0x08d] =  0x1d
0001624e      [0x08e] =  0x01
0001624f      [0x08f] =  0x81
00016250      [0x090] =  0x02
00016251      [0x091] =  0x05
00016252      [0x092] =  0x0d
00016253      [0x093] =  0x09
00016254      [0x094] =  0x48
00016255      [0x095] =  0x81
00016256      [0x096] =  0x02
00016257      [0x097] =  0x09
00016258      [0x098] =  0x49
00016259      [0x099] =  0x81
0001625a      [0x09a] =  0x02
0001625b      [0x09b] =  0xc0
0001625c      [0x09c] =  0x05
0001625d      [0x09d] =  0x0d
0001625e      [0x09e] =  0x09
0001625f      [0x09f] =  0x54
00016260      [0x0a0] =  0x95
00016261      [0x0a1] =  0x01
00016262      [0x0a2] =  0x75
00016263      [0x0a3] =  0x08
00016264      [0x0a4] =  0x81
00016265      [0x0a5] =  0x02
00016266      [0x0a6] =  0x09
00016267      [0x0a7] =  0x55
00016268      [0x0a8] =  0xb1
00016269      [0x0a9] =  0x02
0001626a      [0x0aa] =  0xc0
0001626b      [0x0ab] =  0x09
0001626c      [0x0ac] =  0x0e
0001626d      [0x0ad] =  0xa1
0001626e      [0x0ae] =  0x01
0001626f      [0x0af] =  0x85
00016270      [0x0b0] =  0x02
00016271      [0x0b1] =  0x09
00016272      [0x0b2] =  0x22
00016273      [0x0b3] =  0xa1
00016274      [0x0b4] =  0x00
00016275      [0x0b5] =  0x09
00016276      [0x0b6] =  0x52
00016277      [0x0b7] =  0x09
00016278      [0x0b8] =  0x53
00016279      [0x0b9] =  0x15
0001627a      [0x0ba] =  0x00
0001627b      [0x0bb] =  0x25
0001627c      [0x0bc] =  0x0a
0001627d      [0x0bd] =  0x75
0001627e      [0x0be] =  0x08
0001627f      [0x0bf] =  0x95
00016280      [0x0c0] =  0x02
00016281      [0x0c1] =  0xb1
00016282      [0x0c2] =  0x02
00016283      [0x0c3] =  0xc0
00016284      [0x0c4] =  0xc0
00016285      [0x0c5] =  0x05
00016286      [0x0c6] =  0x01
00016287      [0x0c7] =  0x09
00016288      [0x0c8] =  0x02
00016289      [0x0c9] =  0xa1
0001628a      [0x0ca] =  0x01
0001628b      [0x0cb] =  0x85
0001628c      [0x0cc] =  0x03
0001628d      [0x0cd] =  0x09
0001628e      [0x0ce] =  0x01
0001628f      [0x0cf] =  0xa1
00016290      [0x0d0] =  0x00
00016291      [0x0d1] =  0x05
00016292      [0x0d2] =  0x09
00016293      [0x0d3] =  0x19
00016294      [0x0d4] =  0x01
00016295      [0x0d5] =  0x29
00016296      [0x0d6] =  0x02
00016297      [0x0d7] =  0x15
00016298      [0x0d8] =  0x00
00016299      [0x0d9] =  0x25
0001629a      [0x0da] =  0x01
0001629b      [0x0db] =  0x75
0001629c      [0x0dc] =  0x01
0001629d      [0x0dd] =  0x95
0001629e      [0x0de] =  0x02
0001629f      [0x0df] =  0x81
000162a0      [0x0e0] =  0x02
000162a1      [0x0e1] =  0x95
000162a2      [0x0e2] =  0x06
000162a3      [0x0e3] =  0x81
000162a4      [0x0e4] =  0x03
000162a5      [0x0e5] =  0x05
000162a6      [0x0e6] =  0x01
000162a7      [0x0e7] =  0x26
000162a8      [0x0e8] =  0xff
000162a9      [0x0e9] =  0x7f
000162aa      [0x0ea] =  0x75
000162ab      [0x0eb] =  0x10
000162ac      [0x0ec] =  0x95
000162ad      [0x0ed] =  0x01
000162ae      [0x0ee] =  0x55
000162af      [0x0ef] =  0x0f
000162b0      [0x0f0] =  0x65
000162b1      [0x0f1] =  0x11
000162b2      [0x0f2] =  0x35
000162b3      [0x0f3] =  0x00
000162b4      [0x0f4] =  0x45
000162b5      [0x0f5] =  0x00
000162b6      [0x0f6] =  0x09
000162b7      [0x0f7] =  0x30
000162b8      [0x0f8] =  0x81
000162b9      [0x0f9] =  0x02
000162ba      [0x0fa] =  0x09
000162bb      [0x0fb] =  0x31
000162bc      [0x0fc] =  0x81
000162bd      [0x0fd] =  0x02
000162be      [0x0fe] =  0x05
000162bf      [0x0ff] =  0x01
000162c0      [0x100] =  0x09
000162c1      [0x101] =  0x38
000162c2      [0x102] =  0x15
000162c3      [0x103] =  0x81
000162c4      [0x104] =  0x25
000162c5      [0x105] =  0x7f
000162c6      [0x106] =  0x75
000162c7      [0x107] =  0x08
000162c8      [0x108] =  0x95
000162c9      [0x109] =  0x01
000162ca      [0x10a] =  0x81
000162cb      [0x10b] =  0x06
000162cc      [0x10c] =  0xc0
000162cd      [0x10d] =  0xc0
000162ce      [0x10e] =  0x05
000162cf      [0x10f] =  0x0d
000162d0      [0x110] =  0x09
000162d1      [0x111] =  0x04
000162d2      [0x112] =  0xa1
000162d3      [0x113] =  0x01
000162d4      [0x114] =  0x85
000162d5      [0x115] =  0x04
000162d6      [0x116] =  0x05
000162d7      [0x117] =  0x0d
000162d8      [0x118] =  0x09
000162d9      [0x119] =  0x22
000162da      [0x11a] =  0xa1
000162db      [0x11b] =  0x00
000162dc      [0x11c] =  0x09
000162dd      [0x11d] =  0x32
000162de      [0x11e] =  0x09
000162df      [0x11f] =  0x42
000162e0      [0x120] =  0x15
000162e1      [0x121] =  0x00
000162e2      [0x122] =  0x25
000162e3      [0x123] =  0x01
000162e4      [0x124] =  0x75
000162e5      [0x125] =  0x01
000162e6      [0x126] =  0x95
000162e7      [0x127] =  0x02
000162e8      [0x128] =  0x81
000162e9      [0x129] =  0x02
000162ea      [0x12a] =  0x75
000162eb      [0x12b] =  0x01
000162ec      [0x12c] =  0x95
000162ed      [0x12d] =  0x06
000162ee      [0x12e] =  0x81
000162ef      [0x12f] =  0x01
000162f0      [0x130] =  0x05
000162f1      [0x131] =  0x01
000162f2      [0x132] =  0x26
000162f3      [0x133] =  0xff
000162f4      [0x134] =  0x7f
000162f5      [0x135] =  0x75
000162f6      [0x136] =  0x10
000162f7      [0x137] =  0x95
000162f8      [0x138] =  0x01
000162f9      [0x139] =  0x55
000162fa      [0x13a] =  0x0f
000162fb      [0x13b] =  0x65
000162fc      [0x13c] =  0x11
000162fd      [0x13d] =  0x09
000162fe      [0x13e] =  0x30
000162ff      [0x13f] =  0x35
00016300      [0x140] =  0x00
00016301      [0x141] =  0x46
00016302      [0x142] =  0xfe
00016303      [0x143] =  0x01
00016304      [0x144] =  0x81
00016305      [0x145] =  0x02
00016306      [0x146] =  0x09
00016307      [0x147] =  0x31
00016308      [0x148] =  0x46
00016309      [0x149] =  0x1d
0001630a      [0x14a] =  0x01
0001630b      [0x14b] =  0x81
0001630c      [0x14c] =  0x02
0001630d      [0x14d] =  0xc0
0001630e      [0x14e] =  0xc0
0001630f  }

0001630f                                               00                                                                 .
00016310  uint8_t HIDPenDescriptor[0x41] = 
00016310  {
00016310      [0x00] =  0x05
00016311      [0x01] =  0x0d
00016312      [0x02] =  0x09
00016313      [0x03] =  0x02
00016314      [0x04] =  0xa1
00016315      [0x05] =  0x01
00016316      [0x06] =  0x85
00016317      [0x07] =  0x0e
00016318      [0x08] =  0x05
00016319      [0x09] =  0x0d
0001631a      [0x0a] =  0x09
0001631b      [0x0b] =  0x20
0001631c      [0x0c] =  0xa1
0001631d      [0x0d] =  0x00
0001631e      [0x0e] =  0x09
0001631f      [0x0f] =  0x32
00016320      [0x10] =  0x09
00016321      [0x11] =  0x42
00016322      [0x12] =  0x15
00016323      [0x13] =  0x00
00016324      [0x14] =  0x25
00016325      [0x15] =  0x01
00016326      [0x16] =  0x75
00016327      [0x17] =  0x01
00016328      [0x18] =  0x95
00016329      [0x19] =  0x02
0001632a      [0x1a] =  0x81
0001632b      [0x1b] =  0x02
0001632c      [0x1c] =  0x75
0001632d      [0x1d] =  0x01
0001632e      [0x1e] =  0x95
0001632f      [0x1f] =  0x06
00016330      [0x20] =  0x81
00016331      [0x21] =  0x01
00016332      [0x22] =  0x05
00016333      [0x23] =  0x01
00016334      [0x24] =  0x26
00016335      [0x25] =  0xff
00016336      [0x26] =  0x7f
00016337      [0x27] =  0x75
00016338      [0x28] =  0x10
00016339      [0x29] =  0x95
0001633a      [0x2a] =  0x01
0001633b      [0x2b] =  0x55
0001633c      [0x2c] =  0x0f
0001633d      [0x2d] =  0x65
0001633e      [0x2e] =  0x11
0001633f      [0x2f] =  0x09
00016340      [0x30] =  0x30
00016341      [0x31] =  0x35
00016342      [0x32] =  0x00
00016343      [0x33] =  0x46
00016344      [0x34] =  0xfe
00016345      [0x35] =  0x01
00016346      [0x36] =  0x81
00016347      [0x37] =  0x02
00016348      [0x38] =  0x09
00016349      [0x39] =  0x31
0001634a      [0x3a] =  0x46
0001634b      [0x3b] =  0x1d
0001634c      [0x3c] =  0x01
0001634d      [0x3d] =  0x81
0001634e      [0x3e] =  0x02
0001634f      [0x3f] =  0xc0
00016350      [0x40] =  0xc0
00016351  }

00016351                                                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                   ...............
00016360  uint8_t HIDVendorDescriptor[0x74] = 
00016360  {
00016360      [0x00] =  0x06
00016361      [0x01] =  0xa0
00016362      [0x02] =  0xff
00016363      [0x03] =  0x09
00016364      [0x04] =  0x02
00016365      [0x05] =  0xa1
00016366      [0x06] =  0x01
00016367      [0x07] =  0x85
00016368      [0x08] =  0x05
00016369      [0x09] =  0x15
0001636a      [0x0a] =  0x00
0001636b      [0x0b] =  0x26
0001636c      [0x0c] =  0xff
0001636d      [0x0d] =  0x00
0001636e      [0x0e] =  0x75
0001636f      [0x0f] =  0x08
00016370      [0x10] =  0x95
00016371      [0x11] =  0x40
00016372      [0x12] =  0x09
00016373      [0x13] =  0x02
00016374      [0x14] =  0x81
00016375      [0x15] =  0x02
00016376      [0x16] =  0x95
00016377      [0x17] =  0x40
00016378      [0x18] =  0x09
00016379      [0x19] =  0x02
0001637a      [0x1a] =  0x91
0001637b      [0x1b] =  0x02
0001637c      [0x1c] =  0xc0
0001637d      [0x1d] =  0x06
0001637e      [0x1e] =  0xa0
0001637f      [0x1f] =  0xff
00016380      [0x20] =  0x09
00016381      [0x21] =  0x06
00016382      [0x22] =  0xa1
00016383      [0x23] =  0x01
00016384      [0x24] =  0x85
00016385      [0x25] =  0x06
00016386      [0x26] =  0x15
00016387      [0x27] =  0x00
00016388      [0x28] =  0x26
00016389      [0x29] =  0xff
0001638a      [0x2a] =  0x00
0001638b      [0x2b] =  0x75
0001638c      [0x2c] =  0x08
0001638d      [0x2d] =  0x95
0001638e      [0x2e] =  0x40
0001638f      [0x2f] =  0x09
00016390      [0x30] =  0x06
00016391      [0x31] =  0x81
00016392      [0x32] =  0x02
00016393      [0x33] =  0x95
00016394      [0x34] =  0x40
00016395      [0x35] =  0x09
00016396      [0x36] =  0x06
00016397      [0x37] =  0x91
00016398      [0x38] =  0x02
00016399      [0x39] =  0xc0
0001639a      [0x3a] =  0x06
0001639b      [0x3b] =  0xa0
0001639c      [0x3c] =  0xff
0001639d      [0x3d] =  0x09
0001639e      [0x3e] =  0x07
0001639f      [0x3f] =  0xa1
000163a0      [0x40] =  0x01
000163a1      [0x41] =  0x85
000163a2      [0x42] =  0x07
000163a3      [0x43] =  0x15
000163a4      [0x44] =  0x00
000163a5      [0x45] =  0x26
000163a6      [0x46] =  0xff
000163a7      [0x47] =  0x00
000163a8      [0x48] =  0x75
000163a9      [0x49] =  0x08
000163aa      [0x4a] =  0x95
000163ab      [0x4b] =  0x40
000163ac      [0x4c] =  0x09
000163ad      [0x4d] =  0x01
000163ae      [0x4e] =  0x81
000163af      [0x4f] =  0x00
000163b0      [0x50] =  0x95
000163b1      [0x51] =  0x40
000163b2      [0x52] =  0x09
000163b3      [0x53] =  0x01
000163b4      [0x54] =  0x91
000163b5      [0x55] =  0x02
000163b6      [0x56] =  0xc0
000163b7      [0x57] =  0x06
000163b8      [0x58] =  0xa0
000163b9      [0x59] =  0xff
000163ba      [0x5a] =  0x09
000163bb      [0x5b] =  0x08
000163bc      [0x5c] =  0xa1
000163bd      [0x5d] =  0x01
000163be      [0x5e] =  0x85
000163bf      [0x5f] =  0x08
000163c0      [0x60] =  0x15
000163c1      [0x61] =  0x00
000163c2      [0x62] =  0x26
000163c3      [0x63] =  0xff
000163c4      [0x64] =  0x00
000163c5      [0x65] =  0x75
000163c6      [0x66] =  0x08
000163c7      [0x67] =  0x95
000163c8      [0x68] =  0x40
000163c9      [0x69] =  0x09
000163ca      [0x6a] =  0x01
000163cb      [0x6b] =  0x81
000163cc      [0x6c] =  0x00
000163cd      [0x6d] =  0x95
000163ce      [0x6e] =  0x40
000163cf      [0x6f] =  0x09
000163d0      [0x70] =  0x01
000163d1      [0x71] =  0x91
000163d2      [0x72] =  0x02
000163d3      [0x73] =  0xc0
000163d4  }

000163d4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

000163e0  struct _MARKER_TYPE __KMDF_CLASS_BIND_START = 
000163e0  {
000163e0      uint8_t Pad[0x10] = 
000163e0      {
000163e0          [0x0] =  0x00
000163e1          [0x1] =  0x00
000163e2          [0x2] =  0x00
000163e3          [0x3] =  0x00
000163e4          [0x4] =  0x00
000163e5          [0x5] =  0x00
000163e6          [0x6] =  0x00
000163e7          [0x7] =  0x00
000163e8          [0x8] =  0x00
000163e9          [0x9] =  0x00
000163ea          [0xa] =  0x00
000163eb          [0xb] =  0x00
000163ec          [0xc] =  0x00
000163ed          [0xd] =  0x00
000163ee          [0xe] =  0x00
000163ef          [0xf] =  0x00
000163f0      }
000163f0  }
000163f0  void* __KMDF_CLASS_BIND_END = 0x0
000163f8  struct _WDF_CLASS_BIND_INFO* __KMDF_CLASS_BIND_LAST_BOUND = __KMDF_CLASS_BIND_START
00016400  struct _MARKER_TYPE __KMDF_TYPE_INIT_START = 
00016400  {
00016400      uint8_t Pad[0x10] = 
00016400      {
00016400          [0x0] =  0x00
00016401          [0x1] =  0x00
00016402          [0x2] =  0x00
00016403          [0x3] =  0x00
00016404          [0x4] =  0x00
00016405          [0x5] =  0x00
00016406          [0x6] =  0x00
00016407          [0x7] =  0x00
00016408          [0x8] =  0x00
00016409          [0x9] =  0x00
0001640a          [0xa] =  0x00
0001640b          [0xb] =  0x00
0001640c          [0xc] =  0x00
0001640d          [0xd] =  0x00
0001640e          [0xe] =  0x00
0001640f          [0xf] =  0x00
00016410      }
00016410  }
00016410  void* __KMDF_TYPE_INIT_END = 0x0

00016418                                                                          00 00 00 00 00 00 00 00                          ........
00016420  void (* WdfFunctions[0x0])() = 
00016420  {
00016420  }
00016420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
00016430  data_16430:
00016430                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00016440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000164a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000164c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000164e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000165a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000165c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

000165d8  int64_t data_165d8 = 0x0

000165e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00016660  int64_t data_16660 = 0x0

00016668                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

00016678  int64_t data_16678 = 0x0

00016680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000166a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

000166b8  int64_t data_166b8 = 0x0

000166c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000166e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000167a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

000167c0  int64_t data_167c0 = 0x0

000167c8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

000167d8  int64_t data_167d8 = 0x0

000167e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016820  00 00 00 00 00 00 00 00                                                                          ........

00016828  int64_t data_16828 = 0x0

00016830                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00016840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000168a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000168c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

000168e0  int64_t data_168e0 = 0x0

000168e8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00016900  00 00 00 00 00 00 00 00                                                                          ........

00016908  int64_t data_16908 = 0x0
00016910  int64_t data_16910 = 0x0

00016918                                                                          00 00 00 00 00 00 00 00                          ........
00016920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

00016978  int64_t data_16978 = 0x0
00016980  int64_t data_16980 = 0x0
00016988  int64_t data_16988 = 0x0
00016990  int64_t data_16990 = 0x0

00016998                                                                          00 00 00 00 00 00 00 00                          ........
000169a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000169c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
000169e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016a00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016a20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016a30  int64_t data_16a30 = 0x0

00016a38                                                                          00 00 00 00 00 00 00 00                          ........
00016a40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016a60  00 00 00 00 00 00 00 00                                                                          ........

00016a68  int64_t data_16a68 = 0x0
00016a70  int64_t data_16a70 = 0x0

00016a78                                                                          00 00 00 00 00 00 00 00                          ........
00016a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00016aa0  int64_t data_16aa0 = 0x0

00016aa8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00016ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016ae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016b00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016b20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016b50  int64_t data_16b50 = 0x0
00016b58  int64_t data_16b58 = 0x0

00016b60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016b80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00016ba0  int64_t data_16ba0 = 0x0

00016ba8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00016bc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016c00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

00016c58  int64_t data_16c58 = 0x0

00016c60  00 00 00 00 00 00 00 00                                                                          ........

00016c68  int64_t data_16c68 = 0x0
00016c70  int64_t data_16c70 = 0x0

00016c78                                                                          00 00 00 00 00 00 00 00                          ........
00016c80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016c90  int64_t data_16c90 = 0x0

00016c98                                                                          00 00 00 00 00 00 00 00                          ........
00016ca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

00016cb8  int64_t data_16cb8 = 0x0

00016cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

00016cd8  int64_t data_16cd8 = 0x0

00016ce0  00 00 00 00 00 00 00 00                                                                          ........

00016ce8  int64_t data_16ce8 = 0x0
00016cf0  int64_t data_16cf0 = 0x0

00016cf8                                                                          00 00 00 00 00 00 00 00                          ........
00016d00  00 00 00 00 00 00 00 00                                                                          ........

00016d08  int64_t data_16d08 = 0x0

00016d10                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00016d20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016d60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016d80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016da0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016dc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00016de0  int64_t data_16de0 = 0x0
00016de8  int64_t data_16de8 = 0x0
00016df0  int64_t data_16df0 = 0x0
00016df8  int64_t data_16df8 = 0x0
00016e00  int64_t data_16e00 = 0x0
00016e08  int64_t data_16e08 = 0x0
00016e10  int64_t data_16e10 = 0x0
00016e18  int64_t data_16e18 = 0x0
00016e20  int64_t data_16e20 = 0x0
00016e28  int64_t data_16e28 = 0x0
00016e30  int64_t data_16e30 = 0x0
00016e38  int64_t data_16e38 = 0x0
00016e40  int64_t data_16e40 = 0x0
00016e48  int64_t data_16e48 = 0x0

00016e50                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00016e60  00 00 00 00 00 00 00 00                                                                          ........

00016e68  int64_t data_16e68 = 0x0
00016e70  int64_t data_16e70 = 0x0

00016e78                                                                          00 00 00 00 00 00 00 00                          ........
00016e80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00016ea0  int64_t data_16ea0 = 0x0

00016ea8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00016ec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016ed0  int64_t data_16ed0 = 0x0

00016ed8                                                                          00 00 00 00 00 00 00 00                          ........
00016ee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016ef0  int64_t data_16ef0 = 0x0

00016ef8                                                                          00 00 00 00 00 00 00 00                          ........
00016f00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016f10  int64_t data_16f10 = 0x0

00016f18                                                                          00 00 00 00 00 00 00 00                          ........
00016f20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016f40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016f60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00016f70  int64_t data_16f70 = 0x0

00016f78                                                                          00 00 00 00 00 00 00 00                          ........

00016f80  int64_t data_16f80 = 0x0
00016f88  int64_t data_16f88 = 0x0

00016f90                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00016fa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016fc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00016fe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

00016ff8  int64_t data_16ff8 = 0x0
00017000  int64_t data_17000 = 0x0

00017008                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00017020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00017040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00017060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00017080  struct _WDF_IFR_HEADER* typeWDF_IFR_HEADER = 0x0
00017088  struct _UNICODE_STRING WdfDriverStubRegistryPath = 
00017088  {
00017088      USHORT Length = 0x0
0001708a      USHORT MaximumLength = 0x0
00017090      PWCH Buffer = 0x0
00017098  }
00017098  void (* WdfDriverStubDisplacedDriverUnload)(struct _DRIVER_OBJECT*) = 0x0
000170a0  void (* WdfDriverStubOriginalWdfDriverMiniportUnload)(struct _WDF_DRIVER_GLOBALS*, struct WDFDRIVER__*) = 0x0
000170a8  struct _WDF_DRIVER_GLOBALS* WdfDriverGlobals = 0x0
000170b0  struct _DRIVER_OBJECT* WdfDriverStubDriverObject = 0x0

000170b8                                                                          00 00 00 00 00 00 00 00                          ........

000170c0  wchar16 WdfDriverStubRegistryPathBuffer[0x104] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
000172c8  struct _DRIVER_OBJECT* NWDriverObject = 0x0

000172d0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

000172e0  struct _NW_MEMORY_USAGE_CB NWMemoryUsage = 
000172e0  {
000172e0      uint32_t TotalNonPagedPool = 0x0
000172e4      uint32_t TotalPagedPool = 0x0
000172e8      uint32_t AllocationTable[0x3] = 
000172e8      {
000172e8          [0x0] =  0x00000000
000172ec          [0x1] =  0x00000000
000172f0          [0x2] =  0x00000000
000172f4      }
000172f4  }

000172f4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

00017300  struct _UNICODE_STRING NWRegistryPath = 
00017300  {
00017300      USHORT Length = 0x0
00017302      USHORT MaximumLength = 0x0
00017308      PWCH Buffer = 0x0
00017310  }
.data section ended  {0x16000-0x17310}

.pdata section started  {0x18000-0x181d4}
00018000  struct Exception_Directory_Entry __exception_directory_entries(0) = 
00018000  {
00018000      uint32_t beginAddress = 0x1008
00018004      uint32_t endAddress = 0x1154
00018008      uint32_t unwindInformation = 0x53c0
0001800c  }
0001800c  struct Exception_Directory_Entry __exception_directory_entries(1) = 
0001800c  {
0001800c      uint32_t beginAddress = 0x115c
00018010      uint32_t endAddress = 0x1194
00018014      uint32_t unwindInformation = 0x53cc
00018018  }
00018018  struct Exception_Directory_Entry __exception_directory_entries(2) = 
00018018  {
00018018      uint32_t beginAddress = 0x119c
0001801c      uint32_t endAddress = 0x1771
00018020      uint32_t unwindInformation = 0x539c
00018024  }
00018024  struct Exception_Directory_Entry __exception_directory_entries(3) = 
00018024  {
00018024      uint32_t beginAddress = 0x1778
00018028      uint32_t endAddress = 0x17c7
0001802c      uint32_t unwindInformation = 0x5330
00018030  }
00018030  struct Exception_Directory_Entry __exception_directory_entries(4) = 
00018030  {
00018030      uint32_t beginAddress = 0x17f0
00018034      uint32_t endAddress = 0x1a0a
00018038      uint32_t unwindInformation = 0x5360
0001803c  }
0001803c  struct Exception_Directory_Entry __exception_directory_entries(5) = 
0001803c  {
0001803c      uint32_t beginAddress = 0x1a10
00018040      uint32_t endAddress = 0x1ce3
00018044      uint32_t unwindInformation = 0x5380
00018048  }
00018048  struct Exception_Directory_Entry __exception_directory_entries(6) = 
00018048  {
00018048      uint32_t beginAddress = 0x1cec
0001804c      uint32_t endAddress = 0x1d98
00018050      uint32_t unwindInformation = 0x5354
00018054  }
00018054  struct Exception_Directory_Entry __exception_directory_entries(7) = 
00018054  {
00018054      uint32_t beginAddress = 0x1da0
00018058      uint32_t endAddress = 0x1f41
0001805c      uint32_t unwindInformation = 0x5338
00018060  }
00018060  struct Exception_Directory_Entry __exception_directory_entries(8) = 
00018060  {
00018060      uint32_t beginAddress = 0x1f48
00018064      uint32_t endAddress = 0x2061
00018068      uint32_t unwindInformation = 0x52a8
0001806c  }
0001806c  struct Exception_Directory_Entry __exception_directory_entries(9) = 
0001806c  {
0001806c      uint32_t beginAddress = 0x2068
00018070      uint32_t endAddress = 0x20ad
00018074      uint32_t unwindInformation = 0x5330
00018078  }
00018078  struct Exception_Directory_Entry __exception_directory_entries(10) = 
00018078  {
00018078      uint32_t beginAddress = 0x20b4
0001807c      uint32_t endAddress = 0x2154
00018080      uint32_t unwindInformation = 0x5330
00018084  }
00018084  struct Exception_Directory_Entry __exception_directory_entries(11) = 
00018084  {
00018084      uint32_t beginAddress = 0x215c
00018088      uint32_t endAddress = 0x2345
0001808c      uint32_t unwindInformation = 0x5298
00018090  }
00018090  struct Exception_Directory_Entry __exception_directory_entries(12) = 
00018090  {
00018090      uint32_t beginAddress = 0x234c
00018094      uint32_t endAddress = 0x2506
00018098      uint32_t unwindInformation = 0x5318
0001809c  }
0001809c  struct Exception_Directory_Entry __exception_directory_entries(13) = 
0001809c  {
0001809c      uint32_t beginAddress = 0x250c
000180a0      uint32_t endAddress = 0x2698
000180a4      uint32_t unwindInformation = 0x5284
000180a8  }
000180a8  struct Exception_Directory_Entry __exception_directory_entries(14) = 
000180a8  {
000180a8      uint32_t beginAddress = 0x26a0
000180ac      uint32_t endAddress = 0x26fc
000180b0      uint32_t unwindInformation = 0x5330
000180b4  }
000180b4  struct Exception_Directory_Entry __exception_directory_entries(15) = 
000180b4  {
000180b4      uint32_t beginAddress = 0x2704
000180b8      uint32_t endAddress = 0x27cb
000180bc      uint32_t unwindInformation = 0x5378
000180c0  }
000180c0  struct Exception_Directory_Entry __exception_directory_entries(16) = 
000180c0  {
000180c0      uint32_t beginAddress = 0x27d4
000180c4      uint32_t endAddress = 0x2859
000180c8      uint32_t unwindInformation = 0x5234
000180cc  }
000180cc  struct Exception_Directory_Entry __exception_directory_entries(17) = 
000180cc  {
000180cc      uint32_t beginAddress = 0x2860
000180d0      uint32_t endAddress = 0x2915
000180d4      uint32_t unwindInformation = 0x5308
000180d8  }
000180d8  struct Exception_Directory_Entry __exception_directory_entries(18) = 
000180d8  {
000180d8      uint32_t beginAddress = 0x291c
000180dc      uint32_t endAddress = 0x29ef
000180e0      uint32_t unwindInformation = 0x52f8
000180e4  }
000180e4  struct Exception_Directory_Entry __exception_directory_entries(19) = 
000180e4  {
000180e4      uint32_t beginAddress = 0x29f8
000180e8      uint32_t endAddress = 0x2b4e
000180ec      uint32_t unwindInformation = 0x52e8
000180f0  }
000180f0  struct Exception_Directory_Entry __exception_directory_entries(20) = 
000180f0  {
000180f0      uint32_t beginAddress = 0x2b54
000180f4      uint32_t endAddress = 0x3076
000180f8      uint32_t unwindInformation = 0x52c4
000180fc  }
000180fc  struct Exception_Directory_Entry __exception_directory_entries(21) = 
000180fc  {
000180fc      uint32_t beginAddress = 0x307c
00018100      uint32_t endAddress = 0x312b
00018104      uint32_t unwindInformation = 0x5274
00018108  }
00018108  struct Exception_Directory_Entry __exception_directory_entries(22) = 
00018108  {
00018108      uint32_t beginAddress = 0x3134
0001810c      uint32_t endAddress = 0x3247
00018110      uint32_t unwindInformation = 0x5264
00018114  }
00018114  struct Exception_Directory_Entry __exception_directory_entries(23) = 
00018114  {
00018114      uint32_t beginAddress = 0x3250
00018118      uint32_t endAddress = 0x332c
0001811c      uint32_t unwindInformation = 0x5250
00018120  }
00018120  struct Exception_Directory_Entry __exception_directory_entries(24) = 
00018120  {
00018120      uint32_t beginAddress = 0x3334
00018124      uint32_t endAddress = 0x3415
00018128      uint32_t unwindInformation = 0x5250
0001812c  }
0001812c  struct Exception_Directory_Entry __exception_directory_entries(25) = 
0001812c  {
0001812c      uint32_t beginAddress = 0x341c
00018130      uint32_t endAddress = 0x3474
00018134      uint32_t unwindInformation = 0x5234
00018138  }
00018138  struct Exception_Directory_Entry __exception_directory_entries(26) = 
00018138  {
00018138      uint32_t beginAddress = 0x347c
0001813c      uint32_t endAddress = 0x34b0
00018140      uint32_t unwindInformation = 0x5330
00018144  }
00018144  struct Exception_Directory_Entry __exception_directory_entries(27) = 
00018144  {
00018144      uint32_t beginAddress = 0x34b8
00018148      uint32_t endAddress = 0x357f
0001814c      uint32_t unwindInformation = 0x5240
00018150  }
00018150  struct Exception_Directory_Entry __exception_directory_entries(28) = 
00018150  {
00018150      uint32_t beginAddress = 0x3588
00018154      uint32_t endAddress = 0x3605
00018158      uint32_t unwindInformation = 0x52b4
0001815c  }
0001815c  struct Exception_Directory_Entry __exception_directory_entries(29) = 
0001815c  {
0001815c      uint32_t beginAddress = 0x3648
00018160      uint32_t endAddress = 0x366f
00018164      uint32_t unwindInformation = 0x5218
00018168  }
00018168  struct Exception_Directory_Entry __exception_directory_entries(30) = 
00018168  {
00018168      uint32_t beginAddress = 0x3684
0001816c      uint32_t endAddress = 0x36b2
00018170      uint32_t unwindInformation = 0x53cc
00018174  }
00018174  struct Exception_Directory_Entry __exception_directory_entries(31) = 
00018174  {
00018174      uint32_t beginAddress = 0x36c4
00018178      uint32_t endAddress = 0x36eb
0001817c      uint32_t unwindInformation = 0x53cc
00018180  }
00018180  struct Exception_Directory_Entry __exception_directory_entries(32) = 
00018180  {
00018180      uint32_t beginAddress = 0x36f4
00018184      uint32_t endAddress = 0x3816
00018188      uint32_t unwindInformation = 0x5220
0001818c  }
0001818c  struct Exception_Directory_Entry __exception_directory_entries(33) = 
0001818c  {
0001818c      uint32_t beginAddress = 0x381c
00018190      uint32_t endAddress = 0x3846
00018194      uint32_t unwindInformation = 0x5234
00018198  }
00018198  struct Exception_Directory_Entry __exception_directory_entries(34) = 
00018198  {
00018198      uint32_t beginAddress = 0x384c
0001819c      uint32_t endAddress = 0x38c3
000181a0      uint32_t unwindInformation = 0x5234
000181a4  }
000181a4  struct Exception_Directory_Entry __exception_directory_entries(35) = 
000181a4  {
000181a4      uint32_t beginAddress = 0x38cc
000181a8      uint32_t endAddress = 0x3951
000181ac      uint32_t unwindInformation = 0x52b4
000181b0  }
000181b0  struct Exception_Directory_Entry __exception_directory_entries(36) = 
000181b0  {
000181b0      uint32_t beginAddress = 0x3958
000181b4      uint32_t endAddress = 0x39bc
000181b8      uint32_t unwindInformation = 0x5234
000181bc  }
000181bc  struct Exception_Directory_Entry __exception_directory_entries(37) = 
000181bc  {
000181bc      uint32_t beginAddress = 0x3f0c
000181c0      uint32_t endAddress = 0x3f6f
000181c4      uint32_t unwindInformation = 0x5330
000181c8  }
000181c8  struct Exception_Directory_Entry __exception_directory_entries(38) = 
000181c8  {
000181c8      uint32_t beginAddress = 0x3f78
000181cc      uint32_t endAddress = 0x3f95
000181d0      uint32_t unwindInformation = 0x53cc
000181d4  }
.pdata section ended  {0x18000-0x181d4}

INIT section started  {0x19000-0x194d8}
00019000  00 00 00 00 00 00 00 00                                                                          ........

00019008    void __security_init_cookie()

00019008  {
00019008      uint64_t __security_cookie_1 = __security_cookie;
00019008      
00019021      if (!__security_cookie_1 || __security_cookie_1 == 0x2b992ddfa232)
00019021      {
00019044          __security_cookie_1 =
00019044              (*(uint64_t*)-0xfffff78000000320 ^ &__security_cookie) & 0xffffffffffff;
00019044          
00019047          if (!__security_cookie_1)
00019047              __security_cookie_1 = 0x2b992ddfa232;
00019047          
0001904b          __security_cookie = __security_cookie_1;
00019021      }
00019021      
00019055      __security_cookie_complement = ~__security_cookie_1;
00019008  }

0001905d                                                                                         cc cc cc                               ...
00019060  struct Import_Directory_Table __IMPORT_DESCRIPTOR_ntoskrnl[0x4] = 
00019060  {
00019060      [0x0] = 
00019060      {
00019060          uint32_t importLookupTableRva = 0x9168
00019064          uint32_t timeDateStamp = 0x0
00019068          uint32_t forwarderChain = 0x0
0001906c          uint32_t nameRva = 0x92a0
00019070          uint32_t importAddressTableRva = 0x50b8
00019074      }
00019074      [0x1] = 
00019074      {
00019074          uint32_t importLookupTableRva = 0x90b0
00019078          uint32_t timeDateStamp = 0x0
0001907c          uint32_t forwarderChain = 0x0
00019080          uint32_t nameRva = 0x9450
00019084          uint32_t importAddressTableRva = 0x5000
00019088      }
00019088      [0x2] = 
00019088      {
00019088          uint32_t importLookupTableRva = 0x9140
0001908c          uint32_t timeDateStamp = 0x0
00019090          uint32_t forwarderChain = 0x0
00019094          uint32_t nameRva = 0x94cc
00019098          uint32_t importAddressTableRva = 0x5090
0001909c      }
0001909c      [0x3] = 
0001909c      {
0001909c          uint32_t importLookupTableRva = 0x0
000190a0          uint32_t timeDateStamp = 0x0
000190a4          uint32_t forwarderChain = 0x0
000190a8          uint32_t nameRva = 0x0
000190ac          uint32_t importAddressTableRva = 0x0
000190b0      }
000190b0  }
000190b0  uint64_t __import_lookup_table_1(NWTransLibV:TransLibEnterWorkingState) = 0x9338
000190b8  uint64_t __import_lookup_table_1(NWTransLibV:TransLibProcessUserReport) = 0x938a
000190c0  uint64_t __import_lookup_table_1(NWTransLibV:TransLibSetParsedTransfer) = 0x936e
000190c8  uint64_t __import_lookup_table_1(NWTransLibV:TransLibGetThreadTimes) = 0x9354
000190d0  uint64_t __import_lookup_table_1(NWTransLibV:TransLibLeaveWorkingState) = 0x931c
000190d8  uint64_t __import_lookup_table_1(NWTransLibV:TransLibProcessStreamSync) = 0x9434
000190e0  uint64_t __import_lookup_table_1(NWTransLibV:TransLibHardwareReadSync) = 0x9418
000190e8  uint64_t __import_lookup_table_1(NWTransLibV:TLConfigureTrace) = 0x9404
000190f0  uint64_t __import_lookup_table_1(NWTransLibV:TLGetTraceBuffer) = 0x93f0
000190f8  uint64_t __import_lookup_table_1(NWTransLibV:TLGetTranslationMode) = 0x93d8
00019100  uint64_t __import_lookup_table_1(NWTransLibV:TLSetTranslationMode) = 0x93c0
00019108  uint64_t __import_lookup_table_1(NWTransLibV:TLDbgLogMsg) = 0x92ae
00019110  uint64_t __import_lookup_table_1(NWTransLibV:TransLibGetParsedTransfer) = 0x92bc
00019118  uint64_t __import_lookup_table_1(NWTransLibV:TransLibInitialize) = 0x92d8
00019120  uint64_t __import_lookup_table_1(NWTransLibV:TransLibShutdown) = 0x92ee
00019128  uint64_t __import_lookup_table_1(NWTransLibV:TransLibGetMemoryUsage) = 0x9302
00019130  uint64_t __import_lookup_table_1(NWTransLibV:TransLibUpdateInputMode) = 0x93a6
00019138  uint64_t data_19138 = 0x0
00019140  uint64_t __import_lookup_table_2(WDFLDR:WdfVersionBind) = 0x948c
00019148  uint64_t __import_lookup_table_2(WDFLDR:WdfVersionBindClass) = 0x949e
00019150  uint64_t __import_lookup_table_2(WDFLDR:WdfVersionUnbindClass) = 0x94b4
00019158  uint64_t __import_lookup_table_2(WDFLDR:WdfVersionUnbind) = 0x9478
00019160  uint64_t data_19160 = 0x0
00019168  uint64_t __import_lookup_table_0(ntoskrnl:KeBugCheckEx) = 0x9290
00019170  uint64_t __import_lookup_table_0(ntoskrnl:KeDelayExecutionThread) = 0x9276
00019178  uint64_t __import_lookup_table_0(ntoskrnl:KeSetEvent) = 0x9268
00019180  uint64_t __import_lookup_table_0(ntoskrnl:KeClearEvent) = 0x9258
00019188  uint64_t __import_lookup_table_0(ntoskrnl:DbgPrint) = 0x924c
00019190  uint64_t __import_lookup_table_0(ntoskrnl:RtlInitUnicodeString) = 0x9234
00019198  uint64_t __import_lookup_table_0(ntoskrnl:RtlCopyUnicodeString) = 0x9460
000191a0  uint64_t __import_lookup_table_0(ntoskrnl:KeReadStateEvent) = 0x9220
000191a8  uint64_t __import_lookup_table_0(ntoskrnl:RtlGetVersion) = 0x9210
000191b0  uint64_t __import_lookup_table_0(ntoskrnl:KeInitializeEvent) = 0x91fc
000191b8  uint64_t __import_lookup_table_0(ntoskrnl:ExFreePoolWithTag) = 0x91e8
000191c0  uint64_t __import_lookup_table_0(ntoskrnl:ExAllocatePoolWithTag) = 0x91d0
000191c8  uint64_t data_191c8 = 0x0
000191d0  uint16_t __export_name_ptr_table_0(ntoskrnl:ExAllocatePoolWithTag) = 0x46
000191d2  char __import_name_0(ntoskrnl:ExAllocatePoolWithTag)[0x16] = "ExAllocatePoolWithTag", 0
000191e8  uint16_t __export_name_ptr_table_0(ntoskrnl:ExFreePoolWithTag) = 0x58
000191ea  char __import_name_0(ntoskrnl:ExFreePoolWithTag)[0x12] = "ExFreePoolWithTag", 0
000191fc  uint16_t __export_name_ptr_table_0(ntoskrnl:KeInitializeEvent) = 0x22e
000191fe  char __import_name_0(ntoskrnl:KeInitializeEvent)[0x12] = "KeInitializeEvent", 0
00019210  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlGetVersion) = 0x436
00019212  char __import_name_0(ntoskrnl:RtlGetVersion)[0xe] = "RtlGetVersion", 0
00019220  uint16_t __export_name_ptr_table_0(ntoskrnl:KeReadStateEvent) = 0x252
00019222  char __import_name_0(ntoskrnl:KeReadStateEvent)[0x11] = "KeReadStateEvent", 0

00019233                                                           00                                                         .

00019234  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlInitUnicodeString) = 0x43e
00019236  char __import_name_0(ntoskrnl:RtlInitUnicodeString)[0x15] = "RtlInitUnicodeString", 0

0001924b                                   00                                                                         .

0001924c  uint16_t __export_name_ptr_table_0(ntoskrnl:DbgPrint) = 0x31
0001924e  char __import_name_0(ntoskrnl:DbgPrint)[0x9] = "DbgPrint", 0

00019257                                                                       00                                                 .

00019258  uint16_t __export_name_ptr_table_0(ntoskrnl:KeClearEvent) = 0x216
0001925a  char __import_name_0(ntoskrnl:KeClearEvent)[0xd] = "KeClearEvent", 0

00019267                       00                                                                                 .

00019268  uint16_t __export_name_ptr_table_0(ntoskrnl:KeSetEvent) = 0x278
0001926a  char __import_name_0(ntoskrnl:KeSetEvent)[0xb] = "KeSetEvent", 0

00019275                                                                 00                                                     .

00019276  uint16_t __export_name_ptr_table_0(ntoskrnl:KeDelayExecutionThread) = 0x218
00019278  char __import_name_0(ntoskrnl:KeDelayExecutionThread)[0x17] = "KeDelayExecutionThread", 0

0001928f                                               00                                                                 .

00019290  uint16_t __export_name_ptr_table_0(ntoskrnl:KeBugCheckEx) = 0x213
00019292  char __import_name_0(ntoskrnl:KeBugCheckEx)[0xd] = "KeBugCheckEx", 0

0001929f                                                                                               00                                 .

000192a0  char __import_dll_name(ntoskrnl)[0xd] = "ntoskrnl.exe", 0

000192ad                                         00                                                                     .

000192ae  uint16_t __export_name_ptr_table_1(NWTransLibV:TLDbgLogMsg) = 0x3
000192b0  char __import_name_1(NWTransLibV:TLDbgLogMsg)[0xc] = "TLDbgLogMsg", 0
000192bc  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibGetParsedTransfer) = 0xa
000192be  char __import_name_1(NWTransLibV:TransLibGetParsedTransfer)[0x1a] = "TransLibGetParsedTransfer", 0
000192d8  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibInitialize) = 0xd
000192da  char __import_name_1(NWTransLibV:TransLibInitialize)[0x13] = "TransLibInitialize", 0

000192ed                                         00                                                                     .

000192ee  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibShutdown) = 0x12
000192f0  char __import_name_1(NWTransLibV:TransLibShutdown)[0x11] = "TransLibShutdown", 0

00019301     00                                                                                             .

00019302  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibGetMemoryUsage) = 0x9
00019304  char __import_name_1(NWTransLibV:TransLibGetMemoryUsage)[0x17] = "TransLibGetMemoryUsage", 0

0001931b                                                                                   00                                         .

0001931c  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibLeaveWorkingState) = 0xe
0001931e  char __import_name_1(NWTransLibV:TransLibLeaveWorkingState)[0x1a] = "TransLibLeaveWorkingState", 0
00019338  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibEnterWorkingState) = 0x8
0001933a  char __import_name_1(NWTransLibV:TransLibEnterWorkingState)[0x1a] = "TransLibEnterWorkingState", 0
00019354  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibGetThreadTimes) = 0xb
00019356  char __import_name_1(NWTransLibV:TransLibGetThreadTimes)[0x17] = "TransLibGetThreadTimes", 0

0001936d                                         00                                                                     .

0001936e  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibSetParsedTransfer) = 0x11
00019370  char __import_name_1(NWTransLibV:TransLibSetParsedTransfer)[0x1a] = "TransLibSetParsedTransfer", 0
0001938a  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibProcessUserReport) = 0x10
0001938c  char __import_name_1(NWTransLibV:TransLibProcessUserReport)[0x1a] = "TransLibProcessUserReport", 0
000193a6  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibUpdateInputMode) = 0x13
000193a8  char __import_name_1(NWTransLibV:TransLibUpdateInputMode)[0x18] = "TransLibUpdateInputMode", 0
000193c0  uint16_t __export_name_ptr_table_1(NWTransLibV:TLSetTranslationMode) = 0x7
000193c2  char __import_name_1(NWTransLibV:TLSetTranslationMode)[0x15] = "TLSetTranslationMode", 0

000193d7                                                                       00                                                 .

000193d8  uint16_t __export_name_ptr_table_1(NWTransLibV:TLGetTranslationMode) = 0x6
000193da  char __import_name_1(NWTransLibV:TLGetTranslationMode)[0x15] = "TLGetTranslationMode", 0

000193ef                                               00                                                                 .

000193f0  uint16_t __export_name_ptr_table_1(NWTransLibV:TLGetTraceBuffer) = 0x5
000193f2  char __import_name_1(NWTransLibV:TLGetTraceBuffer)[0x11] = "TLGetTraceBuffer", 0

00019403           00                                                                                         .

00019404  uint16_t __export_name_ptr_table_1(NWTransLibV:TLConfigureTrace) = 0x2
00019406  char __import_name_1(NWTransLibV:TLConfigureTrace)[0x11] = "TLConfigureTrace", 0

00019417                                                                       00                                                 .

00019418  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibHardwareReadSync) = 0xc
0001941a  char __import_name_1(NWTransLibV:TransLibHardwareReadSync)[0x19] = "TransLibHardwareReadSync", 0

00019433                                                           00                                                         .

00019434  uint16_t __export_name_ptr_table_1(NWTransLibV:TransLibProcessStreamSync) = 0xf
00019436  char __import_name_1(NWTransLibV:TransLibProcessStreamSync)[0x1a] = "TransLibProcessStreamSync", 0
00019450  char __import_dll_name(NWTransLibV)[0x10] = "NWTransLibV.sys", 0
00019460  uint16_t __export_name_ptr_table_0(ntoskrnl:RtlCopyUnicodeString) = 0x3ee
00019462  char __import_name_0(ntoskrnl:RtlCopyUnicodeString)[0x15] = "RtlCopyUnicodeString", 0

00019477                                                                       00                                                 .

00019478  uint16_t __export_name_ptr_table_2(WDFLDR:WdfVersionUnbind) = 0x8
0001947a  char __import_name_2(WDFLDR:WdfVersionUnbind)[0x11] = "WdfVersionUnbind", 0

0001948b                                   00                                                                         .

0001948c  uint16_t __export_name_ptr_table_2(WDFLDR:WdfVersionBind) = 0x6
0001948e  char __import_name_2(WDFLDR:WdfVersionBind)[0xf] = "WdfVersionBind", 0

0001949d                                                                                         00                                     .

0001949e  uint16_t __export_name_ptr_table_2(WDFLDR:WdfVersionBindClass) = 0x7
000194a0  char __import_name_2(WDFLDR:WdfVersionBindClass)[0x14] = "WdfVersionBindClass", 0
000194b4  uint16_t __export_name_ptr_table_2(WDFLDR:WdfVersionUnbindClass) = 0x9
000194b6  char __import_name_2(WDFLDR:WdfVersionUnbindClass)[0x16] = "WdfVersionUnbindClass", 0
000194cc  char __import_dll_name(WDFLDR)[0xb] = "WDFLDR.SYS", 0

000194d7                                                                       00                                                 .
INIT section ended  {0x19000-0x194d8}

.rsrc section started  {0x1a000-0x1a2e0}
0001a000  struct Resource_Directory_Table __resource_directory_table_0 = 
0001a000  {
0001a000      uint32_t characteristics = 0x0
0001a004      uint32_t timeDateStamp = 0x0
0001a008      uint16_t majorVersion = 0x0
0001a00a      uint16_t minorVersion = 0x0
0001a00c      uint16_t numNameEntries = 0x0
0001a00e      uint16_t numIdEntries = 0x1
0001a010  }
0001a010  struct Resource_Directory_Table_Entry __resource_directory_table_0_entries[0x1] = 
0001a010  {
0001a010      [0x0] = 
0001a010      {
0001a010          uint32_t id = 0x10
0001a014          uint32_t offset = 0x80000018
0001a018      }
0001a018  }
0001a018  struct Resource_Directory_Table __resource_directory_table_1 = 
0001a018  {
0001a018      uint32_t characteristics = 0x0
0001a01c      uint32_t timeDateStamp = 0x0
0001a020      uint16_t majorVersion = 0x0
0001a022      uint16_t minorVersion = 0x0
0001a024      uint16_t numNameEntries = 0x0
0001a026      uint16_t numIdEntries = 0x1
0001a028  }
0001a028  struct Resource_Directory_Table_Entry __resource_directory_table_1_entries[0x1] = 
0001a028  {
0001a028      [0x0] = 
0001a028      {
0001a028          uint32_t id = 0x1
0001a02c          uint32_t offset = 0x80000030
0001a030      }
0001a030  }
0001a030  struct Resource_Directory_Table __resource_directory_table_2 = 
0001a030  {
0001a030      uint32_t characteristics = 0x0
0001a034      uint32_t timeDateStamp = 0x0
0001a038      uint16_t majorVersion = 0x0
0001a03a      uint16_t minorVersion = 0x0
0001a03c      uint16_t numNameEntries = 0x0
0001a03e      uint16_t numIdEntries = 0x1
0001a040  }
0001a040  struct Resource_Directory_Table_Entry __resource_directory_table_2_entries[0x1] = 
0001a040  {
0001a040      [0x0] = 
0001a040      {
0001a040          uint32_t id = 0x409
0001a044          uint32_t offset = 0x48
0001a048      }
0001a048  }
0001a048  struct Resource_Data_Entry __resource_directory_table_2_data_entry_0 = 
0001a048  {
0001a048      uint32_t dataRva = 0xa060
0001a04c      uint32_t dataSize = 0x27c
0001a050      uint32_t codepage = 0x0
0001a054      uint32_t reserved = 0x0
0001a058  }

0001a058                                                                          00 00 00 00 00 00 00 00                          ........

0001a060  char data_1a060[0x27c] = "|\x024\x00\x00\x00V\x00S\x00_\x00V\x00E\x00R\x00S\x00I\x00O\x00N\x00_\x00I\x00N\x00F\x00O\x00\x00\x00\x00\x00\xbd\x04\xef\xfe\x00\x00\x01\x00\x01\x00\x03\x00\x07\x00\x0c\x00\x01\x00\x03\x00\x07\x00\x0c\x00\x17\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdc\x01\x00\x00\x01\x00S\x00t\x00r\x00i\x00n\x00g\x00F\x00i\x00l\x00e\x00I\x00n\x00f\x00o\x00\x00\x00\xb8\x01\x00\x00\x01\x000\x004\x000\x009\x000\x004\x00b\x000\x00\x00\x00:\x00\t\x00\x01\x00F\x00i\x00l\x00e\x00D\x00e\x00s\x00c\x00r\x00i\x00p\x00t\x00i\x00o\x00n\x00\x00\x00\x00\x00N\x00W\x00H\x00I\x00D\x00F\x00i\x00l\x00\x00\x00\x00\x008\x00\x0c\x00\x01\x00F\x00i\x00l\x00e\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00\x00\x00\x00\x003\x00,\x00 \x001\x00,\x00 \x001\x002\x00,\x00 \x007\x00\x00\x002\x00\t\x00\x01\x00I\x00n\x00t\x00e\x00r\x00n\x00a\x00l\x00N\x00a\x00m\x00e\x00\x00\x00N\x00W\x00H\x00I\x00D\x00F\x00i\x00l\x00\x00\x00\x00\x00J\x00\x13\x00\x01\x00L\x00e\x00g\x00a\x00l\x00C\x00o\x00p\x00y\x00r\x00i\x00g\x00h\x00t\x00\x00\x00C\x00o\x00p\x00y\x00r\x00i\x00g\x00h\x00t\x00 \x00(\x00C\x00)\x00 \x002\x000\x001\x000\x00\x00\x00\x00\x00:\x00\t\x00\x01\x00O\x00r\x00i\x00g\x00i\x00n\x00a\x00l\x00F\x00i\x00l\x00e\x00n\x00a\x00m\x00e\x00\x00\x00N\x00W\x00H\x00I\x00D\x00F\x00i\x00l\x00\x00\x00\x00\x002\x00\t\x00\x01\x00P\x00r\x00o\x00d\x00u\x00c\x00t\x00N\x00a\x00m\x00e\x00\x00\x00\x00\x00N\x00W\x00H\x00I\x00D\x00F\x00i\x00l\x00\x00\x00\x00\x00<\x00\x0c\x00\x01\x00P\x00r\x00o\x00d\x00u\x00c\x00t\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00\x00\x003\x00,\x00 \x001\x00,\x00 \x001\x002\x00,\x00 \x007\x00\x00\x00D\x00\x00\x00\x01\x00V\x00a\x00r\x00F\x00i\x00l\x00e\x00I\x00n\x00f\x00o\x00\x00\x00\x00\x00$\x00\x04\x00\x00\x00T\x00r\x00a\x00n\x00s\x00l\x00a\x00t\x00i\x00o\x00n\x00\x00\x00\x00\x00\t\x04\xb0\x04"

0001a2dc                                                                                      00 00 00 00                              ....
.rsrc section ended  {0x1a000-0x1a2e0}

.reloc section started  {0x1b000-0x1b06c}
0001b000  00 60 00 00 1c 00 00 00 18 a1 30 a1 48 a1 58 a1 70 a1 80 a1 98 a1 a8 a1 f8 a3 00 00 00 00 00 00  .`........0.H.X.p...............
0001b020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0001b040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0001b060  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
.reloc section ended  {0x1b000-0x1b06c}

.extern section started  {0x1b070-0x1b178}
0001b070  extern uint32_t DbgPrint(char* Format, ...)
0001b078  extern void* ExAllocatePoolWithTag(POOL_TYPE PoolType, uint64_t NumberOfBytes, uint32_t Tag)
0001b080  extern void ExFreePoolWithTag(void* P, uint32_t Tag)
0001b088  extern void KeBugCheckEx(enum BUGCHECK_ERROR BugCheckCode, uint64_t BugCheckParameter1, uint64_t BugCheckParameter2, uint64_t BugCheckParameter3, uint64_t BugCheckParameter4)
0001b090  extern void KeClearEvent(KEVENT* Event)
0001b098  extern NTSTATUS KeDelayExecutionThread(char WaitMode, BOOLEAN Alertable, int64_t* Interval)
0001b0a0  extern void KeInitializeEvent(KEVENT* Event, EVENT_TYPE Type, BOOLEAN State)
0001b0a8  extern int32_t KeReadStateEvent(KEVENT* Event)
0001b0b0  extern int32_t KeSetEvent(KEVENT* Event, int32_t Increment, BOOLEAN Wait)
0001b0b8  extern void RtlCopyUnicodeString(UNICODE_STRING* DestinationString, UNICODE_STRING* SourceString)
0001b0c0  extern NTSTATUS RtlGetVersion(OSVERSIONINFOW* lpVersionInformation)
0001b0c8  extern void RtlInitUnicodeString(UNICODE_STRING* DestinationString, wchar16* SourceString)
0001b0d0  extern TLConfigureTrace
0001b0d8  extern TLDbgLogMsg
0001b0e0  extern TLGetTraceBuffer
0001b0e8  extern TLGetTranslationMode
0001b0f0  extern TLSetTranslationMode
0001b0f8  extern TransLibEnterWorkingState
0001b100  extern TransLibGetMemoryUsage
0001b108  extern TransLibGetParsedTransfer
0001b110  extern TransLibGetThreadTimes
0001b118  extern TransLibHardwareReadSync
0001b120  extern TransLibInitialize
0001b128  extern TransLibLeaveWorkingState
0001b130  extern TransLibProcessStreamSync
0001b138  extern TransLibProcessUserReport
0001b140  extern TransLibSetParsedTransfer
0001b148  extern TransLibShutdown
0001b150  extern TransLibUpdateInputMode
0001b158  extern WdfVersionBind
0001b160  extern WdfVersionBindClass
0001b168  extern WdfVersionUnbind
0001b170  extern WdfVersionUnbindClass
.extern section ended  {0x1b070-0x1b178}

.synthetic_builtins section started  {0x1b180-0x1b1b0}
0001b180  extern void* __builtin_memcpy(void* dest, void const* src, uint64_t count)
0001b188  extern void* __builtin_memset(void* dest, int32_t ch, uint64_t count)
0001b190  extern char* __builtin_strcpy(char* dest, char const* src)
0001b198  extern char* __builtin_strncpy(char* dest, char const* src, uint64_t count)
0001b1a0  extern wchar16* __builtin_wcscpy(wchar16* dest, wchar16 const* src)
0001b1a8  extern wchar16* __builtin_wmemcpy(wchar16* dest, wchar16 const* src, uint64_t count)
.synthetic_builtins section ended  {0x1b180-0x1b1b0}

